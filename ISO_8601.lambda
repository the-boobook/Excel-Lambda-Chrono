/*#####################################################################################################
# ISO_8601                                                                                            #   
#                                                                                                     #
# The ISO 8601 standard defines a universal notation of calendar date and times.                      #
# Dates are in the Gregorian calendar and times are based on the 24 hour timekeeping system with      #
# an optional time zone offset from UTC.                                                              #
#                                                                                                     #
# Module Dependencies: None                                                                           #
#                                                                                                     #
# General Functions                                                                                   #
# --------------------------------------------------------------------------------------------------- #
# IS_LEAP_YEAR           Tests if a year includes a leap day in the Gregorian calendar.               #
# IS_VALID_DATE          Tests if a date is valid for the Gregorian calendar.                         # 
# IS_VALID_TIME          Tests if a time is valid for the 24 hour timekeeping system.                 # 
# IS_VALID_TIME_ZONE     Tests if time zone offset in minutes is in valid range.                      #
# IS_VALID_ORDINAL_DATE  Tests if an ordinal date is valid for the Gregorian calendar.                #
# IS_VALID_WEEK_DATE     Tests if a week date is valid for the Gregorian calendar.                    # 
# DAY_ORDINAL            Returns the ordinal day number of a date.                                    #
# DAY_OF_WEEK            Returns the ISO defined day of week number for a given date.                 #
# YEAR_WEEK_COUNT        Returns the count of ISO defined weeks in a given year.                      #
# WEEK_NUMBER            Returns the ISO defined week number of a given date.                         #
# FROM_ORDINAL_DATE      Returns the Gregorian calendar date from a given ordinal date.               #
# WEEK_FROM_ORDINAL      Returns the ISO defined week number of a given ordinal date.                 #
# TO_WEEK_DATE           Returns the ISO defined week number and day of week from a given date.       #
# FROM_WEEK_DATE         Returns the either a Gregorian calendar date or ordinal date from a given    #
#                        week and day of week.                                                        #
#                                                                                                     #
# Parsing Functions                                                                                   #
# --------------------------------------------------------------------------------------------------- #
# VALIDATE_CHARACTERS    Tests if text contains only characters that are valid for ISO 8601.          #
# PARSE_DATE             Returns the year, month and day of a date from text in the ISO 8601 format.  #
# PARSE_TIME             Returns the hour, minute and second of time from text in the ISO 8601 format.#
# PARSE_TIME_ZONE        Returns the time zone offset in minutes from text in the ISO 8601 format.    #
# PARSE_ORDINAL_DATE     Returns the year and ordinal day from text in the ISO 8601 format.           #
# PARSE_WEEK_DATE        Returns the year, week and day of week from text in the ISO 8601 format.     #
# PARSE_DATE_TIME        Returns the date and time from text in the ISO 8601 format.                  #
#                                                                                                     #
# Formatting Functions                                                                                #
# --------------------------------------------------------------------------------------------------- #
# FORMAT_DATE            Returns a date as text in the ISO 8601 format.                               #
# FORMAT_TIME            Returns a time as text in the ISO 8601 format.                               #
# FORMAT_TIME_ZONE       Returns a time zone as text in the ISO 8601 format.                          #
# FORMAT_ORDINAL_DATE    Returns an ordinal date as text in the ISO 8601 format.                      #
# FORMAT_WEEK_DATE       Returns a week date as text in the ISO 8601 format.                          #
# FORMAT_DATE_TIME       Returns a date and time as text in the ISO 8601 format.                      #
#                                                                                                     #
# Conversion Functions                                                                                #
# --------------------------------------------------------------------------------------------------- #
# ISO_TO_DATE            Converts text in ISO format to an Excel date.                                #
# DATE_TO_ISO            Converts an Excel date to ISO formatted text.                                #
#                                                                                                     #
#####################################################################################################*/

/*-----------------------------------------------------------------------------------------------------
IS_LEAP_YEAR

Tests if a year includes a leap day in the Gregorian calendar.

Parameters
-------------------------------------------------------------------------------------------------------
YearCE : Year in common era
-----------------------------------------------------------------------------------------------------*/
IS_LEAP_YEAR = LAMBDA(
    YearCE,
    IF(
        YearCE = "",
        "",
        LET(
            _y, INT(YearCE),
            IF(MOD(_y, 400) = 0, TRUE, IF(MOD(_y, 100) = 0, FALSE, MOD(_y, 4) = 0))
        )
    )
);

/*-----------------------------------------------------------------------------------------------------
IS_VALID_DATE

Tests if a date is valid for the Gregorian calendar.
If month and day missing, considered a year only date.
If only day is missing, considered a year and month date.

Parameters
-------------------------------------------------------------------------------------------------------
YearCE      : Year in common era.
Month       : Month of year.
Day         : Day of month.
[NoNulls]   : Disallow short forms:  Year, Year and month
-----------------------------------------------------------------------------------------------------*/
IS_VALID_DATE = LAMBDA(
    YearCE,
    Month,
    Day,
    [NoNulls],
    IF(
        YearCE = "",
        FALSE, // Year mandatory
        IF(
            (N(NoNulls) <> 0) * ((Month = "") + (Day = "")),
            FALSE, // NoNulls set and either Month or Day is Null
            LET(
                _y, INT(N(YearCE)),
                IF(
                    ABS(_y) > 99999,
                    FALSE, // Year out of range
                    IF(
                        Month = "",
                        IF(
                            Day = "",
                            TRUE, // Year only date
                            FALSE // day without month
                        ),
                        LET(
                            _m, INT(N(Month)),
                            IF(
                                ((_m >= 1) * (_m <= 12)) = 0,
                                FALSE, // Month out of range
                                IF(
                                    Day = "",
                                    TRUE, // Year and month date
                                    LET(
                                        _d, INT(N(Day)),
                                        IFS(
                                            (_m = 2), // Feb
                                            ((_d >= 1) * (_d <= (28 + N(IS_LEAP_YEAR(_y))))) <> 0,
                                            (_m < 8), // Jan, Mar, Apr, May, Jun, Jul
                                            ((_d >= 1) * (_d <= (30 + MOD(_m, 2)))) <> 0,
                                            (_m >= 8), // Aug, Sep, Oct, Nov, Dec
                                            (_d >= 1) * (_d <= (31 - MOD(_m, 2))) <> 0
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);

/*-----------------------------------------------------------------------------------------------------
IS_VALID_TIME

Tests if a time is valid for the 24 hour timekeeping system.

Parameters
-------------------------------------------------------------------------------------------------------
Hour
Minute
Second
[NoNulls] : Disallow short forms:  Hour, Hour and minute
-----------------------------------------------------------------------------------------------------*/
IS_VALID_TIME = LAMBDA(
    Hour,
    Minute,
    Second,
    [NoNulls],
    IF(
        Hour = "",
        FALSE, // Hour mandatory
        IFS(
            (N(NoNulls) <> 0) * ((Minute = "") + (Second = "")),
            FALSE, // NoNulls set and either Minute or Second is Null
            (Minute = "") * (Second <> ""),
            FALSE, // Second provided with no Minute
            (Minute = "") * (Second = ""),
            LET(
                //test for valid hour
                _h, INT(N(Hour)),
                (_h >= 0) * (_h <= 24) <> 0
            ),
            (Minute <> "") * (Second = ""),
            LET(
                _h, INT(N(Hour)),
                _m, INT(N(Minute)),
                IF(
                    _h = 24,
                    // no remainder minute at 24 hour
                    (_m = 0),
                    
                    // test for valid hour, minute
                    ((_h >= 0) * (_h < 24) * (_m >= 0) * (_m <= 59)) <> 0
                )
            ),
            (Minute <> "") * (Second <> ""),
            LET(
                _h, INT(N(Hour)),
                _m, INT(N(Minute)),
                _s, ROUNDDOWN(N(Second), 3),
                IF(
                    _h = 24,
                    // no remainder minute or second at 24 hour
                    (_m = 0) * (_s = 0) <> 0,
                    
                    // test for valid hour, minute, second
                    ((_h >= 0) * (_h < 24) * (_m >= 0) * (_m <= 59) * (_s >= 0) * (_s < 60)) <> 0
                )
            )
        )
    )
);

/*-----------------------------------------------------------------------------------------------------
IS_VALID_TIME_ZONE

Tests if time zone offset in minutes is in valid range.

Parameters
-------------------------------------------------------------------------------------------------------
OffsetMinutes : Range is -900..+900 which corresponds to -15:00..+15:00
-----------------------------------------------------------------------------------------------------*/
IS_VALID_TIME_ZONE = LAMBDA(
    OffsetMinutes,
    IF(OffsetMinutes = "", FALSE, LET(_tzo, N(OffsetMinutes), (_tzo >= -900) * (_tzo <= 900) <> 0))
);

/*-----------------------------------------------------------------------------------------------------
IS_VALID_ORDINAL_DATE

Tests if an ordinal date is valid for the Gregorian calendar.

Parameters
-------------------------------------------------------------------------------------------------------
YearCE    : Year in common era.
Ordinal   : Day of year.
[NoNulls] : Disallow short form: Year
-----------------------------------------------------------------------------------------------------*/
IS_VALID_ORDINAL_DATE = LAMBDA(
    YearCE,
    Ordinal,
    [NoNulls],
    IF(
        YearCE = "",
        FALSE, // Year mandatory
        IF(
            (N(NoNulls) <> 0) * (Ordinal = ""),
            FALSE, // NoNulls set and Ordinal is Null
            LET(
                _y, INT(N(YearCE)),
                IF(
                    ABS(_y) > 99999,
                    FALSE, // Year out of range
                    IF(
                        Ordinal = "",
                        TRUE, // Year only date
                        LET(
                            _o, INT(N(Ordinal)),
                            _leapDay, N(IS_LEAP_YEAR(_y)),
                            
                            // test for valid ordinal date
                            ((_o >= 1) * (_o <= (365 + _leapDay))) <> 0
                        )
                    )
                )
            )
        )
    )
);

/*-----------------------------------------------------------------------------------------------------
IS_VALID_WEEK_DATE

Tests if a week date is valid for the Gregorian calendar.
Required: Year
          Year and Week
          Year, Week and DayOfWeek

Parameters
-------------------------------------------------------------------------------------------------------
YearCE     : Year in common era
Week       : ISO defined week number of the year
DayOfWeek  : Day of the week where 1..7 -> Mon..Sun
[NoNulls]  : Disallow short forms:  Hour, Hour and minute
-----------------------------------------------------------------------------------------------------*/
IS_VALID_WEEK_DATE = LAMBDA(
    YearCE,
    Week,
    DayOfWeek,
    [NoNulls],
    IF(
        YearCE = "",
        FALSE, // Year mandatory
        IF(
            (N(NoNulls) <> 0) * ((Week = "") + (DayOfWeek = "")),
            FALSE, // NoNulls set and either Week or DayOfWeek is Null
            LET(
                _y, INT(N(YearCE)),
                IF(
                    ABS(_y) > 99999,
                    FALSE, // Year out of range
                    IF(
                        Week = "",
                        (DayOfWeek = ""), // Test for Year only date
                        LET(
                            _w, INT(N(Week)),
                            IF(
                                ((_w >= 1) * (_w <= YEAR_WEEK_COUNT(_y))) = 0,
                                FALSE, // Week out of range
                                IF(
                                    DayOfWeek = "",
                                    TRUE, // Year and week date
                                    LET(
                                        _dow, INT(N(DayOfWeek)),
                                        ((_dow >= 1) * (_dow <= 7)) <> 0 // Test for DayOfWeek 1..7
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);

/*-----------------------------------------------------------------------------------------------------
DAY_ORDINAL

Returns the ordinal day number of a date.

Parameters
-------------------------------------------------------------------------------------------------------
YearCE : Year in common era
Month  : Month of year
Day    : Day of month
-----------------------------------------------------------------------------------------------------*/
DAY_ORDINAL = LAMBDA(
    YearCE,
    Month,
    Day,
    IF(
        NOT(IS_VALID_DATE(YearCE, Month, Day, 1)), #NUM!,
        LET(
            _y, INT(N(YearCE)),
            _m, INT(N(Month)),
            _d, INT(N(Day)),
            IFS(
                _m = 1,
                _d,
                _m = 2,
                31 + _d,
                TRUE,
                LET(
                    _leapDay, N(IS_LEAP_YEAR(_y)),
                    IFS(
                        _m = 3,
                        59 + _leapDay + _d,
                        _m = 4,
                        90 + _leapDay + _d,
                        _m = 5,
                        120 + _leapDay + _d,
                        _m = 6,
                        151 + _leapDay + _d,
                        _m = 7,
                        181 + _leapDay + _d,
                        _m = 8,
                        212 + _leapDay + _d,
                        _m = 9,
                        243 + _leapDay + _d,
                        _m = 10,
                        273 + _leapDay + _d,
                        _m = 11,
                        304 + _leapDay + _d,
                        _m = 12,
                        334 + _leapDay + _d
                    )
                )
            )
        )
    )
);

/*-----------------------------------------------------------------------------------------------------
DAY_OF_WEEK

Returns the ISO defined day of week number for a given date.
  1 - Monday
  2 - Tuesday
  3 - Wednesday
  4 - Thurday
  5 - Friday
  6 - Saturday
  7 - Sunday

Parameters
-------------------------------------------------------------------------------------------------------
YearCE : Year in common era
Month  : Month of year
Day    : Day of month
-----------------------------------------------------------------------------------------------------*/
DAY_OF_WEEK = LAMBDA(
    YearCE,
    Month,
    Day,
    IF(
        NOT(IS_VALID_DATE(YearCE, Month, Day, 1)),
        #NUM!,
        LET(
            _y, INT(N(YearCE)),
            _m, INT(N(Month)),
            _d, INT(N(Day)),
            
            // Using Zeller Congruence, cf. https://en.wikipedia.org/wiki/Zeller%27s_congruence
            
            // Map months Mar..Feb -> 3..14
            _zellerMonth, MOD(_m - 3, 12) + 3,
            
            // Jan, Feb considered belonging to previous year
            _zellerYear, _y - QUOTIENT(_zellerMonth, 13),
            _yearOfCent, MOD(_zellerYear, 100),
            _zeroBasedCent, QUOTIENT(_zellerYear, 100),
            
            // Zeller Congruence for Gregorian calender
            // returns weekdays 0..6 -> Sat..Fri
            _zellerWeekDay, MOD(
                _d + QUOTIENT(13 * (_zellerMonth + 1), 5) + _yearOfCent + QUOTIENT(_yearOfCent, 4) +
                    QUOTIENT(_zeroBasedCent, 4) - 2 * _zeroBasedCent,
                7
            ),
            
            // Translate to ISO numbering 1..7 -> Mon..Sun
            MOD(_zellerWeekDay + 5, 7) + 1
        )
    )
);

/*-----------------------------------------------------------------------------------------------------
YEAR_WEEK_COUNT

Returns the count of ISO defined weeks in a given year.

Parameters
-------------------------------------------------------------------------------------------------------
YearCE : Year in common era
-----------------------------------------------------------------------------------------------------*/
YEAR_WEEK_COUNT = LAMBDA(
    YearCE,
    LET(
        _y, INT(N(YearCE)),
        IF(
            (ABS(_y) > 99999),
            #NUM!,
            LET(
                _dowLastDay, MOD(_y + QUOTIENT(_y, 4) - QUOTIENT(_y, 100) + QUOTIENT(_y, 400), 7),
                IF(
                    _dowLastDay = 4,
                    // if last day of year is a Thursday, then has an extra week
                    53,
                    LET(
                        _lastYear, _y - 1,
                        _dowLastDayPrev, MOD(
                            _lastYear + QUOTIENT(_lastYear, 4) - QUOTIENT(_lastYear, 100) +
                                QUOTIENT(_lastYear, 400),
                            7
                        ),
                        IF(
                            _dowLastDayPrev = 3,
                            // if last day of previous year is a Wednesday, then has an extra week
                            53,
                            // otherwize
                            52
                        )
                    )
                )
            )
        )
    )
);

/*-----------------------------------------------------------------------------------------------------
WEEK_NUMBER

Returns the ISO defined week number of a given date.

Parameters
-------------------------------------------------------------------------------------------------------
YearCE : Year in common era
Month  : Month of year
Day    : Day of month
-----------------------------------------------------------------------------------------------------*/
WEEK_NUMBER = LAMBDA(
    YearCE,
    Month,
    Day,
    IF(
        NOT(IS_VALID_DATE(YearCE, Month, Day, 1)),
        #NUM!,
        LET(
            _y, INT(YearCE),
            _m, INT(Month),
            _d, INT(Day),
            _ordinal, DAY_ORDINAL(_y, _m, _d),
            _dayOfWeek, DAY_OF_WEEK(_y, _m, _d),
            QUOTIENT(_ordinal - _dayOfWeek + 10, 7)
        )
    )
);

/*-----------------------------------------------------------------------------------------------------
FROM_ORDINAL_DATE

Returns the Gregorian calendar date from a given ordinal date.
Columns:
  1 - Year CE
  2 - Month
  3 - Day

Parameters
-------------------------------------------------------------------------------------------------------
YearCE  : Year in common era
Ordinal : Ordinal day of year
-----------------------------------------------------------------------------------------------------*/
FROM_ORDINAL_DATE = LAMBDA(
    YearCE,
    Ordinal,
    LET(
        _y, INT(N(YearCE)),
        _o, INT(N(Ordinal)),
        IF(
            (ABS(_y) > 99999),
            #NUM!,
            LET(
                _leapDay, N(IS_LEAP_YEAR(_y)),
                IF(
                    (_o < 1) + (_o > (365 + _leapDay)),
                    #NUM!,
                    IFS(
                        _o <= 31,
                        HSTACK(_y, 1, _o),
                        _o <= 59 + _leapday,
                        HSTACK(_y, 2, _o - 31),
                        _o <= 90 + _leapday,
                        HSTACK(_y, 3, _o - 59 - _leapDay),
                        _o <= 120 + _leapday,
                        HSTACK(_y, 4, _o - 90 - _leapDay),
                        _o <= 151 + _leapday,
                        HSTACK(_y, 5, _o - 120 - _leapDay),
                        _o <= 181 + _leapday,
                        HSTACK(_y, 6, _o - 151 - _leapDay),
                        _o <= 212 + _leapday,
                        HSTACK(_y, 7, _o - 181 - _leapDay),
                        _o <= 243 + _leapday,
                        HSTACK(_y, 8, _o - 212 - _leapDay),
                        _o <= 273 + _leapday,
                        HSTACK(_y, 9, _o - 243 - _leapDay),
                        _o <= 304 + _leapday,
                        HSTACK(_y, 10, _o - 273 - _leapDay),
                        _o <= 334 + _leapday,
                        HSTACK(_y, 11, _o - 304 - _leapDay),
                        TRUE,
                        HSTACK(_y, 12, _o - 334 - _leapDay)
                    )
                )
            )
        )
    )
);

/*-----------------------------------------------------------------------------------------------------
WEEK_FROM_ORDINAL

Returns the ISO defined week number of a given ordinal date.

Parameters
-------------------------------------------------------------------------------------------------------
YearCE  : Year in common era
Ordinal : Ordinal day of year
-----------------------------------------------------------------------------------------------------*/
WEEK_FROM_ORDINAL = LAMBDA(
    YearCE,
    Ordinal,
    IF(
        NOT(IS_VALID_ORDINAL_DATE(YearCE, Ordinal, 1)),
        #NUM!,
        LET(
            _y, INT(N(YearCE)),
            _o, INT(N(Ordinal)),
            _date, FROM_ORDINAL_DATE(_y, _o),
            _dayOfWeek, DAY_OF_WEEK(_y, INDEX(_date, 1, 2), INDEX(_date, 1, 3)),
            QUOTIENT(_o - _dayOfWeek + 10, 7)
        )
    )
);

/*-----------------------------------------------------------------------------------------------------
TO_WEEK_DATE

Returns the ISO defined week number and day of week from a given date. The provided date can implicitly
be either a calendar date or ordininal date.
Columns:
  1 - Year CE
  2 - Week
  3 - Day of week

Parameters
-------------------------------------------------------------------------------------------------------
YearCE        : Year in common era
Month         : Month of the year. If ommitted, day is assumed to be ordinal.
Day           : Day of the month when month provided, otherwize ordinal day of the year.
-----------------------------------------------------------------------------------------------------*/
TO_WEEK_DATE = LAMBDA(
    YearCE,
    Month,
    Day,
    IF(
        NOT(IS_VALID_DATE(YearCE, Month, Day, 1)),
        #NUM!,
        LET(
            _dayIsOrdinal, (Month = ""),
            _y, INT(N(YearCE)),
            _m, INT(N(Month)),
            _d, INT(N(Day)),
            _yCorrection, DAY_OF_WEEK(_y, 1, 4) + 3,
            IF(
                _dayIsOrdinal,
                LET(
                    _w, WEEK_FROM_ORDINAL(_y, _d),
                    _dow, MOD(_d + _yCorrection, 7),
                    HSTACK(_y, _w, _dow)
                ),
                LET(
                    _o, DAY_ORDINAL(_y, _m, _d),
                    _w, WEEK_FROM_ORDINAL(_y, _o),
                    _dow, MOD(_o + _yCorrection, 7),
                    HSTACK(_y, _w, _dow)
                )
            )
        )
    )
);

/*-----------------------------------------------------------------------------------------------------
FROM_WEEK_DATE

Returns the either a Gregorian calendar date or ordinal date from a given week and day of week.                                                                #
Columns (ReturnOrdinal = FALSE):
  1 - Year CE
  2 - Month
  3 - Day

Parameters
-------------------------------------------------------------------------------------------------------
YearCE          : Year in common era
Week            : ISO defined week number of the year
DayOfWeek       : Day of the week where 1..7 -> Mon..Sun 
[ReturnOrdinal] : Flag to return result as an ordinal date
-----------------------------------------------------------------------------------------------------*/
FROM_WEEK_DATE = LAMBDA(
    YearCE,
    Week,
    DayOfWeek,
    [ReturnOrdinal],
    IF(
        NOT(IS_VALID_WEEK_DATE(YearCE, Week, DayOfWeek, 1)),
        #NUM!,
        LET(
            _y, INT(N(YearCE)),
            _w, INT(N(Week)),
            _d, INT(N(DayOfWeek)),
            _yCorrection, DAY_OF_WEEK(_y, 1, 4) + 3,
            _ordinalDay, _w * 7 + _d - _yCorrection,
            IF(N(ReturnOrdinal) <> 0, _ordinalDay, FROM_ORDINAL_DATE(_y, _ordinalDay))
        )
    )
);

/*-----------------------------------------------------------------------------------------------------
VALIDATE_CHARACTERS

Tests if text contains only characters that are valid for ISO 8601.

Parameters
-------------------------------------------------------------------------------------------------------
Text : ISO 8601 formatted text.
       Valid charset: +-0123456789:TWZ
-----------------------------------------------------------------------------------------------------*/
VALIDATE_CHARACTERS = LAMBDA(
    Text,
    IF(
        Text = "",
        "",
        LET(
            _xml, "<t><s>" & Text & "</s></t>",
            _xpath, "//s[translate(.,'+-.0123456789:TWZ','')='']",
            NOT(ISERROR(FILTERXML(_xml, _xpath)))
        )
    )
);

/*-----------------------------------------------------------------------------------------------------
PARSE_DATE

Returns the year, month and day of a date from text in the ISO 8601 format.
Columns:
  1 - Year CE
  2 - Month
  3 - Day
  4 - Format (optional, toggled by ReturnFormat parameter)
        0 - no date
        1 - basic
        2 - extended
        3 - consistent with basic or extended
        
Parameters
-------------------------------------------------------------------------------------------------------
Text           : ISO 8601 formatted date.
               : Example formats (not exhaustive):
               : +YYYYY-MM-DD
               : -YYYY-MM-DD
               : YYYY-MM-DD
               : YYYY-MM
               : YYYYMMDD
               : YYYY
               :
               : Note YYYYMM is invalid, due to collision with truncated format YYMMDD in earlier
               : versions of the ISO 8601 standard.
[ReturnFormat] : Sets whether to return from which format the date was parsed
-----------------------------------------------------------------------------------------------------*/
PARSE_DATE = LAMBDA(
    Text,
    [ReturnFormat],
    LET(
        _flgFmt, N(ReturnFormat) <> 0,
        IF(Text = "",
            IF(_flgFmt, HSTACK("", "", "", 0), HSTACK("", "", "")),
            LET(
                fnValidDate, LAMBDA(_y, _m, _d, _f, _x,
                    IF(IS_VALID_DATE(_y, _m, _d),
                        IF(_f, HSTACK(_y, _m, _d, _x), HSTACK(_y, _m, _d)),
                        #NUM!
                    )
                ),
                _yearSign, IF(LEFT(Text, 1) = "-", -1, 1),
                _sDate, IFS(
                    _yearSign = -1,
                    RIGHT(Text, LEN(Text) - 1),
                    LEFT(Text, 1) = "+",
                    RIGHT(Text, LEN(Text) - 1),
                    TRUE,
                    Text
                ),
                _basic, IFERROR(FIND("-", _sDate), 0) = 0,
                IF(
                    _basic,
                    LET(
                        // basic format, positional elements
                        _cLen, LEN(_sDate),
                        IF(
                            (_cLen < 4) + (_cLen > 9),
                            #VALUE!,
                            LET(
                                _yLen, 4 + MOD(_cLen, 2),
                                _yearCE, _yearSign * VALUE(LEFT(_sDate, _yLen)),
                                _month, IF(_cLen > _yLen, VALUE(MID(_sDate, _yLEn + 1, 2)), ""),
                                _day, IF(_cLen > _yLen + 2, VALUE(MID(_sDate, _yLEn + 3, 2)), ""),
                                _x, IF(_cLen = _yLen, 3, 1),
                                fnValidDate(_yearCE, _month, _day, _flgFmt, _x)
                            )
                        )
                    ),
                    LET(
                        // expanded format, delimited elements
                        _cDate, TEXTSPLIT(_sDate, "-"),
                        _cols, COLUMNS(_cDate),
                        IFS(
                            _cols = 2,
                            IF(
                                (LEN(INDEX(_cDate, 1, 1)) < 4) + (LEN(INDEX(_cDate, 1, 1)) > 5) +
                                    (LEN(INDEX(_cDate, 1, 2)) <> 2),
                                #VALUE!,
                                LET(
                                    _yearCE, _yearSign * VALUE(INDEX(_cDate, 1, 1)),
                                    _month, VALUE(INDEX(_cDate, 1, 2)),
                                    _day, "",
                                    fnValidDate(_yearCE, _month, _day, _flgFmt, 2)
                                )
                            ),
                            _cols = 3,
                            IF(
                                (LEN(INDEX(_cDate, 1, 1)) < 4) + (LEN(INDEX(_cDate, 1, 1)) > 5) +
                                    (LEN(INDEX(_cDate, 1, 2)) <> 2) + (LEN(INDEX(_cDate, 1, 3)) <> 2),
                                #VALUE!,
                                LET(
                                    _yearCE, _yearSign * VALUE(INDEX(_cDate, 1, 1)),
                                    _month, VALUE(INDEX(_cDate, 1, 2)),
                                    _day, VALUE(INDEX(_cDate, 1, 3)),
                                    fnValidDate(_yearCE, _month, _day, _flgFmt, 2)
                                )
                            ),
                            
                            // _cols = 1 or > 3
                            TRUE,
                            #VALUE!
                        )
                    )
                )
            )
        )
    )
);

/*-----------------------------------------------------------------------------------------------------
PARSE_TIME

Returns the hour, minute and second of time from text in the ISO 8601 format.
Columns:
  1 - Hour
  2 - Minute
  3 - Second

Parameters
-------------------------------------------------------------------------------------------------------
Text           : ISO 8601 formatted time.
               : Example formats (not exhaustive):
               : Thh:mm:ss.sss
               : Thh:mm:ss
               : Thhmm
[ReturnFormat] : Sets whether to return from which format the time was parsed
-----------------------------------------------------------------------------------------------------*/
PARSE_TIME = LAMBDA(
    Text,
    [ReturnFormat],
    LET(
        _flgFmt, N(ReturnFormat) <> 0,
        IF(Text = "",
            IF(_flgFmt, HSTACK("", "", "", 0), HSTACK("", "", "")),
            // LEFT(Text, 1) <> "T" (case-sensitive)
            IF(CODE(LEFT(Text, 1)) <> 84,
                #VALUE!,
                LET(
                    fnValidTime, LAMBDA(_h, _m, _s, _f, _x,
                        IF(IS_VALID_TIME(_h, _m, _s),
                            IF(_f, HSTACK(_h, _m, _s, _x), HSTACK(_h, _m, _s)),
                            #NUM!
                        )
                    ),
                    _sTime, RIGHT(Text, LEN(Text) - 1),
                    _basic, IFERROR(FIND(":", _sTime), 0) = 0,
                    IF(_basic,
                        LET(
                            // basic format, positional elements
                            _cLen, LEN(_sTime),
                            IF(
                                ((_cLen = 2) + (_cLen = 4) + (_cLen = 6) + (_cLen = 10)) = 0,
                                #VALUE!,
                                LET(
                                    _hour, VALUE(LEFT(_sTime, 2)),
                                    _minute, IF(_cLen >= 4, VALUE(MID(_sTime, 3, 2)), ""),
                                    _second, IF(_cLen > 4, VALUE(RIGHT(_sTime, _cLen - 4)), ""),
                                    _x, IF(_cLen = 2, 3, 1),
                                    fnValidTime(_hour, _minute, _second, _flgFmt, _x)
                                )
                            )
                        ),
                        LET(
                            // expanded format, delimited elements
                            _cTime, TEXTSPLIT(_sTime, ":"),
                            _cols, COLUMNS(_cTime),
                            _parseErr, IF(
                                _cols > 3,
                                1,
                                IF(
                                    _cols = 2,
                                    (LEN(INDEX(_cTime, 1, 1)) <> 2) + (LEN(INDEX(_cTime, 1, 2)) <> 2),
                                    // _cols = 3
                                    (LEN(INDEX(_cTime, 1, 1)) <> 2) + (LEN(INDEX(_cTime, 1, 2)) <> 2) +
                                        (
                                            (LEN(INDEX(_cTime, 1, 3)) <> 2) *
                                                (LEN(INDEX(_cTime, 1, 3)) <> 6)
                                        )
                                )
                            ),
                            IF(
                                _parseErr,
                                #VALUE!,
                                LET(
                                    _hour, VALUE(INDEX(_cTime, 1, 1)),
                                    _minute, VALUE(INDEX(_cTime, 1, 2)),
                                    _second, IF(_cols = 3, VALUE(INDEX(_cTime, 1, 3)), ""),
                                    fnValidTime(_hour, _minute, _second, _flgFmt, 2)
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);


/*-----------------------------------------------------------------------------------------------------
PARSE_TIME_ZONE

Returns the time zone offset in minutes from text in the ISO 8601 format.

Parameters
-------------------------------------------------------------------------------------------------------
Text :         : ISO 8601 formatted time zone.
               : Example formats (not exhaustive):
               : +hh:mm:ss
               : -hh:mm
               : +hh
               : Z
[ReturnFormat] : Sets whether to return from which format the time zone was parsed
-----------------------------------------------------------------------------------------------------*/
PARSE_TIME_ZONE = LAMBDA(
    Text,
    [ReturnFormat],
    LET(
        _flgFmt, N(ReturnFormat) <> 0,
        IF(
            Text = "", IF(_flgFmt, HSTACK("", 0), ""),
            // Text = "Z" (case-sensitive)
            IF(
                (CODE(Text) = 90) * (LEN(Text) = 1),
                IF(_flgFmt, HSTACK(0, 3), 0),
                IF(
                    (LEFT(Text, 1) = "+") + (LEFT(Text, 1) = "-") = 0,
                    #VALUE!,
                    LET(
                        fnValidTZO, LAMBDA(_sg, _h, _m, _s, _f, _x,
                            IF(
                                (_m >= 60) + (_s >= 60),
                                #NUM!,
                                LET(
                                    _tzoMinutes, _sg * (_h * 60 + _m + _s / 60),
                                    IF(IS_VALID_TIME_ZONE(_tzoMinutes),
                                        IF(_f, HSTACK(_tzoMinutes, _x), _tzoMinutes),
                                        #NUM!
                                    )
                                )
                            )
                        ),
                        _sign, IF(LEFT(Text, 1) = "-", -1, 1),
                        _sTZO, RIGHT(Text, LEN(Text) - 1),
                        _basic, IFERROR(FIND(":", _sTZO), 0) = 0,
                        IF(_basic,
                            LET(
                                // basic format, positional elements
                                _cLen, LEN(_sTZO),
                                IF(
                                    ((_cLen = 2) + (_cLen = 4) + (_cLen = 6)) = 0,
                                    #VALUE!,
                                    LET(
                                        _hour, VALUE(LEFT(_sTZO, 2)),
                                        _minute, IF(_cLen >= 4, VALUE(MID(_sTZO, 3, 2)), 0),
                                        _second, IF(_cLen > 4, VALUE(RIGHT(_sTZO, _cLen - 4)), 0),
                                        _x, IF(_cLen = 2, 3, 1),
                                        fnValidTZO(_sign, _hour, _minute, _second, _flgFmt, _x)
                                    )
                                )
                            ),
                            LET(
                                // expanded format, delimited elements
                                _cTZO, TEXTSPLIT(_sTZO, ":"),
                                _cols, COLUMNS(_cTZO),
                                _parseErr, IF(
                                    _cols > 3,
                                    1,
                                    IF(
                                        _cols = 2,
                                        (LEN(INDEX(_cTZO, 1, 1)) <> 2) + (LEN(INDEX(_cTZO, 1, 2)) <> 2),
                                        // _cols = 3
                                        (LEN(INDEX(_cTZO, 1, 1)) <> 2) +
                                            (LEN(INDEX(_cTZO, 1, 2)) <> 2) +
                                            (LEN(INDEX(_cTZO, 1, 3)) <> 2)
                                    )
                                ),
                                IF(
                                    _parseErr,
                                    #VALUE!,
                                    LET(
                                        _hour, VALUE(INDEX(_cTZO, 1, 1)),
                                        _minute, VALUE(INDEX(_cTZO, 1, 2)),
                                        _second, IF(_cols = 3, VALUE(INDEX(_cTZO, 1, 3)), 0),
                                        fnValidTZO(_sign, _hour, _minute, _second, _flgFmt, 2)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);


/*-----------------------------------------------------------------------------------------------------
PARSE_ORDINAL_DATE

Returns the year and ordinal day from text in the ISO 8601 format.
Columns:
  1 - Year CE
  2 - Ordinal Day

Parameters
-------------------------------------------------------------------------------------------------------
Text           : ISO8601 formatted year and ordinal day.
               : Example formats (not exhaustive):
               : +YYYYY-DDD
               : -YYYY-DDD
               : YYYY-DDD
               : YYYYDDD
               :
               : Note YYYYYDDD is invalid, due to collision with format YYYYMMDD

[ReturnFormat] : Sets whether to return from which format the ordinal date was parsed
-----------------------------------------------------------------------------------------------------*/
PARSE_ORDINAL_DATE = LAMBDA(
    Text,
    [ReturnFormat],
    LET(
        _flgFmt, N(ReturnFormat) <> 0,
        IF(Text = "",
            IF(_flgFmt, HSTACK("", "", 0), HSTACK("", "")),
            LET(
                fnValidOrdinalDate, LAMBDA(_y, _o, _f, _x,
                    IF(IS_VALID_ORDINAL_DATE(_y, _o),
                        IF(_f, HSTACK(_y, _o, _x), HSTACK(_y, _o)),
                        #NUM!
                    )
                ),
                _yearSign, IF(LEFT(Text, 1) = "-", -1, 1),
                _sDate, IFS(
                    _yearSign = -1,
                    RIGHT(Text, LEN(Text) - 1),
                    LEFT(Text, 1) = "+",
                    RIGHT(Text, LEN(Text) - 1),
                    TRUE,
                    Text
                ),
                _cDate, TEXTSPLIT(_sDate, "-"),
                _cols, COLUMNS(_cDate),
                IF(
                    _cols = 1,
                    LET(
                        // basic format, positional
                        _cLen, LEN(_sDate),
                        IFS(
                            (_cLen >= 4) * (_cLen <= 5),
                                fnValidOrdinalDate(_yearSign * VALUE(_sDate), "", _flgFmt, 3),
                            _cLen = 7,
                            LET(
                                _yearCE, _yearSign * VALUE(LEFT(_sDate, _cLen - 3)),
                                _ordinal, VALUE(RIGHT(_sDate, 3)),
                                fnValidOrdinalDate(_yearCE, _ordinal, _flgFmt, 1)
                            ),
                            TRUE,
                            #VALUE!
                        )
                    ),
                    IF(
                        _cols > 2,
                        #VALUE!,
                        // expanded format, delimited elements
                        IF(
                            (LEN(INDEX(_cDate, 1, 1)) < 4) + (LEN(INDEX(_cDate, 1, 1)) > 5) +
                                (LEN(INDEX(_cDate, 1, 2)) <> 3),
                            #VALUE!,
                            LET(
                                _yearCE, _yearSign * VALUE(INDEX(_cDate, 1, 1)),
                                _ordinal, VALUE(INDEX(_cDate, 1, 2)),
                                fnValidOrdinalDate(_yearCE, _ordinal, _flgFmt, 2)
                            )
                        )
                    )
                )
            )
        )
    )
);


/*-----------------------------------------------------------------------------------------------------
PARSE_WEEK_DATE

Returns the year, week and day of week from text in the ISO 8601 format.
Columns:
  1 - Year CE
  2 - Week
  3 - Weekday

Parameters
-------------------------------------------------------------------------------------------------------
Text           : ISO8601 formatted year and ordinal week.
               : Example formats (not exhaustive):
               : +YYYYY-Www
               : -YYYY-Www
               : YYYY-Www-D
               : YYYYWwwD
[ReturnFormat] : Sets whether to return from which format the week date was parsed
-----------------------------------------------------------------------------------------------------*/
PARSE_WEEK_DATE = LAMBDA(
    Text,
    [ReturnFormat],
    LET(
        _flgFmt, N(ReturnFormat) <> 0,
        IF(Text = "",
            IF(_flgFmt, HSTACK("", "", "", 0), HSTACK("", "", "")),
            LET(
                fnValidWeekDate, LAMBDA(_y, _w, _dow, _f, _x,
                    IF(IS_VALID_WEEK_DATE(_y, _w, _dow),
                        IF(_f, HSTACK(_y, _w, _dow, _x), HSTACK(_y, _w, _dow)),
                        #NUM!
                    )
                ),
                _yearSign, IF(LEFT(Text, 1) = "-", -1, 1),
                _sWeekDate, IFS(
                    _yearSign = -1,
                    RIGHT(Text, LEN(Text) - 1),
                    LEFT(Text, 1) = "+",
                    RIGHT(Text, LEN(Text) - 1),
                    TRUE,
                    Text
                ),
                _basic, IFERROR(FIND("-", _sWeekDate), 0) = 0,
                IF(
                    _basic,
                    LET(
                        // basic format, positional elements
                        _cBasic, TEXTSPLIT(_sWeekDate, "W"),
                        _parseErr, IF(
                            COLUMNS(_cBasic) <> 2,
                            1,
                            LET(
                                _yLen, LEN(INDEX(_cBasic, 1, 1)),
                                _wLen, LEN(INDEX(_cBasic, 1, 2)),
                                (_yLen < 4) + (_yLen > 5) + (_wLen < 2) + (_wLen > 3)
                            )
                        ),
                        IF(
                            _parseErr,
                            #VALUE!,
                            LET(
                                _yearCE, _yearSign * VALUE(INDEX(_cBasic, 1, 1)),
                                _week, VALUE(LEFT(INDEX(_cBasic, 1, 2), 2)),
                                _dow, IF(
                                    LEN(INDEX(_cBasic, 1, 2)) = 2,
                                    "",
                                    VALUE(RIGHT(INDEX(_cBasic, 1, 2), 1))
                                ),
                                fnValidWeekDate(_yearCE, _week, _dow, _flgFmt, 1)
                            )
                        )
                    ),
                    LET(
                        // expanded format, delimited elements
                        _cExpanded, TEXTSPLIT(_sWeekDate, "-"),
                        _cols, COLUMNS(_cExpanded),
                        _parseErr, IF(
                            _cols > 3,
                            1,
                            LET(
                                _yLen, LEN(INDEX(_cExpanded, 1, 1)),
                                _wLen, LEN(INDEX(_cExpanded, 1, 2)),
                                _dLen, IF(_cols = 2, 0, LEN(INDEX(_cExpanded, 1, 3))),
                                IFS(
                                    _yLen < 4,
                                    1,
                                    _yLen > 5,
                                    1,
                                    _wLen <> 3,
                                    1,
                                    _dLen > 1,
                                    1,
                                    // LEFT(INDEX(_cExpanded, 1, 2), 1) <> "W" (case-sensitive)
                                    CODE(LEFT(INDEX(_cExpanded, 1, 2), 1)) <> 87,
                                    1,
                                    TRUE,
                                    0
                                )
                            )
                        ),
                        IF(
                            _parseErr,
                            #VALUE!,
                            LET(
                                _yearCE, _yearSign * VALUE(INDEX(_cExpanded, 1, 1)),
                                _week, VALUE(RIGHT(INDEX(_cExpanded, 1, 2), 2)),
                                _dow, IF(_cols = 2, "", VALUE(INDEX(_cExpanded, 1, 3))),
                                fnValidWeekDate(_yearCE, _week, _dow, _flgFMt, 2)
                            )
                        )
                    )
                )
            )
        )
    )
);

/*-----------------------------------------------------------------------------------------------------
PARSE_DATE_TIME

Returns the date and time of text in the ISO8601 format.
With columns:
  1 - Date Type : 0 - no date present
                  1 - Calendar date
                  2 - Ordinal date
                  3 - Week date
  2 - Year 
  3 - Month/Week
  4 - Day/Ordinal
  5 - Hour
  6 - Minute
  7 - Second
  8 - Time zone offset in minutes

Parameters
-------------------------------------------------------------------------------------------------------
Text         : ISO8601 formatted date.
             : Example formats (not exhaustive):
             :   +YYYYY-MM-DDThh:mm:ss.sss+hh:mm:ss
             :   -YYYY-MM-DDThh:mm:ss+hh:mm
             :   YYYY-MM-DDThh:mm-hh
             :   YYYY-MM-DDThh:mmZ
             :   YYYY-Www-DThh:mm
[Permissive] : Allow mixed use of basic and extended formats
-----------------------------------------------------------------------------------------------------*/
PARSE_DATE_TIME = LAMBDA(
    Text,
    [Permissive],
    IF(
        Text = "",
        HSTACK("", "", "", "", "", "", "", "", "", "", ""),
        LET(
            fnSplit, LAMBDA(Text,
                IF(
                    Text = "",
                    HSTACK("", "", ""),
                    // Text = "Z" (case-sensitive)
                    IF(
                        (CODE(Text) = 90) * (LEN(Text) = 1),
                        HSTACK("", "", "Z"),
                        LET(
                            _dSplit, TEXTSPLIT(Text, "T"),
                            _cols, COLUMNS(_dSplit),
                            IFS(
                                _cols = 2,
                                LET(
                                    // has a time part
                                    _sDate, INDEX(_dSplit, 1, 1),
                                    _sTimePart, "T" & INDEX(_dSplit, 1, 2),
                                    _tSplit, TEXTSPLIT(_sTimePart, {"+", "-", "Z"}),
                                    IF(
                                        COLUMNS(_tSplit) <= 1,
                                        // time value with no TZ
                                        HSTACK(_sDate, _sTimePart, ""),
                                        LET(
                                            // has time zone
                                            _sTime, INDEX(_tSplit, 1, 1),
                                            _sTZ, RIGHT(_sTimePart, LEN(_sTimePart) - LEN(_sTime)),
                                            HSTACK(_sDate, _sTime, _sTZ)
                                        )
                                    )
                                ),
                                _cols = 1,
                                LET(
                                    // hint this should be a date value
                                    _colonPos, IFERROR(FIND(":", Text), 0),
                                    IF(
                                        _colonPos > 0,
                                        IF(
                                            (LEFT(Text, 1) = "+") + (LEFT(Text, 1) = "-"),
                                            
                                            // assume a timezone
                                            HSTACK("", "", Text),
                                            
                                            // indeterminate
                                            #VALUE!
                                        ),
                                        
                                        // _colonPos = 0
                                        IF(
                                            LEN(Text) >= 6,
                                            // assume a date value
                                            HSTACK(Text, "", ""),
                                            
                                            // indeterminate
                                            #VALUE!
                                        )
                                    )
                                ),
                                // _cols = 0 or > 2
                                TRUE,
                                #VALUE!
                            )
                        )
                    )
                )
            ),
            fnDetectDateType, LAMBDA(_text,
                
                // no date type
                IF(
                    _text = "",
                    0,
                    IF(
                        IFERROR(FIND("W", _text), 0) <> 0,
                        // Y W DoW date type (basic or extended formats)
                        3,
                        LET(
                            _unsignedDate, IFS(
                                LEFT(_text, 1) = "+",
                                RIGHT(_text, LEN(_text) - 1),
                                LEFT(_text, 1) = "-",
                                RIGHT(_text, LEN(_text) - 1),
                                TRUE,
                                _text
                            ),
                            _dateLen, LEN(_unsignedDate),
                            _countMinus, _dateLen - LEN(SUBSTITUTE(_unsignedDate, "-", "")),
                            IFS(
                                // Y M D date type (extended format)
                                _countMinus = 2,
                                1,
                                _countMinus = 1,
                                LET(
                                    _minusPosFromEnd, LEN(_unsignedDate) -
                                        IFERROR(FIND("-", _unsignedDate), 0),
                                    IF(
                                        _minusPosFromEnd = 3,
                                        // Y O date type (extended format)
                                        2,
                                        
                                        // Y M date type (extended format)
                                        1
                                    )
                                ),
                                _countMinus = 0,
                                IF(
                                    // Y O date type (basic format)
                                    _dateLen = 7,
                                    2,
                                    
                                    // Y M D date type (basic format)
                                    1
                                )
                            )
                        )
                    )
                )
            ),
            fnCheckStrictness, LAMBDA(_cDate,_hms,_tzo,
                LET(
                    _dateFmt, INDEX(_cDate, 1, 4),
                    _timeFmt, INDEX(_hms, 1, 4),
                    _tzoFmt, INDEX(_tzo, 1, 2),
                    
                    _allFmt, IFS(
                        (_dateFmt <> 2) * (_timeFmt <> 2) * (_tzoFmt <> 2),
                            // all basic format where present
                            1,
                        (_dateFmt <> 1) * (_timeFmt <> 1) * (_tzoFmt <> 1),
                            // all extended format where present 
                            2,
                        TRUE,
                            // mixed format
                            0
                    ),
                    IF(N(_allFmt) = 0, 0,
                        LET(
                            _hasDate, _dateFmt <> 0,
                            _hasTime, _timeFmt <> 0,
                            _hasTZO, _tzoFmt <> 0,
                            _fullDate, INDEX(_cDate, 1, 3) <> "",
                            _passTest, (_hasDate * _hasTime * _fullDate) + (N(_hasDate) = 0),
                            N(_passTest)
                        )
                    )
                )
            ),
            _strict, N(Permissive) = 0,
            _parts, fnSplit(Text),
            IF(
                ISERROR(INDEX(_parts, 1, 1)),
                #VALUE!,
                LET(
                    _sDate, INDEX(_parts, 1, 1),
                    _isDateType, fnDetectDateType(_sDate),
                    _cDate, IFS(
                        _isDateType <= 1,
                            PARSE_DATE(_sDate, _strict),

                        _isDateType = 2,
                            LET(
                                _o, PARSE_ORDINAL_DATE(_sDate, _strict),
                                HSTACK(INDEX(_o, 1, 1), "", DROP(_o, , 1))
                            ),

                        _isDateType = 3,
                            PARSE_WEEK_DATE(_sDate, _strict)
                    ),

                    _hms, PARSE_TIME(INDEX(_parts, 1, 2), _strict),
                    _tzo, PARSE_TIME_ZONE(INDEX(_parts, 1, 3), _strict),

                    if(_strict,
                        LET(
                            _passTest, fnCheckStrictness(_cDate, _hms, _tzo),
                            IF(_passTest, 
                                HSTACK(_isDateType,
                                    DROP(_cDate, , -1),
                                    DROP(_hms, , -1),
                                    DROP(_tzo, , -1)
                                ),
                                #VALUE!
                            )
                        ),
                        HSTACK(_isDateType, _cDate, _hms, _tzo)
                    )
                )
            )
        )
    )
);


/*-----------------------------------------------------------------------------------------------------
FORMAT_DATE

Returns a date as text in the ISO 8601 format.
Example formats (not exhaustive):
+YYYYY-MM-DD
-YYYY-MM-DD
YYYY-MM-DD
YYYY-MM
YYYYMMDD
YYYY

Parameters
-------------------------------------------------------------------------------------------------------
YearCE  : Year in common era
[Month] : Month of year
[Day]   : Day of month
[Basic] : Return in basic format eg YYYYMMDD. Note YYYYMM is not permissable.
-----------------------------------------------------------------------------------------------------*/
FORMAT_DATE = LAMBDA(
    YearCE,
    [Month],
    [Day],
    [Basic],
    IF((YearCE = "") * (Month = "") * (Day = ""), "",
        IF(NOT(IS_VALID_DATE(YearCE, Month, Day)), #NUM!,
            LET(
                _basicFormat, N(Basic) <> 0,
                IF((Day = "") * _basicFormat, #VALUE!,
                    LET(
                        _y, INT(VALUE(YearCE)),
                        _sYear, IF(ABS(_y) >= 10000,
                            TEXT(_y, "+00000;-00000"),
                            TEXT(_y, "0000;-0000;0000")
                        ),
                        IF(Month = "",
                            _sYear,
                            LET(
                                _sMonth, TEXT(INT(VALUE(Month)), "00"), 
                                IF(Day = "",
                                    IF(_basicFormat, _sYear & _sMonth, _sYear & "-" & _sMonth),
                                    LET(
                                        _sDay, TEXT(INT(VALUE(Day)), "00"),
                                        IF(_basicFormat, _sYear & _sMonth & _sDay, _sYear & "-" & _sMonth & "-" & _sDay)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);


/*-----------------------------------------------------------------------------------------------------
FORMAT_TIME

Returns a time as text in the ISO 8601 format.
Example formats (not exhaustive):
Thh:mm:ss.sss
Thh:mm:ss
Thh:mm
Thhmmss
Thh

Parameters
-------------------------------------------------------------------------------------------------------
Hour        :
Minute      :
Second      :
[Basic]     : Return in basic format
[Precision] : Select precision level
            :   0 - automatic
            :   1 - hours
            :   2 - minutes
            :   3 - integer seconds
            :   4 - fractional seconds
-----------------------------------------------------------------------------------------------------*/
FORMAT_TIME = LAMBDA(
    Hour,
    Minute,
    Second,
    [Basic],
    [Precision],
    IF((Hour = "") * (Minute = "") * (Second = ""), "",
        IF(NOT(IS_VALID_TIME(Hour, Minute, Second)), #NUM!,
            LET(
                _basicFormat, N(Basic) <> 0,
                _s, ROUNDDOWN(VALUE(Second), 3),
                _m, INT(VALUE(Minute)),
                _h, INT(VALUE(Hour)),
                _precision, IF(N(Precision) <> 0,
                    N(Precision),
                    IFS(
                        Second <> "",
                            IF(_s = INT(_s), 3, 4),
                        Minute <> "",
                            2,
                        TRUE,
                            1
                    )
                ),
                IFS(
                    _precision = 1,
                        "T" & TEXT(_h, "00"),
                    _precision = 2,
                        IF(_basicFormat,
                            "T" & TEXT(_h, "00") & TEXT(_m, "00"),
                            "T" & TEXT(_h, "00") & ":" & TEXT(_m, "00")
                        ),
                    _precision = 3,
                        IF(_basicFormat,
                            "T" & TEXT(_h, "00") & TEXT(_m, "00") & TEXT(_s, "00"),
                            "T" & TEXT(_h, "00") & ":" & TEXT(_m, "00") & ":" & TEXT(_s, "00")
                        ),
                
                    //_precision = 4
                    TRUE,
                    IF(_basicFormat,
                        "T" & TEXT(_h, "00") & TEXT(_m, "00") & TEXT(_s, "00.000"),
                        "T" & TEXT(_h, "00") & ":" & TEXT(_m, "00") & ":" & TEXT(_s, "00.000")
                    )
                )
            )
        )
    )
);


/*-----------------------------------------------------------------------------------------------------
FORMAT_TIME_ZONE

Returns a time zone as text in the ISO 8601 format.
Example formats (not exhaustive):
+hh:mm:ss
+hh:mm
-hh:mm
+hh
Z

Parameters
-------------------------------------------------------------------------------------------------------
OffsetMinutes : Time zone offset from UTC in minutes.
              : Valid range -900..+900
[Basic]       : Return in basic format
[Precision]   : Select precision level
              :   0 - automatic
              :   1 - hours
              :   2 - minutes
              :   3 - seconds
[NoZulu]      : Use +00:00 instead of Z for UTC time zone.
-----------------------------------------------------------------------------------------------------*/
FORMAT_TIME_ZONE = LAMBDA(
    OffsetMinutes,
    [Basic],
    [Precision],
    [NoZulu],
    IF(OffsetMinutes = "", "",
        LET(
            _basicFormat, N(Basic) <> 0,
            _precision, N(Precision),
            _offsetMins, VALUE(OffsetMinutes),
            _nearZero, ROUNDDOWN(_offsetMins * 60, 0) = 0,
            IF((N(NoZulu) = 0) * _nearZero, "Z",
                IF(NOT(IS_VALID_TIME_ZONE(_offsetMins)), #NUM!,
                    LET(
                        _hasSecs, ROUNDDOWN(MOD(_offsetMins, 1) * 60, 0) > 0,
                        _sFmt, IFS(
                            _precision = 0,
                                IF(_hasSecs,
                                    IF(_basicFormat, "hhmmss", "hh:mm:ss"),
                                    IF(_basicFormat, "hhmm", "hh:mm")
                                ),
                            _precision = 1,
                                "hh",
                            _precision = 2,
                                IF(_basicFormat, "hhmm", "hh:mm"),
                            
                            // _precision = 3
                            TRUE,
                                IF(_basicFormat, "hhmmss", "hh:mm:ss")
                        ),
                        _sign, IF(SIGN(_offsetMins) < 0, "-", "+"),
                        _timeZoneOffset, ABS(_offsetMins) / 1440,
                        _sign & TEXT(_timeZoneOffset, _sFmt)
                    )
                )
            )
        )
    )
);


/*-----------------------------------------------------------------------------------------------------
FORMAT_ORDINAL_DATE

Returns an ordinal date as text in the ISO 8601 format.
Example formats (not exhaustive):
YYYY-DDD
YYYYDDD

Parameters
-------------------------------------------------------------------------------------------------------
YearCE  : Year in common era
Ordinal : Ordinal day of year
[Basic] : Return in basic format eg YYYYDDD.
-----------------------------------------------------------------------------------------------------*/
FORMAT_ORDINAL_DATE = LAMBDA(
    YearCE,
    Ordinal,
    [Basic],
    IF((YearCE = "") * (Ordinal = ""), "",
        IF(NOT(IS_VALID_ORDINAL_DATE(YearCE, Ordinal)), #NUM!,
            LET(
                _basicFormat, N(Basic) <> 0,
                _y, INT(VALUE(YearCE)),
                _o, INT(VALUE(Ordinal)),
                _sYear, IF(
                    ABS(_y) >= 10000,
                    TEXT(_y, "+00000;-00000"),
                    TEXT(_y, "0000;-0000;0000")
                ),
                IF(Ordinal = "", _sYear,
                    LET(
                        _sOrdinal, TEXT(_o, "000"),
                        IF(_basicFormat,
                            _sYear & _sOrdinal,
                            _sYear & "-" & _sOrdinal
                        )
                    )
                )
            )
        )
    )
);


/*-----------------------------------------------------------------------------------------------------
FORMAT_WEEK_DATE

Returns a week date as text in the ISO 8601 format.
Example formats (not exhaustive):
YYYY-Www-D
YYYY-Www
YYYYWwwD
YYYYWww

Parameters
-------------------------------------------------------------------------------------------------------
YearCE      : Year in common era
Week        : ISO defined week number of the year
[DayOfWeek] : Day of the week where 1..7 -> Mon..Sun 
[Basic]     : Return in basic format eg YYYYWwwD.
-----------------------------------------------------------------------------------------------------*/
FORMAT_WEEK_DATE = LAMBDA(
    YearCE,
    Week,
    DayOfWeek,
    [Basic],
    IF((YearCE = "") * (Week = "") * (DayOfWeek = ""), "",
        IF(NOT(IS_VALID_WEEK_DATE(YearCE, Week, DayOfWeek, 1)), #NUM!,
            LET(
                _basicFormat, N(Basic) <> 0,
                _y, INT(VALUE(YearCE)),
                _w, INT(VALUE(Week)),
                _dow, IF(DayOfWeek = "", "", INT(VALUE(DayOfWeek))),
                _sYear, IF(
                    ABS(_y) >= 10000,
                    TEXT(_y, "+00000;-00000"),
                    TEXT(_y, "0000;-0000;0000")
                ),
                _sWeek, TEXT(_w, "W00"),
                IF(
                    DayOfWeek = "",
                    IF(_basicFormat, _sYear & _sWeek, _sYear & "-" & _sWeek),
                    IF(_basicFormat, _sYear & _sWeek & _dow, _sYear & "-" & _sWeek & "-" & _dow)
                )
            )
        )
    )
);


/*-----------------------------------------------------------------------------------------------------
FORMAT_DATE_TIME

Returns a date and time as text in the ISO 8601 format.
Example formats (not exhaustive):
YYYY-MM-DDThh:mm:ss.sss+hh:mm:ss
YYYY-MM-DDThh:mm:ssZ
Thh:mm:ss

Parameters
-------------------------------------------------------------------------------------------------------
[DateType]       : Date type represented in DateArg1 and DateArg2
                 :   0 - Calendar date
                 :   1 - Ordinal date
                 :   2 - Week date 
[YearCE]         : Year in common era
[DateArg1]       : Month or Week
[DateArg2]       : Day or Ordinal
[Hour]           :
[Minute]         :
[Second]         :
[TimeZoneOffset] : Time zone offset in minutes from UTC 
[Basic]          : Return in basic format eg YYYYMMDDT1045+0930
[Precision]      : Precision level to use
                 :   0 - Automatic
                 :   1 - Year
                 :   2 - Month/Week
                 :   3 - Day/Ordinal
                 :   4 - Hour
                 :   5 - Minute
                 :   6 - Second
                 :   7 - Fractional
[NoTimezone]     : Drop tim zone from output.
[NoZulu]         : Use +00:00 instead of Z for UTC time zone.
-----------------------------------------------------------------------------------------------------*/
FORMAT_DATE_TIME = LAMBDA(
    DateType,
    [YearCE],
    [DateArg1],
    [DateArg2],
    [Hour],
    [Minute],
    [Second],
    [TimeZoneOffset],
    [Basic],
    [Precision],
    [NoTimeZone],
    [NoZulu],
    LET(
        _hasDate, (YearCE <> "") + (DateArg1 <> "") + (DateArg2 <> "") <> 0,
        _hasTime, (Hour <> "") + (Minute <> "") + (Second <> "") <> 0,
        _hasTimeZone, (TimeZoneOffset <> ""),
        _showTimeZone, N(NoTimeZone) = 0, 
        _isEmpty, _hasDate + _hasTime + (_hasTimeZone * _showTimeZone) = 0,
        IF(_isEmpty, "",
            IF((_hasDate * _hasTimeZone * _showTimeZone) * NOT(_hasTime), #VALUE!,
                LET(
                    _dateType, N(DateType),
                    _precision, MAX(N(Precision), 0),
                    _sDate, IFS(
                        _dateType = 1,
                            IFS(
                                (_precision = 0) + (_precision >= 3), 
                                    FORMAT_DATE(YearCE, DateArg1, DateArg2, Basic),
                                _precision = 1, 
                                    FORMAT_DATE(YearCE, "", "", Basic),
                                _precision = 2, 
                                    FORMAT_DATE(YearCE, DateArg1, "", Basic)
                            ),

                        _dateType = 2,
                            IF((_precision = 0) + (_precision >= 3), 
                                FORMAT_ORDINAL_DATE(YearCE, DateArg2, Basic),
                                FORMAT_ORDINAL_DATE(YearCE, "", Basic)
                            ),
                            
                        _dateType = 3,
                            IFS(
                                (_precision = 0) + (_precision >= 3), 
                                    FORMAT_WEEK_DATE(YearCE, DateArg1, DateArg2, Basic),
                                _precision = 1, 
                                    FORMAT_WEEK_DATE(YearCE, "", "", Basic),
                                _precision = 2, 
                                    FORMAT_WEEK_DATE(YearCE, DateArg1, "", Basic)
                            ),
                        
                        TRUE, //_dateType = 0,
                            ""
                    ),
                    _sTime, IF((_precision = 0) + (_precision >= 4),
                        FORMAT_TIME(Hour, Minute, Second, Basic, MAX(_precision - 3, 0)),
                        ""
                    ),
                    _sTZO, IF(((_precision = 0) + (_precision >= 4)) * _hasTimeZone * _showTimeZone,
                        IFS(_precision = 0,
                                FORMAT_TIME_ZONE(TimeZoneOffset, Basic, 0, NoZulu),
                            _precision >= 6,
                                FORMAT_TIME_ZONE(TimeZoneOffset, Basic, 3, NoZulu),
                            TRUE, //_precision >= 4
                                FORMAT_TIME_ZONE(TimeZoneOffset, Basic, MAX(_precision - 3, 0), NoZulu)
                        ),
                        ""
                    ),
                    _sDate & _sTime & _sTZO
                )
            )
        )
    )
);


/*-----------------------------------------------------------------------------------------------------
ISO_TO_DATE

Converts text in ISO format to an Excel date. 

Parameters
-------------------------------------------------------------------------------------------------------
Text                  : ISO 8601 formatted date, time, time zone.
[ReturnTimeZoneOffset : Include another column to eturn time zone offset in minutes.
-----------------------------------------------------------------------------------------------------*/
ISO_TO_DATE = LAMBDA(
    Text,
    [ReturnTimeZoneOffset],
    LET(
        _elements, PARSE_DATE_TIME(Text),
        _dateType, INDEX(_elements, 1, 1),
        _hasTime, (INDEX(_elements, 1, 5) <> "") + (INDEX(_elements, 1, 6) <> "") + (INDEX(_elements, 1, 7) <> "") <> 0,
        _hasTimeZone, (INDEX(_elements, 1, 8) <> ""),
        _retTZO, N(ReturnTimeZoneOffset) <> 0,
        _year, N(INDEX(_elements, 1, 2)),
        IF((_year < 1900) + (_year >= 10000), #NUM!,
            LET(
                _date, IFS(_dateType = 0, "",
                    _dateType = 1,
                        DATE(_year, N(INDEX(_elements, 1, 3)), N(INDEX(_elements, 1, 4))),

                    _dateType = 2,
                        LET(
                            _cDate, FROM_ORDINAL_DATE(_year, N(INDEX(_elements, 1, 4))),
                            DATE(INDEX(_cDate, 1, 1), INDEX(_cDate, 1, 2), INDEX(_cDate, 1, 3))
                        ),
                    
                    _dateType = 3,
                        LET(
                            _cDate, FROM_WEEK_DATE(_year, N(INDEX(_elements, 1, 3)), N(INDEX(_elements, 1, 4))),
                            DATE(INDEX(_cDate, 1, 1), INDEX(_cDate, 1, 2), INDEX(_cDate, 1, 3))
                        )
                ),
                _time, IF(_hasTime,
                    TIME(N(INDEX(_elements, 1, 5)), N(INDEX(_elements, 1, 6)), N(INDEX(_elements, 1, 7))),
                    ""
                ),
                _dt, N(_date) + N(_time),
                IF(_retTZO,
                    LET(
                        _tzo, IF(_hasTimeZone,
                            INDEX(_elements, 1, 8),
                            ""
                        ),
                        HSTACK(_dt, _tzo)
                    ),
                    _dt
                )
            )
        )
    )
);

/*-----------------------------------------------------------------------------------------------------
DATE_TO_ISO

Converts an Excel date to ISO formatted text.

Parameters
-------------------------------------------------------------------------------------------------------
Date             : An Excel date and/or time.
[TimeZoneOffset] : Time zone offset in minutes from UTC 
[Basic]          : Return in basic format eg YYYYMMDDT1045+0930
[Precision]      : Precision level to use
                 :   0 - Automatic
                 :   1 - Year
                 :   2 - Month/Week
                 :   3 - Day/Ordinal
                 :   4 - Hour
                 :   5 - Minute
                 :   6 - Second
                 :   7 - Fractional
[NoTimezone]     : Drop tim zone from output.
[NoZulu]         : Use +00:00 instead of Z for UTC time zone.
-----------------------------------------------------------------------------------------------------*/
DATE_TO_ISO = LAMBDA(
    Date,
    [TimeZoneOffset],
    [Basic],
    [Precision],
    [NoTimeZone],
    [NoZulu],
    LET(
        _isDate, N(INT(Date) <> 0),
        _year, IF(_isDate, YEAR(Date), ""),
        _month, IF(_isDate, MONTH(Date), ""),
        _day, IF(_isDate, DAY(Date), ""),
        FORMAT_DATE_TIME(
            _isDate, _year, _month, _day,
             HOUR(Date), MINUTE(Date), SECOND(Date),
            TimeZoneOffset, Basic, Precision, NoTimeZone, NoZulu
        )
    )
);
