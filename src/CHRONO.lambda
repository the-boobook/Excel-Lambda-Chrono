/*##############################################################################################################
# CHRONO v3.0                                                                                                  #
#                                                                                                              #
# Module for working with dates and times in the Gregorian and Julian calendars outside the range of the       #
# Excel Date/Time type.                                                                                        #
#                                                                                                              #
# Dependencies: FN module, ARRAYS module                                                                       #
#                                                                                                              #
# TIMESPAN                                                                                                     #
# ------------------------------------------------------------------------------------------------------------ #
# IS_VALID_TIMESPAN          Tests if a sexagesimal complication is a valid timespan. A component can exceed   #
#                            its modulus if no higher order element is provided.                               #
# TIMESPAN                   Returns a decimal timespan as a fraction of a day from a sexagesimal complication.#
#                            Note components exceeding their modulus will carry.                               #
# ROUND_TIMESPAN             Returns a decimal timespan value rounded to the specified precision on a low      #
#                            order component.                                                                  #
# TIMESPAN_TO_DHMS           Returns a sexagesimal complication from a decimal timespan expressed from the     #
#                            specified high to low order components.                                           #
# RESOLVE_TIMESPAN_DHMS      Resolves a timespan sexagesimal complication so that each component is within its #
#                            modulus.                                                                          #
# PARSE_TIMESPAN_DHMS        Parses a text timespan expression as a sexagesimal complication.                  #
# PARSE_TIMESPAN             Parses a text timespan expression as a decimal value.                             #
# FORMAT_TIMESPAN            Returns a timespan as text in the specified format from a given decimal value.    #
#                                                                                                              #
# COMPLICATIONS                                                                                                #
# ------------------------------------------------------------------------------------------------------------ #
# VALIDATE_DT                Validate a day and time complication.                                             #
# IS_VALID_DT                Tests if a day and time complication is valid.                                    #
# RESOLVE_DT                 Resolves a day and time complication, where time can exceed its modulus.          #
# COMBINE_DT                 Combines a day and time complication to a decimal day value.                      #
# DT_COMPLICATION            Resolves a day and time complication from a decimal day value.                    #
# ROUND_TO_DT                Takes a decimal day value and returns a day and time complication rounded to a    #
#                            specified low order component.                                                    #
# IS_VALID_TIME_OF_DAY       Tests if a sexagesimal complication is a valid time of day.                       #
# TIME_OF_DAY                Returns a decimal time of day value from a time complication.                     #
# DAY_AND_TIME_TO_DHMS       Returns the sexagesimal complication from a day and time value expressed to a     #
#                            specified low order component.                                                    #
# RESOLVE_DHMS               Resolves a sexagesimal complication to represent day and time of day so that each #
#                            component is within its modulus.                                                  #
# PARSE_TIME_OF_DAY_HMS      Parses a formatted time of day into a time complication.                          #
# PARSE_TIME_OF_DAY          Parses a formatted time of day as a decimal value.                                #
# FORMAT_TIME_OF_DAY         Returns a formatted sexagesimal complication from a decimal time of day.          #
#                                                                                                              #
# TIME ZONE                                                                                                    #
# ------------------------------------------------------------------------------------------------------------ #
# IS_VALID_TZO               Tests if a time zone offset in minutes is within the range -900..+900             #
# TIMESPAN_TO_TZO            Converts a deimal timespan into time zone offset minutes.                         #
# TZO_TO_TIMESPAN            Converts time zone offset minutes into a decimal timespan.                        #
# PARSE_ISO_TZO              Parses an ISO formatted time zone offset into a decimal timespan.                 #
# FORMAT_ISO_TZO             Returns a time zone offset as text in ISO format.                                 #
# MILITARY_TZO               Returns the time zone offset in minutes of a military time zone designator.       #
# TZO_TO_MILITARY            Returns the closest military time zone designator, its offset in minutes and the  #
#                            time adjustment to that time zone for the provided time zone offset in minutes.   #
# SHIFT_TIMEZONE             Translates a Modified Julian Date from one time zone to another. If a time zone   #
#                            is omitted it is assumed to be UTC.                                               #
#                                                                                                              #
# YEAR                                                                                                         #
# ------------------------------------------------------------------------------------------------------------ #
# YEAR_BCE_TO_CE             Converts to year value relative to the Common Era for a given year Before Common  #
#                            Era. Function is symmetrical, can also be used for CE to BCE conversion.          #
# IS_LEAP_YEAR               Tests if a year includes a leap day in the given calendar.                        #
# DAYS_IN_YEAR               Returns number of days in the given year of the specified calendar.               #
# PARSE_ISO_YEAR             Returns a number representing the year relative to the common era from a text     #
#                            representation of year in ISO8601 format.                                         #
# FORMAT_ISO_YEAR            Returns a year formatted in ISO8601 style.                                        #
# PARSE_LITERARY_YEAR        Returns a number representing the year relative to the common era from a given    #
#                            literary year.                                                                    #
# FORMAT_LITERARY_YEAR       Returns a year formatted in literary style.                                       #
#                                                                                                              #
# MONTH                                                                                                        #
# ------------------------------------------------------------------------------------------------------------ #
# PARSE_MONTH                Returns a number representing the month of year from a text expression.           #
# MONTH_NAME                 Returns name of month.                                                            #
# DAYS_IN_MONTH              Returns number of days in the given month and year of the specified calendar.     #
#                                                                                                              #
# WEEKDAY                                                                                                      #
# ------------------------------------------------------------------------------------------------------------ #
# CONVERT_WEEKDAY_NUMBER     Returns an integer for the day of the week from the traditonal numbering scheme   #
#                            to the ISO definition, or vice versa.                                             #
# PARSE_WEEKDAY              Returns a number representing the day of the week from a given text weekday name. #
# WEEKDAY_NAME               Returns name of an ISO day of week number as text.                                #
#                                                                                                              #
# CALENDAR DATE                                                                                                #
# ------------------------------------------------------------------------------------------------------------ #
# VALIDATE_CALENDAR_DATE     Validate a year, month and day representation of a date of the specified calendar.#
# IS_VALID_CALENDAR_DATE     Tests if a month and day representation of a date is valid for the specified      #
#                            calendar.                                                                         #
# RESOLVE_CALENDAR_DATE      Resolves the date where month and day values may exceed their valid range.        #
# GREGORIAN_TO_JULIAN        Translates a date in the Gregorian proleptic calendar to the Julian proleptic     #
#                            calendar.                                                                         #
# JULIAN_TO_GREGORIAN        Translates a date in the Julian proleptic calendar to the Gregorian proleptic     #
#                            calendar.                                                                         #
# SECULAR_DIFFERENCE         Returns the number of days the Gregorian proleptic calendar is ahead of the       #
#                            Julian proleptic calendar for a given date.                                       #
# PARSE_ISO_CALENDAR_DATE    Parses an ISO formatted calendar date into respective parts of year, month and    #
#                            day.                                                                              #
# FORMAT_ISO_CALENDAR_DATE   Returns a calendar date as text in ISO format.                                    #
# PARSE_CALENDAR_DATE        Parses a text representation of a calendar date into respective parts of year,    #
#                            month and day.                                                                    #
# FORMAT_CALENDAR_DATE       Returns a calendar date as text in the short modern style.                        #
# PARSE_LITERARY_DATE        Parses a calendar date formatted in literay style into respective parts of year,  #
#                            month, day and weekday.                                                           #
# FORMAT_LITERARY_DATE       Returns a calendar date as text in the literary style.                            #
#                                                                                                              #
# JULIAN DATES                                                                                                 #
# ------------------------------------------------------------------------------------------------------------ #
# JDN                        Returns the Julian Day Number (JDN) of the provided date in the specified         #
#                            calendar. Note the Julian Day Number is an integer type and is an ordinal day     #
#                            number referenced from January 1, 4713 BC in the proleptic Julian calendar. It    #
#                            does not include any value for time of day.                                       #
# MJDN                       Returns the Modified Julian Day Number (MJDN) of the provided date in the         #
#                            specified calendar. Note the Modified Julian Day Number is an integer type and    #
#                            is an ordinal day number referenced from November 17, 1858 in the proleptic       #
#                            Gregorian calendar. It does not include any value for time of day.                #
# JDN_TO_MJDN                Converts a Julian Day Number (JDN) to a Modified Julian Day Number (MJDN).        #
# MJDN_TO_JDN                Converts a Modified Julian Day Number (MJDN) to a Julian Day Number (JDN).        #
# JDN_TO_CALENDAR_DATE       Converts a Julian Day Number (JDN) to a date in the specified calendar.           #
# MJDN_TO_CALENDAR_DATE      Converts a Modified Julian Day Number (MJDN) to a date in the specified calendar. #
# JDN_TO_WEEKDAY             Returns the ISO weekday number for a given Julian Day Number (JDN).               #
# MJDN_TO_WEEKDAY            Returns the ISO weekday number for a given Modified Julian Day Number (MJDN).     #
# JULIAN_DATE                Returns the Julian Date of the provided date and time of day in the specified     #
#                            calendar. Note that the decimal time component of Julian Date is based from       #
#                            midday.                                                                           #
# MODIFIED_JULIAN_DATE       Returns the Modified Julian Date of the provided date and time of day in the      #
#                            specified calendar. Note that the time component of Modified Julian Date is       #
#                            based from midnight.                                                              #
# JDATE_TO_MJDATE            Converts a Julian Date (JDATE) to a Modified Julian Date (MJDATE). Note that the  #
#                            decimal time component of MJDATE is based from midnight.                          #
# MJDATE_TO_JDATE            Converts a Modified Julian Date (MJDATE) to a Julian Date (JDATE). Note that the  #
#                            decimal time component of JDATE is based from midday.                             #
# JDATE_TO_JDN               Returns the corresponding Julian Day Number (JDN) of a given Julian Date (JDATE). #
# JDN_TO_JDATE               Returns the Julian Date (JDATE) at 0:00 of a given Julian Day Number (JDN).       #
# MJDATE_TO_MJDN             Returns the corresponding Modified Julian Day Number (MJDN) of a given Modified   #
#                            Julian Date (JDATE).                                                              #
# JDATE_TO_YMDT              Converts a Julian Date to a date and time in the specified calendar.              #
# MJDATE_TO_YMDT             Converts a Modified Julian Date to a date and time in the specified calendar.     #
# ROUND_JDATE                Returns the decimal JDate value rounded to a low order component.                 #
# ROUND_MJDATE               Returns the decimal MJDate value rounded to a low order component.                #
# JDATE_ADDITION             Returns the addition of a timespan complication to a given Julian Date.           #
# MJDATE_ADDITION            Returns the addition of a timespan complication to a given Modified Julian Date.  #
#                                                                                                              #
# DATE AND TIME                                                                                                #
# ------------------------------------------------------------------------------------------------------------ #
# VALIDATE_YMDT              Validate a year, month, day and time representation of a date in the specified    #
#                            calendar.                                                                         #
# IS_VALID_YMDT              Tests if a year, month, day and time representation of a date is valid for the    #
#                            specified calendar.                                                               #
# RESOLVE_YMDT               Resolves a date and time where components may exceed their modulus.               #
# ROUND_YMDT                 Returns the resolved date and time from the provided components to a low order    #
#                            component rounded to the specified precision.                                     #
# PARSE_ISO_DATETIME         Parses an ISO formatted date and time into respective date parts, time, and time  #
#                            zone offset from UTC. Providing a time zone offset on its own is invalid for      #
#                            this function.                                                                    #
# FORMAT_ISO_DATETIME        Returns a date, time and time zone offset as text in ISO format.                  #
# PARSE_DATETIME             Parses a formated date into respective parts of year, month, day and time of day. #
# FORMAT_DATETIME            Returns a formatted date and time.                                                #
# PARSE_LITERARY_DATETIME    Parses a literary date into respective parts of year, month, day and time of day. #
# FORMAT_LITERARY_DATETIME   Returns a date formatted in literary style.                                       #
# PARSE_MIL_DTG              Parses a date-time group in the format used by US Military message traffic, into  #
#                            respective parts of year, month, day, time of day and time zone offset in         #
#                            minutes from UTC.                                                                 #
# FORMAT_MIL_DTG             Returns a date-time group formatted in US Military message traffic style.         #
#                                                                                                              #
# WEEK DATE                                                                                                    #
# ------------------------------------------------------------------------------------------------------------ #
# WEEKS_IN_YEAR              Returns the count of ISO defined weeks in a given year of the specified calendar. #
# VALIDATE_ISO_WEEK_DATE     Validate a year, week and weekday representation of a ISO week date in a given    #
#                            calendar.                                                                         #
# IS_VALID_ISO_WEEK_DATE     Tests if a year, week and weekday representation of a ISO week date is valid for  #
# RESOLVE_ISO_WEEK_DATE      Resolves an ISO week date where week and weekday values may exceed their modulus. #
#                            the given calendar.                                                               #
# ISO_WEEK_DATE_TO_MJDN      Converts a ISO week date in the specified calendar to a Modified Julian Day       #
#                            Number (MJDN).                                                                    #
# MJDN_TO_ISO_WEEK_DATE      Converts a Modified Julian Day Number (MJDN) to an ISO week date in the specified #
#                            calendar.                                                                         #
# WEEKDAY_OF_MONTH_TO_MJDN   Returns a Modified Julian Date for a given day of week, relative week for the     #
#                            year and month of the specified calendar.                                         #
# PARSE_ISO_WEEK_DATE        Parses an ISO formatted week date into respective parts of year, week and weekday.#
# FORMAT_ISO_WEEK_DATE       Returns a week date as text in ISO format.                                        #
#                                                                                                              #
# QUARTER DATE                                                                                                 #
# ------------------------------------------------------------------------------------------------------------ #
# DAYS_IN_QUARTER            Returns the count of days in a quarter of a given year of the specified calendar. #
# QUARTER_DATE_TO_MJDN       Returns the Modified Julian Day Number (MJDN) for a date expressed as fiscal      #
#                            year, quarter, and day of quarter in the specified calendar.                      #
# MJDN_TO_QUARTER_DATE       Converts a Modified Julian Date (MJDATE) to a date expressed as fiscal year,      #
#                            quarter, day of quarter and time in the specified calendar.                       #
#                                                                                                              #
# DELTAS                                                                                                       #
# ------------------------------------------------------------------------------------------------------------ #
# DELTA_MONTHS               Returns the timespan difference between Modified Julian Dates in months.          #
#                            Calculated on basis of an average of days per month for the calendar.             #
# DELTA_YEARS                Returns the timespan difference between Modified Julian Dates in years.           #
#                            Calculated on basis of an average of days per year for the calendar.              #
# DELTA_YMD                  Returns the timespan difference between Modified Julian Dates in years, months    #
#                            and days.                                                                         #
# DELTA_YWD                  Returns the timespan difference between Modified Julian Dates in years, ISO weeks #
#                            and days.                                                                         #
#                                                                                                              #
# CONVERSIONS                                                                                                  #
# ------------------------------------------------------------------------------------------------------------ #
# ISO_DATETIME_TO_MJDATE     Converts an ISO formatted date and time to a Modified Julian Date and time zone   #
#                            offset.                                                                           #
# MJDATE_TO_ISO_DATETIME     Converts a Modified Julian Date and time zone offset to an ISO formatted date and #
#                            time.                                                                             #
# EXCELDATE_TO_MJDATE        Converts an Excel Date/Time to a Modified Julian Date.                            #
# MJDATE_TO_EXCELDATE        Converts a Modified Julian Date to an Excel Date/Time.                            #
# ISO_DATETIME_TO_EXCELDATE  Converts an ISO formatted date and time to an Excel Date/Time and time zone       #
#                            offset.                                                                           #
# EXCELDATE_TO_ISO_DATETIME  Converts an Excel Date/Time and time zone offset to an ISO formatted date and     #
#                            time.                                                                             #
# USDATE_TO_EXCELDATE        Converts a US format date to an Excel Date/Time.                                  #
# EXCELDATE_TO_USDATE        Converts an Excel Date/Time to a US format date.                                  #
#                                                                                                              #
##############################################################################################################*/







/*##############################################################################################################
# TIMESPAN                                                                                                     #
##############################################################################################################*/


/*--------------------------------------------------------------------------------------------------------------
IS_VALID_TIMESPAN

Tests if a sexagesimal complication is a valid timespan.
A component can exceed its modulus if no higher order element is provided.

Array compatible: As columns

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
----------------------------------------------------------------------------------------------------------------
TimeSpan_C5 | array   C[2..5]  |
   Sign     | integer [-1,0,1] |
   Days     | decimal [0..]    | Fractional allowed if hours, minutes and seconds empty.
   Hours    | decimal [0..24)  | Fractional allowed if minutes and seconds empty.
   Minutes  | decimal [0..60)  | Fractional allowed if seconds empty.
   Seconds  | decimal [0..60)  | Fractional allowed
--------------------------------------------------------------------------------------------------------------*/
IS_VALID_TIMESPAN = LAMBDA(TimeSpan_C5,
    LET(
        fnValidateTimeSpan, LAMBDA(_timeSpan,
            LET(
                _colCount, COLUMNS(_timeSpan),
                
                IF(_colCount > 5, FALSE, // at most 5 terms
                    IF(_colCount < 2, FALSE, // at least sign and days
                        IF(NOT(ARRAYS.IS_NUMERIC_NULL(_timeSpan)), FALSE,  // any term not numeric or null
                            LET(
                                _sign, INDEX(_timeSpan, 1, 1),
                                IF(NOT(ARRAYS.HAS_VALUE(_sign, {-1, 0, 1})), FALSE,  // invalid sign value
                                    LET(
                                        _DHMS, DROP(_timeSpan, , 1),
                                        _isEmpty, EXPAND(N(FN.IS_EMPTY(_DHMS)), , 4, 1),
                                        IF(ARRAYS.ARE_EQUAL(_isEmpty, {1, 1, 1, 1}), FALSE,  // DHMS all empty
                                            IF(ARRAYS.ARE_EQUAL(_isEmpty, {0, 1, 1, 0}), FALSE,  // HM empty with DS
                                                IF(ARRAYS.ARE_EQUAL(_isEmpty, {0, 0, 1, 0}), FALSE,  // M empty with DHS
                                                    IF(ARRAYS.ARE_EQUAL(_isEmpty, {0, 1, 0, 0}), FALSE,  // H empty with DMS
                                                        LET(
                                                            _isNumber, N(ISNUMBER(_DHMS)),
                                                            // index of first number
                                                            _firstNumIdx, XMATCH(1, _isNumber, 0, 1),
                                                            // index of last number
                                                            _lastNumIdx, XMATCH(1, _isNumber, 0, -1),
                                                            // index of first decimal number
                                                            _decimalIdx, IFNA(XMATCH(1, _isNumber * N(NOT(FN.IS_INTEGER(_DHMS))), 0, 1), 0),
                                                            // has a decimal number not at last number position
                                                            IF((_decimalIdx > 0) * (_decimalIdx < _lastNumIdx), FALSE,
                                                                LET(
                                                                    // expand all DHMS values padding with 0
                                                                    _DHMS0, EXPAND(N(_DHMS), , 4, 0),
                                                                    IF(ARRAYS.HAS_NEGATIVE(_DHMS0), FALSE,  // any negative DHMS value
                                                                        IF((_sign = 0) * ARRAYS.HAS_NONZERO(_DHMS0), FALSE,  // sign is zero with non zero DHMS value
                                                                            IF((_firstNumIdx < 2) * (INDEX(_DHMS0, 1, 2) >= 24), FALSE,  // first value is D and H exceeds modulus
                                                                                IF((_firstNumIdx < 3) * (INDEX(_DHMS0, 1, 3) >= 60), FALSE,  // first value is D/H and M exceeds modulus
                                                                                    IF((_firstNumIdx < 4) * (INDEX(_DHMS0, 1, 4) >= 60), FALSE,  // first value is D/H/M and S exceeds modulus
                                                                                        // valid timespan, passed all checks
                                                                                        TRUE
                                                                                    )
                                                                                )
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ),

        BYROW(FN.NULLIFY(TimeSpan_C5),
            LAMBDA(_row,
                fnValidateTimeSpan(_row)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
TIMESPAN

Returns a decimal timespan as a fraction of a day from a sexagesimal complication.
Note components exceeding their modulus will carry.

Array compatible: As columns

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Timespan as fraction of a day. Implicitly converts to Excel Date/Time type for non-negative
   |         | values.

Parameters
----------------------------------------------------------------------------------------------------------------
TimeSpan_C5 | array   C[2..5]  |
   Sign     | integer [-1,0,1] | If empty resolves to 1.
   Days     | decimal          | 
   Hours    | decimal          | 
   Minutes  | decimal          | 
   Seconds  | decimal          |
--------------------------------------------------------------------------------------------------------------*/
TIMESPAN = LAMBDA(TimeSpan_C5,
    LET(
        fnTimeSpan, LAMBDA(_timeSpan,
            LET(
                _colCount, COLUMNS(_timeSpan),
                IF(_colCount > 5, {#REF!}, // at most 5 terms
                    IF(ARRAYS.IS_EMPTY(_timeSpan), "",
                        LET(
                            _firstError, ARRAYS.H_ERROR(_timeSpan),
                            IF(ISERROR(_firstError), _firstError * {1},
                                IF(NOT(ARRAYS.IS_NUMERIC_NULL(_timeSpan)), {#VALUE!},  // any term not numeric or null
                                    IF(_colCount < 2, {#REF!},  // at least sign and days
                                        LET(
                                            _sign, IF(INDEX(_timeSpan, 1, 1) < 0, -1, 1),
                                            _days, N(INDEX(_timeSpan, 1, 2)),
                                            _hours, IF(_colCount < 3, 0, N(INDEX(_timeSpan, 1, 3))),
                                            _minutes, IF(_colCount < 4, 0, N(INDEX(_timeSpan, 1, 4))),
                                            _seconds, IF(_colCount < 5, 0, N(INDEX(_timeSpan, 1, 5))),
                                            _sign * (_days + (_hours / 24) + (_minutes / 1440) + (_seconds / 86400))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ),
    
        BYROW(FN.NULLIFY(TimeSpan_C5),
            LAMBDA(_row,
                fnTimeSpan(_row)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
ROUND_TIMESPAN

Returns a decimal timespan value rounded to the specified precision on a low order component.

Array compatible: TimeSpan_D

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | TimeSpan

Parameters
----------------------------------------------------------------------------------------------------------------
TimeSpan_D         | decimal | Decimal timespan where a day = 1
[LowOrder]         | integer | Lowest-order component. Defaults to Second.
                   | [1..4]  | 1: Day
                   |         | 2: Hour
                   |         | 3: Minute
                   |         | 4: Second
[Precision]        | integer | Select precision level.
                   | [0..9]  | Defaults to 0.
[RoundingOverride] | switch  |  0: Default When Precision = 0, rounds to nearest second and truncates at low order component.
                   |         |             When Precision > 0, rounds to nearest at low order component.
                   |         |  1: Nearest Always round to nearest low order component.
                   |         | -1: Down    Always round down at low order component.
--------------------------------------------------------------------------------------------------------------*/
ROUND_TIMESPAN = LAMBDA(TimeSpan_D, [LowOrder], [Precision], [RoundingOverride],
    LET(
        _maxPrecision, 9,
        _precision, IF(NOT(ISNUMBER(Precision)), 0,
            IF(Precision < 0, 0,
                IF(Precision > _maxPrecision, _maxPrecision, INT(Precision))
            )
        ),

        _lowOrder, IF(NOT(ISNUMBER(LowOrder)), 4,
            IF(LowOrder < 1, 1,
                IF(LowOrder > 4, 4, INT(LowOrder))
            )
        ),
        
        _roundingOverride, FN.COERCE(RoundingOverride),
        // 1 : standard method, round to nearest second, truncate to low order component
        // 2 : round to nearest precision at low order component
        // 3 : round down to precision at low order component
        _roundMethod, IF((_roundingOverride = 0) * (_precision = 0), 1,
            IF(_roundingOverride >= 0, 2,
                IF(_roundingOverride < 0, 3, 1)
            )
        ),
        
        fnRoundWhole, LAMBDA(_timeSpan,
            LET(
                _roundSeconds, ROUND(_timeSpan * 86400, 0),
                SWITCH(_lowOrder,
                    1, ROUNDDOWN(_roundSeconds / 86400, 0),
                    2, ROUNDDOWN(_roundSeconds / 3600, 0) / 24,
                    3, ROUNDDOWN(_roundSeconds / 60, 0) / 1440,
                    _roundSeconds / 86400
                )
            )
        ),

        fnRoundNearest, LAMBDA(_timeSpan,
            SWITCH(_lowOrder,
                1, ROUND(_timeSpan, _precision),
                2, ROUND(_timeSpan * 24, _precision) / 24,
                3, ROUND(_timeSpan * 1440, _precision) / 1440,
                ROUND(_timeSpan * 86400, _precision) / 86400
            )
        ),

        fnRoundDown, LAMBDA(_timeSpan,
            SWITCH(_lowOrder,
                1, ROUNDDOWN(_timeSpan, _precision),
                2, ROUNDDOWN(_timeSpan * 24, _precision) / 24,
                3, ROUNDDOWN(_timeSpan * 1440, _precision) / 1440,
                ROUNDDOWN(_timeSpan * 86400, _precision) / 86400
            )
        ),

        fnRoundTimeSpan, LAMBDA(_timeSpan,
            IF(ISERROR(_timeSpan), _timeSpan * {1},
                IF(_timeSpan = "", "",
                    IF(NOT(ISNUMBER(_timeSpan)), {#VALUE!},
                        IF(_timeSpan = 0, 0,
                            SWITCH(_roundMethod,
                                2, fnRoundNearest(_timeSpan),
                                3, fnRoundDown(_timeSpan),
                                fnRoundWhole(_timeSpan)
                            )
                        )
                    )
                )
            )
        ),
        
        MAP(FN.NULLIFY(TimeSpan_D),
            LAMBDA(_element,
                fnRoundTimeSpan(_element)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
TIMESPAN_TO_DHMS

Returns a sexagesimal complication from a decimal timespan expressed from the specified high to low order components.

Array compatible: TimeSpan_D as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | decimal [0..]    | Days
 3 | decimal [0..24]  | Hours
 4 | decimal [0..60]  | Minutes
 5 | decimal [0..60)  | Seconds

Parameters
----------------------------------------------------------------------------------------------------------------
TimeSpan_D         | decimal | Decimal timespan where a day = 1
[HighOrder]        | integer | Highest-order component. Defaults to Day.
                   | [1..4]  |  1 - Day
                   |         |  2 - Hour
                   |         |  3 - Minute
                   |         |  4 - Second
[LowOrder]         | integer | Lowest-order component. Defaults to Second.
                   | [1..4]  |  1: Day
                   |         |  2: Hour
                   |         |  3: Minute
                   |         |  4: Second
[Precision]        | integer | Select precision level.
                   | [0..9]  | Defaults to a maximum precision of 9.
[RoundingOverride] | switch  |  0: Default When Precision = 0, rounds to nearest second and truncates at low order component.
                   |         |             When Precision > 0, rounds to nearest at low order component.
                   |         |  1: Nearest Always round to nearest low order component.
                   |         | -1: Down    Always round down at low order component.
--------------------------------------------------------------------------------------------------------------*/
TIMESPAN_TO_DHMS = LAMBDA(TimeSpan_D, [HighOrder], [LowOrder], [Precision], [RoundingOverride],
    LET(
        _maxPrecision, 9,
        _precision, IF(NOT(ISNUMBER(Precision)), _maxPrecision,
            IF(Precision < 0, 0,
                IF(Precision > _maxPrecision, _maxPrecision, INT(Precision))
            )
        ),

        _lowOrder, IF(NOT(ISNUMBER(LowOrder)), 4,
            IF(LowOrder < 1, 1,
                IF(LowOrder > 4, 4, INT(LowOrder))
            )
        ),

        _highOrder, LET(
            _high, IF(NOT(ISNUMBER(HighOrder)), 1,
                IF(HighOrder < 1, 1,
                    IF(HighOrder > 4, 4, INT(HighOrder))
                )
            ),
            IF(_high > _lowOrder, _lowOrder, _high)
        ),
        
        _roundingOverride, FN.COERCE(RoundingOverride),
        // 1 : standard method, round to nearest second, truncate to low order component
        // 2 : round to nearest precision at low order component
        // 3 : round down to precision at low order component
        _roundMethod, IF((_roundingOverride = 0) * (_precision = 0), 1,
            IF(_roundingOverride >= 0, 2,
                IF(_roundingOverride < 0, 3, 1)
            )
        ),

        _componentMods, {1, 24, 60, 60},
                
        fnZeroComplication, LAMBDA(
            LET(
                _index, {1, 2, 3, 4, 5},
                MAP(_index,
                    LAMBDA(_n,
                        IF(_n = 1, 0,
                            IF(_n - 1 < _highOrder, "",
                                IF(_n - 1 > _lowOrder, "", 0)
                            )
                        )
                    )
                )
            )
        ),

        fnResolveWhole, LAMBDA(_absTimeSpan,
            LET(
                _index, {1, 2, 3, 4},
                _roundWhole, REDUCE(HSTACK(0, _absTimeSpan), _index,
                    LAMBDA(_acc, _curr,
                        LET(
                            _modulus, INDEX(_componentMods, 1, _curr),
                            _prevRemainder, INDEX(_acc, 1, _curr + 1),
                            _thisRemainder, _prevRemainder * _modulus,
                            IF(_curr < _highOrder, HSTACK(DROP(_acc, , -1), 0, _thisRemainder),
                                IF(_curr = 4,
                                    LET(
                                        _secondComponent, ROUND(_thisRemainder, 0),
                                        HSTACK(DROP(_acc, , -1), _secondComponent)
                                    ),
                                    LET(
                                        _component, INT(_thisRemainder),
                                        _nextRemainder, _thisRemainder - _component,
                                        HSTACK(DROP(_acc, , -1), _component, _nextRemainder)
                                    )
                                )
                            )
                        )
                    )
                ),
                DROP(_roundWhole, , 1)
            )
        ),

        fnResolveFractional, LAMBDA(_absTimeSpan,
            LET(
                _index, {1, 2, 3, 4},
                _roundFrac, REDUCE(HSTACK(0, _absTimeSpan), _index,
                    LAMBDA(_acc, _curr,
                        IF(_curr > _lowOrder, HSTACK(_acc, 0),
                            LET(
                                _modulus, INDEX(_componentMods, 1, _curr),
                                _prevRemainder, TAKE(_acc, 1, -1),
                                _thisRemainder, _prevRemainder * _modulus,
                                IF(_curr < _highOrder, HSTACK(DROP(_acc, , -1), 0, _thisRemainder),
                                    IF(_curr = _lowOrder,
                                        LET(
                                            _lowComponent, IF(_roundMethod = 3,
                                                ROUNDDOWN(_thisRemainder, _precision),
                                                ROUND(_thisRemainder, _precision)
                                            ),
                                            HSTACK(DROP(_acc, , -1), _lowComponent)
                                        ),
                                        LET(
                                            _component, INT(_thisRemainder),
                                            _nextRemainder, _thisRemainder - _component,
                                            HSTACK(DROP(_acc, , -1), _component, _nextRemainder)
                                        )
                                    )
                                )
                            )
                        )
                    )
                ),
                DROP(_roundFrac, , 1)
            )
        ),

        fnResolveModulus, LAMBDA(_complication,
            LET(
                _index, {4, 3, 2, 1},
                _resolve, REDUCE({0, 0}, _index,
                    LAMBDA(_acc, _curr,
                        IF(_curr < _highOrder, HSTACK("", DROP(_acc, , -1), 0),
                            IF(_curr > _lowOrder, HSTACK("", DROP(_acc, , -1), 0),
                                LET(
                                    _carry, TAKE(_acc, 1, -1),
                                    _value, _carry + N(INDEX(_complication, 1, _curr)),
                                    IF(_curr = _highOrder, HSTACK(_value, DROP(_acc, , -1), 0),
                                        LET(
                                            _modulus, INDEX(_componentMods, 1, _curr),
                                            _carryNext, INT(_value /_modulus),
                                            _resolveValue, IF(_carryNext, 0, _value),
                                            HSTACK(_resolveValue, DROP(_acc, , -1), _carryNext)
                                        )
                                    )
                                )
                            )
                        )
                    )
                ),
                DROP(_resolve, , -2)
            )
        ),

        fnSexagesimal, LAMBDA(_timeSpan,
            IF(ISERROR(_timeSpan), _timeSpan * {1, 2, 3, 4, 5},
                IF(_timeSpan = "", {"", "", "", "", ""},
                    IF(NOT(ISNUMBER(_timeSpan)), {#VALUE!, #VALUE!, #VALUE!, #VALUE!, #VALUE!},
                        IF(_timeSpan = 0, fnZeroComplication(),
                            LET(
                                _unroundedSign, IF(_timeSpan < 0, -1, 1),
                                _absTimeSpan, ABS(_timeSpan),
                                _roundComponents, IF(_roundMethod = 1,
                                    fnResolveWhole(_absTimeSpan),
                                    fnResolveFractional(_absTimeSpan)
                                ),
                                _resolveComponents, fnResolveModulus(_roundComponents),
                                _isZero, ARRAYS.IS_ZERO(N(_resolveComponents)),
                                _sign, IF(_isZero, 0, _unroundedSign),
                                HSTACK(_sign, _resolveComponents)
                            )
                        )
                    )
                )
            )
        ),

        _timeSpanColumn, FN.NULLIFY(INDEX(TimeSpan_D, ,  1)),
        _rowCount, ROWS(_timeSpanColumn),
        _byRow, REDUCE("", SEQUENCE(_rowCount),
            LAMBDA(_acc, _curr,
                VSTACK(
                    _acc,
                    fnSexagesimal(INDEX(_timeSpanColumn, _curr, 1))
                )
            )
        ),
        DROP(_byRow, 1)
    )
);


/*--------------------------------------------------------------------------------------------------------------
RESOLVE_TIMESPAN_DHMS

Resolves a timespan sexagesimal complication so that each component is within its modulus.

Array compatible: TimeSpan_C5 as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | decimal [0..]    | Days
 3 | decimal [0..24]  | Hours
 4 | decimal [0..60]  | Minutes
 5 | decimal [0..60)  | Seconds

Parameters
----------------------------------------------------------------------------------------------------------------
TimeSpan_C5        | array   C[2..5]  |
   Sign            | integer [-1,0,1] |
   Days            | decimal [0..]    |
   Hours           | decimal [0..]    |
   Minutes         | decimal [0..]    |
   Seconds         | decimal [0..]    |
[HighOrder]        | integer          | Highest-order component. Defaults to Day.
                   | [1..4]           |  1 - Day
                   |                  |  2 - Hour
                   |                  |  3 - Minute
                   |                  |  4 - Second
[LowOrder]         | integer          | Lowest-order component. Defaults to Second.
                   | [1..4]           |  1 - Day
                   |                  |  2 - Hour
                   |                  |  3 - Minute
                   |                  |  4 - Second
[Precision]        | integer          | Select precision level.
                   | [0..9]           | Defaults to maximum precision of 9.
[RoundingOverride] | switch           |  0: Default When Precision = 0, rounds to nearest second and truncates at low order component.
                   |                  |             When Precision > 0, rounds to nearest at low order component.
                   |                  |  1: Nearest Always round to nearest low order component.
                   |                  | -1: Down    Always round down at low order component.
--------------------------------------------------------------------------------------------------------------*/
RESOLVE_TIMESPAN_DHMS = LAMBDA(TimeSpan_C5, [HighOrder], [LowOrder], [Precision], [RoundingOverride],
    LET(
        _timeSpan_C5, FN.NULLIFY(TimeSpan_C5),
        _timeSpan_D, CHRONO.TIMESPAN(_timeSpan_C5),
        CHRONO.TIMESPAN_TO_DHMS(_timeSpan_D, HighOrder, LowOrder, Precision, RoundingOverride)
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_TIMESPAN_DHMS

Parses a text timespan expression as a sexagesimal complication.

Array compatible: Expression as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Days
 3 | integer [0..23]  | Hours
 4 | integer [0..59]  | Minutes
 5 | decimal [0..60)  | Seconds

Parameters
----------------------------------------------------------------------------------------------------------------
Expression | variant | TimeSpan decimal value or formatted TimeSpan text.

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_TIMESPAN_DHMS("12:00")
Returns: {1, "", 12, 0, ""}

PARSE_TIMESPAN_DHMS("100h")
Returns: {1, "", 100, "", ""}
--------------------------------------------------------------------------------------------------------------*/
PARSE_TIMESPAN_DHMS = LAMBDA(Expression,
    LET(
        _maxPrecision, 9,
        
        _logicTable, {
            // terms, pattern, high, low, hasDecimal
            5, ".::.", 1, 4, TRUE;   // d.hh:mm:ss.000
            4, ".::", 1, 4, FALSE;   // d.hh:mm:ss
            4, "::.", 2, 4, TRUE;    // h:mm:ss.000
            3, ".:", 1, 3, FALSE;    // d.hh:mm
            3, "::", 2, 4, FALSE;    // h:mm:ss
            3, ":.", 3, 4, TRUE;     // m:ss.000
            2, ":", 2, 3, FALSE;     // h:mm
            2, ".", 1, 1, TRUE;      // d.000
            1, "", 1, 1, FALSE;      // d
            5, "dhm.s", 1, 4, TRUE;   // 0d 0h 0m 0.000s
            4, "dhms", 1, 4, FALSE;   // 0d 0h 0m 0s
            4, "dh.m", 1, 3, TRUE;    // 0d 0h 0.000m
            4, "hm.s", 2, 4, TRUE;    // 0h 0m 0.000s
            3, "dhm", 1, 3, FALSE;    // 0d 0h 0m
            3, "hms", 2, 4, FALSE;    // 0h 0m 0s
            3, "d.h", 1, 2, TRUE;     // 0d 0.000h
            2, "h.m", 2, 3, TRUE;     // 0h 0.000m
            2, "m.s", 3, 4, TRUE;     // 0m 0.000s
            2, "dh", 1, 2, FALSE;     // 0d 0h
            2, "hm", 2, 3, FALSE;     // 0h 0m
            2, "ms", 3, 4, FALSE;     // 0m 0s
            2, ".d", 1, 1, TRUE;      // 0.000d
            2, ".h", 2, 2, TRUE;      // 0.000h
            2, ".m", 3, 3, TRUE;      // 0.000m
            2, ".s", 4, 4, TRUE;      // 0.000s
            1, "d", 1, 1, FALSE;      // 0d
            1, "h", 2, 2, FALSE;      // 0h
            1, "m", 3, 3, FALSE;      // 0m
            1, "s", 4, 4, FALSE;      // 0s
            5, "dh'.""", 1, 4, TRUE;  // 0d 0h 0' 0.000"
            4, "dh'""", 1, 4, FALSE;  // 0d 0h 0' 0"
            4, "dh.'", 1, 3, TRUE;    // 0d 0h 0.000'
            4, "h'.""", 2, 4, TRUE;   // 0h 0' 0.000"
            3, "dh'", 1, 3, FALSE;    // 0d 0h 0'
            3, "h'""", 2, 4, FALSE;   // 0h 0' 0"
            3, "h.'", 2, 3, TRUE;     // 0h 0.000'
            3, "'.""", 3, 4, TRUE;    // 0' 0.000"
            2, "h'", 2, 3, FALSE;     // 0h 0'
            2, "'""", 3, 4, FALSE;    // 0' 0"
            2, ".'", 3, 3, TRUE;      // 0.000'
            2, ".""", 4, 4, TRUE;     // 0.000"
            1, "'", 3, 3, FALSE;      // 0'
            1, """", 4, 4, FALSE      // 0"
        },

        fnParseSexagesimal, LAMBDA(_expr,
            LET(
                _expr1, IF(FN.FIND_NTH_CHAR(_expr, "dhms'""") > 0,
                    // remove spaces if hinted at european or traditional style
                    SUBSTITUTE(_expr, " ", ""),
                    _expr
                ),
                _signDenoted, SWITCH(LEFT(_expr1),
                    "+", 1,
                    "-", -1,
                    "−", -1,  // − UNICHAR(8722)
                    ""
                ),
                _hasSign, ISNUMBER(_signDenoted),
                _nominalSign, IF(_hasSign, _signDenoted, 1),
                _unsignedTStext, IF(_hasSign, MID(_expr1, 2, LEN(_expr1) - 1), _expr1),
                _split, FN.SPLIT_AROUND(_unsignedTStext, "0123456789",, 6),
                _terms, INDEX(_split, 1, 1), 
                _pattern, INDEX(_split, 1, 2),
                _match, FILTER(_logicTable, (INDEX(_logicTable, , 1) = _terms) * (INDEX(_logicTable, , 2) = _pattern), #N/A),
                IF(ISNA(INDEX(_match, 1, 1)), {#VALUE!},
                    LET(
                        _high, INDEX(_match, 1, 3),
                        _low, INDEX(_match, 1, 4),
                        _lastCol, 2 + _terms,
                        _hasDecimals, INDEX(_match, 1, 5),
                        _expressedTerms, IF(_hasDecimals,
                            LET(
                                _decimals, MIN(LEN(INDEX(_split, 1, _lastCol)), _maxPrecision),
        
                                IF(_terms > 2,
                                    HSTACK(
                                        VALUE(TAKE(DROP(_split, , 2), 1, _terms - 2)),
                                        VALUE(INDEX(_split, 1, _lastCol - 1)) + (VALUE(LEFT(INDEX(_split, 1, _lastCol), _decimals)) / (10 ^ _decimals))
                                    ),
                                    IF(_terms = 2,
                                        HSTACK(
                                            VALUE(INDEX(_split, 1, _lastCol - 1)) + (VALUE(LEFT(INDEX(_split, 1, _lastCol), _decimals)) / (10 ^ _decimals))
                                        ),
                                        {#VALUE!}
                                    )
                                )
                            ),
                            HSTACK(
                                VALUE(DROP(_split, , 2))
                            )
                        ),
                        _trueSign, IF(ARRAYS.IS_ZERO(N(_expressedTerms)), 0, _nominalSign),
                        IF((_high = 1) * (_low = 4),
                            HSTACK(
                                _trueSign,   
                                _expressedTerms
                            ),
                            IF((_high > 1) * (_low = 4),
                                HSTACK(
                                    _trueSign,
                                    EXPAND("", , _high - 1, ""),
                                    _expressedTerms
                                ),
                                IF((_high = 1) * (_low < 4),
                                    HSTACK(
                                        _trueSign,
                                        _expressedTerms,
                                        EXPAND("", , 4 - _low, "")
                                    ),
                                    HSTACK(
                                        _trueSign,
                                        EXPAND("", , _high - 1, ""),
                                        _expressedTerms,
                                        EXPAND("", , 4 - _low, "")
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ),
        
        fnParseTimeSpan, LAMBDA(_expr,
            IF(ISERROR(_expr), _expr * {1, 2, 3, 4, 5},
                IF(_expr = "", {"", "", "", "", ""},
                    IF(ISNUMBER(_expr), CHRONO.TIMESPAN_TO_DHMS(_expr, 1, 1),
                        LET(
                            _sexagesimal, fnParseSexagesimal(_expr),
                            IF(CHRONO.IS_VALID_TIMESPAN(_sexagesimal),
                                _sexagesimal,
                                {#VALUE!, #VALUE!, #VALUE!, #VALUE!, #VALUE!}
                            )
                        )
                    )
                )
            )
        ),

        _exprColumn, FN.NULLIFY(INDEX(Expression, , 1)),
        _rowCount, ROWS(_exprColumn),
        _byRow, REDUCE("", SEQUENCE(_rowCount),
            LAMBDA(_acc, _curr,
                VSTACK(
                    _acc,
                    fnParseTimeSpan(INDEX(_exprColumn, _curr, 1))
                )
            )
        ),
        DROP(_byRow, 1)
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_TIMESPAN

Parses a text timespan expression as a decimal value.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal [0..1] | Timespan value as decimal days.

Parameters
----------------------------------------------------------------------------------------------------------------
Expression | variant | TimeSpan decimal value or formatted TimeSpan text.

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_TIMESPAN("12:00")
Returns: 0.5
--------------------------------------------------------------------------------------------------------------*/
PARSE_TIMESPAN = LAMBDA(Expression,
    MAP(FN.NULLIFY(Expression),
        LAMBDA(_element,
            LET(
                _timeSpan_C5, CHRONO.PARSE_TIMESPAN_DHMS(_element),
                CHRONO.TIMESPAN(_timeSpan_C5)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
FORMAT_TIMESPAN

Returns a timespan as text in the specified format from a given decimal value.

Array compatible: TimeSpan_D as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | text    | Formatted timespan d.HH:mm:ss.000

Parameters
----------------------------------------------------------------------------------------------------------------
TimeSpan_D     | decimal | Decimal timespan where a day = 1
[Options]      | text    | String with elements: [T|E][+][P][X][N|F][HighOrder][LowOrder][*][0-9]
               |         |      T, E : Traditional or European style. Defaults to Modern style when not present.
               |         |             Modern:      0.00:00:00.000
               |         |             Traditional: 0d 0h 0m 0.000s
               |         |             European:    0d 0h 0' 0.000"
               |         |         + : Display positive sign for non-negative values
               |         |         P : Modern style: pad leading value with zero.
               |         |             Traditional and European styles: pad all values except first with zero.
               |         |         X : Insert spacing. Not applicable to modern style.
               |         |      N, F : Override rounding behaviour.
               |         |             Default method rounds to nearest second and then truncates to low order component.
               |         |             N: always round to nearest.
               |         |             F: always round down.
               |         | HighOrder : High order component. Upper case to set explicitly. Lower case allows floating
               |         |             from expressing in the given component up to days as needed.
               |         | LowOrder  : Low order component. Upper case to set explicitly. Lower case allows floating
               |         |             from expressing in the given component down to seconds as needed.
               |         |             If only a single option is given, it is assigned as LowOrder.
               |         |             Both elements take the following:
               |         |             D, d : Day
               |         |             H, h : Hour
               |         |             M, m : Minute
               |         |             S, s : Second
               |         |         * : Allows floating down the lowest order component needed, including the maximum precision
               |         |             of the style for seconds.
               |         |       0-9 : Decimal places to display. If D, H, M or S supplied for LowOrder then explict decimals.
               |         |             If d, h, m or s supplied for LowOrder then the ceiling of decimals to display.
               |         |             Modern style: Only applies to seconds.
               |         |             Traditional and European styles: Applies to low order component.
Examples
----------------------------------------------------------------------------------------------------------------
FORMAT_TIMESPAN(1.7865)
Returns: 1.18:52:34

FORMAT_TIMESPAN(1.7865, "HS3")
Returns: 42:52:33.600

FORMAT_TIMESPAN(1.7865, "T+XHS")
Returns: + 42h 52m 34s

FORMAT_TIMESPAN(1.7865, "Es*")
Returns: 1d18h52'34.6"
--------------------------------------------------------------------------------------------------------------*/
FORMAT_TIMESPAN = LAMBDA(TimeSpan_D, [Options],
    LET(
        _timeSpanFormatOptions, _FORMAT_TIMESPAN_OPTIONS(Options),

        MAP(FN.NULLIFY(TimeSpan_D),
            LAMBDA(_element,
                _FORMAT_TIMESPAN(_element, _timeSpanFormatOptions)
            )
        )
    )
);

_FORMAT_TIMESPAN_OPTIONS = LAMBDA(_options,
    LET(
        _options1, FN.NULLIFY(_options),
        _style, LEFT(FN.SIFT_FOR_CHARS(_options1, "ET")),
        _signPositive, IFERROR(FIND("+", _options1), 0) > 0,
        _padding, IFERROR(SEARCH("P", _options1), 0) > 0,
        _spacing, IFERROR(SEARCH("X", _options1), 0) > 0,
        
        _roundingOverride, LET(
            _r, LEFT(FN.SIFT_FOR_CHARS(_options1, "NF")),
            SWITCH(_r,
                "N", 1,
                "F", -1,
                0
            )
        ),

        // -2  : default for style
        // -1  : floating as defined in style
        // [n] : precision limit
        _precision, LET(
            _pChar, LEFT(FN.SIFT_FOR_CHARS(_options1, "*0123456789")),
            SWITCH(_pChar,
                "", -2,
                "*", -1,
                VALUE(_pChar)
            )
        ),

        _orderSpec, FN.SIFT_FOR_CHARS(_options1, "DHMS", FALSE, TRUE, 2),
        _highChar, IF(LEN(_orderSpec) = 2, LEFT(_orderSpec), ""),
        _highOrder, SWITCH(_highChar,
            "D", 1,
            "H", 2,
            "M", 3,
            "S", 4,
            0
        ),
        _highFixed, IF(_highOrder = 0, FALSE,
            CODE(_highChar) < 100
        ),
        
        _lowChar, RIGHT(_orderSpec),
        _lowOrder, SWITCH(_lowChar,
            "D", 1,
            "H", 2,
            "M", 3,
            "S", 4,
            0
        ),
        _lowFixed, IF(_lowOrder = 0, FALSE,
            N(CODE(_lowChar) < 100)
        ),

        HSTACK(
            _style,
            _highOrder, _highFixed, _lowOrder, _lowFixed,
            _precision, _roundingOverride,
            _signPositive, _padding, _spacing
        )
    )
);

_FORMAT_TIMESPAN = LAMBDA(_timeSpan_D, _timeSpanFormatOptions,
    IF(ISERROR(_timeSpan_D), _timeSpan_D * {1},
        IF(_timeSpan_D = "", "",
            IF(NOT(ISNUMBER(_timeSpan_D)), {#VALUE!},
                LET(
                    _style, INDEX(_timeSpanFormatOptions, 1, 1),
                    _highOrder, INDEX(_timeSpanFormatOptions, 1, 2),
                    _highFixed, INDEX(_timeSpanFormatOptions, 1, 3),
                    _lowOrder, INDEX(_timeSpanFormatOptions, 1, 4),
                    _lowFixed, INDEX(_timeSpanFormatOptions, 1, 5),
                    _precision, INDEX(_timeSpanFormatOptions, 1, 6),
                    _roundingOverride, INDEX(_timeSpanFormatOptions, 1, 7),
                    
                    _components, IF(_style = "",
                        _TIMESPAN_COMPONENTS_MODERN(_timeSpan_D,
                            _highOrder, _highFixed, _lowOrder, _lowFixed,
                            _precision, _roundingOverride
                        ),
                        _TIMESPAN_COMPONENTS_TRADITIONAL(_timeSpan_D,
                            _highOrder, _highFixed, _lowOrder, _lowFixed,
                            _precision, _roundingOverride
                        )
                    ),

                    IF(ROWS(_components) = 1, INDEX(_components, 1, 1) * {1},
                        LET(
                            _signPositive, INDEX(_timeSpanFormatOptions, 1, 8),
                            _padding, INDEX(_timeSpanFormatOptions, 1, 9),
                            _spacing, INDEX(_timeSpanFormatOptions, 1, 10),

                            _provider, SWITCH(_style,
                                "T", _FORMAT_PROVIDER_TIMESPAN_TRADITIONAL(_components, _signPositive, _padding, _spacing),
                                "E", _FORMAT_PROVIDER_TIMESPAN_EUROPEAN(_components, _signPositive, _padding, _spacing),
                                _FORMAT_PROVIDER_TIMESPAN_MODERN(_components, _signPositive, _padding)
                            ),
                            _TIMESPAN_FORMATTER(_components, _provider)
                        )
                    )
                )
            )
        )
    )
);

_TIMESPAN_FORMATTER = LAMBDA(_components, _provider,
    // Components: {
    //   DisplayCount, DisplayHighOrder, DisplayLowOrder, DisplayDecimals, ResolvePrecision;
    //   Sign,         Days,             Hours,           Minutes,         Seconds
    // }

    // Provider: {
    //   LeadFormat, MidFormat, LastFormat,  Spacing,      #N/A;
    //   Designator, DaySuffix, HourSuffix,  MinuteSuffix, SecondSuffix
    // }

    IF(ROWS(_components) = 1, INDEX(_components, 1, 1),
        IF(ROWS(_provider) = 1, INDEX(_provider, 1, 1),
            LET(
                _count, INDEX(_components, 1, 1),
                IF(_count < 1, "",
                    LET(
                        _designator, IF(INDEX(_provider, 2, 1) = "", "",
                            CONCAT(
                                INDEX(_provider, 2, 1),
                                IF(INDEX(_provider, 1, 4), " ", "")
                            )
                        ),
                        
                        REDUCE(_designator, SEQUENCE(_count),
                            LAMBDA(_acc, _n,
                                LET(
                                    _fmt, IF(_n = _count, INDEX(_provider, 1, 3),
                                        IF(_n = 1, INDEX(_provider, 1, 1),
                                            INDEX(_provider, 1, 2)
                                        )
                                    ),
                                    _col, INDEX(_components, 1, 2) + _n,
                                    _part, TEXT(INDEX(_components, 2, _col), _fmt),
                                    _delim, INDEX(_provider, 2, _col),
                                    _space, IF(INDEX(_provider, 1, 4) * (_n < _count), " ", ""),
                                    CONCAT(_acc, _part, _delim, _space)
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);

_TIMESPAN_EXPRESSED_ORDER = LAMBDA(_timeSpan, _direction,
    // Direction = -1 : low end
    //              1 : high end
    LET(
        _sign, INDEX(_timeSpan, 1, 1),
        IF(_sign = 0, {#N/A},
            LET(
                _nonZeroComponents, IFERROR(DROP(_timeSpan, , 1), 1) <> 0,
                XMATCH(1, N(_nonZeroComponents), 0, _direction)
            )
        )
    )
);

_TIMESPAN_COMPONENTS = LAMBDA(_timeSpan_D,
    _maxHighOrder, _defaultHighOrder, _minLowOrder, _defaultLowOrder, _fractionalSecondsOnly, _maxPrecision, _defaultPrecision,
    _highOrder, _highFixed, _lowOrder, _lowFixed, _precision, _roundingOverride,
    
    // MaxHighOrder:          Maximum high order accepted for the style.
    // DefaultHighOrder:      Default high order if not specified.
    // MinLowOrder:           Minimum low order accepted for the style.
    // DefaultLowOrder:       Default low order if not specified.
    // FractionalSecondsOnly: Precision set to 0 for low order other than seconds.
    // MaxPrecision:          Maximum precision for the style.
    // DefaultPrecision:      Default precision for the style.
    //
    // HighOrder:             High order at which to resolve timespan if HighFixed. 
    //                        Otherwise the high order at maximum to display.
    // HighFixed:             Force display from high order, otherwise allow to float from high order as needed.
    // LowOrder:              Low order at which to round timespan if LowFixed. 
    //                        Otherwise the low order at minimum to display.
    // LowFixed:              Force display to low order, otherwise allow to float from low order as needed.
    // Precision:              -2: Defaults to 0 decimals.
    //                         -1: Expressed up to MaxPrecision.
    //                        [n]: If low order not fixed then decimals expressed up to which ever is lower of
    //                             given precision or MaxPrecision. If low order fixed then expressed explicitly
    //                             at the same.
    // RoundingOverride:        0: Default When Precision = 0, rounds to nearest second and truncates at low order component.
    //                                     When Precision > 0, rounds to nearest at low order component.
    //                          1: Nearest Always round to nearest low order component.
    //                         -1: Down    Always round down at low order component.
    //
    // Output: {
    //   DisplayCount, DisplayHighOrder, DisplayLowOrder, DisplayDecimals, ResolvePrecision;
    //   Sign,         Days,             Hours,           Minutes,         Seconds
    // }

    IF(ISERROR(_timeSpan_D), _timeSpan_D * {1},
        IF(_timeSpan_D = "", "",
            IF(NOT(ISNUMBER(_timeSpan_D)), {#VALUE!},
                LET(
                    _resolveLowDefault, IF(_defaultLowOrder = 0, 4, _defaultLowOrder),
                    _resolveLowOrder, IF(NOT(_lowFixed), 4,  // resolve to seconds
                        IF(_lowOrder = 0, _resolveLowDefault,  // resolve to default of style
                            MAX(_lowOrder, _minLowOrder)  // ensure not a higher order than style allows
                        )
                    ),
            
                    _resolveHighDefault, IF(_defaultHighOrder = 0, 1, _defaultHighOrder),
                    _resolveHighOrder, LET(
                        _high, IF(NOT(_highFixed), 1,  // resolve from days
                            IF(_highOrder = 0, _resolveHighDefault,  // resolve from default of style
                                MIN(_highOrder, _maxHighOrder)  // ensure not a lower order than style allows
                            )
                        ),
                        // ensure not more than low order
                        MIN(_resolveLowOrder, _high)
                    ),
                    
                    _notResolveToSeconds, _lowFixed * (_lowOrder > 0) * (_lowOrder < 4) ,

                    _resolvePrecision, IF(_fractionalSecondsOnly * _notResolveToSeconds, 0,
                        SWITCH(_precision,
                            -2, _defaultPrecision,
                            -1, _maxPrecision,
                            MIN(_precision, _maxPrecision)
                        )
                    ),
                    
                    _sexagesimal, N(CHRONO.TIMESPAN_TO_DHMS(_timeSpan_D, _resolveHighOrder, _resolveLowOrder, _resolvePrecision, _roundingOverride)),

                    _displayHighOrder, IF(_highFixed, _resolveHighOrder,  // display to explicit order
                        // floating
                        LET(
                            _bookend, IF(_highOrder = 0,
                                IF(_defaultHighOrder = 0, 4, _defaultHighOrder),  // default of style
                                MIN(_highOrder, _maxHighOrder)  // not more than style allows
                            ),
                            _hasHighOrder, IFNA(_TIMESPAN_EXPRESSED_ORDER(_sexagesimal, 1), 5),
                            IF(_hasHighOrder < _bookend, _hasHighOrder, _bookend)
                        )
                    ),

                    _displayLowOrder, IF(_lowFixed, _resolveLowOrder, // display to explicit order
                        // floating
                        LET(
                            _bookend, IF(_lowOrder = 0,
                                IF(_defaultLowOrder = 0, 1, _defaultLowOrder),  // default of style
                                MAX(_lowOrder, _minLowOrder)  // not less than style allows
                            ),
                            _hasLowOrder, IFNA(_TIMESPAN_EXPRESSED_ORDER(_sexagesimal, -1), 0),
                            _nominalLowOrder, IF(_hasLowOrder > _bookend, _hasLowOrder, _bookend),
                            MAX(_nominalLowOrder, _displayHighOrder) 
                        )
                    ),
                    
                    _colLowOrder, _displayLowOrder + 1,
                    _displayDecimals, IF(_fractionalSecondsOnly * (_displayLowOrder < 4), 0,
                        IF(_precision = -2, _resolvePrecision,
                            IF(_precision = 0, 0,
                                IF(_lowFixed * (_precision > 0), _resolvePrecision,
                                    LET(
                                        _expressedDecimals, MIN(FN.DECIMALS(INDEX(_sexagesimal, 1, _colLowOrder)), _resolvePrecision),
                                        IF(_precision = -1, _expressedDecimals,
                                            IF(_expressedDecimals = 0, 0, _resolvePrecision)
                                        )
                                    )
                                )
                            )
                        )
                    ),
                    
                    _displayCount, _displayLowOrder - _displayHighOrder + 1,
                    VSTACK(
                        HSTACK(_displayCount, _displayHighOrder, _displayLowOrder, _displayDecimals, _resolvePrecision),
                        _sexagesimal
                    )
                )
            )
        )
    )
);

_TIMESPAN_COMPONENTS_MODERN = LAMBDA(_timeSpan_D, _highOrder, _highFixed, _lowOrder, _lowFixed, _precision, _roundingOverride,
    // HighOrder:        High order at which to resolve timespan if HighFixed. 
    //                   Otherwise the high order at maximum to display.
    // HighFixed:        Force display from high order, otherwise allow to float from high order as needed.
    // LowOrder:         Low order at which to round timespan if LowFixed. 
    //                   Otherwise the low order at minimum to display.
    // LowFixed:         Force display to low order, otherwise allow to float from low order as needed.
    // Precision:         -2: Defaults to 0 decimals.
    //                    -1: Expressed up to 9 decimals.
    //                   [n]: If low order not fixed then decimals expressed up to which ever is lower of
    //                        given precision or MaxPrecision. If low order fixed then expressed explicitly
    //                        at the same.
    // RoundingOverride:   0: Default When Precision = 0, rounds to nearest second and truncates at low order component.
    //                                When Precision > 0, rounds to nearest at low order component.
    //                     1: Nearest Always round to nearest low order component.
    //                    -1: Down    Always round down at low order component.
    //
    // Output: {
    //   DisplayTerms, DisplayHighOrder, DisplayLowOrder, DisplayDecimals, ResolvePrecision;
    //   Sign,         Days,             Hours,           Minutes,         Seconds
    // }

    LET(
        _maxHighOrder, 2,
        _defaultHighOrder, 1,
        _minLowOrder, 3,
        _defaultLowOrder, 4,
        _fractionalSecondsOnly, TRUE,
        _maxPrecision, 9,
        _defaultPrecision, 0,

        _TIMESPAN_COMPONENTS(_timeSpan_D,
            _maxHighOrder, _defaultHighOrder, _minLowOrder, _defaultLowOrder, _fractionalSecondsOnly, _maxPrecision, _defaultPrecision,
            _highOrder, _highFixed, _lowOrder, _lowFixed, _precision, _roundingOverride
        )
    )
);

_TIMESPAN_COMPONENTS_TRADITIONAL = LAMBDA(_timeSpan_D, _highOrder, _highFixed, _lowOrder, _lowFixed, _precision, _roundingOverride,
    // HighOrder:        High order at which to resolve timespan if HighFixed. 
    //                   Otherwise the high order at maximum to display.
    // HighFixed:        Force display from high order, otherwise allow to float from high order as needed.
    // LowOrder:         Low order at which to round timespan if LowFixed. 
    //                   Otherwise the low order at minimum to display.
    // LowFixed:         Force display to low order, otherwise allow to float from low order as needed.
    // Precision:         -2: Defaults to 0 decimals.
    //                    -1: Expressed up to 9 decimals.
    //                   [n]: If low order not fixed then decimals expressed up to which ever is lower of
    //                        given precision or MaxPrecision. If low order fixed then expressed explicitly
    //                        at the same.
    // RoundingOverride:   0: Default When Precision = 0, rounds to nearest second and truncates at low order component.
    //                                When Precision > 0, rounds to nearest at low order component.
    //                     1: Nearest Always round to nearest low order component.
    //                    -1: Down    Always round down at low order component.
    //
    // Output: {
    //   DisplayTerms, DisplayHighOrder, DisplayLowOrder, DisplayDecimals, ResolvePrecision;
    //   Sign,         Days,             Hours,           Minutes,         Seconds
    // }
    
    LET(
        _maxHighOrder, 4,
        _defaultHighOrder, 0,
        _minLowOrder, 1,
        _defaultLowOrder, 0,
        _fractionalSecondsOnly, FALSE,
        _maxPrecision, 9,
        _defaultPrecision, 0,

        _TIMESPAN_COMPONENTS(_timeSpan_D,
            _maxHighOrder, _defaultHighOrder, _minLowOrder, _defaultLowOrder, _fractionalSecondsOnly, _maxPrecision, _defaultPrecision,
            _highOrder, _highFixed, _lowOrder, _lowFixed, _precision, _roundingOverride
        )
    )
);

_FORMAT_PROVIDER_TIMESPAN_MODERN = LAMBDA(_components, _signPositive, _padding,
    // Format:          ±0.00:00:00.000
    // SignPositive:    Prepends + for positive values
    // Padding:         Applies to leading component, trailing components always padded.
    //
    // Output: {
    //   LeadFormat, MidFormat, LastFormat, Spacing:=FALSE, #N/A;
    //   Designator, DaySuffix, HourSuffix, MinuteSuffix,   ""
    // }

    LET(
        _spacing, FALSE,
        
        IF(ROWS(_components) = 1, INDEX(_components, 1, 1),
            IF(INDEX(_components, 1, 1) < 1, "",
                LET(
                    _sign, INDEX(_components, 2, 1), 
                    _designator, IF(_sign < 0, "−", // − UNICHAR(8722)
                        IF(_signPositive, "+", "")
                    ),

                    _displayDecimals, INDEX(_components, 1, 4),
                    _leadFmt, IF(_padding, "00", "0"),
                    _midFmt, "00",
                    _lastFmt, IF(_displayDecimals = 0, _midFmt,
                        CONCAT(_midFmt, LEFT(".000000000", _displayDecimals + 1))
                    ),
                    _formats, HSTACK(_leadFmt, _midFmt, _lastFmt, _spacing),
                    
                    _displayLowOrder, INDEX(_components, 1, 3),
                    _delims, IF(_displayLowOrder = 3,
                        HSTACK(_designator, ".", ":", "", ""),
                        HSTACK(_designator, ".", ":", ":", "")
                    ),

                    VSTACK(
                        _formats,
                        _delims
                    )
                )
            )
        )
    )
);

_FORMAT_PROVIDER_TIMESPAN_TRADITIONAL = LAMBDA(_components, _signPositive, _padding, _spacing,
    // Format:          ± 0d 0h 0m 0.000s
    // SignPositive:    Prepends + for positive values
    // Padding:         Pad all components except first to 00
    // Spacing:         Includes spacing between components.
    //
    // Output: {
    //   LeadFormat, MidFormat, LastFormat, Spacing,      #N/A;
    //   Designator, DaySuffix, HourSuffix, MinuteSuffix, SecondSuffix
    // }
    
    IF(ROWS(_components) = 1, INDEX(_components, 1, 1),
        IF(INDEX(_components, 1, 1) < 1, "",
            LET(
                _sign, INDEX(_components, 2, 1), 
                _designator, IF(_sign < 0, "−", // − UNICHAR(8722)
                    IF(_signPositive, "+", "")
                ),

                _count, INDEX(_components, 1, 1),
                _displayDecimals, INDEX(_components, 1, 4),
                _leadFmt, "0",
                _midFmt, IF(_padding, "00", "0"),
                _lastPad, IF(_count = 1, _leadFmt, _midFmt),
                _lastFmt, IF(_displayDecimals = 0, _lastPad,
                    CONCAT(_lastPad, LEFT(".000000000", _displayDecimals + 1))
                ),
                _formats, HSTACK(_leadFmt, _midFmt, _lastFmt, _spacing),
                    
                _displayLowOrder, INDEX(_components, 1, 3),
                _delims, HSTACK(_designator, "d", "h", "m", "s"),

                VSTACK(
                    _formats,
                    _delims
                )
            )
        )
    )
);

_FORMAT_PROVIDER_TIMESPAN_EUROPEAN = LAMBDA(_components, _signPositive, _padding, _spacing,
    // Format:          ± 0d 0h 0' 0.000"
    // SignPositive:    Prepends + for positive values
    // Padding:         Pad all components except first to 00
    // Spacing:         Includes spacing between components.
    //
    // Output: {
    //   LeadFormat, MidFormat, LastFormat, Spacing,      #N/A;
    //   Designator, DaySuffix, HourSuffix, MinuteSuffix, SecondSuffix
    // }

    IF(ROWS(_components) = 1, INDEX(_components, 1, 1),
        IF(INDEX(_components, 1, 1) < 1, "",
            LET(
                _provider, _FORMAT_PROVIDER_TIMESPAN_TRADITIONAL(_components, _signPositive, _padding, _spacing),
                _delims, HSTACK(
                    TAKE(_provider, -1, 3),
                    "'", """"
                ),
                VSTACK(
                    TAKE(_provider, 1),
                    _delims
                )
            )
        )
    )
);






/*##############################################################################################################
# COMPLICATIONS                                                                                                #
##############################################################################################################*/


/*--------------------------------------------------------------------------------------------------------------
VALIDATE_DT

Validate a day and time complication.

Array compatible: DT as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer        | Day
 2 | decimal [0..1] | Time

Parameters
----------------------------------------------------------------------------------------------------------------
DT        | array   C[1..2] |
   [Day]  | integer         | 
   [Time] | decimal [0..1]  |
--------------------------------------------------------------------------------------------------------------*/
VALIDATE_DT = LAMBDA(DT,
    LET(
        fnValidateDT, LAMBDA(_DT,
            IF(COLUMNS(_DT) > 2, {#REF!, #REF!},
                IF(ARRAYS.IS_EMPTY(_DT), {"", ""},
                    LET(
                        _expandDT, EXPAND(_DT, 1, 2, ""),
                        _d, INDEX(_expandDT, 1, 1),
                        _t, INDEX(_expandDT, 1, 2),
                        _dayHasTimeComponent, IF(NOT(ISNUMBER(_d)), FALSE,
                            NOT(FN.IS_INTEGER(_d))
                        ),
                        _hasTimeComponent, IF(_dayHasTimeComponent, TRUE,
                            NOT(FN.IS_EMPTY(_t))
                        ),
                        _dayAndTimeCollison, _dayHasTimeComponent * NOT(FN.IS_EMPTY(_t)) <> 0, 
                        _day, IF(ISERROR(_d), _d * {1},
                            IF(_dayAndTimeCollison, {#NUM!},
                                IF(_d = "", "",
                                    IF(NOT(ISNUMBER(_d)), {#VALUE!}, INT(_d))
                                )
                            )
                        ),
                        _time, IF(ISERROR(_t), _t * {1},
                            IF(_dayAndTimeCollison, {#NUM!},
                                IF(_t = "",
                                    IF(_dayHasTimeComponent, MOD(_d, 1), ""),
                                    IF(NOT(ISNUMBER(_t)), {#VALUE!},
                                        IF((_t >= 0) * (_t <= 1), _t, {#NUM!})
                                    )
                                )
                            )
                        ),
                        
                        HSTACK(_day, _time)
                    )
                )
            )
        ),

        _DT, FN.NULLIFY(DT),
        _rowCount, ROWS(_DT),
        _byRow, REDUCE("", SEQUENCE(_rowCount),
            LAMBDA(_acc, _curr,
                VSTACK(
                    _acc,
                    fnValidateDT(INDEX(_DT, _curr,))
                )
            )
        ),
        DROP(_byRow, 1)
    )
);


/*--------------------------------------------------------------------------------------------------------------
IS_VALID_DT

Tests if a day and time complication is valid.

Array compatible: DT as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean | 

Parameters
----------------------------------------------------------------------------------------------------------------
DT        | array   C[1..2] |
   [Day]  | integer         | 
   [Time] | decimal [0..1]  |
--------------------------------------------------------------------------------------------------------------*/
IS_VALID_DT = LAMBDA(DT,
    BYROW(FN.NULLIFY(DT),
        LAMBDA(_row,
            IF(ARRAYS.IS_EMPTY(_row), FALSE,
                LET(
                    _validateDT, CHRONO.VALIDATE_DT(_row),
                    NOT(ARRAYS.HAS_ERROR(_validateDT))
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
RESOLVE_DT

Resolves a day and time complication, where time can exceed its modulus.

Array compatible: DT as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer        | Day
 2 | decimal [0..1] | Time

Parameters
----------------------------------------------------------------------------------------------------------------
DT        | array   C[1..2] |
   [Day]  | decimal         | 
   [Time] | decimal         |
--------------------------------------------------------------------------------------------------------------*/
RESOLVE_DT = LAMBDA(DT,
    LET(
        fnResolveDT, LAMBDA(_DT,
            IF(COLUMNS(_DT) > 2, {#REF!, #REF!},
                IF(ARRAYS.IS_EMPTY(_DT), {"", ""},
                    LET(
                        _combineDT, CHRONO.COMBINE_DT(_DT),
                        IF(ISERROR(_combineDT), _combineDT * {1, 2},
                            LET(
                                _dayEmpty, N(FN.IS_EMPTY(CHOOSECOLS(_DT, 1))),
                                _resolveTime, MOD(_combineDT, 1),
                                _nominalDay, INT(_combineDT),
                                _resolveDay, _nominalDay + N(_nominalDay <= 0),
                                HSTACK(_resolveDay, _resolveTime)
                            )
                        )
                    )
                )
            )
        ),

        _DT, FN.NULLIFY(DT),
        _rowCount, ROWS(_DT),
        _byRow, REDUCE("", SEQUENCE(_rowCount),
            LAMBDA(_acc, _curr,
                VSTACK(
                    _acc,
                    fnResolveDT(INDEX(_DT, _curr, ))
                )
            )
        ),
        DROP(_byRow, 1)
    )
);


/*--------------------------------------------------------------------------------------------------------------
COMBINE_DT

Combines a day and time complication as a decimal day.

Array compatible: DT as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Day

Parameters
----------------------------------------------------------------------------------------------------------------
DT        | array   C[1..2] |
   [Day]  | decimal         | 
   [Time] | decimal         |
--------------------------------------------------------------------------------------------------------------*/
COMBINE_DT = LAMBDA(DT,
    LET(
        fnCombineDT, LAMBDA(_DT,
            IF(COLUMNS(_DT) > 2, {#REF!},
                IF(ARRAYS.IS_EMPTY(_DT), "",
                    LET(
                        _expandDT, EXPAND(_DT, 1, 2, ""),
                        _firstError, ARRAYS.H_ERROR(_expandDT), 
                        IF(ISERROR(_firstError), _firstError * {1},
                            IF(NOT(ARRAYS.IS_NUMERIC_NULL(_expandDT)), {#VALUE!},
                                SUM(N(_expandDT))
                            )
                        )
                    )
                )
            )
        ),

        BYROW(FN.NULLIFY(DT),
            LAMBDA(_row,
                fnCombineDT(_row)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
DT_COMPLICATION

Resolves a day and time complication from a decimal day value.

Array compatible: Day_D as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer        | Day
 2 | decimal [0..1] | Time

Parameters
----------------------------------------------------------------------------------------------------------------
Day_D | decimal | Day decimal
--------------------------------------------------------------------------------------------------------------*/
DT_COMPLICATION = LAMBDA(Day_D,
    LET(
        fnDTcomplication, LAMBDA(_day_D,
            IF(ISERROR(_day_D), _day_D * {1, 2},
                IF(_day_D = "", {"", ""},
                    IF(NOT(ISNUMBER(_day_D)), {#VALUE!},
                        LET(
                            _day, INT(_day_D),
                            _time, MOD(_day_D, 1),
                            HSTACK(_day, _time)
                        )
                    )
                )
            )
        ),

        _day_D, FN.NULLIFY(INDEX(Day_D, , 1)),
        _rowCount, ROWS(_day_D),
        _byRow, REDUCE("", SEQUENCE(_rowCount),
            LAMBDA(_acc, _curr,
                VSTACK(
                    _acc,
                    fnDTcomplication(INDEX(_day_D, _curr, 1))
                )
            )
        ),
        DROP(_byRow, 1)
    )
);


/*--------------------------------------------------------------------------------------------------------------
ROUND_TO_DT

Takes a decimal day value and returns a day and time complication rounded to a specified low order component.
Seconds can be rounded to a given precision.

Array compatible: DayAndTime_D

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer        | Day
 2 | decimal [0..1] | Time

Parameters
----------------------------------------------------------------------------------------------------------------
Day_D              | decimal | Decimal day
[LowOrder]         | integer | Lowest-order component. Defaults to Second.
                   | [1..4]  | 1: Day
                   |         | 2: Hour
                   |         | 3: Minute
                   |         | 4: Second
[SecondPrecision]  | integer | Round seconds to specified decimal places.
                   | [0..9]  | Defaults to 0.
[RoundingOverride] | switch  |  0: Default When Precision = 0, rounds to nearest second and truncates at low order component.
                   |         |             When Precision > 0, rounds to nearest at low order component.
                   |         |  1: Nearest Always round to nearest low order component.
                   |         | -1: Down    Always round down at low order component.
--------------------------------------------------------------------------------------------------------------*/
ROUND_TO_DT = LAMBDA(Day_D, [LowOrder], [SecondPrecision], [RoundingOverride],
    LET(
        _lowOrder, IF(NOT(ISNUMBER(LowOrder)), 4,
            IF(LowOrder < 1, 1,
                IF(LowOrder > 4, 4, INT(LowOrder))
            )
         ),

        _maxPrecision, 9,
        _secondPrecision, IF(_lowOrder < 4, 0,
            IF(NOT(ISNUMBER(SecondPrecision)), 0,
                IF(SecondPrecision < 0, 0,
                    IF(SecondPrecision > _maxPrecision, _maxPrecision, INT(SecondPrecision))
                )
            )
        ),

        fnRoundDT, LAMBDA(_day_D,
            IF(ISERROR(_day_D), _day_D * {1, 2},
                IF(_day_D = "", {"", ""},
                    IF(NOT(ISNUMBER(_day_D)), {#VALUE!, #VALUE!},
                        LET(
                            _DT, CHRONO.DT_COMPLICATION(_day_D),
                            _day, INDEX(_DT, 1, 1),
                            _time, INDEX(_DT, 1, 2),
                            _roundTime, CHRONO.ROUND_TIMESPAN(_time, _lowOrder, _secondPrecision, RoundingOverride),
                            _dayCarry, INT(_roundTime),
                            _resolveTime, MOD(_roundTime, 1),
                            _resolveDay, _day + _dayCarry,
                            HSTACK(_resolveDay, _resolveTime)
                        )
                    )
                )
            )
        ),
     
        _day_D, FN.NULLIFY(INDEX(Day_D, , 1)),
        _rowCount, ROWS(_day_D),
        _byRow, REDUCE("", SEQUENCE(_rowCount),
            LAMBDA(_acc, _curr,
                VSTACK(
                    _acc,
                    fnRoundDT(INDEX(_day_D, _curr, 1))
                )
            )
        ),
        DROP(_byRow, 1)
    )
);


/*--------------------------------------------------------------------------------------------------------------
IS_VALID_TIME_OF_DAY

Tests if a sexagesimal complication is a valid time of day.

Array compatible: Time_HMS as columns

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
----------------------------------------------------------------------------------------------------------------
Time_HMS      | array   C[3]    |
   Hour       | integer [0..24] |
   Minute     | integer [0..59] |
   Second     | decimal [0..60) | Fractional less than 60
[Allow24Hour] | switch          | Allow time of 24:00 to refer to midnight at the end of a calendar day.
--------------------------------------------------------------------------------------------------------------*/
IS_VALID_TIME_OF_DAY = LAMBDA(Time_HMS, [Allow24Hour],
    LET(
        _allow24hr, FN.COERCE(Allow24Hour) <> 0,
        
        fnValidateToD, LAMBDA(_time_HMS,
            IF(COLUMNS(_time_HMS) <> 3, FALSE,
                IF(NOT(ARRAYS.IS_NUMERIC(_time_HMS)), FALSE,  // any term not numeric
                    IF(ARRAYS.HAS_NEGATIVE(_time_HMS), FALSE,  // any term negative
                        IF(INDEX(_time_HMS, 1, 3) >= 60, FALSE,  // second 60 or more
                            IF(INDEX(_time_HMS, 1, 2) >= 60, FALSE,  // minute 60 or more
                                IF(NOT(FN.IS_INTEGER(INDEX(_time_HMS, 1, 2))), FALSE,  // minute not an integer
                                    IF(NOT(FN.IS_INTEGER(INDEX(_time_HMS, 1, 1))), FALSE,  // hour not an integer
                                        IF(INDEX(_time_HMS, 1, 1) < 24, TRUE,  // hour less than 24
                                            IF(INDEX(_time_HMS, 1, 1) > 24, FALSE,  // hour greater than 24
                                                IF(_allow24hr = 0, FALSE,  // hour is 24, and not permitted
                                                    IF(INDEX(_time_HMS, 1, 2) > 0, FALSE,  // hour is 24, minute not 0
                                                        IF(INDEX(_time_HMS, 1, 3) > 0, FALSE,  // hour is 24, second not 0
                                                            TRUE    // checks passed
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ),

        BYROW(FN.NULLIFY(Time_HMS),
            LAMBDA(_row,
                fnValidateToD(_row)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
TIME_OF_DAY

Returns a decimal time of day value from a time complication.

Array compatible: Time_HMS as columns

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Time of day as a fraction of a day. Implicitly converts to Excel Date/Time type.

Parameters
----------------------------------------------------------------------------------------------------------------
Time_HMS      | array   C[3]    |
   Hour       | integer [0..24] |
   Minute     | integer [0..59] |
   Second     | decimal [0..60) | Fractional less than 60
--------------------------------------------------------------------------------------------------------------*/
TIME_OF_DAY = LAMBDA(Time_HMS,
    LET(
        fnTimeSpan, LAMBDA(_hms,
            IF(COLUMNS(_hms) <> 3, {#REF!},
                IF(ARRAYS.IS_EMPTY(_hms), "",
                    LET(
                        _firstError, ARRAYS.H_ERROR(_hms),
                        IF(ISERROR(_firstError), _firstError * {1},
                            IF(NOT(CHRONO.IS_VALID_TIME_OF_DAY(_hms, TRUE)), {#NUM!},   // not a valid time of day
                                CHRONO.TIMESPAN(HSTACK(1, 0, _hms))
                            )
                        )
                    )
                )
            )
        ),
    
        BYROW(FN.NULLIFY(Time_HMS),
            LAMBDA(_row,
                fnTimeSpan(_row)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
DAY_AND_TIME_TO_DHMS

Returns the sexagesimal complication from a day and time value expressed to a specified low order component.
Seconds can be rounded to a given precision.

Array compatible: Day_D as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Day
 2 | integer [0..24] | Hour
 3 | integer [0..60) | Minute
 4 | decimal [0..60) | Second

Parameters
----------------------------------------------------------------------------------------------------------------
Day_D              | decimal | Decimal day and time of day where a day = 1
[LowOrder]         | integer | Lowest-order component. Defaults to Second.
                   | [1..4]  | 1: Day
                   |         | 2: Hour
                   |         | 3: Minute
                   |         | 4: Second
[SecondPrecision]  | integer | Round seconds to specified decimal places.
                   | [0..9]  | Defaults to a maximum precision of 9.
[RoundingOverride] | switch  |  0: Default When Precision = 0, rounds to nearest second and truncates at low order component.
                   |         |             When Precision > 0, rounds to nearest at low order component.
                   |         |  1: Nearest Always round to nearest low order component.
                   |         | -1: Down    Always round down at low order component.
--------------------------------------------------------------------------------------------------------------*/
DAY_AND_TIME_TO_DHMS = LAMBDA(DayAndTime_D, [LowOrder], [SecondPrecision], [RoundingOverride],
    LET(
        _highOrder, 1,
        _lowOrder, IF(NOT(ISNUMBER(LowOrder)), 4,
            IF(LowOrder < 1, 1,
                IF(LowOrder > 4, 4, INT(LowOrder))
            )
         ),

        _maxPrecision, 9,
        _secondPrecision, IF(_lowOrder < 4, 0,
            IF(NOT(ISNUMBER(SecondPrecision)), _maxPrecision,
                IF(SecondPrecision < 0, 0,
                    IF(SecondPrecision > _maxPrecision, _maxPrecision, INT(SecondPrecision))
                )
            )
        ),

        fnRoundDayAndTime, LAMBDA(_dayAndTime_D,
            IF(ISERROR(_dayAndTime_D), _dayAndTime_D * {1, 2, 3, 4},
                IF(_dayAndTime_D = "", {"", "", "", ""},
                    IF(NOT(ISNUMBER(_dayAndTime_D)), {#VALUE!, #VALUE!, #VALUE!, #VALUE!},
                        LET(
                            _DT, CHRONO.DT_COMPLICATION(_dayAndTime_D),
                            _day, INDEX(_DT, 1, 1),
                            _time, INDEX(_DT, 1, 2),
                            _roundTime_C5, CHRONO.TIMESPAN_TO_DHMS(_time, _highOrder, _lowOrder, _secondPrecision, RoundingOverride),
                            _dayCarry, INDEX(_roundTime_C5, 1, 2),
                            _resolveDay, _day + _dayCarry, 
                            HSTACK(_resolveDay, DROP(_roundTime_C5, , 2))
                        )
                    )
                )
            )
        ),

        _dayAndTime_D, FN.NULLIFY(INDEX(DayAndTime_D, , 1)),
        _rowCount, ROWS(_dayAndTime_D),
        _byRow, REDUCE("", SEQUENCE(_rowCount),
            LAMBDA(_acc, _curr,
                VSTACK(
                    _acc,
                    fnRoundDayAndTime(INDEX(_dayAndTime_D, _curr, 1))
                )
            )
        ),
        DROP(_byRow, 1)
    )
);


/*--------------------------------------------------------------------------------------------------------------
RESOLVE_DHMS

Resolves a sexagesimal complication to represent day and time of day so that each component is within its modulus.

Array compatible: DayAndTime_C4 as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Day
 2 | integer [0..24] | Hour
 3 | integer [0..60) | Minute
 4 | decimal [0..60) | Second

Parameters
----------------------------------------------------------------------------------------------------------------
DayAndTime_C4      | array C[1..4] |
   Day             | decimal [0..] |
   [Hour]          | decimal [0..] |
   [Minute]        | decimal [0..] |
   [Second]        | decimal [0..] |
[LowOrder]         | integer       | Lowest-order component. Defaults to Second.
                   | [1..4]        | 1: Day
                   |               | 2: Hour
                   |               | 3: Minute
                   |               | 4: Second
[SecondPrecision]  | integer       | Round seconds to specified decimal places.
                   | [0..9]        | Defaults to a maximum precision of 9.
[RoundingOverride] | switch        |  0: Default When Precision = 0, rounds to nearest second and truncates at low order component.
                   |               |             When Precision > 0, rounds to nearest at low order component.
                   |               |  1: Nearest Always round to nearest low order component.
                   |               | -1: Down    Always round down at low order component.
--------------------------------------------------------------------------------------------------------------*/
RESOLVE_DHMS = LAMBDA(DayAndTime_C4, [LowOrder], [SecondPrecision], [RoundingOverride],
    LET(
        fnResolveDayAndTime, LAMBDA(_dayAndTime,
            IF(ARRAYS.IS_EMPTY(_dayAndTime), {"", "", "", ""},
                LET(
                    _timeSpan_C5, HSTACK(1, _dayAndTime),
                    _timeSpan_D, CHRONO.TIMESPAN(_timeSpan_C5),
                    CHRONO.DAY_AND_TIME_TO_DHMS(_timeSpan_D, LowOrder, SecondPrecision, RoundingOverride)
                )
            )
        ),
        
        _dayAndTime, FN.NULLIFY(DayAndTime_C4),
        _rowCount, ROWS(_dayAndTime),
        _byRow, REDUCE("", SEQUENCE(_rowCount),
            LAMBDA(_acc, _curr,
                VSTACK(
                    _acc,
                    fnResolveDayAndTime(INDEX(_dayAndTime, _curr, ))
                )
            )
        ),
        DROP(_byRow, 1)
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_TIME_OF_DAY_HMS

Parses a formatted time of day into a time complication.

Array compatible: Expression as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [0..24]  | Hour
 2 | integer [0..59]  | Minute
 3 | decimal [0..60)  | Second

Parameters
----------------------------------------------------------------------------------------------------------------
Expression       | text   | Time in general format ie. h:mm:ss.000 AM/PM
[RequireISO8601] | switch | Require TimeOfDay is explicitly in ISO8601 format.

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_TIME_OF_DAY_HMS("12:00")
Returns: {12, 0, 0}

PARSE_TIME_OF_DAY_HMS("6 pm")
Returns: {18, 0, 0}

PARSE_TIME_OF_DAY_HMS("24:00:01", TRUE)
Returns: {#NUM!, #NUM!, #NUM!} i.e. range is 0 to 24 hours 
--------------------------------------------------------------------------------------------------------------*/
PARSE_TIME_OF_DAY_HMS = LAMBDA(Expression, [RequireISO8601],
    LET(
        _strictISO, FN.COERCE(RequireISO8601) <> 0,
        _validCharsGeneral, "0123456789AMP :.",
        _validCharsISO, "0123456789:.",
        
        _generalLogicTable, {
            // terms, pattern, hasDecimal, am/pm
            4, "::. a.m.", TRUE,  1;  // h:mm:ss.000 a.m.
            4, "::.a.m.",  TRUE,  1;  // h:mm:ss.000a.m.
            4, "::. am",   TRUE,  1;  // h:mm:ss.000 am
            4, "::.am",    TRUE,  1;  // h:mm:ss.000am
            4, "::. p.m.", TRUE,  2;  // h:mm:ss.000 p.m.
            4, "::.p.m.",  TRUE,  2;  // h:mm:ss.000p.m.
            4, "::. pm",   TRUE,  2;  // h:mm:ss.000 pm
            4, "::.pm",    TRUE,  2;  // h:mm:ss.000pm
            4, "::.",      TRUE,  0;  // H:mm:ss.000
            3, ":: a.m.",  FALSE, 1;  // h:mm:ss a.m. 
            3, "::a.m.",   FALSE, 1;  // h:mm:ssa.m. 
            3, ":: am",    FALSE, 1;  // h:mm:ss am
            3, "::am",     FALSE, 1;  // h:mm:ssam 
            3, ":: p.m.",  FALSE, 2;  // h:mm:ss p.m.
            3, "::p.m.",   FALSE, 2;  // h:mm:ssp.m.
            3, ":: pm",    FALSE, 2;  // h:mm:ss pm
            3, "::pm",     FALSE, 2;  // h:mm:sspm
            3, "::",       FALSE, 0;  // H:mm:ss
            2, ": a.m.",   FALSE, 1;  // h:mm a.m.
            2, ":a.m.",    FALSE, 1;  // h:mma.m.
            2, ": am",     FALSE, 1;  // h:mm am
            2, ":am",      FALSE, 1;  // h:mmam
            2, ": p.m.",   FALSE, 2;  // h:mm p.m.
            2, ":p.m.",    FALSE, 2;  // h:mmp.m.
            2, ": pm",     FALSE, 2;  // h:mm pm
            2, ":pm",      FALSE, 2;  // h:mmpm
            2, ":",        FALSE, 0;  // H:mm
            1, " a.m.",    FALSE, 1;  // h a.m.
            1, "a.m.",     FALSE, 1;  // ha.m.
            1, " am",      FALSE, 1;  // h am
            1, "am",       FALSE, 1;  // ham
            1, " p.m.",    FALSE, 2;  // h p.m.
            1, "p.m.",     FALSE, 2;  // hp.m.
            1, " pm",      FALSE, 2;  // h pm
            1, "pm",       FALSE, 2;  // hpm
            1, "",         FALSE, 0   // H
        },

        fnParseISO, LAMBDA(_timeOfDay,
            IF(NOT(EXACT(LEFT(_timeOfDay), "T")), {#VALUE!, #VALUE!, #VALUE!}, // firstChar must be "T"
                LET(
                    _ISOtime, RIGHT(_timeOfDay, LEN(_timeOfDay) - 1),
                    IF(NOT(FN.VALIDATE_CHARSET(_ISOtime, _validCharsISO)), {#VALUE!, #VALUE!, #VALUE!},
                        LET(
                            _pattern, FN.REPLACE_CHARS(_ISOtime, "0123456789", "0"),
                            _dotPos, IFERROR(FIND(".", _pattern), 0),
                            _lenDecimal, LEN(_pattern) - _dotPos,
                            _decPartError, IF(_dotPos = 0, FALSE,
                                IF(_dotPos = 1, TRUE,
                                    IF(_dotPos = LEN(_pattern), TRUE,
                                        RIGHT(_pattern, _lenDecimal) <> REPT("0", _lenDecimal)
                                    )
                                )
                            ),
                            IF(_decPartError, {#VALUE!, #VALUE!, #VALUE!},
                                LET(
                                    _hmsPattern, IF(_dotPos = 0, _pattern,
                                        LEFT(_pattern, _dotPos - 1)
                                    ),
                                    _hms, SWITCH(_hmsPattern,
                                        "00:00:00", VALUE(MID(_ISOtime, {1, 4, 7}, 2)),
                                        "00:00", HSTACK(VALUE(MID(_ISOtime, {1, 4}, 2)), 0),
                                        "000000", VALUE(MID(_ISOtime, {1, 3, 5}, 2)),
                                        "0000", HSTACK(VALUE(MID(_ISOtime, {1, 3}, 2)), 0),
                                        "00", HSTACK(VALUE(MID(_ISOtime, 1, 2)), 0, 0),
                                        {#VALUE!}
                                    ),
                                    IF(ISERROR(INDEX(_hms, 1, 1)), {#VALUE!, #VALUE!, #VALUE!},
                                        LET(
                                            _fracSeconds, IF(_dotPos = 0, 0,
                                                LET(
                                                    _decimals, MIN(_lenDecimal, 9),
                                                    VALUE(MID(_ISOtime, _dotPos + 1, _decimals)) / (10 ^ _decimals)
                                                )
                                            ),
                                            _hmsf, HSTACK(TAKE(_hms, 1, 2), INDEX(_hms, 1, 3) + _fracSeconds),
                                            _hmsf
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ),
        
        fnParseGeneral, LAMBDA(_timeOfDay,
            IF(NOT(FN.VALIDATE_CHARSET(_timeOfDay, _validCharsGeneral)), {#VALUE!, #VALUE!, #VALUE!},
                LET(
                    _split, FN.SPLIT_AROUND(_timeOfDay, "0123456789", FALSE, 5),
                    _countTerms, INDEX(_split, 1, 1),
                    IF(_countTerms = 0, {#VALUE!, #VALUE!, #VALUE!},
                        IF(_countTerms > 4, {#VALUE!, #VALUE!, #VALUE!},
                            LET(
                                _pattern, INDEX(_split, 1, 2),
                                _match, FILTER(_generalLogicTable,
                                    (INDEX(_generalLogicTable, , 1) = _countTerms)
                                    * (INDEX(_generalLogicTable, , 2) = _pattern),
                                    #N/A
                                ),
                                IF(ISNA(INDEX(_match, 1, 1)), {#VALUE!, #VALUE!, #VALUE!},
                                    LET(
                                        _hasDecimal, INDEX(_match, 1, 3),
                                        _ampm, INDEX(_match, 1, 4),
                                        _terms, DROP(_split, , 2),
                                        _hms, IF(_hasDecimal,
                                            HSTACK(
                                                DROP(_terms, , -2),
                                                CONCAT(INDEX(_terms, 1, _countTerms - 1), ".", LEFT(INDEX(_terms, 1, _countTerms), 9))
                                            ),
                                            _terms
                                        ),
                                        _hms3, EXPAND(VALUE(_hms), 1, 3, 0),
                                        _hms24, IF(_ampm = 0, _hms3,
                                            LET(
                                                _h, INDEX(_hms3, 1, 1),
                                                _resolveH, IF(_h = 0, {#NUM!},
                                                    IF(_h > 12, {#NUM!},
                                                        IF((_ampm = 1) * (_h = 12), 0,
                                                            IF((_ampm = 2) * (_h < 12), _h + 12, _h)
                                                        )
                                                    )
                                                ),
                                                HSTACK(_resolveH, DROP(_hms3, , 1))
                                            )
                                        ),
                                        _hms24
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ),
        
        fnParseTimeOfDay, LAMBDA(_timeOfDay,
            IF(ISERROR(_timeOfDay), {#VALUE!, #VALUE!, #VALUE!},
                LET(
                    _trimToD, TRIM(_timeOfDay),
                    IF(_trimToD = "", {"", "", ""},
                        LET(
                            _parsedTimeOfDay, IF(_strictISO, fnParseISO(_timeOfDay),
                                LET(
                                    _firstChar, LEFT(_timeOfDay),
                                    _detectStyle, IF(EXACT(_firstChar, "T"), 1, // ISO Style
                                        IF(NOT(ISERROR(VALUE(_firstChar))), 2, // General style
                                            3 // Invalid
                                        )
                                    ),
                                    SWITCH(_detectStyle,
                                        1, fnParseISO(_timeOfDay),
                                        2, fnParseGeneral(_trimToD),
                                        {#N/A}
                                    )
                                )
                            ),

                            IF(ISERROR(INDEX(_parsedTimeOfDay, 1, 1)), {#VALUE!, #VALUE!, #VALUE!},
                                IF(NOT(CHRONO.IS_VALID_TIME_OF_DAY(_parsedTimeOfDay, TRUE)), {#NUM!, #NUM!, #NUM!},
                                    _parsedTimeOfDay
                                )
                            )
                        )
                    )
                )
            )
        ),

        _expression, FN.NULLIFY(INDEX(Expression, , 1)),
        _rowCount, ROWS(_expression),
        _byRow, REDUCE("", SEQUENCE(_rowCount),
            LAMBDA(_acc, _curr,
                VSTACK(
                    _acc,
                    fnParseTimeOfDay(INDEX(_expression, _curr, 1))
                )
            )
        ),
        DROP(_byRow, 1)
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_TIME_OF_DAY

Parses a formatted time of day as a decimal value.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal [0..1] | Time of day as decimal fraction of a day. Implicitly equivalent to Excel Time value.

Parameters
----------------------------------------------------------------------------------------------------------------
Expression       | text   | Time in general format ie. h:mm:ss.000 AM/PM
[RequireISO8601] | switch | Require TimeOfDay is explicitly in ISO8601 format.

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_TIME_OF_DAY("12:00")
Returns: 0.5

PARSE_TIME_OF_DAY("6 pm")
Returns: 0.75

PARSE_TIME_OF_DAY("24:00:01", 1)
Returns: #NUM!  i.e. range is 0 to 24 hours 
--------------------------------------------------------------------------------------------------------------*/
PARSE_TIME_OF_DAY = LAMBDA(Expression, [RequireISO8601],
    LET(
        _strictISO, FN.COERCE(RequireISO8601),
        
        MAP(FN.NULLIFY(Expression),
            LAMBDA(_element,
                LET(
                    _HMS, CHRONO.PARSE_TIME_OF_DAY_HMS(_element, _strictISO),
                    CHRONO.TIME_OF_DAY(_HMS)
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
FORMAT_TIME_OF_DAY

Returns a formatted sexagesimal complication from a decimal time of day.

Array compatible: TimeOfDay

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | Formatted sexagesimal representation of time of day

Parameters
----------------------------------------------------------------------------------------------------------------
TimeOfDay        | decimal [0..1] | Time of day as decimal fraction of a day. Implicity equivalent to Excel Time.
[Options]        | text           | String with elements: [C|I|B][A][P][J][K][L][N|F][LowOrder][*][0-9]
                 |                |   C, I, B : Civil, ISO8601 or Basic style. 24 hour style when not present.
                 |                |             24 Hour: H:mm:ss.000    
                 |                |             Civil:   h:mm:ss AM|PM
                 |                |             ISO:     THH:mm:ss.000
                 |                |             Basic:   THHmmss.000
                 |                |         A : Display 24:00 to represent midnight the next day.
                 |                |             Not applicable to Civil style.
                 |                |         P : Pad hours with leading zero for 24 Hour and Civil styles.
                 |                |             ISO8601 and Basic styles always pad with leading zero.
                 |                |         J : Dotted style A.M.|P.M. Applicable to Civil style.
                 |                |         K : No space preceding AM|PM. Applicable to Civil style.
                 |                |         L : Lower case am|pm. Applicable to Civil style.
                 |                |      N, F : Override rounding behaviour.
                 |                |             Default method rounds to nearest second and then truncates to low order component.
                 |                |             N: always round to nearest.
                 |                |             F: always round down.
                 |                |  LowOrder : Low order component. Upper case to set explicitly. Lower case allows floating
                 |                |             from expressing in the given component down to seconds as needed.
                 |                |             Takes the following:
                 |                |             H, h : Hour
                 |                |             M, m : Minute
                 |                |             S, s : Second 
                 |                |         * : Allows floating down the lowest order component needed, including the maximum precision
                 |                |             of the style for seconds.
                 |                |       0-9 : Decimal places for seconds. If LowOrder not supplied, then implicitly LowOrder is 's'.
                 |                |             Not applicable to Civil style.

Examples
----------------------------------------------------------------------------------------------------------------
FORMAT_TIME_OF_DAY(0.25)
Returns: 6:00

FORMAT_TIME_OF_DAY(0.75, "CPL")
Returns: 06:00 pm

FORMAT_TIME_OF_DAY(0.6747, "IM")
Returns: T16:11

FORMAT_TIME_OF_DAY(1)
Returns: 0:00

FORMAT_TIME_OF_DAY(1, "A")
Returns: 24:00
--------------------------------------------------------------------------------------------------------------*/
FORMAT_TIME_OF_DAY = LAMBDA(TimeOfDay, [Options],
    LET(
        _optionSet, _FORMAT_TIME_OF_DAY_OPTIONS(Options, FALSE),
        
        MAP(FN.NULLIFY(TimeOfDay),
            LAMBDA(_element,
                LET(
                    _DT, _FORMAT_TIME_OF_DAY(_element, _optionSet),
                    INDEX(_DT, 1, 2)
                )
            )
        )
    )
);

_FORMAT_TIME_OF_DAY_OPTIONS = LAMBDA(_options, _allowDayResolution,
    LET(
        _options1, FN.NULLIFY(_options),
        _style, LEFT(FN.SIFT_FOR_CHARS(_options1, "CIB")),
        _midnightCeiling, IFERROR(SEARCH("A", _options1), 0) > 0,
        _padding, IFERROR(SEARCH("P", _options1), 0) > 0,
        _ampmDotted, IFERROR(SEARCH("J", _options1), 0) > 0,
        _ampmCondense, IFERROR(SEARCH("K", _options1), 0) > 0,
        _ampmLower, IFERROR(SEARCH("L", _options1), 0) > 0,

        _roundingOverride, LET(
            _r, LEFT(FN.SIFT_FOR_CHARS(_options1, "NF")),
            SWITCH(_r,
                "N", 1,
                "F", -1,
                0
            )
        ),

        // -2  : default for style
        // -1  : floating as defined in style
        // [n] : precision limit
        _secondPrecision, LET(
            _pChar, LEFT(FN.SIFT_FOR_CHARS(_options1, "*0123456789")),
            SWITCH(_pChar,
                "", -2,
                "*", -1,
                VALUE(_pChar)
            )
        ),
        
        _lowOrderChars, IF(_allowDayResolution, "DHMS", "HMS"),
        _lowChar, LEFT(FN.SIFT_FOR_CHARS(_options1, _lowOrderChars)),
        _lowOrder, SWITCH(_lowChar,
            "D", 1,
            "H", 2,
            "M", 3,
            "S", 4,
            0
        ),
        _lowFixed, IF(_lowOrder = 0,
            _secondPrecision <> -1,
            CODE(_lowChar) < 100
        ),

        HSTACK(
            _style,
            _midnightCeiling, _lowOrder, _lowFixed,
            _secondPrecision, _roundingOverride,
            _padding, _ampmDotted, _ampmCondense, _ampmLower
        )
    )
);

_FORMAT_TIME_OF_DAY = LAMBDA(_timeOfDay, _optionSet,
    IF(ISERROR(_timeOfDay), HSTACK(0, _timeOfDay * {1}),
        IF(_timeOfDay = "", {0, ""},
            IF(NOT(ISNUMBER(_timeOfDay)), HSTACK(0, {#VALUE!}),
                LET(
                    _style, INDEX(_optionSet, 1, 1),
                    _midnightCeiling, INDEX(_optionSet, 1, 2),
                    _lowOrder, INDEX(_optionSet, 1, 3),
                    _lowFixed, INDEX(_optionSet, 1, 4),
                    _secondPrecision, INDEX(_optionSet, 1, 5),
                    _roundingOverride, INDEX(_optionSet, 1, 6),

                    _components, SWITCH(_style,
                        "", _TIME_OF_DAY_COMPONENTS_24HR(_timeOfDay,
                                _midnightCeiling, _lowOrder, _lowFixed,
                                _secondPrecision, _roundingOverride
                        ),
                        "C", _TIME_OF_DAY_COMPONENTS_CIVIL(_timeOfDay,
                                _lowOrder, _lowFixed, _roundingOverride
                        ),
                        _TIME_OF_DAY_COMPONENTS_ISO(_timeOfDay,
                                _midnightCeiling, _lowOrder, _lowFixed,
                                _secondPrecision, _roundingOverride
                        )
                    ),
                    
                    IF(ROWS(_components) = 1, HSTACK(0, INDEX(_components, 1, 1) * {1}),
                        LET(
                            _padding, INDEX(_optionSet, 1, 7),
                            _ampmDotted, INDEX(_optionSet, 1, 8),
                            _ampmCondense, INDEX(_optionSet, 1, 9),
                            _ampmLower, INDEX(_optionSet, 1, 10),

                            _provider, SWITCH(_style,
                                "C", _FORMAT_PROVIDER_TIME_OF_DAY_CIVIL(_components,
                                        _padding, _ampmDotted, _ampmCondense, _ampmLower
                                ),
                                "I", _FORMAT_PROVIDER_TIME_OF_DAY_ISO(_components, FALSE),
                                "B", _FORMAT_PROVIDER_TIME_OF_DAY_ISO(_components, TRUE),
                                _FORMAT_PROVIDER_TIME_OF_DAY_24HR(_components, _padding)
                            ),
                                    
                            _carryDay, INDEX(_components, 2, 1), 
                            _sToD, _TIME_OF_DAY_FORMATTER(_components, _provider),
                            HSTACK(_carryDay, _sToD)
                        )
                    )
                )
            )
        )
    )
);

_TIME_OF_DAY_FORMATTER = LAMBDA(_components, _provider,
    // Components: {
    //   DisplayCount, DisplayHighOrder, DisplayLowOrder, DisplayDecimals, ResolvePrecision/IsPM;
    //   CarryDay,     Hour,             Minute,          Second,          #N/A
    // }

    // Provider: {
    //   LeadFormat, MidFormat,  LastFormat,   #N/A;
    //   Designator, HourSuffix, MinuteSuffix, SecondSuffix
    // }

    IF(ROWS(_components) = 1, INDEX(_components, 1, 1),
        IF(ROWS(_provider) = 1, INDEX(_provider, 1, 1),
            LET(
                _count, INDEX(_components, 1, 1),
                IF(_count < 1, "",
                    LET(
                        _designator, INDEX(_provider, 2, 1),
                        
                        REDUCE(_designator, SEQUENCE(_count),
                            LAMBDA(_acc, _n,
                                LET(
                                    _fmt, IF(_n = _count, INDEX(_provider, 1, 3),
                                        IF(_n = 1, INDEX(_provider, 1, 1),
                                            INDEX(_provider, 1, 2)
                                        )
                                    ),
                                    _col, INDEX(_components, 1, 2) + _n - 1,
                                    _part, TEXT(INDEX(_components, 2, _col), _fmt),
                                    _delim, INDEX(_provider, 2, _col),
                                    CONCAT(_acc, _part, _delim)
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);

 _TIME_OF_DAY_COMPONENTS = LAMBDA(_timeOfDay_D,
    _midnightCeiling, _minLowOrder, _defaultLowOrder, _autoLowOrder, _maxPrecision, _defaultPrecision, 
    _lowOrder, _lowFixed, _secondPrecision, _roundingOverride,

    // MidnightCeiling:  Display 24:00 to represent midnight next day.
    // MinLowOrder:      Minimum low order accepted for the style.
    // DefaultLowOrder:  Default low order if not specified.
    // AutoLowOrder:     If low order not specified and precision is explicit then implies low order of second.
    // MaxPrecision:     Maximum precision for the style.
    // DefaultPrecision: Default precision for the style.
    // 
    // LowOrder:         Low order at which to round timespan if LowFixed. 
    //                   Otherwise the low order at minimum to display.
    // LowFixed:         Force display to low order, otherwise allow to float from low order as needed.
    // SecondPrecision:   -2: Second expressed at DefaultPrecision.
    //                    -1: Second expressed up to MaxPrecision.
    //                   [n]: Second expressed at which ever is lower of given precision or MaxPrecision.
    // RoundingOverride:   0: Default Rounds to nearest second and truncates at low order component.
    //                     1: Nearest Always round to nearest low order component.
    //                    -1: Down    Always round down at low order component.
    //
    // Output: {
    //   DisplayCount, DisplayHighOrder, DisplayLowOrder, DisplayDecimals, ResolvePrecision;
    //   CarryDay,     Hour,             Minute,          Second,          #N/A
    // }

    IF(ISERROR(_timeOfDay_D), _timeOfDay_D * {1},
        IF(_timeOfDay_D = "", "",
            IF(NOT(ISNUMBER(_timeOfDay_D)), {#VALUE!},
                LET(
                    _doAuto, _autoLowOrder * (_lowOrder = 0) * (_secondPrecision >= 0) <> 0,
                    _setLowOrder, IF(_doAuto, 4, _lowOrder),
                    _setLowFixed, IF(_doAuto, FALSE, _lowFixed),

                    _resolveLowDefault, IF(_defaultLowOrder = 0, 4, _defaultLowOrder),
                    _resolveLowOrder, IF(NOT(_setLowFixed), 4,  // resolve to seconds
                        IF(_setLowOrder = 0, _resolveLowDefault,  // resolve to default of style
                            IF(_setLowOrder = 1, 1,  // resolve to day is sticky
                                MAX(_setLowOrder, _minLowOrder)  // ensure not less than style allows
                            )
                        )
                    ),
                    
                    _resolveToSeconds, _resolveLowOrder = 4,

                    _resolveSecondPrecision, IF(NOT(_resolveToSeconds), 0,
                        SWITCH(_secondPrecision,
                            -2, _defaultPrecision,
                            -1, _maxPrecision,
                            MIN(_secondPrecision, _maxPrecision)
                        )
                    ),
                    
                    _dhms, N(CHRONO.DAY_AND_TIME_TO_DHMS(_timeOfDay_D, _resolveLowOrder, _resolveSecondPrecision, _roundingOverride)),
                    
                    _displayLowOrder, IF(_setLowFixed, _resolveLowOrder,  // display to explicit order
                        // floating
                        LET(
                            _bookend, SWITCH(_setLowOrder,
                                0, IF(_defaultLowOrder = 0, 1, _defaultLowOrder), // default of style
                                1, 1,   // day is sticky
                                MAX(_setLowOrder, _minLowOrder) // not less than style allows
                            ),
                            _nonZeroComponents, IFERROR(_dhms, 1) <> 0,
                            _hasLowOrder, IFNA(XMATCH(1, N(_nonZeroComponents), 0, -1), 0),
                            IF(_hasLowOrder > _bookend, _hasLowOrder, _bookEnd)
                        )
                    ),
                    
                    _displayHighOrder, 2,
            
                    _displayDecimals, IF(_displayLowOrder < 4, 0,
                        IF(_secondPrecision = -2, _resolveSecondPrecision,
                            IF(_secondPrecision = 0, 0,
                                IF(_setLowFixed * (_secondPrecision > 0), _resolveSecondPrecision,
                                    LET(
                                        _expressedDecimals, MIN(FN.DECIMALS(INDEX(_dhms, 1, 4)), _resolveSecondPrecision),
                                        IF(_secondPrecision = -1, _expressedDecimals,
                                            IF(_expressedDecimals = 0, 0, _resolveSecondPrecision)
                                        )
                                    )
                                )
                            )
                        )
                    ),

                    _dhms1, IF(NOT(_midnightCeiling), _dhms,
                        IF(_displayLowOrder = 1, _dhms,
                            IF(NOT(ARRAYS.ARE_EQUAL(N(DROP(_dhms, ,1)), {0, 0, 0})), _dhms,
                                LET(
                                    _day, INDEX(_dhms, 1, 1) - 1,
                                    HSTACK(_day, 24, DROP(_dhms, , 2))
                                )
                            )
                        )
                    ),

                    _displayCount, _displayLowOrder - _displayHighOrder + 1,
                    VSTACK(
                        HSTACK(_displayCount, _displayHighOrder, _displayLowOrder, _displayDecimals, _resolveSecondPrecision),
                        _dhms1
                    )
                )
            )
        )
    )
);

_TIME_OF_DAY_COMPONENTS_24HR = LAMBDA(_timeOfDay_D, _midnightCeiling, _lowOrder, _lowFixed, _secondPrecision, _roundingOverride,
    // MidnightCeiling:  Display 24:00 to represent midnight next day.
    // LowOrder:         Low order at which to round timespan if LowFixed. Defaults to minutes.
    //                   Otherwise the low order at minimum to display.
    // LowFixed:         Force display to low order, otherwise allow to float from low order as needed.
    // SecondPrecision:   -2: Second defaults to 0 decimals.
    //                    -1: Second expressed up to 9.
    //                   [n]: If low order not fixed then decimals expressed up to which ever is lower of
    //                        given precision or 9. If low order fixed then expressed explicitly
    //                        at the same.
    // RoundingOverride:   0: Default Rounds to nearest second and truncates at low order component.
    //                     1: Nearest Always round to nearest low order component.
    //                    -1: Down    Always round down at low order component.
    //
    // Output: {
    //   DisplayCount, DisplayHighOrder, DisplayLowOrder, DisplayDecimals, ResolvePrecision;
    //   CarryDay,     Hour,             Minute,          Second,          #N/A
    // }

    LET(
        _minLowOrder, 3,
        _defaultLowOrder, 3,
        _autoLowOrder, TRUE,
        _maxPrecision, 9,
        _defaultPrecision, 0,
        
        _TIME_OF_DAY_COMPONENTS(_timeOfDay_D,
            _midnightCeiling, _minLowOrder, _defaultLowOrder, _autoLowOrder, _maxPrecision, _defaultPrecision,
            _lowOrder, _lowFixed, _secondPrecision, _roundingOverride
        )
    )
);

_TIME_OF_DAY_COMPONENTS_CIVIL = LAMBDA(_timeOfDay_D, _lowOrder, _lowFixed, _roundingOverride,
    // LowOrder:          Low order at which to round timespan if LowFixed. Defaults to minutes. 
    //                    Otherwise the low order at minimum to display.
    // LowFixed:          Force display to low order, otherwise allow to float from low order as needed.
    // RoundingOverride:   0: Default Rounds to nearest second and truncates at low order component.
    //                     1: Nearest Always round to nearest low order component.
    //                    -1: Down    Always round down at low order component.
    //
    // Output: {
    //   DisplayCount, DisplayHighOrder, DisplayLowOrder, DisplayDecimals:=0, IsPM;
    //   CarryDay,     Hour,             Minute,          Second,             #N/A
    // }

    LET(
        _midnightCeiling, FALSE,
        _minLowOrder, 3,
        _defaultLowOrder, 3,
        _autoLowOrder, FALSE,
        _defaultPrecision, 0,
        
        _components, _TIME_OF_DAY_COMPONENTS(_timeOfDay_D,
            _midnightCeiling, _minLowOrder, _defaultLowOrder, _autoLowOrder, _defaultPrecision, _defaultPrecision,
            _lowOrder, _lowFixed, _defaultPrecision, _roundingOverride
        ),

        IF(ROWS(_components) = 1, INDEX(_components, 1, 1),
            LET(
                _hour, N(INDEX(_components, 2, 2)),
                _displayLowOrder, INDEX(_components, 1, 3),
                _day, INDEX(_components, 2, 1),
                _hourCivil, IF(_displayLowOrder = 1, "",
                    MOD(_hour - 1, 12) + 1
                ),
                _isPM, MOD(_hour, 24) >= 12,
                VSTACK(
                    HSTACK(TAKE(_components, 1, 4), _isPM),
                    HSTACK(_day, _hourCivil, DROP(_components, 1, 2))
                )
            )
        )
    )
);

_TIME_OF_DAY_COMPONENTS_ISO = LAMBDA(_timeOfDay_D, _midnightCeiling, _lowOrder, _lowFixed, _secondPrecision, _roundingOverride,
    // MidnightCeiling: Display 24:00 to represent midnight next day.
    // LowOrder:        Low order at which to round timespan if LowFixed. Defaults to minutes. 
    //                  Otherwise the low order at minimum to display.
    // LowFixed:        Force display to low order, otherwise allow to float from low order as needed.
    // SecondPrecision: -2 : Second defaults to 0 decimals.
    //                  -1 : Second expressed up to 9.
    //                  [n]: If low order not fixed then decimals expressed up to which ever is lower of
    //                       given precision or 9. If low order fixed then expressed explicitly
    //                       at the same.
    // RoundingOverride:  0: Default Rounds to nearest second and truncates at low order component.
    //                    1: Nearest Always round to nearest low order component.
    //                   -1: Down    Always round down at low order component.
    //
    // Output: {
    //   DisplayCount, DisplayHighOrder, DisplayLowOrder, DisplayDecimals, ResolvePrecision;
    //   CarryDay,     Hour,             Minute,          Second,          #N/A
    // }

    LET(
        _minLowOrder, 2,
        _defaultLowOrder, 3,
        _autoLowOrder, TRUE,
        _maxPrecision, 9,
        _defaultPrecision, 0,
        
        _TIME_OF_DAY_COMPONENTS(_timeOfDay_D,
            _midnightCeiling, _minLowOrder, _defaultLowOrder, _autoLowOrder, _maxPrecision, _defaultPrecision, 
            _lowOrder, _lowFixed, _secondPrecision, _roundingOverride
        )
    )
);

_FORMAT_PROVIDER_TIME_OF_DAY_24HR = LAMBDA(_components, _padding,
    // Format:      0:00:00.000
    // Padding:     Applies to hours.
    //
    // Output: {
    //   LeadFormat, MidFormat,  LastFormat,   #N/A;
    //   "",         HourSuffix, MinuteSuffix, ""
    // }

    IF(ROWS(_components) = 1, INDEX(_components, 1, 1),
        IF(INDEX(_components, 1, 1) = 0, "",
            LET(
                _displayDecimals, INDEX(_components, 1, 4),
                _leadFmt, IF(_padding, "00", "0"),
                _midFmt, "00",
                _lastFmt, IF(_displayDecimals = 0, _midFmt,
                    CONCAT(_midFmt, LEFT(".000000000", _displayDecimals + 1))
                ),
                _formats, HSTACK(_leadFmt, _midFmt, _lastFmt),

                _displayLowOrder, INDEX(_components, 1, 3),
                _delims, SWITCH(_displayLowOrder,
                    3, {"", ":", "", ""},
                    4, {"", ":", ":", ""},
                    {"", "", "", ""}
                ),
                    
                VSTACK(
                    _formats,
                    _delims
                )
            )
        )
    )
);

_FORMAT_PROVIDER_TIME_OF_DAY_CIVIL = LAMBDA(_components, _padding, _AMPMDotted, _AMPMCondense, _AMPMLower,
    // Format:       12:00:00 AM|PM
    // Padding:      Applies to hours.
    // AMPMDotted:   A.M.|P.M.
    // AMPMCondense: No space preceding AM|PM
    // AMPMLower:    Lower case am|pm
    //
    // Output: {
    //   LeadFormat, MidFormat,  LastFormat,   #N/A;
    //   "",         HourSuffix, MinuteSuffix, AM|PM
    // }
    
    IF(ROWS(_components) = 1, INDEX(_components, 1, 1),
        IF(INDEX(_components, 1, 1) = 0, "",
            LET(
                _ampmMatrix, {
                    " AM", "AM", " A.M.", "A.M.";
                    " PM", "PM", " P.M.", "P.M.";
                    " am", "am", " a.m.", "a.m.";
                    " pm", "pm", " p.m.", "p.m."
                },
                _r, 1 + (2 * N(_AMPMLower)),
                _c, 1 + N(_AMPMCondense) + (2 * N(_AMPMDotted)),
                _am, INDEX(_ampmMatrix, _r, _c),
                _pm, INDEX(_ampmMatrix, _r + 1, _c),
            
                _displayLowOrder, INDEX(_components, 1, 3),
                _leadFmt, IF(_padding, "00", "0"),
                _midFmt, "00",
                _lastFmt, IF(_displayLowOrder = 2, _leadFmt, _midFmt),
                _formats, HSTACK(_leadFmt, _midFmt, _lastFmt),

                _ampm, IF(INDEX(_components, 1, 5), _pm, _am),
                _delims, SWITCH(_displayLowOrder,
                    2, HSTACK("", _ampm, "", ""),
                    3, HSTACK("", ":", _ampm, ""),
                    4, HSTACK("", ":", ":", _ampm),
                    {"", "", "", ""}
                ),
                    
                VSTACK(
                    _formats,
                    _delims
                )
            )
        )
    )
);

_FORMAT_PROVIDER_TIME_OF_DAY_ISO = LAMBDA(_components, _basic,
    // Format:      T00:00:00.000
    // Basic:       T000000.000
    //
    // Output: {
    //   LeadFormat, MidFormat,  LastFormat,    #N/A;
    //   "T",        HourSuffix, MinuteSuffix,  ""
    // }

    IF(ROWS(_components) = 1, INDEX(_components, 1, 1),
        IF(INDEX(_components, 1, 1) = 0, "",
            LET(
                _displayDecimals, INDEX(_components, 1, 4),
                _leadFmt, "00",
                _midFmt, "00",
                _lastFmt, IF(_displayDecimals = 0, _midFmt,
                    CONCAT(_midFmt, LEFT(".000000000", _displayDecimals + 1))
                ),
                _formats, HSTACK(_leadFmt, _midFmt, _lastFmt),

                _displayLowOrder, INDEX(_components, 1, 3),
                _delims, IF(_basic, {"T", "", "", ""},
                    SWITCH(_displayLowOrder,
                        2, {"T", "", "", ""},
                        3, {"T", ":", "", ""},
                        4, {"T", ":", ":", ""},
                        {"", "", "", ""}
                    )
                ),

                VSTACK(
                    _formats,
                    _delims
                )
            )
        )
    )
);










/*##############################################################################################################
# TIME ZONE                                                                                                    #
##############################################################################################################*/


/*--------------------------------------------------------------------------------------------------------------
IS_VALID_TZO

Tests if a time zone offset in minutes is within the range -15:00..+15:00

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
----------------------------------------------------------------------------------------------------------------
TZOMinutes | decimal [-900..900] | Time zone offset in minutes.
--------------------------------------------------------------------------------------------------------------*/
IS_VALID_TZO = LAMBDA(TZOMinutes,
    IF(NOT(ISNUMBER(TZOMinutes)), FALSE,
        ABS(TZOMinutes) <= 900
    )
);


/*--------------------------------------------------------------------------------------------------------------
TIMESPAN_TO_TZO

Converts a deimal timespan into time zone offset minutes.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
----------------------------------------------------------------------------------------------------------------
TZOTimeSpan | decimal [-0.625..0.625] |
--------------------------------------------------------------------------------------------------------------*/
TIMESPAN_TO_TZO = LAMBDA(TZOTimeSpan,
    LET(
        _TZOTimeSpan, FN.NULLIFY(TZOTimeSpan),
        IF(ISERROR(_TZOTimeSpan), _TZOTimeSpan * {1},
            IF(_TZOTimeSpan = "", "",
                IF(NOT(ISNUMBER(_TZOTimeSpan)), {#VALUE!},
                    LET(
                        _tzo, _TZOTimeSpan * 1440,
                        IF(CHRONO.IS_VALID_TZO(_tzo), _tzo, {#NUM!})
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
TZO_TO_TIMESPAN

Converts time zone offset minutes into a decimal timespan.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean | Time Zone Offset expressed as a TimeSpan 

Parameters
----------------------------------------------------------------------------------------------------------------
TZOTimeSpan | decimal [-0.625..0.625] |
--------------------------------------------------------------------------------------------------------------*/
TZO_TO_TIMESPAN = LAMBDA(TZOMinutes,
    LET(
        _TZOMinutes, FN.NULLIFY(TZOMinutes),
        IF(ISERROR(_TZOMinutes), _TZOMinutes * {1},
            IF(_TZOMinutes = "", "",
                IF(NOT(ISNUMBER(_TZOMinutes)), {#VALUE!},
                    IF(NOT(CHRONO.IS_VALID_TZO(_TZOMinutes)), {#NUM!},
                        _TZOMinutes / 1440
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_ISO_TZO

Parses an ISO formatted time zone offset into time zone offset minutes.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal [-900..900] | Time zone offset in minutes

Parameters
----------------------------------------------------------------------------------------------------------------
Expression | text | Time zone offset in ISO format ie. ±hh:mm or value in minutes.

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_ISO_TZO("Z")
Returns: 0 i.e. UTC time zone (Zulu)

PARSE_ISO_TZO("−06:00")
Returns: -360

PARSE_ISO_TZO("+16:00")
Returns: #NUM! i.e. range is −15:00 to +15:00
--------------------------------------------------------------------------------------------------------------*/
PARSE_ISO_TZO = LAMBDA(Expression,
    LET(
        fnParseTZO, LAMBDA(_TZO,
            IF(ISERROR(_TZO), _TZO * {1},
                IF(_TZO = "", "",
                    IF(ISNUMBER(_TZO), IF(CHRONO.IS_VALID_TZO(_TZO), _TZO, {#NUM!}),
                        IF(EXACT(_TZO, "Z"), 0,
                            LET(
                                _sChar, LEFT(_TZO),
                                _sign, SWITCH(_sChar,
                                    "+", 1,
                                    "-", -1,
                                    "−", -1, // − UNICHAR(8722)
                                    0
                                ),
                                IF(_sign = 0, {#VALUE!},
                                    LET(
                                        _tz, "T" & RIGHT(_TZO, LEN(_TZO) - 1),
                                        _ISOtimeValue, CHRONO.PARSE_TIME_OF_DAY(_tz, TRUE),
                                        CHRONO.TIMESPAN_TO_TZO(_sign * _ISOtimeValue)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ),

        MAP(FN.NULLIFY(Expression),
            LAMBDA(_element,
                fnParseTZO(_element)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
FORMAT_ISO_TZO

Returns a time zone offset as text in ISO format.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | ISO formatted time zone offset

Parameters
----------------------------------------------------------------------------------------------------------------
TZOMinutes | decimal     | Time zone offset from UTC in minutes.
           | [-900..900] | [-15:00..+15:00]
[Options]  | text        | String with elements: [B][Z][H|M|S]
           |             |       B : Display in basic format eg +0000
           |             |       Z : Display 'Z' for Zulu time zone +00:00
           |             | H, M, S : Force low order component. If omitted auto adjusts to minutes or seconds.
           |             |           Returns an error if H specified and TZOMinutes is not a multiple of 60. 
--------------------------------------------------------------------------------------------------------------*/
FORMAT_ISO_TZO = LAMBDA(TZOMinutes, [Options],
    LET(
        _options, FN.NULLIFY(Options),
        _basic, IFERROR(SEARCH("B", _options), 0) > 0,
        _zulu, IFERROR(SEARCH("Z", _options), 0) > 0,
        _lowOrder, LEFT(FN.SIFT_FOR_CHARS(_options, "HMS")),
        
        _fmt, SWITCH(_lowOrder,
            "", IF(_basic, "Bm0", "Im0"),
            "H", "BH",
            "M", IF(_basic, "BM", "IM"),
            "S", IF(_basic, "BS0", "IS0")
        ),
        
        fnFormatTZO, LAMBDA(_TZOMinutes,
            IF(ISERROR(_TZOMinutes), _TZOMinutes * {1},
                IF(_TZOMinutes = "", "",
                    IF(NOT(ISNUMBER(_TZOMinutes)), {#VALUE!},
                        IF(NOT(CHRONO.IS_VALID_TZO(_TZOMinutes)), {#NUM!},
                            IF((_lowOrder = "H") * (MOD(_TZOMinutes, 60) <> 0), {#NUM!},
                                IF((_TZOMinutes = 0) * _zulu, "Z",
                                    LET(
                                        _signChar, IF(_TZOMinutes >= 0, "+", "−"), // − UNICHAR(8722)
                                        _tod, CHRONO.FORMAT_TIME_OF_DAY(ABS(_TZOMinutes) / 1440, _fmt),
                                        CONCAT(_signChar, RIGHT(_tod, LEN(_tod) - 1))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ),

        MAP(FN.NULLIFY(TZOMinutes),
            LAMBDA(_element,
                fnFormatTZO(_element)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------
MILITARY_TZO

Returns the time zone offset in minutes of a military time zone designator.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------
 1 | decimal     | Time zone offset in minutes
   | [-720..720] | [-12:00..+12:00]

Parameters
----------------------------------------------------------------------------------------------------------
Designator | text | Military time zone designator 
           |      | [ABCDEFGHIJKLMNOPQRSTUVWXYZ]

Examples
----------------------------------------------------------------------------------------------------------
MILITARY_TZO("A")
Returns: 60

FORMAT_MIL_DTG("J")
Returns: #N/A (local time zone)
--------------------------------------------------------------------------------------------------------*/
MILITARY_TZO = LAMBDA(Designator,
    LET(
        _Designator, FN.NULLIFY(Designator),
        IF(ISERROR(_Designator), _Designator * {1},
            IF(_Designator = "", "",
                LET(
                    _code, CODE(_Designator) - 64,
                    IF(_code <= 0, {#VALUE!},
                        IF(_code > 26, {#VALUE!},
                            IF(_code = 10, {#N/A}, // J = Local Time
                                IF(_code = 26, 0, // Z = UTC
                                    IF(_code <= 9, _code * 60, // ABCDEFGHI -> +1..+9
                                        IF(_code <= 13, (_code - 1) * 60,  // KLM -> +10..+12
                                            IF(_code <= 25, (13 - _code) * 60, // NOPQRSTUVWXY -> -1..-12
                                                {#VALUE!}
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------
TZO_TO_MILITARY

Returns the closest military time zone designator, its offset in minutes, and the time shift to that
time zone for the provided time zone offset in minutes.

Array compatible: TZOMinutes as column

Output
----------------------------------------------------------------------------------------------------------
 1 | text            |  Military time zone designator
   |                 | [ABCDEFGHIJKLMNOPQRSTUVWXYZ]
 2 | integer         | Time zone offset in minutes
   | [-720..720]     | [-12:00..+12:00]
 3 | decimal         | Time shift
   | [-0.125..0.125] | [-3:00..+3:00]

Parameters
----------------------------------------------------------------------------------------------------------
[TZOMinutes] | decimal     | Time zone offset from UTC in minutes
             | [-900..900] | Assumed to be UTC if omitted. [-15:00..+15:00]

Examples
----------------------------------------------------------------------------------------------------------
TZO_TO_MILITARY(60)
Returns: {A, 60, 0}

TZO_TO_MILITARY(#N/A)
Returns: {J, ,0} (local time zone)

TZO_TO_MILITARY(570)
Returns: {K, 600, 0.020833}

TZO_TO_MILITARY(840)
Returns: {M, 720, -0.08333}
--------------------------------------------------------------------------------------------------------*/
TZO_TO_MILITARY = LAMBDA(TZOMinutes,
    LET(
        fnTZOMilitary, LAMBDA(_TZO,
            IF(ISNA(_TZO), {"J", "", 0},
                IF(ISERROR(_TZO), _TZO * {1, 2, 3},
                    IF(_TZO = "", {"", "", ""},
                        IF(NOT(ISNUMBER(_TZO)), {#VALUE!, #VALUE!, #VALUE!},
                            IF(NOT(CHRONO.IS_VALID_TZO(_TZO)), {#NUM!, #NUM!, #NUM!},
                                IF(_TZO = 0, HSTACK("Z", 0, 0),
                                    IF(_TZO > 720, HSTACK("M", 720, (720 - _TZO) / 1440),
                                        IF(_TZO < -720, HSTACK("Y", -720, (-720 - _TZO) / 1440),
                                            LET(
                                                _militaryTZO, SIGN(_TZO) * MROUND(ABS(_TZO), 60),
                                                _idx, INT(_militaryTZO / 60) + 13,
                                                _militaryTZ, INDEX({"Y", "X", "W", "V", "U", "T", "S", "R", "Q", "P", "O", "N", "Z", "A", "B", "C", "D", "E", "F", "G", "H", "I", "K", "L", "M"}, 1, _idx),
                                                HSTACK(_militaryTZ, _militaryTZO, (_TZO - _militaryTZO) / 1440)
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ),

        _TZOMinutes, FN.NULLIFY(INDEX(TZOMinutes, , 1)),
        _rowCount, ROWS(_TZOMinutes),
        _byRow, REDUCE("", SEQUENCE(_rowCount),
            LAMBDA(_acc, _curr,
                VSTACK(
                    _acc,
                    fnTZOMilitary(INDEX(_TZOMinutes, _curr, 1))
                )
            )
        ),
        DROP(_byRow, 1)
    )
);


/*--------------------------------------------------------------------------------------------------------
SHIFT_TIMEZONE

Translates a Modified Julian Date from one time zone to another. If a time zone is omitted it is assumed
to be UTC.

Array compatible: MJDate

Output
----------------------------------------------------------------------------------------------------------
 1 | decimal | MJDate

Parameters
----------------------------------------------------------------------------------------------------------
MJDate                | decimal     | Modified Julian Date
[ReferenceTZOMinutes] | decimal     | Time zone offset referenced by the MJDate
                      | [-900..900] | Assumed to be UTC if omitted. [-15:00..+15:00]
[TranslateTZOMinutes] | decimal     | Time zone offset to translate the MJDate to.
                      | [-900..900] | Assumed to be UTC if omitted. [-15:00..+15:00]
--------------------------------------------------------------------------------------------------------*/
SHIFT_TIMEZONE = LAMBDA(MJDate, [ReferenceTZOMinutes], [TranslateTZOMinutes],
    LET(
        _MJDate, FN.NULLIFY(MJDate),
        IF(ISERROR(_MJDate), _MJDate * {1},
            IF(_MJDate = "", "",
                IF(NOT(ISNUMBER(_MJDate)), {#VALUE!},
                    LET(
                        _referenceTZ, N(ReferenceTZOMinutes),
                        _translateTZ, N(TranslateTZOMinutes),
                        _difference, (_translateTZ - _referenceTZ) / 1440,
                        _MJDate + _difference
                    )
                )
            )
        )
    )
);







/*##############################################################################################################
# YEAR                                                                                                         #
##############################################################################################################*/


/*--------------------------------------------------------------------------------------------------------------
YEAR_BCE_TO_CE

Converts to year value relative to the Common Era for a given year Before Common Era.
This function is symmetrical, so it can also be used for CE to BCE conversion.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | 1 BCE = 0, 2 BCE = -1

Parameters
----------------------------------------------------------------------------------------------------------------
Year  | integer | Where 1 is first year Before Common Era
--------------------------------------------------------------------------------------------------------------*/
YEAR_BCE_TO_CE = LAMBDA(Year,
    LET(
        _year, FN.NULLIFY(Year),
        IF(ISERROR(_year), _year * {1},
            IF(_year = "", "",
                IF(NOT(ISNUMBER(_year)), {#VALUE!},
                    IF(NOT(FN.IS_INTEGER(_year)), {#NUM!},
                        1 - _year
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
IS_LEAP_YEAR

Tests if a year includes a leap day in the given calendar.

Array compatible: YearCE only

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean | null if empty

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE           | decimal | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
IS_LEAP_YEAR = LAMBDA(YearCE, [JulianCalendar],
    LET(
        _gregorian, FN.COERCE(JulianCalendar) = 0,
        
        fnIsLeapYear, LAMBDA(_yearCE,
            IF(ISERROR(_yearCE), _yearCE * {1},
                IF(_yearCE = "", "",
                    IF(NOT(ISNUMBER(_yearCE)), {#VALUE!},
                        LET(
                            _iYear, INT(_yearCE),
                            IF(_gregorian,
                                IF(MOD(_iYear, 400) = 0, TRUE,
                                    IF(MOD(_iYear, 100) = 0, FALSE,
                                        MOD(_iYear, 4) = 0
                                    )
                                ),
                                MOD(_iYear, 4) = 0
                            )
                        )
                    )
                )
            )
        ),

        MAP(FN.NULLIFY(YearCE),
            LAMBDA(_element,
                fnIsLeapYear(_element)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
DAYS_IN_YEAR

Returns number of days in the given year of the specified calendar.

Array compatible: YearCE only

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [365,366]

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE           | integer | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian proleptic
                 |         | calendar.
--------------------------------------------------------------------------------------------------------------*/
DAYS_IN_YEAR = LAMBDA(YearCE, [JulianCalendar],
    LET(
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,
        
        MAP(FN.NULLIFY(YearCE),
            LAMBDA(_element,
                IF(ISERROR(_element), _element * {1},
                    IF(_element = "", "",
                        IF(CHRONO.IS_LEAP_YEAR(_element, _julianCalendar), 366, 365)
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_ISO_YEAR

Returns a number representing the year relative to the common era from a text representation of year in ISO8601 format.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | YearCE. Note that 1 BC = 0 CE, 2 BC = -1 CE

Parameters
----------------------------------------------------------------------------------------------------------------
Expression | text | ISO year
--------------------------------------------------------------------------------------------------------------*/
PARSE_ISO_YEAR = LAMBDA(Expression,
    LET(
        fnParseISOYear, LAMBDA(_sYear,
            IF(ISERROR(_sYear), _sYear * {1},
                IF(_sYear = "", "",
                    IF(FN.IS_INTEGER(_sYear), _sYear,
                        // non-integer
                        IF(ISNUMBER(_sYear), {#NUM!},
                            LET(
                                _sChar, LEFT(_sYear),
                                _sign, SWITCH(_sChar,
                                    "+", 1,
                                    "-", -1,
                                    "−", -1, // − UNICHAR(8722)
                                    #N/A
                                ),
                                _nominalYear, IF(ISNA(_sign),
                                    VALUE(_sYear),
                                    _sign * VALUE(RIGHT(_sYear, LEN(_sYear) - 1))
                                ),
                                IF(ISERROR(_nominalYear), {#VALUE!},
                                    IF(NOT(FN.IS_INTEGER(_nominalYear)), {#NUM!},
                                        _nominalYear
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ),

        MAP(FN.NULLIFY(Expression),
            LAMBDA(_element,
                fnParseISOYear(_element)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
FORMAT_ISO_YEAR

Returns a year formatted in ISO8601 style.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | ISO 8601 year

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE       | integer | Note that 1 BC = 0 CE, 2 BC = -1 CE
[AlwaysSign] | switch  | Always display sign, zero signed with +.
--------------------------------------------------------------------------------------------------------------*/
FORMAT_ISO_YEAR = LAMBDA(YearCE, [AlwaysSign],
    LET(
        _alwaysSign, FN.COERCE(AlwaysSign),
        
        fnFormatISOYear, LAMBDA(_year,
            IF(ISERROR(_year), _year * {1},
                IF(_year = "", "",
                    IF(NOT(ISNUMBER(_year)), {#VALUE!},
                        IF(NOT(FN.IS_INTEGER(_year)), {#NUM!},
                            LET(
                                _yearFmt, IF(_alwaysSign, "+0000;−0000;+0000;", // − UNICHAR(8722)      
                                    IF((_year >= 0) * (_year <= 9999), "0000;−0000", // − UNICHAR(8722)      
                                        "+0000;−0000" // − UNICHAR(8722)
                                    )
                                ),
                                TEXT(_year, _yearFmt)
                            )
                        )
                    )
                )
            )
        ),

        MAP(FN.NULLIFY(YearCE),
            LAMBDA(_element,
                fnFormatISOYear(_element)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_LITERARY_YEAR

Returns a number representing the year relative to the common era from a given literary year.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | YearCE. Note that 1 BC = 0 CE, 2 BC = -1 CE

Parameters
----------------------------------------------------------------------------------------------------------------
Expression | text | Literary year
--------------------------------------------------------------------------------------------------------------*/
PARSE_LITERARY_YEAR = LAMBDA(Expression,
    LET(
        _validCharSet, "0123456789ABCDEabcde .-+−", // − UNICHAR(8722)
        
        fnYearValue, LAMBDA(_sYear,
            LET(
                _sChar, LEFT(_sYear),
                _sign, SWITCH(_sChar,
                    "+", 1,
                    "-", -1,
                    "−", -1, // − UNICHAR(8722)
                    ""
                ), 
                IF(_sign = "",
                    INT(VALUE(_sYear)),
                    _sign * INT(VALUE(RIGHT(_sYear, LEN(_sYear) -1)))
                )
            )
        ),

        fnParseLiteraryYear, LAMBDA(_expr,
            IF(ISERROR(_expr), _expr * {1},
                IF(_expr = "", "",
                    IF(ISNUMBER(_expr), IF(FN.IS_INTEGER(_expr), _expr, {#NUM!}),
                        IF(NOT(FN.VALIDATE_CHARSET(_expr, _validCharSet)), {#VALUE!},
                            LET(
                                _litYear, FN.REPLACE_CHARS(_expr, ", ", ""),
                                IF(RIGHT(_litYear, 3) = "BCE",
                                    LET(
                                        _sYear, LEFT(_litYear, LEN(_litYear) - 3),
                                        1 - fnYearValue(_sYear)
                                    ),
                                    IF((RIGHT(_litYear, 2) = "CE") + (RIGHT(_litYear, 2) = "AD"),
                                        LET(
                                            _sYear, LEFT(_litYear, LEN(_litYear) - 2),
                                            fnYearValue(_sYear)
                                        ),
                                        IF(RIGHT(_litYear, 2) = "BC",
                                            LET(
                                                _sYear, LEFT(_litYear, LEN(_litYear) - 2),
                                                1 - fnYearValue(_sYear)
                                            ),
                                            IF(RIGHT(_litYear, 6) = "B.C.E.",
                                                LET(
                                                    _sYear, LEFT(_litYear, LEN(_litYear) - 6),
                                                    1 - fnYearValue(_sYear)
                                                ),
                                                IF((RIGHT(_litYear, 4) = "C.E.") + (RIGHT(_litYear, 2) = "A.D."),
                                                    LET(
                                                        _sYear, LEFT(_litYear, LEN(_litYear) - 4),
                                                        fnYearValue(_sYear)
                                                    ),
                                                    IF(RIGHT(_litYear, 4) = "B.C.",
                                                        LET(
                                                            _sYear, LEFT(_litYear, LEN(_litYear) - 4),
                                                            1 - fnYearValue(_sYear)
                                                        ),
                                                        fnYearValue(_litYear)
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ),

        MAP(FN.NULLIFY(Expression),
            LAMBDA(_element,
                fnParseLiteraryYear(_element)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
FORMAT_LITERARY_YEAR

Returns a year formatted in literary style.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | Literary year

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE          | integer | Note that 1 BC = 0 CE, 2 BC = -1 CE
[Options]       | text    | [E][J][K][T]
                |         |   E : Always display BCE|CE era. Otherwise only years less than 1000 display an era.
                |         |   J : Dotted style B.C.E.|C.E.
                |         |   K : No space preceding era.
                |         |   T : Use traditional era notation AD|BC instead of secular BCE|CE.
--------------------------------------------------------------------------------------------------------------*/
FORMAT_LITERARY_YEAR = LAMBDA(YearCE, [Options],
    LET(
        _options, IF(ISOMITTED(Options), "", Options),
        _alwaysShowEra, IFERROR(SEARCH("E", _options), 0) > 0,
        _dotted, IFERROR(SEARCH("J", _options), 0) > 0,
        _noSpace, IFERROR(SEARCH("K", _options), 0) > 0,
        _traditional, IFERROR(SEARCH("T", _options), 0) > 0,
        _eraMatrix, {
            " CE", "CE", " C.E.", "C.E.";
            " BCE", "BCE", " B.C.E.", "B.C.E.";
            " AD", "AD", " A.D.", "A.D.";
            " BC", "BC", " B.C.", "B.C."
        },
        _r, 1 + (2 * N(_traditional)),
        _c, 1 + N(_noSpace) + (2 * N(_dotted)),
        _CE, INDEX(_eraMatrix, _r, _c),
        _BCE, INDEX(_eraMatrix, _r + 1, _c),
        
        fnFormatLiteraryYear, LAMBDA(_yearCE,
            IF(ISERROR(_yearCE), _yearCE * {1},
                IF(_yearCE = "", "",
                    IF(NOT(ISNUMBER(_yearCE)), {#VALUE!},
                        IF(NOT(FN.IS_INTEGER(_yearCE)), {#NUM!},
                            LET(
                                _isCE, _yearCE >= 1,
                                _year, IF(_isCE, _yearCE, 1 - _yearCE),
                                _suffix, IF(NOT(_isCE), _BCE,
                                    IF(_yearCE < 1000, _CE,
                                        IF(_alwaysShowEra, _CE, "")
                                    )
                                ),
                                TEXT(_year, "0") & _suffix
                            )
                        )
                    )
                )
            )
        ),

        MAP(FN.NULLIFY(YearCE),
            LAMBDA(_element,
                fnFormatLiteraryYear(_element)
            )
        )
    )
);







/*##############################################################################################################
# MONTH                                                                                                        #
##############################################################################################################*/


/*--------------------------------------------------------------------------------------------------------------
PARSE_MONTH

Returns a number representing the month of year from a text expression.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [1..12] | Month

Parameters
----------------------------------------------------------------------------------------------------------------
Expression     | text | Month name
[LanguageCode] | text | Language. If omitted then local language set in Excel.

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_MONTH("Feb")
Returns: 2

PARSE_MONTH("January")
Returns: 1

PARSE_MONTH("J")
Returns: #VALUE!

PARSE_MONTH("Marzo")
Returns: 3 (if local language is set to Italian)

PARSE_MONTH(4)
Returns: 4
--------------------------------------------------------------------------------------------------------------*/
PARSE_MONTH = LAMBDA(Expression, [LanguageCode],
    LET(
        _languageID, FN.LANGUAGE_ID(FN.NULLIFY(LanguageCode)),

        fnParseMonthFromText, LAMBDA(_text,
            IF(_languageID = "",
                MONTH(DATEVALUE(CONCAT(_text, " 2000"))),
                LET(
                    _longMonthList, CHRONO.MONTH_NAME(SEQUENCE(12), FALSE, _languageID),
                    _lMonth, IFNA(XMATCH(_text, _longMonthList, 0), 0),
                    IF(_lMonth > 0, _lMonth,
                        LET(
                            _shortMonthList, CHRONO.MONTH_NAME(SEQUENCE(12), TRUE, _languageID),
                            _sMonth, IFNA(XMATCH(_text, _shortMonthList, 0), 0),
                            IF(_sMonth > 0, _sMonth, {#VALUE!})
                        )
                    )
                )
            )
        ),

        fnParseMonth, LAMBDA(_expr,
            IF(ISERROR(_expr), _expr * {1},
                IF(_expr = "", "",
                    // discard time values
                    IF(IFERROR(FIND(":", _expr), 0) > 0, {#VALUE!},
                        LET(
                            _numericVal, VALUE(_expr),
                            IF(ISERROR(_numericVal), fnParseMonthFromText(_expr),
                                IF(NOT(FN.IS_INTEGER(_numericVal)), {#NUM!},
                                    IF((_numericVal >= 1) * (_numericVal <= 12), _numericVal, {#NUM!})
                                )
                            )
                        )
                    )
                )
            )
        ),

        MAP(FN.NULLIFY(Expression),
            LAMBDA(_element,
                fnParseMonth(_element)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
MONTH_NAME

Returns a month as text.

Array compatible: Month only

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | Month name

Parameters
----------------------------------------------------------------------------------------------------------------
Month          | integer [1..12] | Month. For values outside of range modulus is taken.
[Short]        | switch          | Return short format Jan..Dec
[LanguageCode] | text            | Language. If omitted then local language set in Excel.
--------------------------------------------------------------------------------------------------------------*/
MONTH_NAME = LAMBDA(Month, [Short], [LanguageCode],
    LET(
        _useShort, FN.COERCE(Short),
        _languageID, FN.LANGUAGE_ID(FN.NULLIFY(LanguageCode)),
        _fmt, IF(_useShort, "MMM", "MMMM"),
        _iFmt, IF(_languageID = "", _fmt,
            "[$-" & _languageID & "]" & _fmt
        ),
        
        fnMonthName, LAMBDA(_m,
            IF(ISERROR(_m), _m * {1},
                IF(_m = "", "",
                    IF(NOT(ISNUMBER(_m)), {#VALUE!},
                        LET(
                            _month, MOD(INT(_m) - 1, 12) + 1,
                            _dayOfMonth, DATE(2000, _month, 1),
                            TEXT(_dayOfMonth, _iFmt)
                        )
                    )
                )
            )
        ),

        MAP(FN.NULLIFY(Month),
            LAMBDA(_element,
                fnMonthName(_element)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
DAYS_IN_MONTH

Returns number of days in the given month and year of the specified calendar.

Array compatible: Month, YearCE as columns

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [1..31]

Parameters
----------------------------------------------------------------------------------------------------------------
Month            | integer [1..12] | Month of year
[YearCE]         | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
DAYS_IN_MONTH = LAMBDA(Month, [YearCE], [JulianCalendar],
    LET(
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,
        _month, FN.NULLIFY(Month),
        _year, FN.NULLIFY(YearCE),
        
        _rowCount, ROWS(Month),
        BYROW(SEQUENCE(_rowCount),
            LAMBDA(_row,
                LET(
                    _m, INDEX(_month, _row, 1),
                    IF(ISERROR(_m), _m * {1},
                        IF(_m = "", "",
                            IF(NOT(ISNUMBER(_m)), {#VALUE!},
                                IF(NOT(FN.IS_INTEGER(_m)), {#NUM!},
                                    IF((_m < 1) + (_m > 12), {#NUM!},
                                        // February
                                        IF(_m= 2,
                                            LET(
                                                _y, IFERROR(INDEX(_year, _row, 1), ""),
                                                _leapDay, IF(ISNUMBER(_y), N(CHRONO.IS_LEAP_YEAR(_y, _julianCalendar)), 0),
                                                28 + _leapDay
                                            ),
                                            // Jan, Mar, Apr, May, Jun, Jul
                                            IF(_m <= 7,
                                                30 + MOD(_m, 2),
                                                // Aug, Sep, Oct, Nov, Dec
                                                31 - MOD(_m, 2)
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);







/*##############################################################################################################
# WEEKDAY                                                                                                      #
##############################################################################################################*/


/*--------------------------------------------------------------------------------------------------------------
CONVERT_WEEKDAY_NUMBER

Returns an integer for the day of the week from the traditonal numbering scheme to the ISO definition, or
vice versa.

Array compatible: DayOfWeek

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Weekday number
   | [1..7]  |    | ISO       | Traditioal
   |         | ---------------------------
   |         |  1 | Monday    | Sunday 
   |         |  2 | Tuesday   | Monday 
   |         |  3 | Wednesday | Tuesday
   |         |  4 | Thursday  | Wednesday
   |         |  5 | Friday    | Thursday
   |         |  6 | Saturday  | Friday
   |         |  7 | Sunday    | Saturday

Parameters
----------------------------------------------------------------------------------------------------------------
DayOfWeek          | integer [1..7] | Day of week number
[ISOtoTraditional] | switch         | Return day of week using traditional numbering scheme, assuming 
                   |                | DayOfWeek was provided according to ISO definition.
                   |                | Default is to return in ISO definition, assuming DayOfWeek was
                   |                | provided according to the traditional numbering scheme.
--------------------------------------------------------------------------------------------------------------*/
CONVERT_WEEKDAY_NUMBER = LAMBDA(DayOfWeek, [ISOtoTraditional],
    LET(
        _ISOSoffset, IF(FN.COERCE(ISOtoTraditional), 0, -2),

        fnWeekday, LAMBDA(_dayOfWeek,
            IF(ISERROR(_dayOfWeek), _dayOfWeek * {1},
                IF(_dayOfWeek = "", "",
                    IF(NOT(ISNUMBER(_dayOfWeek)), {#VALUE!},
                        LET(
                            _givenDoW, INT(N(_dayOfWeek)),
                            _shiftDoW, _givenDow + _ISOSoffset,
                            MOD(_shiftDow, 7) + 1
                        )
                    )
                )
            )
        ),

        MAP(FN.NULLIFY(DayOfWeek),
            LAMBDA(_element,
                fnWeekday(_element)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_WEEKDAY

Returns a number representing the day of the week from a given text weekday name.

Array compatible: Expression

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | ISO Weekday number
   | [1..7]  |  1 : Monday
   |         |  2 : Tuesday
   |         |  3 : Wednesday
   |         |  4 : Thursday
   |         |  5 : Friday
   |         |  6 : Saturday
   |         |  7 : Sunday

Parameters
----------------------------------------------------------------------------------------------------------------
weekdayText    | text | Day of week name
[LanguageCode] | text | Language. If omitted then local language set in Excel.

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_WEEKDAY("Saturday")
Returns: 6

PARSE_WEEKDAY("Thurs")
Returns: #VALUE!

PARSE_WEEKDAY("Ven", "IT")
Returns: 5 (Friday in Italian)
--------------------------------------------------------------------------------------------------------------*/
PARSE_WEEKDAY = LAMBDA(Expression, [LanguageCode],
    LET(
        _languageID, FN.LANGUAGE_ID(FN.NULLIFY(LanguageCode)),

        fnParseWeekdayFromText, LAMBDA(_text,
            LET(
                _longWeekdayList, CHRONO.WEEKDAY_NAME(SEQUENCE(7), FALSE, _languageID),
                _lWeekday, IFNA(XMATCH(_text, _longWeekdayList, 0), 0),
                IF(_lWeekday > 0, _lWeekday,
                    LET(
                        _shortWeekdayList, CHRONO.WEEKDAY_NAME(SEQUENCE(7), TRUE, _languageID),
                        _sWeekday, IFNA(XMATCH(_text, _shortWeekdayList, 0), 0),
                        IF(_sWeekday > 0, _sWeekday, {#VALUE!})
                    )
                )
            )
        ),
        
        fnParseWeekday, LAMBDA(_expr,
            IF(ISERROR(_expr), _expr * {1},
                IF(_expr = "", "",
                    // discard time values
                    IF(IFERROR(FIND(":", _expr), 0) > 0, {#VALUE!},
                        LET(
                            _numericVal, INT(VALUE(_expr)),
                            IF(ISNUMBER(_numericVal),
                                IF((_numericVal >= 1) * (_numericVal <= 7), _numericVal, {#NUM!}),
                                LET(
                                    _ISOWeekday, fnParseWeekdayFromText(_expr),
                                    IF(ISNUMBER(_ISOWeekday), _ISOWeekday, {#VALUE!})
                                )
                            )
                        )
                    )
                )
            )
        ),

        MAP(FN.NULLIFY(Expression),
            LAMBDA(_element,
                fnParseWeekday(_element)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
WEEKDAY_NAME

Returns name of an ISO day of week number as text.

Array compatible: ISOWeekday

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | Weekday

Parameters
----------------------------------------------------------------------------------------------------------------
ISOWeekday     | integer [1..7] | ISO day of week number
[Short]        | switch         | Return short format Mon..Sun
[LanguageCode] | text           | Language. If omitted then local language set in Excel.
--------------------------------------------------------------------------------------------------------------*/
WEEKDAY_NAME = LAMBDA(ISOWeekday, [Short], [LanguageCode],
    LET(
        _useShort, FN.COERCE(Short),
        _languageID, FN.LANGUAGE_ID(FN.NULLIFY(LanguageCode)),
        _fmt, IF(_useShort, "ddd", "dddd"),
        _iFmt, IF(_languageID = "", _fmt,
            "[$-" & _languageID & "]" & _fmt
        ),
        
        fnWeekDayName, LAMBDA(_wd,
            IF(ISERROR(_wd), _wd * {1},
                IF(_wd = "", "",
                    IF(NOT(ISNUMBER(_wd)), {#VALUE!},
                        LET(
                            _isoDoW, MOD(INT(_wd) - 1, 7) + 1,
                            _y2krefDay, 36527 + _isoDoW,
                            TEXT(_y2krefDay, _iFmt)
                        )
                    )
                )
            )
        ),

        MAP(FN.NULLIFY(ISOWeekday),
            LAMBDA(_element,
                fnWeekDayName(_element)
            )
        )
    )
);






/*##############################################################################################################
# CALENDAR DATE                                                                                                #
##############################################################################################################*/


/*--------------------------------------------------------------------------------------------------------------
VALIDATE_CALENDAR_DATE

Validate a year, month and day representation of a date in a given calendar.

Array compatible: Date_YMD as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer         | YearCE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YMD         | array   C[1..3] |
   YearCE        | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE. Can be empty.
   [Month]       | integer [1..12] | Month of year. Can be empty.
   [Day]         | decimal [0..32) | Day. Can be empty.
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
VALIDATE_CALENDAR_DATE = LAMBDA(Date_YMD, [JulianCalendar],
    LET(
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,
        
        fnValidateDate, LAMBDA(_date_YMD,
            IF(COLUMNS(_date_YMD) > 3, {#REF!, #REF!, #REF!},
                LET(
                    _YMD, EXPAND(_date_YMD, 1, 3, ""),
                    IF(ARRAYS.IS_EMPTY(_YMD), {"", "", ""},
                        LET(
                            _y, INDEX(_YMD, 1, 1),
                            _m, INDEX(_YMD, 1, 2),
                            _d, INDEX(_YMD, 1, 3),
                        
                            _year, IF(ISERROR(_y), _y * {1},
                                IF(_y = "", "",
                                    IF(NOT(ISNUMBER(_y)), {#VALUE!},
                                        IF(FN.IS_INTEGER(_y), _y, {#NUM!})
                                    )
                                )
                            ),

                            _day, IF(ISERROR(_d), _d * {1},
                                IF(_d = "", "",
                                    IF(NOT(ISNUMBER(_d)), {#VALUE!},
                                        LET(
                                            _iDay, INT(_d),
                                            IF(_iDay < 1, {#NUM!},
                                                IF(ISNUMBER(_m),
                                                    LET(
                                                        _maxDaysInMonth, IF(ISNUMBER(_year),
                                                            CHRONO.DAYS_IN_MONTH(INT(_m), _year, _julianCalendar),
                                                            CHRONO.DAYS_IN_MONTH(INT(_m), 2000, _julianCalendar)
                                                        ),
                                                        IF(_iDay <= _maxDaysInMonth, _iDay, {#NUM!})
                                                    ),
                                                    IF(_iDay <= 31, _iDay, {#NUM!})
                                                )
                                            )
                                        )
                                    )
                                )
                            ),
                            
                            _month, IF(ISERROR(_m), _m * {1},
                                IF(_m = "",
                                    IF(FN.IS_EMPTY(_day), "",
                                        IF(FN.IS_EMPTY(_year), "", {#VALUE!})
                                    ),
                                    IF(NOT(ISNUMBER(_m)), {#VALUE!},
                                        IF(NOT(FN.IS_INTEGER(_m)), {#NUM!},
                                            IF((_m >= 1) * (_m <= 12), _m, {#NUM!})
                                        )
                                    )
                                )
                            ),

                            HSTACK(_year, _month, _day)
                        )
                    )
                )
            )
        ),

        _date_YMD, FN.NULLIFY(Date_YMD),
        _rowCount, ROWS(_date_YMD),
        _byRow, REDUCE("", SEQUENCE(_rowCount),
            LAMBDA(_acc, _curr,
                VSTACK(
                    _acc,
                    fnValidateDate(INDEX(_date_YMD, _curr,))
                )
            )
        ),
        DROP(_byRow, 1)
    )
);


/*--------------------------------------------------------------------------------------------------------------
IS_VALID_CALENDAR_DATE

Tests if a year, month, and day representation of a date is valid for the specified calendar.

Array compatible: Date_YMD as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YMD         | array   C[1..3] |
   YearCE        | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE. Can be empty.
   [Month]       | integer [1..12] | Month of year. Can be empty.
   [Day]         | decimal [0..32) | Day. Can be empty.
[AllowPartial]   | switch          | Accept partially expressed date. Default tests for a fully expressed date.
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
IS_VALID_CALENDAR_DATE = LAMBDA(Date_YMD, [AllowPartial], [JulianCalendar],
    LET(
        _allowPartial, FN.COERCE(AllowPartial) <> 0,
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,
        
        _date_YMD, FN.NULLIFY(Date_YMD),
        BYROW(_date_YMD,
            LAMBDA(_row,
                LET(
                    _validateDate, CHRONO.VALIDATE_CALENDAR_DATE(_row, _julianCalendar),
                    IF(ARRAYS.IS_EMPTY(_validateDate), FALSE,
                        IF(_allowPartial,
                            NOT(ARRAYS.HAS_ERROR(_validateDate)),
                            ARRAYS.IS_NUMERIC(_validateDate)
                        )
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
RESOLVE_CALENDAR_DATE

Resolves the date where month and day values may exceed their valid range.

Array compatible: Date_YMD as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day of month

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YMD         | array   C[1..3]  |
   YearCE        | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
   [Month]       | integer          | Month of year. Can be empty.
   [Day]         | decimal          | Day. Can be empty.
[JulianCalendar] | switch           | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                  | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
RESOLVE_CALENDAR_DATE = LAMBDA(Date_YMD, [JulianCalendar],
    LET(
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,
       
        fnResolveDate, LAMBDA(_date_YMD,
            IF(COLUMNS(_date_YMD) > 3, {#REF!, #REF!, #REF!},
                IF(ARRAYS.IS_EMPTY(_date_YMD), {"", "", ""},
                    LET(
                        _YMD, EXPAND(_date_YMD, 1, 3, ""),
                        _y, INDEX(_YMD, 1, 1),
                        _m, INDEX(_YMD, 1, 2),
                        _d, INDEX(_YMD, 1, 3),
                        
                        _year, IF(ISERROR(_y), _y,
                            IF(FN.IS_INTEGER(_y), _y,
                                IF(ISNUMBER(_y), {#NUM!}, {#VALUE!})
                            )
                        ),

                        _month, IF(ISERROR(_m), _m,
                            IF(_m = "", 1,
                                IF(FN.IS_INTEGER(_m), _m, 
                                    IF(ISNUMBER(_m), {#NUM!}, {#VALUE!})
                                )
                            )
                        ),

                        _day, IF(ISERROR(_d), _d,
                            IF(_d = "", 1,
                                IF(ISNUMBER(_d), INT(_d), {#VALUE!})
                            )
                        ),
                        
                        IF(ISERROR(_year), _year * {1, 2, 3},
                            IF(ISERROR(_month), _month * {1, 2, 3},
                                IF(ISERROR(_day), _day * {1, 2, 3},
                                    LET(
                                        _resolveYear, _year + INT((_month - 1) / 12),
                                        _resolveMonth, MOD((_month - 1), 12) + 1,
                                        _daysInMonth, CHRONO.DAYS_IN_MONTH(_resolveMonth, _resolveYear, _julianCalendar),
                                        _validDay, (_day >= 1) * (_day <= _daysInMonth),
                                        IF(_validDay, HSTACK(_resolveYear, _resolveMonth, _day),
                                            LET(
                                                _MJD1, CHRONO.MJDN(HSTACK(_resolveYear, _resolveMonth, 1), _julianCalendar),
                                                _resolveMJD, _MJD1 - 1 + _day,
                                                CHRONO.MJDN_TO_CALENDAR_DATE(_resolveMJD, _julianCalendar)
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ),
        
        _date_YMD, FN.NULLIFY(Date_YMD),
        _rowCount, ROWS(_date_YMD),
        _byRow, REDUCE("", SEQUENCE(_rowCount),
            LAMBDA(_acc, _curr,
                VSTACK(
                    _acc,
                    fnResolveDate(INDEX(_date_YMD, _curr, ))
                )
            )
        ),
        DROP(_byRow, 1)
    )
);


/*--------------------------------------------------------------------------------------------------------------
GREGORIAN_TO_JULIAN

Translates a date in the Gregorian proleptic calendar to the Julian proleptic calendar.

Array compatible: Date_YMD as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YMD         | array   C[2..3]  |
   YearCE        | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
   [Month]       | integer [1..12]  | Month of year. Can be empty.
   [Day]         | decimal [0..367) | Day. Ordinal day of year if month empty. Can be empty.
--------------------------------------------------------------------------------------------------------------*/
GREGORIAN_TO_JULIAN = LAMBDA(Date_YMD,
    LET(
        _JDN, CHRONO.JDN(Date_YMD, 0),
        CHRONO.JDN_TO_CALENDAR_DATE(_JDN, 1)
    )
);


/*--------------------------------------------------------------------------------------------------------------
JULIAN_TO_GREGORIAN

Translates a date in the Julian proleptic calendar to the Gregorian proleptic calendar.

Array compatible: Date_YMD as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YMD         | array   C[2..3]  |
   YearCE        | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
   [Month]       | integer [1..12]  | Month of year. Can be empty.
   [Day]         | decimal [0..367) | Day. Ordinal day of year if month empty. Can be empty.
--------------------------------------------------------------------------------------------------------------*/
JULIAN_TO_GREGORIAN = LAMBDA(Date_YMD,
    LET(
        _JDN, CHRONO.JDN(Date_YMD, 1),
        CHRONO.JDN_TO_CALENDAR_DATE(_JDN, 0)
    )
);


/*--------------------------------------------------------------------------------------------------------------
SECULAR_DIFFERENCE

Returns the number of days the Gregorian proleptic calendar is ahead of the Julian proleptic calendar for
a given date.

Array compatible: Date_YMD as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Days difference. Negative values are when the Julian proleptic calender is ahead.

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YMD             | array   C[1..3]  |
   YearCE            | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
   [Month]           | integer [1..12]  | Month of year. Can be empty.
   [Day]             | decimal [0..367) | Day. Ordinal day of year if month empty. Can be empty.
[FromJulianCalendar] | switch           | Provided date is in Julian calendar.
                     |                  | Default is the Gregorian calendar.
--------------------------------------------------------------------------------------------------------------*/
SECULAR_DIFFERENCE = LAMBDA(Date_YMD, [FromJulianCalendar],
    LET(
        _fromJulianCalendar, FN.COERCE(FromJulianCalendar) <> 0,
        
        fnFromGregorian, LAMBDA(_date_YMD,
            LET(
                _JDN_G, CHRONO.JDN(_date_YMD, 0),
                IF(ISERROR(_JDN_G), _JDN_G * {1},
                    IF(_JDN_G = "", "",
                        LET(
                            _year, INDEX(_date_YMD, 1, 1),
                            _month, IFERROR(INDEX(_date_YMD, 1, 2), 1),
                            _day, IFERROR(INDEX(_date_YMD, 1, 3), 1),
                            _JDN_J, IF((_month = 2) * (_day = 29) * NOT(CHRONO.IS_LEAP_YEAR(_year, 1)),
                                CHRONO.JDN(HSTACK(_year, 2, 28), 1),
                                CHRONO.JDN(_date_YMD, 1)
                            ),
                            _JDN_J - _JDN_G
                        )
                    )
                )
            )
        ),
        
        fnFromJulian, LAMBDA(_date_YMD,
            LET(
                _date_G, CHRONO.JULIAN_TO_GREGORIAN(_date_YMD),
                IF(ISERROR(INDEX(_date_G, 1, 1)), INDEX(_date_G, 1, 1) * {1},
                    IF(INDEX(_date_G, 1, 1) = "", "",
                        fnFromGregorian(_date_G)
                    )
                )
            )
        ),

        IF(_fromJulianCalendar,
            BYROW(Date_YMD,
                LAMBDA(_row, fnFromJulian(_row))
            ),
            BYROW(Date_YMD,
                LAMBDA(_row, fnFromGregorian(_row))
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_ISO_CALENDAR_DATE

Parses an ISO formatted calendar date into respective parts of year, month and day.

Array compatible: Expression as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | YearCE
 2 | integer | Month
 3 | integer | Day

Parameters
----------------------------------------------------------------------------------------------------------------
Expression       | text   | Date in ISO format ie. yyyy-MM-dd
[JulianCalendar] | switch | Validate in the Julian proleptic calendar. Default is Gregorian
                 |        | proleptic calendar.

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_ISO_CALENDAR_DATE("2023-05-23")
Returns: {2023, 5, 23}

PARSE_ISO_CALENDAR_DATE("1900-02-29", 1)
Returns: {2023, 2, 29} i.e. Feb 29, 1900 is valid in the Julian calendar
--------------------------------------------------------------------------------------------------------------*/
PARSE_ISO_CALENDAR_DATE = LAMBDA(Expression, [JulianCalendar],
    LET(
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,
        _validCharSet, "0123456789-+−", // − UNICHAR(8722)
        _valErr, {#VALUE!, #VALUE!, #VALUE!},

        fnParseISOCalendarDate, LAMBDA(_expr,
            IF(ISERROR(_expr), _expr * {1, 2, 3},
                IF(_expr = "", {"", "", ""},
                    IF(NOT(FN.VALIDATE_CHARSET(_expr, _validCharSet)), _valErr,
                        LET(
                            _firstChar, LEFT(_expr),
                            _isSigned, SWITCH(_firstChar,
                                "+", TRUE,
                                "-", TRUE,
                                "−", TRUE, // − UNICHAR(8722)
                                FALSE
                            ), 
                            _sign, IF(NOT(_isSigned), 1,
                                SWITCH(_firstChar,
                                    "-", -1,
                                    "−", -1, // − UNICHAR(8722)
                                    1
                                )
                            ),
                            _unSigned, IF(_isSigned,
                                RIGHT(_expr, LEN(_expr) - 1),
                                _expr
                            ),
                            _len, LEN(_unSigned),
                            _pattern, FN.REPLACE_CHARS(_unSigned, "0123456789", "_"),
                            
                            fnTryParse10, LAMBDA(
                                IF(_pattern = RIGHT("_______________-__-__", _len),
                                    HSTACK(
                                        _sign * VALUE(LEFT(_unSigned, _len - 6)),
                                        VALUE(MID(_unSigned, _len - 4, 2)),
                                        VALUE(RIGHT(_unSigned, 2))
                                    ),
                                    IF(_pattern = RIGHT("_______________-__", _len),
                                        HSTACK(
                                            _sign * VALUE(LEFT(_unSigned, _len - 3)),
                                            VALUE(RIGHT(_unSigned, 2)),
                                            ""
                                        ),
                                        IF(_pattern = RIGHT("___________________", _len),
                                            HSTACK(
                                                _sign * VALUE(LEFT(_unSigned, _len - 4)),
                                                VALUE(MID(_unSigned, _len - 3, 2)),
                                                VALUE(RIGHT(_unSigned, 2))
                                            ),
                                            _valErr
                                        )
                                    )
                                )
                            ),

                            fnTryParse8, LAMBDA(
                                IF(_pattern = RIGHT("______-__", _len),
                                    HSTACK(
                                        _sign * VALUE(LEFT(_unSigned, _len - 3)),
                                        VALUE(RIGHT(_unSigned, 2)),
                                        ""
                                    ),
                                    IF(_pattern = RIGHT("_________", _len),
                                        HSTACK(
                                            _sign * VALUE(LEFT(_unSigned, _len - 4)),
                                            VALUE(MID(_unSigned, _len - 3, 2)),
                                            VALUE(RIGHT(_unSigned, 2))
                                        ),
                                        _valErr
                                    )
                                )
                            ),

                            fnTryParse7, LAMBDA(
                                IF(_pattern = "____-__",
                                    HSTACK(
                                        _sign * VALUE(LEFT(_unSigned, 4)),
                                        VALUE(RIGHT(_unSigned, 2)),
                                        ""
                                    ),
                                    _valErr
                                )
                            ),

                            fnTryParse4, LAMBDA(
                                IF(_pattern = RIGHT("_____", _len),
                                    HSTACK(
                                        _sign * VALUE(_unSigned),
                                        "",
                                        ""
                                    ),
                                    _valErr
                                )
                            ),

                            _tryParse, IF(_len >= 10, fnTryParse10(),
                                IF(_len >= 8, fnTryParse8(),
                                    IF(_len = 7, fnTryParse7(),
                                        IF((_len = 5) + (_len = 4), fnTryParse4(),
                                            _valErr
                                        )
                                    )
                                )
                            ),
                            IF(ISERROR(INDEX(_tryParse, 1, 1)), _tryParse,
                                CHRONO.VALIDATE_CALENDAR_DATE(_tryParse, _julianCalendar)
                            )
                        )
                    )
                )
            )
        ),

        _expression, FN.NULLIFY(INDEX(Expression, , 1)),
        _rowCount, ROWS(_expression),
        _byRow, REDUCE("", SEQUENCE(_rowCount),
            LAMBDA(_acc, _curr,
                VSTACK(
                    _acc,
                    fnParseISOCalendarDate(INDEX(_expression, _curr, 1))
                )
            )
        ),
        DROP(_byRow, 1)
    )
);


/*--------------------------------------------------------------------------------------------------------------
FORMAT_ISO_CALENDAR_DATE

Returns a calendar date as text in ISO format.

Array compatible: Date_YMD as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | ISO formatted date

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YMDT        | array   C[1..4]  |
   YearCE        | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
   [Month]       | integer [1..12]  | Month of year. Can be empty.
   [Day]         | decimal [0..32)  | Day. Can be empty.
   [TimeOfDay]   | decimal          | Time of day. Optional and is ignored.
[Options]        | text             | [B][+]
                 |                  |   B : Display in basic ISO style.
                 |                  |   + : Display positive sign for non-negative years.
[JulianCalendar] | switch           | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                  | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
FORMAT_ISO_CALENDAR_DATE = LAMBDA(Date_YMDT, [Options], [JulianCalendar],
    LET(
        _options, FN.NULLIFY(Options),
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,
        _basic, IFERROR(SEARCH("B", _options), 0) > 0,
        _alwaysSign, IFERROR(FIND("+", _options), 0) > 0, 
        _separator, IF(_basic, "", "-"),
        
        fnFormatISOCalendarDate, LAMBDA(_date_YMD,
            IF(ARRAYS.IS_EMPTY(_date_YMD), "",
                LET(
                    _validateDate, CHRONO.VALIDATE_CALENDAR_DATE(_date_YMD, _julianCalendar),
                    _firstError, ARRAYS.H_ERROR(_validateDate),
                    IF(ISERROR(_firstError), _firstError * {1},
                        IF(_basic * (ABS(INDEX(_validateDate, 1, 1)) > 9999), {#VALUE!},
                            LET(
                                _sYear, CHRONO.FORMAT_ISO_YEAR(INDEX(_validateDate, 1, 1), _alwaysSign), 
                                IF(INDEX(_validateDate, 1, 2) = "",
                                    IF(INDEX(_validateDate, 1, 3) = "",
                                        _sYear,
                                        {#VALUE!}
                                    ),
                                    LET(
                                        _sMonth, TEXT(INDEX(_validateDate, 1, 2), "00"),
                                        IF(INDEX(_validateDate, 1, 3) = "",
                                            IF(_basic, {#VALUE!},
                                                CONCAT(_sYear, _separator, _sMonth)
                                            ),
                                            CONCAT(_sYear, _separator, _sMonth, _separator, TEXT(INDEX(_validateDate, 1, 3), "00"))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ),

        _date_YMDT, FN.NULLIFY(Date_YMDT),
        BYROW(_date_YMDT,
            LAMBDA(_row,
                fnFormatISOCalendarDate(_row)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_CALENDAR_DATE

Parses a text representation of a calendar date into respective parts of year, month and day.

Array compatible: Expression as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day

Parameters
----------------------------------------------------------------------------------------------------------------
Expression            | text   | Calendar date
[NorthAmericanRegion] | switch | TRUE assume order in North American format mm/dd/yyyy 
                      |        | FALSE assume order in internationl format dd/mm/yyyy 
                      |        | If omitted then defaults to local regional settings of Excel
[JulianCalendar]      | switch | Calculate for the Julian proleptic calendar. Default is Gregorian
                      |        | proleptic calendar. 

Example
----------------------------------------------------------------------------------------------------------------
PARSE_CALENDAR_DATE("25/01/2014")
Returns: {2014, 1, 25}
--------------------------------------------------------------------------------------------------------------*/
PARSE_CALENDAR_DATE = LAMBDA(Expression, [NorthAmericanRegion], [JulianCalendar], 
    LET(
        _northAmericanRegion, IF(ISOMITTED(NorthAmericanRegion), FN.NORTH_AMERICAN_REGION(),
            FN.COERCE(NorthAmericanRegion) <> 0
        ),
         
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,
        
        _expression, FN.NULLIFY(INDEX(Expression, , 1)),
        _rowCount, ROWS(_expression),
        _byRow, REDUCE("", SEQUENCE(_rowCount),
            LAMBDA(_acc, _curr,
                LET(
                    _parts, _PARSE_DATE_PARTS(INDEX(_expression, _curr, 1)),
                    _YMD, IF(_northAmericanRegion, CHOOSECOLS(_parts, {1, 3, 2}), _parts),
                    _validateYMD, CHRONO.VALIDATE_CALENDAR_DATE(_YMD, _julianCalendar),
                    VSTACK(_acc, _validateYMD)
                )
            )
        ),
        DROP(_byRow, 1)
    )
);

_PARSE_DATE_PARTS = LAMBDA(_expression,
    LET(
        _validCharSet, "+−0123456789-./", // − UNICHAR(8722)

        fnYearValue, LAMBDA(_sYear, _knownMinus,
            LET(
                _sChar, LEFT(_sYear),
                _hasSign, SWITCH(_sChar,
                    "+", TRUE,
                    "−", TRUE, // − UNICHAR(8722)
                    FALSE
                ), 
                _sign, IF(_knownMinus, -1,
                    IF(_hasSign,
                        SWITCH(_sChar,
                            "+", 1,
                            "−", -1, // − UNICHAR(8722)
                            1
                        ),
                        1
                    )
                ),
                _absYearVal, IF(_hasSign,
                    VALUE(RIGHT(_sYear, LEN(_sYear) - 1)),
                    VALUE(_sYear)
                ),
                _sign * _absYearVal
            )
        ),

        IF(ISERROR(_expression), _expression * {1, 2, 3},
            IF(ISNUMBER(_expression), {#VALUE!, #VALUE!, #VALUE!},
                LET(
                    _trimExpr, TRIM(_expression),
                    IF(_trimExpr = "", {"", "", ""},
                        IF(NOT(FN.VALIDATE_CHARSET(_trimExpr, _validCharSet)), {#VALUE!, #VALUE!, #VALUE!},
                            LET(
                                _dateSplit, FN.SPLIT_AROUND(_trimExpr, "+−0123456789", FALSE, 4), // − UNICHAR(8722)
                                _splitCount, INDEX(_dateSplit, 1, 1),
                                _separators, INDEX(_dateSplit, 1, 2),
                                _parseError, IF(_splitCount <> 3, TRUE,
                                    SWITCH(_separators,
                                        "//", FALSE,
                                        "--", FALSE,
                                        "..", FALSE,
                                        "//-", FALSE,
                                        "---", FALSE,
                                        "..-", FALSE,
                                        TRUE
                                    )
                                ),
                                IF(_parseError, {#VALUE!, #VALUE!, #VALUE!},
                                    LET(
                                        _knownMinus, (LEN(_separators) = 3) * (RIGHT(_separators) = "-"),
                                        _y, fnYearValue(INDEX(_dateSplit, 1, 5), _knownMinus),
                                        _ab, VALUE(CHOOSECOLS(_dateSplit, {4, 3})),
                                        HSTACK(_y, _ab)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
FORMAT_CALENDAR_DATE

Returns a calendar date as text in the short modern style.

Array compatible: Date_YMD as columns

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | Calendar date

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YMDT        | array   C[3]    |
   YearCE        | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
   Month         | integer [1..12] | Month of year.
   Day           | decimal [0..32) | Day. Any decimal part is ignored.
[Options]        | text            | [.|-][+][P][U|V]
                 |                 |   .|- : Separator. Defaults to /
                 |                 |     + : Display positive sign for non-negative years.
                 |                 |     P : Pad months and days with leading zero.
                 |                 |  U, V : U to order in international format dd/mm/yyyy
                 |                 |         V to order in North American format mm/dd/yyyy
                 |                 |         Defaults to local regional settings of Excel.
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
FORMAT_CALENDAR_DATE = LAMBDA(Date_YMD, [Options], [JulianCalendar],
    LET(
        _options, FN.NULLIFY(Options),
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,
        _separator, LET(
            _sepOption, LEFT(FN.SIFT_FOR_CHARS(_options, ".-")),
            SWITCH(_sepOption, "", "/", _sepOption)
        ),
        _alwaysSign, IFERROR(FIND("+", _options), 0) > 0,
        _internationalOrder, IF(IFERROR(SEARCH("U", _options), 0) > 0, TRUE,
            IF(IFERROR(SEARCH("V", _options), 0) > 0, FALSE,
                NOT(FN.NORTH_AMERICAN_REGION())
            )
        ),
        _mdFmt, IF(IFERROR(SEARCH("P", _options), 0) > 0, "00", "0"),

        fnFormatDate, LAMBDA(_date_YMD,
            LET(
                _validateDate, CHRONO.VALIDATE_CALENDAR_DATE(_date_YMD, _julianCalendar),
                IF(ARRAYS.IS_EMPTY(_validateDate), "",
                    LET(
                        _firstError, ARRAYS.H_ERROR(_validateDate),
                        IF(ISERROR(_firstError), _firstError * {1},
                            IF(ARRAYS.HAS_EMPTY(_validateDate), {#VALUE!},
                                LET(
                                    _sYear, CHRONO.FORMAT_ISO_YEAR(INDEX(_validateDate, 1, 1), _alwaysSign),
                                    _sMonth, TEXT(INDEX(_validateDate, 1, 2), _mdFmt),
                                    _sDay, TEXT(INDEX(_validateDate, 1, 3), _mdFmt),
                                    IF(_internationalOrder,
                                        CONCAT(_sDay, _separator, _sMonth, _separator, _sYear),
                                        CONCAT(_sMonth, _separator, _sDay, _separator, _sYear)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ),
        
        _date_YMD, FN.NULLIFY(Date_YMD),
        _rowCount, ROWS(_date_YMD),
        _byRow, REDUCE("", SEQUENCE(_rowCount),
            LAMBDA(_acc, _curr,
                VSTACK(
                    _acc,
                    fnFormatDate(INDEX(_date_YMD, _curr, ))
                )
            )
        ),
        DROP(_byRow, 1)
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_LITERARY_DATE

Parses a literary date into respective parts of year, month, day and weekday.

Array compatible: Expression as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day
 4 | integer [1..7]  | Weekday

Parameters
----------------------------------------------------------------------------------------------------------------
Expression       | text   | Literary date
[LanguageCode]   | text   | Language. If omitted then local language set in Excel.
[JulianCalendar] | switch | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |        | proleptic calendar. 

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_LITERARY_DATE("Feb 25, 2014")
Returns: {2014, 2, 25, ""}

PARSE_LITERARY_DATE("Sun Dec 31, 2023")
Returns: {2023, 12, 31, 7}

PARSE_LITERARY_DATE("Mon Feb 25th")
Returns: {"", 2, 25, 1}

PARSE_LITERARY_DATE("Feb 2000")
Returns: {2000, 2, "", ""}
--------------------------------------------------------------------------------------------------------------*/
PARSE_LITERARY_DATE = LAMBDA(Expression, [LanguageCode], [JulianCalendar],
    LET(
        _YMDWT, CHRONO.PARSE_LITERARY_DATETIME(Expression, LanguageCode, JulianCalendar),
        TAKE(_YMDWT, 1, 4)
    )
);


/*--------------------------------------------------------------------------------------------------------------
FORMAT_LITERARY_DATE

Returns a calendar date as text in the literary style.

Array compatible: Date_YMDW as columns

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | Literary date

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YMDTW       | array   C[1..4] |
   [YearCE]      | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
   [Month]       | integer [1..12] | 
   [Day]         | integer [0..31] | 
   [Weekday]     | integer [1..7]  | Applicable if any of year, month or day are omitted.
[Options]        | text            | [W][R][G][E][T][J][K]
                 |                 |   W : Display weekday.
                 |                 |   R : Display short-form month and weekday.
                 |                 |   G : No comma separators.
                 |                 |   E : Always apply era suffix. If not used, only years less than 1000
                 |                 |       show an era.
                 |                 |   T : Use traditional era notation AD|BC instead of secular BCE|CE.
                 |                 |   J : Dotted monikers B.C.E|C.E.|A.D.|B.C.
                 |                 |   K : No space preceding monikers BCE|CE|AD|BC.
[LanguageCode]   | text            | Language. If omitted then local language set in Excel.
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.

Examples
----------------------------------------------------------------------------------------------------------------
FORMAT_LITERARY_DATE({2014, 2, 25}, "WRGETJK")
Returns: "Tue Feb 25th 2014AD"

FORMAT_LITERARY_DATE({"", 12, 31})
Returns: "December 31st"

FORMAT_LITERARY_DATE({2000, 3}, "")
Returns: "March, 2000"
--------------------------------------------------------------------------------------------------------------*/
FORMAT_LITERARY_DATE = LAMBDA(Date_YMDW, [Options], [LanguageCode], [JulianCalendar],
    LET(
        _options, FN.NULLIFY(Options),
        _languageID, FN.LANGUAGE_ID(FN.NULLIFY(LanguageCode)),
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,
        
        _showWeekday, IFERROR(SEARCH("W", _options), 0) > 0,
        _short, IFERROR(SEARCH("R", _options), 0) > 0,
        _separator, IF(IFERROR(SEARCH("G", _options), 0), " ", ", "),
        _yearOptions, FN.SIFT_FOR_CHARS(_options, "ETJK"),

        fnValidateYMD, LAMBDA(_YMD,
            LET(
                _firstError, ARRAYS.H_ERROR(_YMD),
                IF(ISERROR(_firstError), _firstError * {1},
                    IF(NOT(ARRAYS.IS_NUMERIC_NULL(_YMD)), {#VALUE!},
                        IF(ARRAYS.HAS_DECIMAL(TAKE(_YMD, 1, 2)), {#NUM!},
                            LET(
                                _month, INDEX(_YMD, 1, 2),
                                _day, INDEX(_YMD, 1, 3),
                                _validDate, IF((_month = "") * (_day >= 1) * (_day <= 31), TRUE,
                                    CHRONO.IS_VALID_CALENDAR_DATE(_YMD, TRUE, _julianCalendar)
                                ),
                                IF(_validDate, TRUE, {#NUM!})
                            )
                        )
                    )
                )
            )
        ),

        fnWeekday, LAMBDA(_YMD, _DoW,
            LET(
                _validateDoW, IF(ISERROR(_DoW), _DoW * {1},
                    IF(_DoW = "", "",
                        IF(NOT(ISNUMBER(_DoW)), {#VALUE!},
                            LET(
                                _iDoW, INT(_DoW),
                                IF((_iDoW >= 1) * (_iDoW <= 7), _iDoW, {#NUM!})
                            )
                        )
                    )
                ),
                
                _resolveDoW, IF(ISERROR(_validateDoW), _validateDoW * {1},
                    IF(ARRAYS.HAS_EMPTY(_YMD), _validateDoW,
                        LET(
                            _MJDN, CHRONO.MJDN(_YMD, _julianCalendar),
                            _calcDoW, CHRONO.MJDN_TO_WEEKDAY(_MJDN),
                            IF(ISNUMBER(_validateDoW),
                                IF(_calcDoW = _validateDoW, _calcDoW, {#NUM!}),
                                _calcDoW
                            )
                        )
                    )
                ),

                CHRONO.WEEKDAY_NAME(_resolveDoW, _short, _languageID)
            )
        ),
        
        fnDatePart, LAMBDA(_validatedYMDTW,
            LET(
                _YMD, TAKE(_validatedYMDTW, 1 , 3),
                IF(ARRAYS.IS_EMPTY(_YMD), "",
                    LET(
                        _sYear, CHRONO.FORMAT_LITERARY_YEAR(INDEX(_YMD, 1, 1), _yearOptions),
                        _sMonth, CHRONO.MONTH_NAME(INDEX(_YMD, 1, 2), _short, _languageID),
                        _sDay, FN.FORMAT_ORDINAL(INDEX(_YMD, 1, 3)),
                        _sMonthDay, TEXTJOIN(" ", TRUE, _sMonth, _sDay),
                        TEXTJOIN(_separator, TRUE, _sMonthDay, _sYear)
                    )
                )
            )
        ),
        
        fnFormatLiteraryDate, LAMBDA(_date_YMDW,
            IF(COLUMNS(_date_YMDW) > 4, {#REF!},
                LET(
                    _expandYMDW, EXPAND(_date_YMDW, 1, 4, ""),
                    _YMD, TAKE(_expandYMDW, 1, 3),
                    _W, INDEX(_expandYMDW, 1, 4),
                    _isValidYMD, fnValidateYMD(_YMD),
                    IF(ISERROR(_isValidYMD), _isValidYMD * {1},
                        LET(
                            _sDate, fnDatePart(_YMD),
                            IF(NOT(_showWeekday), _sDate, 
                                LET(
                                    _sWeekday, fnWeekday(_YMD, _W),
                                    TEXTJOIN(_separator, TRUE, _sWeekday, _sDate)
                                )
                            )
                        )
                    )
                )
            )
        ),
        
        BYROW(FN.NULLIFY(Date_YMDW),
            LAMBDA(_row,
                fnFormatLiteraryDate(_row)
            )
        )
    )
);








/*##############################################################################################################
# JULIAN DATES                                                                                                 #
##############################################################################################################*/


_JULIAN_DAY_NUMBER = LAMBDA(_yearCE, _month, _day, _julianCalendar,
    LET(
        _YEAR4801BCE, -4800,
        _G4801BCE_JD, -32045,
        _J4801BCE_JD, -32083,
        _DaysIn5MonthsFromMarch, 153,
        _iMonth, INT(_month),
        _MarchShiftYear, INT((14 - _iMonth) / 12),
        _years, INT(_yearCE) - _YEAR4801BCE - _MarchShiftYear,
        _MarchShiftMonth, _iMonth + (12 * _MarchShiftYear) - 3,
        _days, 365 * _years + INT(_years / 4) + INT((_DaysIn5MonthsFromMarch * _MarchShiftMonth + 2) / 5) + INT(_day),
        _days + IF(_julianCalendar,
            _J4801BCE_JD,
            _G4801BCE_JD - INT(_years / 100) + INT(_years / 400)
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
JDN

Returns the Julian Day Number (JDN) of the provided date in the specified calendar.
Note the Julian Day Number is an integer type and is an ordinal day number referenced from January 1,
4713 BC in the proleptic Julian calendar. It does not include any value for time of day.
If month and day are empty then returns JDN for January 1st of the year.

Array compatible: Date_YMD as columns

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Julian Day Number

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YMD         | array   C[1..3] |
   YearCE        | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
   [Month]       | integer [1..12] | Month of year. Can be empty.
   [Day]         | decimal [0..32) | Day. Can be empty.
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
JDN = LAMBDA(Date_YMD, [JulianCalendar],
    LET(
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,

        fnResolveJDN, LAMBDA(_date_YMD,
            IF(ARRAYS.IS_EMPTY(_date_YMD), "",
                LET(
                    _validateDate, CHRONO.VALIDATE_CALENDAR_DATE(_date_YMD, _julianCalendar),
                    _firstError, ARRAYS.H_ERROR(_validateDate),
                    IF(ISERROR(_firstError), _firstError * {1},
                        LET(
                            _y, INDEX(_validateDate, 1, 1),
                            _m, INDEX(_validateDate, 1, 2),
                            _d, INDEX(_validateDate, 1, 3),
                            IF(_m = "",
                                LET(
                                    _JDN_JAN0, _JULIAN_DAY_NUMBER(_y, 1, 0, _julianCalendar),
                                    _JDN_JAN0 + IF(_d = "", 1, _d)
                                ),
                                IF(_d = "", 
                                    _JULIAN_DAY_NUMBER(_y, _m, 1, _julianCalendar),
                                    _JULIAN_DAY_NUMBER(_y, _m, _d, _julianCalendar)
                                )
                            )
                        )
                    )
                )
            )
        ),
                        
        BYROW(FN.NULLIFY(Date_YMD),
            LAMBDA(_row,
                fnResolveJDN(_row)
            )
        )
    )
);




/*--------------------------------------------------------------------------------------------------------------
MJDN

Returns the Modified Julian Day Number (MJDN) of the provided date in the specified calendar.
Note the Modified Julian Day Number is an integer type and is an ordinal day number referenced from November 17,
1858 in the proleptic Gregorian calendar. It does not include any value for time of day.
If month and day are empty then returns MJDN for January 1st of the year.

Array compatible: Date_YMD as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Modified Julian Day Number

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YMD         | array   C[1..3] |
   YearCE        | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
   [Month]       | integer [1..12] | Month of year. Can be empty.
   [Day]         | decimal [0..32) | Day. Can be empty.
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
MJDN = LAMBDA(Date_YMD, [JulianCalendar],
    CHRONO.JDN_TO_MJDN(
        CHRONO.JDN(Date_YMD, JulianCalendar)
    )
);


/*--------------------------------------------------------------------------------------------------------------
JDN_TO_MJDN

Converts a Julian Day Number (JDN) to a Modified Julian Day Number (MJDN).

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Modified Julian Day Number

Parameters
----------------------------------------------------------------------------------------------------------------
JDN | integer | Julian Day Number
--------------------------------------------------------------------------------------------------------------*/
JDN_TO_MJDN = LAMBDA(JDN,
    LET(
        _JDN, FN.NULLIFY(JDN),
        IF(ISERROR(_JDN), _JDN * {1},
            IF(_JDN = "", "",
                INT(_JDN + 0.5) - 2400001
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
MJDN_TO_JDN

Converts a Modified Julian Day Number (MJDN) to a Julian Day Number (JDN).

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Julian Day Number

Parameters
----------------------------------------------------------------------------------------------------------------
MJDN | integer | Modified Julian Day Number
--------------------------------------------------------------------------------------------------------------*/
MJDN_TO_JDN = LAMBDA(MJDN,
    LET(
        _MJDN, FN.NULLIFY(MJDN),
        IF(ISERROR(_MJDN), _MJDN * {1},
            IF(_MJDN = "", "",
                INT(_MJDN) + 2400001
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
JDN_TO_CALENDAR_DATE

Converts a Julian Day Number to a date in the specified calendar.

Array compatible: JDN as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day of month

Parameters
----------------------------------------------------------------------------------------------------------------
JDN              | integer | Julian Day Number
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
JDN_TO_CALENDAR_DATE = LAMBDA(JDN, [JulianCalendar],
    LET(
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,

        fnJDNtoCalendarDate, LAMBDA(_JDN,
            IF(ISERROR(_JDN), _JDN * {1, 2, 3},
                IF(_JDN = "", {"", "", ""},
                    IF(NOT(ISNUMBER(_JDN)), {#VALUE!, #VALUE!, #VALUE!},
                        LET(
                            _YEAR4801BCE, -4800,
                            _DaysIn4Year, 1461,
                            _DaysInYear, 365,
                            _MonthCorrectionDays, 308,
                            _DaysIn4Months, 122,
                            _DaysIn5MonthsFromMarch, 153,
                            IF(_julianCalendar,
                                LET(
                                    _J4801BCE_JD0, -32083,
                                    _days0, INT(_JDN) - _J4801BCE_JD0 - 1,
                                    _quadYr, INT(_days0 / _DaysIn4Year),
                                    _days1, _days0 - _quadYr * _DaysIn4Year,
                                    _remYr, INT((INT(_days1 / _DaysInYear) + 1) * 0.75),
                                    _days2, _days1 - _remYr * _DaysInYear,
                                    _y, _quadYr * 4 + _remYr,
                                    _m, INT((_days2 * 5 + _MonthCorrectionDays) / _DaysIn5MonthsFromMarch) - 2,
                                    _day, _days2 - INT((_m + 4) * _DaysIn5MonthsFromMarch / 5) +
                                        _DaysIn4Months + 1,
                                    _year, _YEAR4801BCE + _y + INT((_m + 2) / 12),
                                    _month, MOD(_m + 2, 12) + 1,
                                    HSTACK(_year, _month, _day)
                                ),
                                LET(
                                    _G4801BCE_JD0, -32045,
                                    _GregDaysIn400Year, 146097,
                                    _GregDaysIn100Year, 36524,
                                    _days0, INT(_JDN) - _G4801BCE_JD0 - 1,
                                    _quadCent, INT(_days0 / _GregDaysIn400Year),
                                    _days1, _days0 - _quadCent * _GregDaysIn400Year,
                                    _remCent, INT((INT(_days1 / _GregDaysIn100Year) + 1) * 0.75),
                                    _days2, _days1 - _remCent * _GregDaysIn100Year,
                                    _quadYr, INT(_days2 / _DaysIn4Year),
                                    _days3, _days2 - _quadYr * _DaysIn4Year,
                                    _remYr, INT((INT(_days3 / _DaysInYear) + 1) * 0.75),
                                    _days4, _days3 - _remYr * _DaysInYear,
                                    _y, _quadCent * 400 + _remCent * 100 + _quadYr * 4 + _remYr,
                                    _m, INT((_days4 * 5 + _MonthCorrectionDays) / _DaysIn5MonthsFromMarch) - 2,
                                    _day, _days4 - INT((_m + 4) * _DaysIn5MonthsFromMarch / 5) +
                                        _DaysIn4Months + 1,
                                    _year, _YEAR4801BCE + _y + INT((_m + 2) / 12),
                                    _month, MOD(_m + 2, 12) + 1,
                                    HSTACK(_year, _month, _day)
                                )
                            )
                        )
                    )
                )
            )
        ),

        _JDNcolumn, FN.NULLIFY(INDEX(JDN, , 1)),
        _rowCount, ROWS(_JDNcolumn),
        _byRow, REDUCE("", SEQUENCE(_rowCount),
            LAMBDA(_acc, _curr,
                VSTACK(
                    _acc,
                    fnJDNtoCalendarDate(INDEX(_JDNcolumn, _curr, 1))
                )
            )
        ),
        DROP(_byRow, 1)
    )
);


/*--------------------------------------------------------------------------------------------------------------
MJDN_TO_CALENDAR_DATE

Converts a Modified Julian Day Number (MJDN) to a date in the specified calendar.

Array compatible: MJDN as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day of month

Parameters
----------------------------------------------------------------------------------------------------------------
MJDN             | integer | Modified Julian Day Number
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
MJDN_TO_CALENDAR_DATE = LAMBDA(MJDN, [JulianCalendar],
    LET(
        _JDN, CHRONO.MJDN_TO_JDN(MJDN),
        CHRONO.JDN_TO_CALENDAR_DATE(_JDN, JulianCalendar)
    )
);


/*--------------------------------------------------------------------------------------------------------------
JDN_TO_WEEKDAY

Returns the ISO weekday number for a given Julian Day Number (JDN).

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [1..7] | ISO weekday number
   |                | Monday..Sunday

Parameters
----------------------------------------------------------------------------------------------------------------
JDN | integer | Julian Day Number. Fractional numbers will be trunctated.
--------------------------------------------------------------------------------------------------------------*/
JDN_TO_WEEKDAY = LAMBDA(JDN,
    LET(
        _MJDN, CHRONO.JDN_TO_MJDN(JDN),
        CHRONO.MJDN_TO_WEEKDAY(_MJDN)
    )
);


/*--------------------------------------------------------------------------------------------------------------
MJDN_TO_WEEKDAY

Returns the ISO weekday number for a given Modified Julian Day Number (MJDN).

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [1..7] | ISO weekday number
   |                | Monday..Sunday

Parameters
----------------------------------------------------------------------------------------------------------------
MJDN | integer | Modified Julian Day Number. Fractional numbers will be trunctated.
--------------------------------------------------------------------------------------------------------------*/
MJDN_TO_WEEKDAY = LAMBDA(MJDN,
    LET(
        fnISOWeekday, LAMBDA(_MJDN,
            IF(ISERROR(_MJDN), _MJDN * {1},
                IF(_MJDN = "", "",
                    IF(NOT(ISNUMBER(_MJDN)), {#VALUE!},
                        LET(
                            _iMJDN, INT(_MJDN),
                            MOD(_iMJDN + 2, 7) + 1
                        )
                    )
                )
            )
        ),

        MAP(FN.NULLIFY(MJDN),
            LAMBDA(_element,
                fnISOWeekday(_element)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
JULIAN_DATE

Returns the Julian Date of the provided date and time of day in the specified calendar.
Note that the decimal time component of Julian Date is based from midday.

Array compatible: Date_YMDT as columns

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Julian Date

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YMDT        | array   C[1..4]  |
   YearCE        | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
   [Month]       | integer [1..12]  | Month of year. Can be empty.
   [Day]         | decimal [0..367) | Day. Can be empty.
   [Time]        | decimal [0..1)   | Time of day. If omitted then decimal part of day is taken.
[JulianCalendar] | switch           | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                  | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
JULIAN_DATE = LAMBDA(Date_YMDT, [JulianCalendar],
    LET(
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,
        
        fnJulianDate, LAMBDA(_date_YMDT,
            LET(
                _MJDate, CHRONO.MODIFIED_JULIAN_DATE(_date_YMDT),
                CHRONO.MJDATE_TO_JDATE(_MJDate)
            )
        ),
        
        BYROW(FN.NULLIFY(Date_YMDT),
            LAMBDA(_dateRow,
                fnJulianDate(_dateRow)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
MODIFIED_JULIAN_DATE

Returns the Modified Julian Date of the provided date and time of day in the specified calendar.
Note that the time component of Modified Julian Date is based from midnight.

Array compatible: Date_YMDT as columns

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Modified Julian Date

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YMDT        | array   C[1..4]  |
   YearCE        | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
   [Month]       | integer [1..12]  | Month of year. Can be empty.
   [Day]         | decimal [0..32)  | Day. Can be empty. If time is provided, any decimal part is ignored.
   [Time]        | decimal [0..1)   | Time of day. If omitted then decimal part of day is taken.
[JulianCalendar] | switch           | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                  | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
MODIFIED_JULIAN_DATE = LAMBDA(Date_YMDT, [JulianCalendar],
    LET(
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,
        
        fnModifiedJulianDate, LAMBDA(_date_YMDT,
            IF(COLUMNS(_date_YMDT) > 4, {#REF!},
                IF(ARRAYS.IS_EMPTY(_date_YMDT), "",
                    LET(
                        _firstError, ARRAYS.H_ERROR(_date_YMDT),
                        IF(ISERROR(_firstError), _firstError * {1},
                            IF(NOT(ARRAYS.IS_NUMERIC_NULL(_date_YMDT)), {#VALUE!},
                                LET(
                                    _expandYMDT, EXPAND(_date_YMDT, 1, 4, ""),
                                    _DT, CHRONO.RESOLVE_DT(DROP(_expandYMDT, , 2)),
                                    _resolveYMD, LET(
                                        _y, CHOOSECOLS(_expandYMDT, 1),
                                        _m, IF(FN.IS_EMPTY(CHOOSECOLS(_expandYMDT, 2)), 1, 
                                            CHOOSECOLS(_expandYMDT, 2)
                                        ),
                                        _d, CHOOSECOLS(_DT, 1),
                                        HSTACK(_y, _m, _d)
                                    ),
                                    _MJDN, CHRONO.MJDN(_resolveYMD, _julianCalendar),
                                    IF(ISERROR(_MJDN), _MJDN * {1},
                                        LET(
                                            _time, CHOOSECOLS(_DT, 2),
                                            _MJDN + N(_time)
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ),
        
        BYROW(FN.NULLIFY(Date_YMDT),
            LAMBDA(_dateRow,
                fnModifiedJulianDate(_dateRow)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
JDATE_TO_MJDATE

Converts a Julian Date (JDATE) to a Modified Julian Date (MJDATE).
Note that the decimal time component of MJDATE is based from midnight.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Modified Julian Date

Parameters
----------------------------------------------------------------------------------------------------------------
JDate | decimal | Julian Date
--------------------------------------------------------------------------------------------------------------*/
JDATE_TO_MJDATE = LAMBDA(JDate,
    LET(
        _JDate, FN.NULLIFY(JDate),
        IF(_JDate = "", "",
            _JDate - 2400000.5
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
MJDATE_TO_JDATE

Converts a Modified Julian Date (MJDATE) to a Julian Date (JDATE).
Note that the decimal time component of JDATE is based from midday.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Julian Date

Parameters
----------------------------------------------------------------------------------------------------------------
MJDate | decimal | Modified Julian Date
--------------------------------------------------------------------------------------------------------------*/
MJDATE_TO_JDATE = LAMBDA(MJDate,
    LET(
        _MJDate, FN.NULLIFY(MJDate),
        IF(_MJDate = "", "",
            _MJDate + 2400000.5
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
JDATE_TO_JDN

Returns the corresponding Julian Day Number (JDN) of a given Julian Date (JDATE).
Note that the decimal time component of JDATE is based from midday.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Julian Day Number

Parameters
----------------------------------------------------------------------------------------------------------------
JDate | decimal | Julian Date
--------------------------------------------------------------------------------------------------------------*/
JDATE_TO_JDN = LAMBDA(JDate,
    LET(
        _JDate, FN.NULLIFY(JDate),
        IF(_JDate = "", "",
            INT(_JDate + 0.5)
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
JDN_TO_JDATE

Returns the Julian Date (JDATE) at 0:00 of a given Julian Day Number (JDN).
Note that the decimal time component of JDATE is based from midday.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Julian Date

Parameters
----------------------------------------------------------------------------------------------------------------
JDN | integer | Julian Day Number
--------------------------------------------------------------------------------------------------------------*/
JDN_TO_JDATE = LAMBDA(JDN,
    LET(
        _JDN, FN.NULLIFY(JDN),
        IF(_JDN = "", "",
            _JDN - 0.5
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
MJDATE_TO_MJDN

Returns the corresponding Modified Julian Day Number (MJDN) of a given Modified Julian Date (JDATE).
Note that the decimal time component of MJDATE is based from midnight.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Modified Julian Day Number

Parameters
----------------------------------------------------------------------------------------------------------------
MJDate | decimal | Modified Julian Date
--------------------------------------------------------------------------------------------------------------*/
MJDATE_TO_MJDN = LAMBDA(MJDate,
    LET(
        _MJDate, FN.NULLIFY(MJDate),
        IF(_MJDate = "", "",
            INT(_MJDate)
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
JDATE_TO_YMDT

Converts a Julian Date to a date and time in the specified calendar.

Array compatible: JDate as column

Output C[4]
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day of month
 4 | decimal [0..1)  | Time of day

Parameters
----------------------------------------------------------------------------------------------------------------
JDate              | decimal | Julian Date
[LowOrder]         | integer | Lowest-order component. Defaults to Second.
                   | [1..4]  | 1: Day
                   |         | 2: Hour
                   |         | 3: Minute
                   |         | 4: Second
[SecondPrecision]  | integer | Round seconds to specified decimal places.
                   | [0..9]  | Defaults to a miximum precision of 9.
[RoundingOverride] | switch  |  0: Default When Precision = 0, rounds to nearest second and truncates at low order component.
                   |         |             When Precision > 0, rounds to nearest at low order component.
                   |         |  1: Nearest Always round to nearest low order component.
                   |         | -1: Down    Always round down at low order component.
[JulianCalendar]   | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                   |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
JDATE_TO_YMDT = LAMBDA(JDate, [LowOrder], [SecondPrecision], [RoundingOverride], [JulianCalendar],
    LET(
        _MJDate, CHRONO.JDATE_TO_MJDATE(JDate),
        CHRONO.MJDATE_TO_YMDT(_MJDate, LowOrder, SecondPrecision, RoundingOverride, JulianCalendar)
    )
);


/*--------------------------------------------------------------------------------------------------------------
MJDATE_TO_YMDT

Converts a Modified Julian Date to a date and time in the specified calendar.

Array compatible: MJDate as column

Output C[4]
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day of month
 4 | decimal [0..1)  | Time of day

Parameters
----------------------------------------------------------------------------------------------------------------
MJDate             | decimal | Modified Julian Date
[LowOrder]         | integer | Lowest-order component. Defaults to Second.
                   | [1..4]  | 1: Day
                   |         | 2: Hour
                   |         | 3: Minute
                   |         | 4: Second
[SecondPrecision]  | integer | Round seconds to specified decimal places.
                   | [0..9]  | Defaults to a miximum precision of 9.
[RoundingOverride] | switch  |  0: Default When Precision = 0, rounds to nearest second and truncates at low order component.
                   |         |             When Precision > 0, rounds to nearest at low order component.
                   |         |  1: Nearest Always round to nearest low order component.
                   |         | -1: Down    Always round down at low order component.
[JulianCalendar]   | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                   |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
MJDATE_TO_YMDT = LAMBDA(MJDate, [LowOrder], [SecondPrecision], [RoundingOverride], [JulianCalendar],
    LET(
        _lowOrder, IF(NOT(ISNUMBER(LowOrder)), 4,
            IF(LowOrder < 1, 1,
                IF(LowOrder > 4, 4,
                    INT(LowOrder)
                )
            )
         ),

        _maxPrecision, 9,
        _secondPrecision, IF(_lowOrder < 4, 0,
            IF(NOT(ISNUMBER(SecondPrecision)), _maxPrecision,
                IF(SecondPrecision < 0, 0,
                    IF(SecondPrecision > _maxPrecision, _maxPrecision,
                        INT(SecondPrecision)
                    )
                )
            )
        ),

        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,

        fnMJDateToYMDT, LAMBDA(_MJDate,
            IF(ISERROR(_MJDate), _MJDate * {1, 2, 3, 4},
                IF(_MJDate = "", {"", "", "", ""},
                    IF(NOT(ISNUMBER(_MJDate)), {#VALUE!, #VALUE!, #VALUE!, #VALUE!},
                        LET(
                            _DT, CHRONO.ROUND_TO_DT(_MJDate, _lowOrder, _secondPrecision, RoundingOverride),
                            _MJDN, INDEX(_DT, 1, 1),
                            _date_YMD, CHRONO.MJDN_TO_CALENDAR_DATE(_MJDN, _julianCalendar),
                            IF(_lowOrder = 1, HSTACK(_date_YMD, ""),
                                LET(
                                    _time, INDEX(_DT, 1, 2),
                                    HSTACK(_date_YMD, _time)
                                )
                            )
                        )
                    )
                )
            )
        ),
        
        _MJDate, FN.NULLIFY(INDEX(MJDate, , 1)),
        _rowCount, ROWS(_MJDate),
        _byRow, REDUCE("", SEQUENCE(_rowCount),
            LAMBDA(_acc, _curr,
                VSTACK(
                    _acc,
                    fnMJDateToYMDT(INDEX(_MJDate, _curr, 1))
                )
            )
        ),
        DROP(_byRow, 1)
    )
);


/*--------------------------------------------------------------------------------------------------------------
ROUND_JDATE

Returns the decimal JDate value rounded to a low order component.

Array compatible: JDate

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Julian Date

Parameters
----------------------------------------------------------------------------------------------------------------
JDate              | decimal | Julian Date
[LowOrder]         | integer | Lowest-order component. Defaults to Second.
                   | [1..4]  | 1: Day
                   |         | 2: Hour
                   |         | 3: Minute
                   |         | 4: Second
[SecondPrecision]  | integer | Round seconds to specified decimal places.
                   | [0..9]  | Defaults to 0.
[RoundingOverride] | switch  |  0: Default When Precision = 0, rounds to nearest second and truncates at low order component.
                   |         |             When Precision > 0, rounds to nearest at low order component.
                   |         |  1: Nearest Always round to nearest low order component.
                   |         | -1: Down    Always round down at low order component.
--------------------------------------------------------------------------------------------------------------*/
ROUND_JDATE = LAMBDA(JDate, [LowOrder], [SecondPrecision], [RoundingOverride],
    LET(
        _MJDate, CHRONO.JDATE_TO_MJDATE(JDate),
        _roundMJDate, CHRONO.ROUND_MJDATE(_MJDate, LowOrder, SecondPrecision, RoundingOverride),
        CHRONO.MJDATE_TO_JDATE(_roundMJDate)
    )
);


/*--------------------------------------------------------------------------------------------------------------
ROUND_MJDATE

Returns the decimal MJDate value rounded to a low order component.

Array compatible: MJDate

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Modified Julian Date

Parameters
----------------------------------------------------------------------------------------------------------------
MJDate             | decimal | Modified Julian Date
[LowOrder]         | integer | Lowest-order component. Defaults to Second.
                   | [1..4]  | 1: Day
                   |         | 2: Hour
                   |         | 3: Minute
                   |         | 4: Second
[SecondPrecision]  | integer | Round seconds to specified decimal places.
                   | [0..9]  | Defaults to 0.
[RoundingOverride] | switch  |  0: Default When Precision = 0, rounds to nearest second and truncates at low order component.
                   |         |             When Precision > 0, rounds to nearest at low order component.
                   |         |  1: Nearest Always round to nearest low order component.
                   |         | -1: Down    Always round down at low order component.
--------------------------------------------------------------------------------------------------------------*/
ROUND_MJDATE = LAMBDA(MJDate, [LowOrder], [SecondPrecision], [RoundingOverride],
    LET(
        _lowOrder, IF(NOT(ISNUMBER(LowOrder)), 4,
            IF(LowOrder < 1, 1,
                IF(LowOrder > 4, 4,
                    INT(LowOrder)
                )
            )
         ),

        _maxPrecision, 9,
        _secondPrecision, IF(_lowOrder < 4, 0,
            IF(NOT(ISNUMBER(SecondPrecision)), 0,
                IF(SecondPrecision < 0, 0,
                    IF(SecondPrecision > _maxPrecision, _maxPrecision,
                        INT(SecondPrecision)
                    )
                )
            )
        ),

        fnRoundMJDate, LAMBDA(_MJDate,
            IF(ISERROR(_MJDate), _MJDate * {1},
                IF(_MJDate = "", "",
                    IF(NOT(ISNUMBER(_MJDate)), {#VALUE!},
                        LET(
                            _roundMJDate, CHRONO.ROUND_TO_DT(_MJDate, _lowOrder, _secondPrecision, RoundingOverride),
                            SUM(_roundMJDate)
                        )
                    )
                )
            )
        ),
        
        MAP(FN.NULLIFY(MJDate),
            LAMBDA(_element,
                fnRoundMJDate(_element)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
JDATE_ADDITION

Returns the addition of a timespan component to a given Julian Date.
Note if date components of years, quarters or months are added for a JDate expressed in UTC rather than
local time, then results may be inconsistent due to the bounds of calendar days.

Array compatible: LocalJDate as column, AddValue as scalar or column

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Julian Date

Parameters
----------------------------------------------------------------------------------------------------------------
LocalJDate       | decimal | Julian Date in local time zone
AddValue         | decimal | Add timespan expressed in the given Component.
[Component]      | text    | Component denomination of added value. Defaults to Days if omitted.
                 |         |    Y - Years. Any fractional part will round to months and whole days.
                 |         |    Q - Quarters. Any fractional part will round to months and whole days.
                 |         |    L - Months. Any fractional part will round to months and whole days.
                 |         |    W - Weeks. Any fractional part will round to whole days.
                 |         |    D - Days
                 |         |    H - Hours
                 |         |    M - Minutes
                 |         |    S - Seconds
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar. Only needed if Component is set to years, quarters or months.
--------------------------------------------------------------------------------------------------------------*/
JDATE_ADDITION = LAMBDA(LocalJDate, AddValue, [Component], [JulianCalendar],
    LET(
        _localMJDate, CHRONO.JDATE_TO_MJDATE(LocalJDate),
        _resultMJDate, CHRONO.MJDATE_ADDITION(_localMJDate, AddValue, Component, JulianCalendar),
        CHRONO.MJDATE_TO_JDATE(_resultMJDate)
    )
);


/*--------------------------------------------------------------------------------------------------------------
MJDATE_ADDITION

Returns the addition of a timespan component to a given Modified Julian Date.
Note if date components of years, quarters or months are added for a MJDate expressed in UTC rather than
local time, then results may be inconsistent due to the bounds of calendar days.

Array compatible: LocalMJDate as column, AddValue as scalar or column

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Modified Julian Date

Parameters
----------------------------------------------------------------------------------------------------------------
LocalMJDate      | decimal | Modified Julian Date in local time zone
AddValue         | decimal | Add timespan expressed in the given Component.
[Component]      | text    | Component denomination of added value. Defaults to Days if omitted.
                 |         |    Y - Years. Any fractional part will round to months and whole days.
                 |         |    Q - Quarters. Any fractional part will round to months and whole days.
                 |         |    L - Months. Any fractional part will round to months and whole days.
                 |         |    W - Weeks. Any fractional part will round to whole days.
                 |         |    D - Days
                 |         |    H - Hours
                 |         |    M - Minutes
                 |         |    S - Seconds
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar. Only needed if Component is set to years, quarters or months.
--------------------------------------------------------------------------------------------------------------*/
MJDATE_ADDITION = LAMBDA(LocalMJDate, AddValue, [Component], [JulianCalendar],
    LET(
        _component, IF(ISOMITTED(Component), "D",
            IF(Component = "", "D",
                LET(
                    _c, LEFT(FN.SIFT_FOR_CHARS(Component, "YQLWDHMS")),
                    IF(_c = "", "D", _c)
                )
            )
        ),
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,
        
        fnMJDateAddition, LAMBDA(_localMJDate, _addValue,
            IF(ISERROR(_localMJDate), _localMJDate * {1},
                IF(ISERROR(_addValue), _addValue * {1},
                    IF(_localMJDate = "", "",
                        IF(_addValue = "", _localMJDate,
                            IF(NOT(ISNUMBER(_localMJDate)), {#VALUE!},
                                IF(NOT(ISNUMBER(_addValue)), {#VALUE!},
                                    IF(_component = "W", _localMJDate + ROUND(_addValue * 7, 0),
                                        IF(_component = "D", _localMJDate + _addValue,
                                            IF(_component = "H", _localMJDate + (_addValue / 24),
                                                IF(_component = "M", _localMJDate + (_addValue / 1440),
                                                    IF(_component = "S", _localMJDate + (_addValue / 86400),
                                                        LET(
                                                            _avgDaysMonth, IF(_julianCalendar, 30.4375, 30.436875),
                                                            _decAddMonths, _addValue * SWITCH(_component,
                                                                "Y", 12,
                                                                "Q", 3,
                                                                "L", 1
                                                            ),
                                                            _intAddMonths, INT(_decAddMonths),
                                                            _partialMonths, MOD(_decAddMonths, 1),
                                                            _localDate_YMDT, CHRONO.MJDATE_TO_YMDT(_localMJDate, , , , _julianCalendar),
                                                            _addedDate_YMDT, _localDate_YMDT + HSTACK(
                                                                0,
                                                                _intAddMonths,
                                                                ROUND(_partialMonths * _avgDaysMonth, 0),
                                                                0
                                                            ),
                                                            _resolve_YMDT, CHRONO.RESOLVE_YMDT(_addedDate_YMDT, _julianCalendar),
                                                            CHRONO.MODIFIED_JULIAN_DATE(_resolve_YMDT, _julianCalendar)
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ),

        _localMJDate, FN.NULLIFY(INDEX(LocalMJDate, , 1)),
        _addValue, FN.NULLIFY(INDEX(AddValue, , 1)),
        _rowCount, ROWS(_localMJDate),
        _addCount, ROWS(_addValue),
        
        IF(_addCount = 1,
            LET(
                _addScalar, INDEX(_addValue, 1, 1),
                _byMJDate, REDUCE("", SEQUENCE(_rowCount),
                    LAMBDA(_acc, _curr,
                        VSTACK(
                            _acc,
                            fnMJDateAddition(INDEX(_localMJDate, _curr, 1), _addScalar)
                        )
                    )
                ),
                DROP(_byMJDate, 1)
            ),
            LET(
                _byRow, REDUCE("", SEQUENCE(_rowCount),
                    LAMBDA(_acc, _curr,
                        LET(
                            _addValue, IF(_curr <= _addCount,
                                 INDEX(_addValue, _curr, 1),
                                 0
                            ),
                            VSTACK(
                                _acc,
                                fnMJDateAddition(INDEX(_localMJDate, _curr, 1), _addValue)
                            )
                        )
                    )
                ),
                DROP(_byRow, 1)
            )
        )
    )
);













/*##############################################################################################################
# DATE AND TIME                                                                                                #
##############################################################################################################*/


/*--------------------------------------------------------------------------------------------------------------
VALIDATE_YMDT

Validate a year, month, day and time representation of a date in the specified calendar.

Array compatible: Date_YMDT as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer         | YearCE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day
 4 | decimal [0..1]  | Time of day

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YMDT        | array   C[1..4] |
   YearCE        | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE. Can be empty.
   [Month]       | integer [1..12] | Month of year. Can be empty.
   [Day]         | decimal [0..32) | Day. Can be empty.
   [TimeOfDay]   | decimal [0..1]  | Time of day. Can be empty.
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
VALIDATE_YMDT = LAMBDA(Date_YMDT, [JulianCalendar],
    LET(
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,
        
        fnValidateDateTime, LAMBDA(_date_YMDT,
            IF(COLUMNS(_date_YMDT) > 4, {#REF!, #REF!, #REF!, #REF!},
                IF(ARRAYS.IS_EMPTY(_date_YMDT), {"", "", "", ""},
                    LET(
                        _expandYMDT, EXPAND(_date_YMDT, 1, 4, ""),
                        _YM, TAKE(_expandYMDT, 1, 2),
                        _DT, CHRONO.VALIDATE_DT(DROP(_expandYMDT, , 2)),
                        _time, CHOOSECOLS(_DT, 2),
                        _day, IF(ARRAYS.IS_EMPTY(_DT), "",
                            LET(
                                _d, CHOOSECOLS(_DT, 1),
                                IF(NOT(FN.IS_EMPTY(_d)), _d,
                                    IF(ARRAYS.IS_EMPTY(_YM), "", {#VALUE!})
                                )
                            )
                        ),
                        _YMD, HSTACK(_YM, _day),
                        _validateYMD, CHRONO.VALIDATE_CALENDAR_DATE(_YMD, _julianCalendar),
                        HSTACK(_validateYMD, _time)
                    )
                )
            )
        ),

        _date_YMDT, FN.NULLIFY(Date_YMDT),
        _rowCount, ROWS(_date_YMDT),
        _byRow, REDUCE("", SEQUENCE(_rowCount),
            LAMBDA(_acc, _curr,
                VSTACK(
                    _acc,
                    fnValidateDateTime(INDEX(_date_YMDT, _curr,))
                )
            )
        ),
        DROP(_byRow, 1)
    )
);


/*--------------------------------------------------------------------------------------------------------------
IS_VALID_YMDT

Tests if a year, month, day and time representation of a date is valid for the specified calendar.

Array compatible: Date_YMDT as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YMDT        | array   C[1..4] |
   YearCE        | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE. Can be empty.
   [Month]       | integer [1..12] | Month of year. Can be empty.
   [Day]         | decimal [0..32) | Day. Can be empty.
   [TimeOfDay]   | decimal [0..1]  | Time of day. Can be empty.
[AllowPartial]   | switch          | Accept partially expressed date. Default tests for a fully expressed date.
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
IS_VALID_YMDT = LAMBDA(Date_YMDT, [AllowPartial], [JulianCalendar],
    LET(
        _date_YMDT, FN.NULLIFY(Date_YMDT),
        _allowPartial, FN.COERCE(AllowPartial) <> 0,
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,
        
        BYROW(_date_YMDT,
            LAMBDA(_row,
                IF(ARRAYS.IS_EMPTY(_row), FALSE,
                    LET(
                        _validateYMDT, CHRONO.VALIDATE_YMDT(_row, _julianCalendar),
                        IF(_allowPartial,
                            NOT(ARRAYS.HAS_ERROR(_validateYMDT)),
                            ARRAYS.IS_NUMERIC(_validateYMDT)
                        )
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
RESOLVE_YMDT

Resolves a date and time where components may exceed their modulus.

Array compatible: Date_YMDT as column

Output C[4]
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day of month
 4 | decimal [0..1)  | Time of day

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YMDT          | array C[1..4] |
   YearCE          | integer       | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
   [Month]         | integer       | Month of year. Can be empty.
   [Day]           | decimal       | Day. Can be empty.
   [Time]          | decimal       | Time of day. Can be empty.
[JulianCalendar]   | switch        | Calculate for the Julian proleptic calendar. Default is Gregorian
                   |               | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
RESOLVE_YMDT = LAMBDA(Date_YMDT, [JulianCalendar],
    LET(
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,

        fnResolveYMDT, LAMBDA(_date_YMDT,
            IF(COLUMNS(_date_YMDT) > 4, {#REF!, #REF!, #REF!, #REF!},
                IF(ARRAYS.IS_EMPTY(_date_YMDT), {"", "", "", ""},
                    IF(FN.IS_EMPTY(INDEX(_date_YMDT, 1, 1)), {#VALUE!, #VALUE!, #VALUE!, #VALUE!},
                        LET(
                            _firstError, ARRAYS.H_ERROR(_date_YMDT),
                            IF(ISERROR(_firstError), _firstError * {1, 2, 3, 4},
                                IF(NOT(ARRAYS.IS_NUMERIC_NULL(_date_YMDT)), {#VALUE!, #VALUE!, #VALUE!, #VALUE!},
                                    LET(
                                        _expandYMDT, EXPAND(_date_YMDT, 1, 4, ""),
                                        _YM, TAKE(_expandYMDT, 1, 2),
                                        _DT, CHRONO.RESOLVE_DT(DROP(_expandYMDT, , 2)),
                                        _day, CHOOSECOLS(_dt, 1),
                                        _time, CHOOSECOLS(_dt, 2),
                                        _YMD, HSTACK(_YM, _day),
                                        _resolveYMD, CHRONO.RESOLVE_CALENDAR_DATE(_YMD, _julianCalendar),
                                        HSTACK(_resolveYMD, _time)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ),

        _date_YMDT, FN.NULLIFY(Date_YMDT),
        _rowCount, ROWS(_date_YMDT),
        _byRow, REDUCE("", SEQUENCE(_rowCount),
            LAMBDA(_acc, _curr,
                VSTACK(
                    _acc,
                    fnResolveYMDT(INDEX(_date_YMDT, _curr, ))
                )
            )
        ),
        DROP(_byRow, 1)
    )
);


/*--------------------------------------------------------------------------------------------------------------
ROUND_YMDT

Returns the resolved date and time from the provided components to a low order component rounded to the
specified precision.

Array compatible: Date_YMDT as column

Output C[4]
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day of month
 4 | decimal [0..1)  | Time of day

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YMDT          | array C[1..4] |
   YearCE          | integer       | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
   [Month]         | integer       | Month of year. Can be empty.
   [Day]           | decimal       | Day. Ordinal day of year if month empty.
   [Time]          | decimal       | Time of day.
[LowOrder]         | integer       | Lowest-order component. Defaults to Second.
                   | [1..4]        | 1: Day
                   |               | 2: Hour
                   |               | 3: Minute
                   |               | 4: Second
[SecondPrecision]  | integer       | Round seconds to specified decimal places.
                   | [0..9]        | Defaults to a maximum precision of 9.
[RoundingOverride] | switch        |  0: Default When Precision = 0, rounds to nearest second and truncates at low order component.
                   |               |             When Precision > 0, rounds to nearest at low order component.
                   |               |  1: Nearest Always round to nearest low order component.
                   |               | -1: Down    Always round down at low order component.
[JulianCalendar]   | switch        | Calculate for the Julian proleptic calendar. Default is Gregorian
                   |               | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
ROUND_YMDT = LAMBDA(Date_YMDT, [LowOrder], [SecondPrecision], [RoundingOverride], [JulianCalendar],
    LET(
        _lowOrder, IF(NOT(ISNUMBER(LowOrder)), 4,
            IF(LowOrder < 1, 1,
                IF(LowOrder > 4, 4,
                    INT(LowOrder)
                )
            )
         ),

        _maxPrecision, 9,
        _secondPrecision, IF(_lowOrder < 4, 0,
            IF(NOT(ISNUMBER(SecondPrecision)), _maxPrecision,
                IF(SecondPrecision < 0, 0,
                    IF(SecondPrecision > _maxPrecision, _maxPrecision,
                        INT(SecondPrecision)
                    )
                )
            )
        ),

        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,

        fnRoundYMDT, LAMBDA(_date_YMDT,
            LET(
                _resolveYMDT, CHRONO.RESOLVE_YMDT(_date_YMDT, _julianCalendar),
                IF(ISERROR(INDEX(_resolveYMDT, 1, 1)), _resolveYMDT,
                    IF(ARRAYS.IS_EMPTY(_resolveYMDT), _resolveYMDT,
                        LET(
                            _YM, TAKE(_resolveYMDT, 1, 2),
                            _roundDT, CHRONO.ROUND_TO_DT(
                                CHRONO.COMBINE_DT(DROP(_resolveYMDT, , 2)),
                                _lowOrder, _secondPrecision, RoundingOverride
                            ),
                            _day, CHOOSECOLS(_roundDT, 1),
                            _time, CHOOSECOLS(_roundDT, 2),
                            _YMD, HSTACK(_YM, _day),
                            _resolveYMD, CHRONO.RESOLVE_CALENDAR_DATE(_YMD, _julianCalendar),
                            _showTime, IF(_lowOrder = 1, "", _time),
                            HSTACK(_resolveYMD, _showTime)
                        )
                    )
                )
            )
        ),

        _date_YMDT, FN.NULLIFY(Date_YMDT),
        _rowCount, ROWS(_date_YMDT),
        _byRow, REDUCE("", SEQUENCE(_rowCount),
            LAMBDA(_acc, _curr,
                VSTACK(
                    _acc,
                    fnRoundYMDT(INDEX(_date_YMDT, _curr, ))
                )
            )
        ),
        DROP(_byRow, 1)
    )
);

/*--------------------------------------------------------------------------------------------------------------
PARSE_ISO_DATETIME

Parses an ISO formatted date and time into respective date parts, time, and time zone offset from UTC.

Array compatible: Expression as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year
 2 | integer         | Month
 3 | integer         | Day
 4 | decimal [0..1]  | Time
 5 | decimal         | Time zone offset from UTC
   | [-0.625..0.625] | 

Parameters
----------------------------------------------------------------------------------------------------------------
Expression       | text   | Date time in ISO format ie. yyyy-MM-ddThh:mm:ss+hh:mm
[StrictISO]      | switch | Enforce strict ISO validation. No mixing of basic and extended formats. eg. yyyyMMddThh:mm
[JulianCalendar] | switch | Validate in the Julian proleptic calendar. Default is Gregorian
                 |        | proleptic calendar.

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_ISO_DATETIME("2023-05-23")
Returns: {2023, 5, 23, , }

PARSE_ISO_DATETIME("2023-05-23T06:00")
Returns: {2023, 5, 23, 0.25, }

PARSE_ISO_DATETIME("T12:00")
Returns: { , , , 0.5, }

PARSE_ISO_DATETIME("T12:00−06:00")
Returns: { , , , 0.5, -360}

PARSE_ISO_DATETIME("2023-05-23T+09:00")
Returns: {2023, 5, 23, , 540}
--------------------------------------------------------------------------------------------------------------*/
PARSE_ISO_DATETIME = LAMBDA(Expression, [StrictISO], [JulianCalendar],
    Let(
        _strictISO, FN.COERCE(StrictISO) <> 0,
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,
        _validCharSet, "0123456789TWZ:-+.,−", // − UNICHAR(8722)
        _TZdelim, "Z-+−", // − UNICHAR(8722)

        fnParseISODateTime, LAMBDA(_expr,
            IF(ISERROR(_expr), _expr * {1, 2, 3, 4, 5},
                IF(_expr = "", {"", "", "", "", ""},
                    IF(NOT(FN.VALIDATE_CHARSET(_expr, _validCharSet, 1)), {#VALUE!, #VALUE!, #VALUE!, #VALUE!, #VALUE!},
                        LET(
                            _Tpos, IFERROR(FIND("T", _expr), 0),
                            _parts, IF(_Tpos = 0,
                                HSTACK(_expr, "", ""),
                                LET(
                                    _len, LEN(_expr),
                                    _datePart, LEFT(_expr, _Tpos - 1),
                                    _TZpos, FN.FIND_NTH_CHAR(_expr, _TZdelim, 1, 1, 0, _Tpos + 1),
                                    IF(_TZpos = 0,
                                        HSTACK(
                                            _datePart,
                                            RIGHT(_expr, _len - _Tpos + 1),
                                            ""
                                        ),
                                        IF(_TZpos = _Tpos + 1,
                                            HSTACK(
                                                _datePart,
                                                "",
                                                RIGHT(_expr, _len - _TZpos + 1)
                                            ),
                                            HSTACK(
                                                _datePart,
                                                MID(_expr, _Tpos, _TZPos - _Tpos),
                                                RIGHT(_expr, _len - _TZpos + 1)
                                            )
                                        )
                                    )
                                )
                            ),
                            _failStyleCheck, IF(NOT(_strictISO), FALSE,
                                LET(
                                    _styleDate, IF(INDEX(_parts, 1, 1) = "", 3,
                                        IF(IFERROR(FIND("-", INDEX(_parts, 1, 1), 5), 0) > 0, 2, 1)
                                    ),
                                    _styleTime, IF(INDEX(_parts, 1, 2) = "", 3,
                                        IF(LEN(INDEX(_parts, 1, 2)) = 3, 3,
                                            IF(IFERROR(FIND(":", INDEX(_parts, 1, 2), 4), 0) > 0, 2, 1)
                                        )
                                    ),
                                    _styleTZO, IF(INDEX(_parts, 1, 3) = "", 3,
                                        IF(EXACT(INDEX(_parts, 1, 3), "Z"), 3,
                                            IF(LEN(INDEX(_parts, 1, 3)) = 3, 3,
                                                IF(IFERROR(FIND(":", INDEX(_parts, 1, 3), 4), 0) > 0, 2, 1)
                                            )
                                        )
                                    ),
                                    IF(BITAND(_styleDate, _styleTime) = 0, TRUE,
                                        IF(BITAND(_styleDate, _styleTZO) = 0, TRUE,
                                            BITAND(_styleTime, _styleTZO) = 0
                                        )
                                    )
                                )
                            ),
                            IF(_failStyleCheck, {#VALUE!, #VALUE!, #VALUE!, #VALUE!, #VALUE!},
                                LET(
                                    _time, CHRONO.PARSE_TIME_OF_DAY(INDEX(_parts, 1, 2), TRUE),
                                    _tzo, CHRONO.PARSE_ISO_TZO(INDEX(_parts, 1, 3)),
                                    IF(INDEX(_parts, 1, 1) = "",
                                        IF(_time = "",
                                            HSTACK("", "", "", {#N/A}, _tzo),
                                            HSTACK("", "", "", _time, _tzo)
                                        ),
                                        LET(
                                            _date, CHRONO.PARSE_ISO_CALENDAR_DATE(INDEX(_parts, 1, 1), _julianCalendar),
                                            HSTACK(_date, _time, _tzo)
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ),

        _expression, FN.NULLIFY(INDEX(Expression, , 1)),
        _rowCount, ROWS(_expression),
        _byRow, REDUCE("", SEQUENCE(_rowCount),
            LAMBDA(_acc, _curr,
                VSTACK(
                    _acc,
                    fnParseISODateTime(INDEX(_expression, _curr, 1))
                )
            )
        ),
        DROP(_byRow, 1)
    )
);


/*--------------------------------------------------------------------------------------------------------------
FORMAT_ISO_DATETIME

Returns a date, time and time zone offset as text in ISO format.

Array compatible: Date_YMDT as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | ISO formatted date, time and time zone offset

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YMDT        | array   C[4]     |
   YearCE        | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
   Month         | integer [1..12]  | Month of year.
   Day           | decimal [0..367) | Day. Ordinal day of year if month empty.
   Time          | decimal [0..1)   | Time of day.
[TZOMinutes]     | decimal          | Time zone offset from UTC in minutes
                 | [-900..900]      | [-15:00..+15:00]
[Options]        | text             | [B][+][Z][A][N|F][LowOrder][*][0-9]
                 |                  |        B : Display in basic ISO style.
                 |                  |        + : Display positive sign for non-negative years.
                 |                  |        Z : Display 'Z' for Zulu time zone +00:00
                 |                  |        A : Display a time value of 24:00 to represent midnight at the end of the calendar day.
                 |                  |            Not applicable if LowOrder is D.
                 |                  |     N, F : Override rounding behaviour. Default method rounds to nearest second, and
                 |                  |            rounds down on other low order components.
                 |                  |            N: always round to nearest.
                 |                  |            F: always round down
                 |                  | LowOrder : Low order component. Upper case to set explicitly. Lower case allows floating
                 |                  |            from expressing in the given component down to seconds as needed.
                 |                  |            Takes the following:
                 |                  |            D, d : Day
                 |                  |            H, h : Hour
                 |                  |            M, m : Minute
                 |                  |            S, s : Second 
                 |                  |        * : Allows floating down the lowest order component needed, including the maximum precision
                 |                  |            for seconds.
                 |                  |      0-9 : Decimal places for seconds. * floats up to a maximum precision of 9.
[JulianCalendar] | switch           | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                  | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
FORMAT_ISO_DATETIME = LAMBDA(Date_YMDT, [TZOMinutes], [Options], [JulianCalendar],
    LET(
        _options, FN.NULLIFY(Options),
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,
        _dateOptions, FN.SIFT_FOR_CHARS(_options, "B+"),
        _basic, IFERROR(SEARCH("B", _dateOptions), 0) > 0,
        _TZoptions, FN.SIFT_FOR_CHARS(_options, "BZ"),
        _TZOpart, CHRONO.FORMAT_ISO_TZO(TZOMinutes, _TZoptions),
        
        _timeOfDayOptionSet, _FORMAT_TIME_OF_DAY_OPTIONS(_options & "I", TRUE),

        fnValidate, LAMBDA(_YMDT,
            IF(COLUMNS(_YMDT) > 4, {#REF!},
                IF(ARRAYS.IS_EMPTY(_YMDT), "",
                    LET(
                        _firstError, ARRAYS.H_ERROR(_YMDT),
                        IF(ISERROR(_firstError), _firstError * {1},
                            IF(NOT(ARRAYS.IS_NUMERIC_NULL(_YMDT)), {#VALUE!},
                                LET(
                                    _expandYMDT, EXPAND(_YMDT, 1, 4, ""),
                                    IF(ARRAYS.HAS_NEGATIVE(DROP(_expandYMDT,, 1)), {#NUM!},
                                        LET(
                                            _nominalToD, INDEX(_expandYMDT, 1, 4),
                                            _hasToD, ISNUMBER(_nominalToD),
                                            IF(_hasToD * ((_nominalToD < 0) + (_nominalToD > 1)), {#NUM!},
                                                LET(
                                                    _YMD, TAKE(_expandYMDT, 1, 3),
                                                    _noDate, ARRAYS.IS_EMPTY(_YMD),
                                                    IF(_noDate, _expandYMDT,
                                                        IF(NOT(CHRONO.IS_VALID_CALENDAR_DATE(_YMD, TRUE, _julianCalendar)), {#NUM!},
                                                            _expandYMDT
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ),

        fnResolveDatePart, LAMBDA(_validatedYMDT, _carryDay,
            IF(INDEX(_validatedYMDT, 1, 1) = "", "",
                LET(
                    _YM, TAKE(_validatedYMDT, 1, 2),
                    _providedDay, INDEX(_validatedYMDT, 1, 3),
                    _nominalDay, _carryDay + IF(_providedDay = "", 1, _providedDay),
                    _YMD, HSTACK(_YM, _nominalDay),
                    _resolveDate, CHRONO.RESOLVE_CALENDAR_DATE(_YMD, _julianCalendar),
                    CHRONO.FORMAT_ISO_CALENDAR_DATE(_resolveDate, _dateOptions, _julianCalendar)
                )
            )
        ),
                
        fnFormatISODateTime, LAMBDA(_YMDT,
            LET(
                _validateYMDT, fnValidate(_YMDT),
                IF(COLUMNS(_validateYMDT) = 1, INDEX(_validateYMDT, 1, 1),
                    LET(
                        _timeInfo, _FORMAT_TIME_OF_DAY(INDEX(_validateYMDT, 1, 4), _timeOfDayOptionSet),
                        _carryDay, INDEX(_timeInfo, 1, 1),
                        _timePart, INDEX(_timeInfo, 1, 2),
                        _datePart, fnResolveDatePart(_validateYMDT, _carryDay),
                        IF(_timePart = "",
                            _datePart,
                            CONCAT(_datePart, _timePart, _TZOpart)
                        )
                    )
                )
            )
        ),
        
        _date_YMDT, FN.NULLIFY(Date_YMDT),
        BYROW(_date_YMDT,
            LAMBDA(_row,
                fnFormatISODateTime(_row)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_DATETIME

Parses a formated date into respective parts of year, month, day and time of day.

Array compatible: Expression as column

Output C[4]
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day
 4 | decimal [0..1)  | Time

Parameters
----------------------------------------------------------------------------------------------------------------
Expression            | text   | Date and time in DMYT format ie. dd/MM/yyyy hh:mm:ss
[NorthAmericanRegion] | switch | TRUE assume order in North American format mm/dd/yyyy 
                      |        | FALSE assume order in internationl format dd/mm/yyyy 
                      |        | If omitted then defaults to local regional settings of Excel
[JulianCalendar]      | switch | Calculate for the Julian proleptic calendar. Default is Gregorian
                      |        | proleptic calendar. 

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_DATETIME("25/1/2014 6:00")
Returns: {2014, 1, 25, 0.25}

PARSE_DATETIME("31/12/2023")
Returns: {2023, 12, 31, ""}
--------------------------------------------------------------------------------------------------------------*/
PARSE_DATETIME = LAMBDA(Expression, [NorthAmericanRegion], [JulianCalendar], 
    LET(
        _northAmericanRegion, IF(ISOMITTED(NorthAmericanRegion), FN.NORTH_AMERICAN_REGION(),
            FN.COERCE(NorthAmericanRegion) <> 0
        ),
        
        _julianCalendar, N(JulianCalendar) <> 0,
        
        _validCharSet, "0123456789AMPTamp :,-./_−", // − UNICHAR(8722)

        fnParseDateTime, LAMBDA(_expression,
            IF(ISERROR(_expression), Expression * {1, 2, 3, 4},
                IF(_expression = "", {"", "", "", ""},
                    IF(NOT(FN.VALIDATE_CHARSET(_expression, _validCharSet, TRUE)), {#VALUE!, #VALUE!, #VALUE!, #VALUE!},
                        LET(
                            _timeDelim, LEFT(FN.SIFT_FOR_CHARS(_expression, ",-./_:m")),
                            _isTimeOnly, SWITCH(_timeDelim,
                                ":", TRUE,
                                "m", TRUE,
                                FALSE
                            ),
                            _parts, IF(_isTimeOnly, HSTACK("", _expression),
                                LET(
                                    _tPos1, FN.FIND_NTH_CHAR(_expression, " T_,", 1, TRUE),
                                    _tPos2, IF(_tPos1 = 0, 0, FN.FIND_NTH_CHAR(_expression, "0123456789", 1, FALSE, FALSE, _tPos1 + 1)),
                                    _datePart, IF(_tPos1 = 0, _expression, TRIM(LEFT(_expression, _tPos1 - 1))),
                                    _timePart, IF(_tPos2 = 0, "", TRIM(RIGHT(_expression, LEN(_expression) - _tPos2 + 1))),
                                    HSTACK(_datePart, _timePart)
                                )
                            ),
                            _YMD, CHRONO.PARSE_CALENDAR_DATE(INDEX(_parts, 1, 1), _northAmericanRegion, _julianCalendar),
                            _timeOfDay, CHRONO.PARSE_TIME_OF_DAY(INDEX(_parts, 1, 2), FALSE),
                            HSTACK(_YMD, _timeOfDay)
                        )
                    )
                )
            )
        ),
        
        _expression, FN.NULLIFY(INDEX(Expression, , 1)),
        _rowCount, ROWS(_expression),
        _byRow, REDUCE("", SEQUENCE(_rowCount),
            LAMBDA(_acc, _curr,
                VSTACK(
                    _acc,
                    fnParseDateTime(INDEX(_expression, _curr, 1))
                )
            )
        ),
        DROP(_byRow, 1)
    )
);


/*--------------------------------------------------------------------------------------------------------------
FORMAT_DATETIME

Returns a formatted date and time.

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | Date and time

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YMDT        | array   C[3..4]  |
   YearCE        | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
   Month         | integer [1..12]  | Month of year.
   Day           | decimal [0..32)  | Day. If time is not omitted any decimal part is ignored.
   [Time]        | decimal [0..1]   | Time of day. If omitted then decimal part of day is taken.
[Options]        | text             | [.|-][+][U|V][C][A][P][J][K][L][N|F][LowOrder][*][0-9]
                 |                  |      .|- : Separator. Defaults to /
                 |                  |        + : Display positive sign for non-negative years.
                 |                  |     U, V : U to order in international format dd/mm/yyyy
                 |                  |            V to order in North American format mm/dd/yyyy
                 |                  |            Defaults to local regional settings of Excel.
                 |                  |        C : Civil time style. Defaults to 24 hour style.
                 |                  |            24 Hour: H:mm:ss.000    
                 |                  |            Civil:   h:mm:ss AM|PM
                 |                  |        A : Allow a time value of 24:00 to represent midnight the following day.
                 |                  |            Not applicable if LowOrder is D
                 |                  |        P : Pad components with leading zero.
                 |                  |        J : Dotted style A.M.|P.M. Applicable to Civil style.
                 |                  |        K : No space preceding AM|PM. Applicable to Civil style.
                 |                  |        L : Lower case am|pm. Applicable to Civil style.
                 |                  |     N, F : Override rounding behaviour. Default method rounds to nearest second, and
                 |                  |            rounds down on other low order components.
                 |                  |            N: always round to nearest.
                 |                  |            F: always round down
                 |                  | LowOrder : Low order component. Upper case to set explicitly. Lower case allows floating
                 |                  |            from expressing in the given component down to seconds as needed.
                 |                  |            Takes the following:
                 |                  |            D, d : Day
                 |                  |            H, h : Hour
                 |                  |            M, m : Minute
                 |                  |            S, s : Second 
                 |                  |        * : Allows floating down the lowest order component needed, including the maximum precision
                 |                  |            for seconds.
                 |                  |      0-9 : Decimal places for seconds. If LowOrder not supplied, then implicitly LowOrder is 's'.
                 |                  |            Not applicable to Civil style.
[JulianCalendar] | switch           | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                  | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
FORMAT_DATETIME = LAMBDA(Date_YMDT, [Options], [JulianCalendar],
    LET(
        _julianCalendar, N(JulianCalendar) <> 0,
        _options, FN.NULLIFY(Options),
        _padding, IFERROR(SEARCH("P", _options), 0) > 0,
        
        _dateOptions, FN.SIFT_FOR_CHARS(_options, ".-+UVP"),
        _timeOptions, FN.SIFT_FOR_CHARS(_options, "CAPJKLNFDHMS*0123456789"),
        _timeOfDayOptionSet, _FORMAT_TIME_OF_DAY_OPTIONS(_timeOptions, TRUE),
        
        fnFormatDateTime, LAMBDA(_date_YMDT,
            IF(COLUMNS(_date_YMDT) > 4, {#REF!},
                LET(
                    _firstError, ARRAYS.H_ERROR(_date_YMDT),
                    IF(ISERROR(_firstError), _firstError * {1},
                        IF(ARRAYS.IS_EMPTY(_date_YMDT), "",
                            IF(NOT(ARRAYS.IS_NUMERIC_NULL(_date_YMDT)), {#VALUE!},
                                LET(
                                    _expandYMDT, EXPAND(_date_YMDT, 1, 4, ""),
                                    _YMD, TAKE(_expandYMDT, 1, 3),
                                    IF(NOT(CHRONO.IS_VALID_CALENDAR_DATE(_YMD, TRUE, _julianCalendar)), {#NUM!},
                                        LET(
                                            _hasTime, NOT(FN.IS_EMPTY(INDEX(_expandYMDT, 1, 4))),
                                            _DT, _FORMAT_TIME_OF_DAY(INDEX(_expandYMDT, 1, 4), _timeOfDayOptionSet),
                                            _carryDay, INDEX(_DT, 1, 1),
                                            _sToD, INDEX(_DT, 1, 2),
                                            _resolveYMD, IF(_carryDay = 0,
                                                CHRONO.RESOLVE_CALENDAR_DATE(_YMD, _julianCalendar),
                                                LET(
                                                    _YMD1, CHRONO.RESOLVE_CALENDAR_DATE(_YMD, _julianCalendar),
                                                    _roundedYMD, _YMD1 + HSTACK(0, 0, _carryDay),
                                                    CHRONO.RESOLVE_CALENDAR_DATE(_roundedYMD, _julianCalendar)
                                                )
                                            ),
                                            _sDate, CHRONO.FORMAT_CALENDAR_DATE(_resolveYMD, _dateOptions, _julianCalendar),
                                            IF(_hasTime, _sDate & " " & _sToD, _sDate)
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ),

        BYROW(FN.NULLIFY(Date_YMDT),
            LAMBDA(_row,
                fnFormatDateTime(_row)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_LITERARY_DATETIME

Parses a literary date into respective parts of year, month, day, time of day and day of week.

Array compatible: Expression as column

Output C[5]
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day
 4 | integer [1..7]  | Day of Week
 5 | decimal [0..1]  | Time of Day. Maximum resolution is seconds.

Parameters
----------------------------------------------------------------------------------------------------------------
Expression       | text   | Literary date and time
[LanguageCode]   | text   | Language. If omitted then local language set in Excel.
[JulianCalendar] | switch | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |        | proleptic calendar. 

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_LITERARY_DATETIME("Feb 25, 2014, 6:00")
Returns: {2014, 2, 25, 0.25, ""}

PARSE_LITERARY_DATETIME("Sun Dec 31, 2023, 24:00")
Returns: {2023, 12, 31, 1, 7}

PARSE_LITERARY_DATETIME("Mon Feb 25th")
Returns: {"", 2, 25, "", 1}

PARSE_LITERARY_DATETIME("Feb 2000")
Returns: {2000, 2, "", "", ""}
--------------------------------------------------------------------------------------------------------------*/
PARSE_LITERARY_DATETIME = LAMBDA(Expression, [LanguageCode], [JulianCalendar],
    LET(
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,
        _languageID, FN.LANGUAGE_ID(FN.NULLIFY(LanguageCode)),
        
        fnMinusDelimToSpace, LAMBDA(_text,
            LET(
                _charArray, MID(_text, SEQUENCE(LEN(_text)), 1),
                _reduceMinus, REDUCE({""; 1}, _charArray,
                    LAMBDA(_acc, _currChar,
                        LET(
                            _isMinus, N(_currChar = "-"),
                            _prevIsSpace, INDEX(_acc, 2),

                            IF(NOT(_prevIsSpace) * _isMinus,
                                VSTACK(INDEX(_acc, 1) & " ", 1),
                                LET(
                                    _isSpace, N(_currChar = " "),
                                    VSTACK(INDEX(_acc, 1) & _currChar, _isSpace)
                                )
                            )
                        )
                    )
                ),
                INDEX(_reduceMinus, 1)
            )
        ),

        fnParseNotation, LAMBDA(_text,
            LET(
                _resolveSuffix, SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(
                    UPPER(_text),
                    "A.M.", "AM"),
                    "P.M.", "PM"),
                    "C.E.", "CE"),
                    "A.D.", "AD"),
                    "B.C.E.", "BCE"),
                    "B.C.", "BC"
                ),
                
                _condensed, FN.CONDENSE_WHITESPACE(TRIM(FN.REPLACE_CHARS(_resolveSuffix, "\|,;/.", " "))),
                
                SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(
                    _condensed,
                    " AM", "AM"),
                    " PM", "PM"),
                    " CE", "CE"),
                    " AD", "AD"),
                    " BC", "BC"
                )
            )
        ),

        fnParseLiteraryDate, LAMBDA(_literaryDate,
            IF(ISERROR(_literaryDate), _literaryDate * {1, 2, 3, 4, 5},
                IF(_literaryDate = "", {"", "", "", "", ""},
                    LET(
                        _parseMinusDelims, fnMinusDelimToSpace(_literaryDate),
                        _parseDelims, fnParseNotation(_parseMinusDelims),
                        _split, FN.SPLIT(_parseDelims, " ", FALSE, TRUE, 6),
                        _countParts, INDEX(_split, 1, 1),
                        _parts, DROP(_split, 0, 1),
                        IF(_countParts > 5, {#VALUE!, #VALUE!, #VALUE!, #VALUE!, #VALUE!},
                            LET(
                                _values, VALUE(_parts),
                                _testTextParts, N(ISERROR(_values)) + N(IFERROR(FIND(":", _parts), 0) > 0),
                                _textParts, FILTER(_parts, _testTextParts > 0, #N/A),
                                _numericParts, FILTER(_values, _testTextParts = 0, #N/A),
                                _parseTextParts, _PARSE_LITERARY_DATE_TEXT_PARTS(_textParts, _languageID),
                                _parsedTextYMD, TAKE(_parseTextParts, 1, 3),
                                _parseNumericParts, _PARSE_LITERARY_DATE_NUMERIC_PARTS(_numericParts, _parsedTextYMD, _julianCalendar),
                                _resolvedYMD, HSTACK(
                                    INDEX(_parseNumericParts, 1, 1),
                                    INDEX(_parsedTextYMD, 1, 2),
                                    INDEX(_parseNumericParts, 1, 2)
                                ),
                                _parsedWeekday, INDEX(_parseTextParts, 1, 4),
                                _parsedToD, INDEX(_parseTextParts, 1, 5),
                                _resolvedWeekday, IF(NOT(ISNUMBER(_parsedWeekday)), _parsedWeekday,
                                    IF(NOT(ARRAYS.IS_NUMERIC(_resolvedYMD)), _parsedWeekday,
                                        LET(
                                            _MJDN, CHRONO.MJDN(_resolvedYMD, _julianCalendar),
                                            IF(_parsedWeekday = CHRONO.MJDN_TO_WEEKDAY(_MJDN), _parsedWeekday, {#NUM!})
                                        )
                                    )
                                ),
                                _resolvedYMDWT, HSTACK(_resolvedYMD, _resolvedWeekday, _parsedToD),
                                IF(ISERROR(INDEX(_resolvedYMDWT, 1, 1)) * ARRAYS.IS_EMPTY(DROP(_resolvedYMDWT, , 1)),
                                    INDEX(_resolvedYMDWT, 1, 1) * {1, 2, 3, 4, 5},
                                    _resolvedYMDWT
                                )
                            )
                        )
                    )
                )
            )
        ),
        
        _expression, FN.NULLIFY(INDEX(Expression, , 1)),
        _rowCount, ROWS(_expression),
        _byRow, REDUCE("", SEQUENCE(_rowCount),
            LAMBDA(_acc, _curr,
                VSTACK(
                    _acc,
                    fnParseLiteraryDate(INDEX(_expression, _curr, 1))
                )
            )
        ),
        DROP(_byRow, 1)
    )
);

_PARSE_LITERARY_DATE_TEXT_PARTS = LAMBDA(_textParts, _languageID,
    // Returns {Year, Month, Day, Time, DayOfWeek}
    IF(ISNA(INDEX(_textParts, 1, 1)), HSTACK("", "", "", "", ""),
        LET(
            _parseMonthParts, CHRONO.PARSE_MONTH(_textParts, _languageID),
            _isMonth, N(ISNUMBER(_parseMonthParts)),
            _countMonth, SUM(_isMonth),
            _month, SWITCH(_countMonth,
                0, "",
                1, XLOOKUP(1, _isMonth, _parseMonthParts),
                {#VALUE!}
            ),
            _remainParts1, FILTER(_textParts, _isMonth = 0, #N/A),
            IF(ISNA(INDEX(_remainParts1, 1, 1)), HSTACK("", _month, "", "", ""),
                LET(
                    _parseDayOfWeekParts, CHRONO.PARSE_WEEKDAY(_remainParts1, _languageID),
                    _isDayOfWeek, N(ISNUMBER(_parseDayOfWeekParts)),
                    _countDayOfWeek, SUM(_isDayOfWeek),
                    _dayOfWeek, SWITCH(_countDayOfWeek,
                        0, "",
                        1, XLOOKUP(1, _isDayOfWeek, _parseDayOfWeekParts),
                        {#VALUE!}
                    ),
                    _remainParts2, FILTER(_remainParts1, _isDayOfWeek = 0, #N/A),
                    IF(ISNA(INDEX(_remainParts2, 1, 1)), HSTACK("", _month, "", _dayOfWeek, ""),
                        LET(
                            _parseDayOrdinalParts, FN.ORDINAL_VALUE(_remainParts2),
                            _isDayOrdinal, N(ISNUMBER(_parseDayOrdinalParts)),
                            _countDayOrdinal, SUM(_isDayOrdinal),
                            _day, SWITCH(_countDayOrdinal,
                                0, "",
                                1, XLOOKUP(1, _isDayOrdinal, _parseDayOrdinalParts),
                                {#VALUE!}
                            ),
                            _remainParts3, FILTER(_remainParts2, _isDayOrdinal = 0, #N/A),
                            IF(ISNA(INDEX(_remainParts3, 1, 1)), HSTACK("", _month, _day, _dayOfWeek, ""),
                                LET(
                                    _parseTimeSpanParts, CHRONO.PARSE_TIMESPAN(_remainParts3),
                                    _parseTimeOfDayParts, CHRONO.PARSE_TIME_OF_DAY(_remainParts3),
                                    _isTimeSpan, N(ISNUMBER(_parseTimeSpanParts)),
                                    _isTimeOfDay, N(ISNUMBER(_parseTimeOfDayParts)),
                                    _countTimeSpan, SUM(_isTimeSpan),
                                    _countTimeOfDay, SUM(_isTimeOfDay),
                                    _timeOfday, SWITCH(_countTimeOfDay,
                                        0, IF(_countTimeSpan = 0, "", {#NUM!}),
                                        1, XLOOKUP(1, _isTimeOfDay, _parseTimeOfDayParts),
                                        {#VALUE!}
                                    ),
                                    _remainParts4, FILTER(_remainParts3, (_isTimeSpan = 0) * (_isTimeOfDay = 0), #N/A),
                                    IF(ISNA(INDEX(_remainParts4, 1, 1)), HSTACK("", _month, _day, _dayOfWeek, _timeOfday),
                                        LET(
                                            _parseYearParts, CHRONO.PARSE_LITERARY_YEAR(_remainParts4),
                                            _isYear, N(ISNUMBER(_parseYearParts)),
                                            _countYear, SUM(_isYear),
                                            _year, SWITCH(_countYear,
                                                0, {#VALUE!},
                                                1, XLOOKUP(1, _isYear, _parseYearParts),
                                                {#VALUE!}
                                            ),
                                            HSTACK(_year, _month, _day, _dayOfWeek, _timeOfday)
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);

_PARSE_LITERARY_DATE_NUMERIC_PARTS = LAMBDA(_numericParts, _textYMD, _julianCalendar,
    // Returns {Year, Day}
    LET(
        _textYear, INDEX(_textYMD, 1, 1),
        _textMonth, INDEX(_textYMD, 1, 2),
        _textDay, INDEX(_textYMD, 1, 3),
        _countNumericParts, IF(ISNA(INDEX(_numericParts, 1, 1)), 0, COLUMNS(_numericParts)),
        _countYD, N(ISNUMBER(_textYear)) + N(ISNUMBER(_textDay)),
        _maxNumericParts, 2 - _countYD,
        
        IF(_countNumericParts > _maxNumericParts, HSTACK(IF(ISNUMBER(_textYear), _textYear, {#VALUE!}), {#VALUE!}),
            IF(_countNumericParts = 0, HSTACK(_textYear, _textDay),
                IF(_countNumericParts = 1,
                    IF(INDEX(_numericParts, 1, 1) < 1,
                        IF(ISNUMBER(_textYear),
                            HSTACK(_textYear, {#VALUE!}),
                            HSTACK(INDEX(_numericParts, 1, 1), _textDay)
                        ),
                        LET(
                            _maxDay, IF(ISNUMBER(_textMonth), CHRONO.DAYS_IN_MONTH(_textMonth, _textYear, _julianCalendar), 31),
                            IF(INDEX(_numericParts, 1, 1) <= _maxDay,
                                HSTACK(_textYear, INDEX(_numericParts, 1, 1)),
                                IF(ISNUMBER(_textYear),
                                    HSTACK(_textYear, {#VALUE!}),
                                    HSTACK(INDEX(_numericParts, 1, 1), _textDay)
                                )
                            )
                        )
                    ),
                    IF(_countNumericParts = 2,
                        LET(
                            _isDayFirst, IF(INDEX(_numericParts, 1, 1) < 1, FALSE,
                                LET(
                                    _maxDayFirst, IF(ISNUMBER(_textMonth), CHRONO.DAYS_IN_MONTH(_textMonth, INDEX(_numericParts, 1, 2), _julianCalendar), 31),
                                    INDEX(_numericParts, 1, 1) <= _maxDayFirst
                                )
                            ),
                            IF(_isDayFirst, CHOOSECOLS(_numericParts, {2, 1}),
                                LET(
                                    _isDaySecond, IF(INDEX(_numericParts, 1, 2) < 1, FALSE,
                                        LET(
                                            _maxDaySecond, IF(ISNUMBER(_textMonth), CHRONO.DAYS_IN_MONTH(_textMonth, INDEX(_numericParts, 1, 1), _julianCalendar), 31),
                                            INDEX(_numericParts, 1, 2) <= _maxDaySecond
                                        )
                                    ),
                                    IF(_isDaySecond,
                                        _numericParts,
                                        HSTACK(INDEX(_numericParts, 1, 2), {#NUM!})
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
FORMAT_LITERARY_DATETIME

Returns a date and time formatted in literary style.

Array compatible: Date_YMDWT as columns

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | Literary date

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YMDWT       | array   C[1..5]  |
   [YearCE]      | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
   [Month]       | integer [1..12]  | 
   [Day]         | decimal [0..31]  | 
   [DayOfWeek]   | integer [1..7]   | Applicable if any of year, month or day are omitted.
   [Time]        | decimal [0..1]   | 
[Options]        | text             | [W][R][E][T][J][K][L][A][LowOrder]
                 |                  |        W : Display weekday.
                 |                  |        R : Display short-form month and weekday.
                 |                  |        G : No comma delimiters.
                 |                  |        E : Always apply era suffix. If not used, only years less than 1000
                 |                  |            show an era.
                 |                  |        T : Use traditional era notation AD|BC instead of secular BCE|CE.
                 |                  |        J : Dotted monikers B.C.E|C.E.|A.M.|P.M.
                 |                  |        K : No space preceding monikers BCE|CE|AM|PM.
                 |                  |        L : Lower case am|pm.
                 |                  | LowOrder : Low order component. Defaults to minute.
                 |                  |            D : Day
                 |                  |            H : Hour
                 |                  |            M : Minute
                 |                  |            S : Second
[LanguageCode]   | text             | Language. If omitted then local language set in Excel.
[JulianCalendar] | switch           | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                  | proleptic calendar.

Examples
----------------------------------------------------------------------------------------------------------------
FORMAT_LITERARY_DATETIME({2014, 2, 25, 0.25}, "WRETJKL")
Returns: "Tue Feb 25th 2014AD 6:00am"

FORMAT_LITERARY_DATETIME({"", 12, 31})
Returns: "December 31st"

FORMAT_LITERARY_DATETIME({2000, 3}, "")
Returns: "March, 2000"
--------------------------------------------------------------------------------------------------------------*/
FORMAT_LITERARY_DATETIME = LAMBDA(Date_YMDWT, [Options], [LanguageCode], [JulianCalendar],
    LET(
        _options, IF(ISOMITTED(Options), "", Options),
        _languageID, FN.LANGUAGE_ID(FN.NULLIFY(LanguageCode)),
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,
        
        _showWeekday, IFERROR(SEARCH("W", _options), 0) > 0,
        _short, IFERROR(SEARCH("R", _options), 0) > 0,
        _delim, IF(IFERROR(SEARCH("G", _options), 0) > 0, " ", ", "),
        
        _yearOptions, FN.SIFT_FOR_CHARS(_options, "ETJK", 1),

        _timeOptions, "C" & FN.SIFT_FOR_CHARS(_options, "JKLDHMS"),
        _timeOfDayOptionSet, _FORMAT_TIME_OF_DAY_OPTIONS(_timeOptions, TRUE),

        fnValidate, LAMBDA(_YMDWT,
            IF(COLUMNS(_YMDWT) > 5, {#REF!},
                IF(ARRAYS.IS_EMPTY(_YMDWT), "",
                    LET(
                        _firstError, ARRAYS.H_ERROR(_YMDWT),
                        IF(ISERROR(_firstError), _firstError * {1},
                            IF(NOT(ARRAYS.IS_NUMERIC_NULL(_YMDWT)), {#VALUE!},
                                LET(
                                    _expandYMDWT, EXPAND(_YMDWT, 1, 5, ""),
                                    IF(ARRAYS.HAS_NEGATIVE(DROP(_expandYMDWT,, 1)), {#NUM!},
                                        IF(N(INDEX(_expandYMDWT, 1, 5)) > 1, {#NUM!}, _expandYMDWT)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ),

        fnResolveDatePart, LAMBDA(_validateYMDWT, _carryDay,
            LET(
                _YMD, TAKE(_validateYMDWT, 1, 3),
                IF(ARRAYS.IS_EMPTY(_YMD), HSTACK("", "", "", ""),
                    LET(
                        _resolveYMD, IF(_carryDay = 0, _YMD,
                            IF(ARRAYS.HAS_EMPTY(_YMD), _YMD,
                                LET(
                                    _MJDN, CHRONO.MJDN(_YMD, _julianCalendar) + _carryDay,
                                    CHRONO.MJDN_TO_CALENDAR_DATE(_MJDN, _julianCalendar)
                                )
                            )
                        ),
                        _sYear, CHRONO.FORMAT_LITERARY_YEAR(INDEX(_resolveYMD, 1, 1), _yearOptions),
                        _sMonth, CHRONO.MONTH_NAME(INDEX(_resolveYMD, 1, 2), _short, _languageID),
                        _sDay, FN.FORMAT_ORDINAL(INDEX(_resolveYMD, 1, 3)),
                        _sMonthDay, TEXTJOIN(" ", TRUE, _sMonth, _sDay),
                        _sDate, TEXTJOIN(_delim, TRUE, _sMonthDay, _sYear),
                        HSTACK(_sDate, _resolveYMD)
                    )
                )
            )
        ),

        fnResolveWeekday, LAMBDA(_YMD, _DoW,
            IF(ARRAYS.IS_EMPTY(_YMD) * FN.IS_EMPTY(_DoW), "",
                LET(
                    _resolvedDoW, IF(ARRAYS.HAS_EMPTY(_YMD), _DoW,
                        LET(
                            _MJDN, CHRONO.MJDN(_YMD, _julianCalendar),
                            CHRONO.MJDN_TO_WEEKDAY(_MJDN)
                        )
                    ),
                    CHRONO.WEEKDAY_NAME(_resolvedDoW, _short, _languageID)
                )
            )
        ),
        
        fnFormatLiteraryDateTime, LAMBDA(_date_YMDWT,
            LET(
                _validateYMDWT, fnValidate(_date_YMDWT),
                IF(COLUMNS(_validateYMDWT) = 1, INDEX(_validateYMDWT, 1, 1),
                    LET(
                        _time, INDEX(_validateYMDWT, 1, 5),
                        _DT, _FORMAT_TIME_OF_DAY(_time, _timeOfDayOptionSet),
                        _carryDay, INDEX(_DT, 1, 1),
                        _timePart, INDEX(_DT, 1, 2),
                        _dateInfo, fnResolveDatePart(_validateYMDWT, _carryDay),
                        _datePart, INDEX(_dateInfo, 1, 1),
                        _resolveYMD, DROP(_dateInfo,,1),
                        _sDateTime, TEXTJOIN(_delim, TRUE, _datePart, _timePart),
                        IF(NOT(_showWeekday), _sDateTime, 
                            LET(
                                _sDoW, fnResolveWeekday(_resolveYMD, INDEX(_validateYMDWT, 1, 4)),
                                TEXTJOIN(_delim, TRUE, _sDoW, _sDateTime)
                            )
                        )
                    )
                )
            )
        ),
        
        BYROW(FN.NULLIFY(Date_YMDWT),
            LAMBDA(_row,
                fnFormatLiteraryDateTime(_row)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_MIL_DTG

Parses a date-time group in the format used by US Military message traffic, into respective parts of year,
month, day, time of day and time zone offset in minutes.

Array compatible: Expression as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [1951..2050] | Year
 2 | integer [1..12]      | Month
 3 | integer [1..31]      | Day
 4 | decimal [0..1)       | Time
 5 | decimal [-900..900]  | Time zone offset minutes

Parameters
----------------------------------------------------------------------------------------------------------------
DTG | text | Date-time group in US Military format ie. ddHHmmssZmmmYY

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_MIL_DTG("12 15 30 45 B MAY 23")
Returns: {2023, 5, 12, 0.77118055, 120}

PARSE_MIL_DTG("05064515KJUN00")
Returns: {2000, 6, 5, 0.281423611, 600}

PARSE_MIL_DTG("150600Z")
Returns: { , , 15, 0.25, 0}
--------------------------------------------------------------------------------------------------------------*/
PARSE_MIL_DTG = LAMBDA(Expression,
    LET(
        _valErr, {#VALUE!, #VALUE!, #VALUE!, #VALUE!, #VALUE!},

        fnParseDTG, LAMBDA(_expr,
            IF(ISERROR(_expr), _expr * {1, 2, 3, 4, 5},
                LET(
                    _DTG, SUBSTITUTE(_expr, " ", ""),
                    IF(_DTG = "", {"", "", "", "", ""},
                        IF(NOT(FN.VALIDATE_CHARSET(_DTG, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ", 1)), _valErr,
                            LET(
                                fnYear, LAMBDA(_sYear,
                                    LET(
                                        _yy, VALUE(_sYear),
                                        IF(_yy < 51, 2000 + _yy, 1900 + _yy)
                                    )
                                ),

                                fnParseFull, LAMBDA(_DTG,
                                    LET(
                                        _YMD, HSTACK(
                                            fnYear(RIGHT(_DTG, 2)),
                                            CHRONO.PARSE_MONTH(MID(_DTG, 10, 3)),
                                            VALUE(LEFT(_DTG, 2))
                                        ),
                                        IF(NOT(CHRONO.IS_VALID_CALENDAR_DATE(_YMD, TRUE, FALSE)), _valErr,
                                            LET(
                                                _HMS, HSTACK(
                                                    VALUE(MID(_DTG, 3, 2)),
                                                    VALUE(MID(_DTG, 5, 2)),
                                                    VALUE(MID(_DTG, 7, 2))
                                                ),
                                                _ToD, CHRONO.TIME_OF_DAY(_HMS),
                                                _TZ, IFNA(CHRONO.MILITARY_TZO(MID(_DTG, 9, 1)), ""),
                                                HSTACK(_YMD, _ToD, _TZ)
                                            )
                                        )
                                    )
                                ),

                                fnParseShort, LAMBDA(_DTG,
                                    LET(
                                        _YMD, HSTACK(
                                            fnYear(RIGHT(_DTG, 2)),
                                            CHRONO.PARSE_MONTH(MID(_DTG, 8, 3)),
                                            VALUE(LEFT(_DTG, 2))
                                        ),
                                        IF(NOT(CHRONO.IS_VALID_CALENDAR_DATE(_YMD, TRUE, FALSE)), _valErr,
                                            LET(
                                                _HMS, HSTACK(
                                                    VALUE(MID(_DTG, 3, 2)),
                                                    VALUE(MID(_DTG, 5, 2)),
                                                    0
                                                ),
                                                _ToD, CHRONO.TIME_OF_DAY(_HMS),
                                                _TZ, IFNA(CHRONO.MILITARY_TZO(MID(_DTG, 7, 1)), ""),
                                                HSTACK(_YMD, _ToD, _TZ)
                                            )
                                        )
                                    )
                                ),

                                fnParsePlan, LAMBDA(_DTG,
                                    LET(
                                        _YMD, HSTACK("", "", VALUE(LEFT(_DTG, 2))),
                                        _HMS, HSTACK(
                                            VALUE(MID(_DTG, 3, 2)),
                                            VALUE(MID(_DTG, 5, 2)),
                                            0
                                        ),
                                        _ToD, CHRONO.TIME_OF_DAY(_HMS),
                                        _TZ, IFNA(CHRONO.MILITARY_TZO(MID(_DTG, 7, 1)), ""),
                                        HSTACK(_YMD, _ToD, _TZ)
                                    )
                                ),

                                _len, LEN(_DTG),
                                SWITCH(_len,
                                    14, fnParseFull(_DTG),
                                    12, fnParseShort(_DTG),
                                    7, fnParsePlan(_DTG),
                                    _valErr
                                )
                            )
                        )
                    )
                )
            )
        ),

        _expression, FN.NULLIFY(INDEX(Expression, , 1)),
        _rowCount, ROWS(_expression),
        _byRow, REDUCE("", SEQUENCE(_rowCount),
            LAMBDA(_acc, _curr,
                VSTACK(
                    _acc,
                    fnParseDTG(INDEX(_expression, _curr, 1))
                )
            )
        ),
        DROP(_byRow, 1)
    )
);


/*--------------------------------------------------------------------------------------------------------
FORMAT_MIL_DTG

Returns a date formatted in US Military message traffic style.

Array compatible: Date_YMDT as columns

Output
----------------------------------------------------------------------------------------------------------
 1 | text | DTG formatted date

Parameters
----------------------------------------------------------------------------------------------------------
Year         | integer         |
             | [1951..2050]    |
Month        | integer [1..12] |
Day          | integer [1..31] |
Time         | decimal [0..1)  | Time of day as decimal fraction of a day.
[TZOMinutes] | decimal         | Time zone offset from UTC in minutes
             | [-900..900]     | Assumed to be UTC if omitted. [-15:00..+15:00]
             |                 | Time will be converted if the offset does not align with military
             |                 | time zones.
[Options]    | text            | String with elements: [M][X][N|F]
             |                 |     M : Short format, omits seconds.
             |                 |     X : Insert spacing between components.
             |                 |  N, F : Override rounding behaviour.
             |                 |         Default method rounds to nearest second and then truncates to low order component.
             |                 |         N: always round to nearest.
             |                 |         F: always round down.

Examples
----------------------------------------------------------------------------------------------------------
FORMAT_MIL_DTG(2023, 2, 12, 0.75, 600, 1)
Returns: 121800KFEB23

FORMAT_MIL_DTG( , , 12, 0.25)
Returns: 120600J
--------------------------------------------------------------------------------------------------------*/
FORMAT_MIL_DTG = LAMBDA(Date_YMDT, [TZOMinutes], [Options],
    LET(
        _tzo, FN.NULLIFY(TZOMinutes),
        _militaryTZ, LET(
            _z, IF(_tzo = "", {#N/A}, _tzo),
            CHRONO.TZO_TO_MILITARY(_z)
        ),
        _sTZ, INDEX(_militaryTZ, 1, 1),
        _milOffset, INDEX(_militaryTZ, 1, 3),

        _options, FN.NULLIFY(Options),
        _short, IFERROR(SEARCH("S", _options), 0) > 0,
        _spacing, IFERROR(SEARCH("X", _options), 0) > 0,
        _spc, IF(_spacing, " ", ""),
        _timeFmt, IF(_short,
            IF(_spacing, "[HH] mm", "[HH]mm"),
            IF(_spacing, "[HH] mm ss", "[HH]mmss")
        ),
        
        _lowOrder, 4 - N(_short), 
        _roundingOverride, LET(
            _r, LEFT(FN.SIFT_FOR_CHARS(_options, "NF")),
            SWITCH(_r,
                "N", 1,
                "F", -1,
                0
            )
        ),

        fnFormatTime, LAMBDA(_time,
            LET(
                _nominalTime, N(_time) + _milOffset,
                IF(_nominalTime = 1, HSTACK(0, TEXT(1, _timeFmt)),
                    LET(
                        _DT, CHRONO.ROUND_TO_DT(_nominalTime, _lowOrder, 0, _roundingOverride),
                        _ToD, INDEX(_DT, 1, 2),
                        _carryDay, INDEX(_DT, 1, 1),
                        _sTime, TEXT(_ToD, _timeFmt),
                        HSTACK(_carryDay, _sTime)
                    )
                )
            )
        ),

        fnFormatDTG, LAMBDA(_date_YMDT,
            IF(COLUMNS(_date_YMDT) <> 4, {#REF!},
                IF(ARRAYS.IS_EMPTY(_date_YMDT), "",
                    LET(
                        _firstError, ARRAYS.H_ERROR(_date_YMDT),
                        IF(ISERROR(_firstError), _firstError * {1},
                            IF(NOT(ARRAYS.IS_NUMERIC_NULL(_date_YMDT)), {#VALUE!},
                                IF(INDEX(_date_YMDT, 1, 3) = "", {#VALUE!},
                                    LET(
                                        _isPlanner, ARRAYS.IS_EMPTY(TAKE(_date_YMDT, 1, 2)),
                                        IF(_isPlanner,
                                            LET(
                                                _DT, fnFormatTime(INDEX(_date_YMDT, 1, 4)),
                                                _day, N(INDEX(_date_YMDT, 1, 3)) + INDEX(_DT, 1, 1),
                                                _sDay, TEXT(_day, "00"),
                                                _sTime, INDEX(_DT, 1, 2),
                                                CONCAT(_sDay, _spc, _sTime, _spc, _sTZ)
                                            ),
                                            LET(
                                                _validateYMD, CHRONO.VALIDATE_CALENDAR_DATE(TAKE(_date_YMDT, 1, 3), FALSE),
                                                _firstError1, ARRAYS.H_ERROR(_validateYMD),
                                                IF(ISERROR(_firstError1), _firstError1 * {1},
                                                    LET(
                                                        _DT, fnFormatTime(INDEX(_date_YMDT, 1, 4)),
                                                        _day, INDEX(_validateYMD, 1, 3) + INDEX(_DT, 1, 1),
                                                        _resolveYMD, CHRONO.RESOLVE_CALENDAR_DATE(HSTACK(TAKE(_validateYMD, 1, 2), _day), FALSE),
                                                        _year, INDEX(_resolveYMD, 1, 1),
                                                        IF((_year < 1951) + (_year > 2050), {#NUM!},
                                                            LET(
                                                                _sTime, INDEX(_DT, 1, 2),
                                                                _sDay, TEXT(INDEX(_resolveYMD, 1, 3), "00"),
                                                                _sMonth, UPPER(MONTH_NAME(INDEX(_resolveYMD, 1, 2), TRUE, TRUE)),
                                                                _sYY, TEXT(MOD(_year, 100), "00"),
                                                                CONCAT(_sDay, _spc, _sTime, _spc, _sTZ, _spc, _sMonth, _spc, _sYY)
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )

            )
        ),

        _date_YMDT, FN.NULLIFY(Date_YMDT),
        BYROW(_date_YMDT,
            LAMBDA(_row,
                fnFormatDTG(_row)
            )
        )
    )
);






/*##############################################################################################################
# WEEK DATE                                                                                                    #
##############################################################################################################*/


/*--------------------------------------------------------------------------------------------------------------
WEEKS_IN_YEAR

Returns the count of ISO defined weeks in a given year of the specified calendar.

Array compatible: YearCE only

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [52,53]

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE           | integer | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
WEEKS_IN_YEAR = LAMBDA(YearCE, [JulianCalendar],
    LET(
        _juilianCalendar, FN.COERCE(JulianCalendar) <> 0,

        fnLastWeekdayOfYear, LAMBDA(_yearCE,
            LET(
                _dayPrecession, IF(_juilianCalendar,
                    _yearCE + INT(_yearCE / 4) + 4,
                    _yearCE + INT(_yearCE / 4) - INT(_yearCE / 100) + INT(_yearCE / 400) + 6
                ),
                MOD(_dayPrecession, 7) + 1
            )
        ),

        fnWeeksInYear, LAMBDA(_yearCE,
            IF(ISERROR(_yearCE), _yearCE * {1},
                IF(_yearCE = "", "",
                    IF(NOT(ISNUMBER(_yearCE)), {#VALUE!},
                        LET(
                            _iYear, INT(_yearCE),
                            _dowLastDay, fnLastWeekDayOfYear(_iYear),
                            IF(_dowLastDay = 4, 53,  // if last day of year is a Thursday, then has an extra week
                                LET(
                                    _dowLastDayPrevYr, fnLastWeekDayOfYear(_iYear - 1),
                                    IF(_dowLastDayPrevYr = 3, 53, 52)  // if last day of previous year is a Wednesday, then has an extra week
                                )
                            )
                        )
                    )
                )
            )
        ),

        MAP(FN.NULLIFY(YearCE),
            LAMBDA(_element,
                fnWeeksInYear(_element)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
VALIDATE_ISO_WEEK_DATE

Validate a year, week and weekday representation of a ISO week date in a given calendar.

Array compatible: Date_YWD as columns

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer         | YearCE
 2 | integer [1..53] | ISO Week
 3 | integer [1..7]  | ISO Weekday

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YWD         | array   C[1..3] |
   YearCE        | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE.
   [ISOWeek]     | integer [1..53] | ISO week of year.
   [Weekday]     | decimal [1..8)  | ISO day of week.
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
VALIDATE_ISO_WEEK_DATE = LAMBDA(Date_YWD, [JulianCalendar],
    LET(
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,
        
        fnValidateWeekDate, LAMBDA(_date_YWD,
            IF(COLUMNS(_date_YWD) > 3, {#REF!, #REF!, #REF!},
                IF(ARRAYS.IS_EMPTY(_date_YWD), {"", "", ""},
                    LET(
                        _YWD, EXPAND(_date_YWD, 1, 3, ""),
                        _y, INDEX(_YWD, 1, 1),
                        _w, INDEX(_YWD, 1, 2),
                        _d, INDEX(_YWD, 1, 3),
                                    
                        _year, IF(ISERROR(_y), _y * {1},
                            IF(NOT(ISNUMBER(_y)), {#VALUE!},
                                IF(FN.IS_INTEGER(_y), _y, {#NUM!})
                            )
                        ),

                        _week, IF(ISERROR(_w), _w * {1},
                            IF(NOT(ISNUMBER(_w)), {#VALUE!},
                                IF(NOT(FN.IS_INTEGER(_w)), {#NUM!},
                                    IF((_w < 1) + (_w > 53), {#NUM!},
                                        IF(_w = 53,
                                            IF(ISERROR(_year), _w,
                                                LET(
                                                    _weeksInYear, CHRONO.WEEKS_IN_YEAR(_year, _julianCalendar),
                                                    IF(_w = _weeksInYear, 53, {#NUM!})
                                                )
                                            ),
                                             _w
                                        )
                                    )
                                )
                            )
                        ),
                                    
                        _weekday, IF(ISERROR(_d), _d * {1},
                            IF(_d = "", "",
                                IF(NOT(ISNUMBER(_d)), {#VALUE!},
                                    LET(
                                        _iDay, INT(_d),
                                        IF((_iDay >= 1) * (_iDay <= 7), _iDay, {#NUM!})
                                    )
                                )
                            )
                        ),
                        
                        HSTACK(_year, _week, _weekday)
                    )
                )
            )
        ),

        _date_YWD, FN.NULLIFY(Date_YWD),
        _rowCount, ROWS(_date_YWD),
        _byRow, REDUCE("", SEQUENCE(_rowCount),
            LAMBDA(_acc, _curr,
                VSTACK(
                    _acc,
                    fnValidateWeekDate(INDEX(_date_YWD, _curr,))
                )
            )
        ),
        DROP(_byRow, 1)
    )
);


/*--------------------------------------------------------------------------------------------------------------
IS_VALID_ISO_WEEK_DATE

Tests if a year, week and weekday representation of a ISO week date is valid for the given calendar.

Array compatible: Date_YWD as columns

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YWD         | array   C[1..3] |
   YearCE        | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE.
   [ISOWeek]     | integer [1..53] | ISO week of year.
   [Weekday]     | decimal [1..8)  | ISO day of week.
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
IS_VALID_ISO_WEEK_DATE = LAMBDA(Date_YWD, [JulianCalendar],
    LET(
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,

        fnIsValidWeekDate, LAMBDA(_date_YWD,
            IF(ARRAYS.IS_EMPTY(_date_YWD), FALSE,
                LET(
                    _validateYWD, CHRONO.VALIDATE_ISO_WEEK_DATE(_date_YWD, _julianCalendar),
                    NOT(ARRAYS.HAS_ERROR(_validateYWD))
                )
            )
        ),
        
        _date_YWD, FN.NULLIFY(Date_YWD),
        BYROW(_date_YWD,
            LAMBDA(_row,
                fnIsValidWeekDate(_row)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
RESOLVE_ISO_WEEK_DATE

Resolves an ISO week date where week and weekday values may exceed their modulus.

Array compatible: Date_YWD as columns

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer         | YearCE
 2 | integer [1..53] | ISO week
 3 | integer [1..7]  | ISO weekday
 4 | integer [52,53] | ISO weeks in year

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YWD         | array   C[1..3] |
   YearCE        | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE.
   [ISOWeek]     | integer         | ISO week of year.
   [Weekday]     | decimal         | ISO day of week.
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
RESOLVE_ISO_WEEK_DATE = LAMBDA(Date_YWD, [JulianCalendar],
    LET(
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,
       
        fnResolveWeekDate, LAMBDA(_date_YWD,
            IF(COLUMNS(_date_YWD) > 3, {#REF!, #REF!, #REF!, #REF!},
                IF(ARRAYS.IS_EMPTY(_date_YWD), {"", "", "", ""},
                    LET(
                        _firstError, ARRAYS.H_ERROR(_date_YWD),
                        IF(ISERROR(_firstError), _firstError * {1, 2, 3, 4},
                            IF(NOT(ARRAYS.IS_NUMERIC_NULL(_date_YWD)), {#VALUE!, #VALUE!, #VALUE!, #VALUE!},
                                IF(NOT(FN.IS_INTEGER(INDEX(_date_YWD, 1, 1))), {#NUM!, #NUM!, #NUM!, #NUM!},
                                    LET(
                                        _YWD, EXPAND(_date_YWD, 1, 3, 1),
                                        _baseYear, INDEX(_YWD, 1, 1),
                                        _w, INDEX(_YWD, 1, 2),
                                        _d, INDEX(_YWD, 1, 3),
                        
                                        _nominalWeek, IF(_w = "", 1, INT(_w)),
                                        _nominalWeekday, IF(_d = "", 1, INT(_d)),
                                        
                                        _MJDNofISOYear, CHRONO.ISO_WEEK_DATE_TO_MJDN(HSTACK(_baseYear, 1, 1), _julianCalendar) - 1,
                                        _MJDNofWeekDate, _MJDNofISOYear + ((_nominalWeek - 1) * 7) + _nominalWeekday,
                                        CHRONO.MJDN_TO_ISO_WEEK_DATE(_MJDNofWeekDate, _julianCalendar)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ),
        
        _date_YWD, FN.NULLIFY(Date_YWD),
        _rowCount, ROWS(_date_YWD),
        _byRow, REDUCE("", SEQUENCE(_rowCount),
            LAMBDA(_acc, _curr,
                VSTACK(
                    _acc,
                    fnResolveWeekDate(INDEX(_date_YWD, _curr, ))
                )
            )
        ),
        DROP(_byRow, 1)
    )
);


/*--------------------------------------------------------------------------------------------------------------
ISO_WEEK_DATE_TO_MJDN

Converts a ISO week date in the specified calendar to a Modified Julian Day Number (MJDN).

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Modified Julian Day Number

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YWD         | array   C[1..3] |
   YearCE        | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE.
   [ISOWeek]     | integer [1..53] | ISO week of year.
   [Weekday]     | decimal [1..8)  | ISO day of week.
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
ISO_WEEK_DATE_TO_MJDN = LAMBDA(Date_YWD, [JulianCalendar],
    LET(
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,

        fnISOWeekdateToMJDN, LAMBDA(_date_YWD,
            IF(ARRAYS.IS_EMPTY(_date_YWD), "",
                LET(
                    _firstError, ARRAYS.H_ERROR(_date_YWD),
                    IF(ISERROR(_firstError), _firstError * {1},
                        LET(
                            _validateYWD, CHRONO.VALIDATE_ISO_WEEK_DATE(_date_YWD, _julianCalendar),
                            _firstError1, ARRAYS.H_ERROR(_validateYWD),
                            IF(ISERROR(_firstError1), _firstError1 * {1},
                                LET(
                                    _year, INDEX(_validateYWD, 1, 1),
                                    _week, INDEX(_validateYWD, 1, 2),
                                    _weekday, LET(
                                        _d, INDEX(_validateYWD, 1, 3),
                                        IF(_d = "", 1, _d)
                                    ),
                                    _shiftWeek, (_week - 1) * 7,
                                    _shiftDayOfWeek, MOD(_weekday - 1, 7),
                                    _firstDayOfYear, CHRONO.MJDN(_year, _julianCalendar),
                                    _firstWeekDay, CHRONO.MJDN_TO_WEEKDAY(_firstDayOfYear),
                                    _yearCorrection, MOD(4 - _firstWeekDay, 7) - 3,
                                    _firstDayOfYear + _yearCorrection + _shiftWeek + _shiftDayOfWeek
                                )
                            )
                        )
                    )
                )
            )
        ),

        _date_YWD, FN.NULLIFY(Date_YWD),
        BYROW(_date_YWD,
            LAMBDA(_row,
                fnISOWeekdateToMJDN(_row)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
MJDN_TO_ISO_WEEK_DATE

Converts a Modified Julian Day Number (MJDN) to an ISO week date in the specified calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer         | YearCE
 2 | integer [1..53] | ISO Week
 3 | integer [1..7]  | ISO Weekday
 4 | integer [52,53] | ISO weeks in year

Parameters
----------------------------------------------------------------------------------------------------------------
MJDN             | integer | Modified Julian Day Number
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
MJDN_TO_ISO_WEEK_DATE = LAMBDA(MJDN, [JulianCalendar],
    LET(
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,

        fnMJDNtoISOWeekDate, LAMBDA(_MJDN,
            IF(ISERROR(_MJDN), _MJDN * {1, 2, 3, 4},
                IF(_MJDN = "", {"", "", "", ""}, 
                    IF(NOT(ISNUMBER(_MJDN)), {#VALUE!, #VALUE!, #VALUE!, #VALUE!},
                        LET(
                            _cDate, CHRONO.MJDN_TO_CALENDAR_DATE(_MJDN, _julianCalendar),
                            _year, INDEX(_cDate, 1, 1),
                            _weekday, CHRONO.MJDN_TO_WEEKDAY(_MJDN),
                            _MJDNofYear, CHRONO.MJDN(_year, _julianCalendar) - 1,
                            _dayOfYear, _MJDN - _MJDNofYear,
                            _nominalWeek, INT((_dayOfYear - _weekday + 10) / 7),
                            IF(_nominalWeek = 0,
                                // last week of previous year
                                LET(
                                    _previousYear, _year - 1,
                                    _weeksInYear, CHRONO.WEEKS_IN_YEAR(_previousYear, _julianCalendar),
                                    HSTACK(_previousYear, _weeksInYear, _weekday, _weeksInYear)
                                ),
                                IF(_nominalWeek = 53,
                                    // auxillary week
                                    IF(CHRONO.WEEKS_IN_YEAR(_year, _julianCalendar) = 53,
                                        // leap week
                                        HSTACK(_year, 53, _weekday, 53),
                                        LET(
                                            // first week of following year
                                            _nextYear, _year + 1,
                                            _weeksInYear, CHRONO.WEEKS_IN_YEAR(_nextYear, _julianCalendar),
                                            HSTACK(_nextYear, 1, _weekday, _weeksInYear)
                                        )
                                    ),
                                    LET(
                                        // any other week in the year
                                        _weeksInYear, CHRONO.WEEKS_IN_YEAR(_year, _julianCalendar),
                                        HSTACK(_year, _nominalWeek, _weekday, _weeksInYear)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ),

        _MJDN, FN.NULLIFY(INDEX(MJDN, , 1)),
        _rowCount, ROWS(_MJDN),
        _byRow, REDUCE("", SEQUENCE(_rowCount),
            LAMBDA(_acc, _curr,
                VSTACK(
                    _acc,
                    fnMJDNtoISOWeekDate(INDEX(_MJDN, _curr, 1))
                )
            )
        ),
        DROP(_byRow, 1)
    )
);


/*--------------------------------------------------------------------------------------------------------------
WEEKDAY_OF_MONTH_TO_MJDN

Returns a Modified Julian Date for a given day of week, relative week for the year and month of the specified calendar.

Array compatible: Date_YMWD as columns

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Modified Julian Day Number

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YWD         | array   C[1..3] |
   YearCE        | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE.
   Month         | integer [1..12] | Month
   Week          | integer         | Week relative to month.
   [Weekday]     | decimal [1..8)  | ISO day of week.
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
    
Examples
----------------------------------------------------------------------------------------------------------------
WEEKDAY_OF_MONTH_TO_MJDN({2023, 6, 0, 7})
Returns: MJDate 60120.0 (25/06/2023) ie. the last Sunday of June 2023

WEEKDAY_OF_MONTH_TO_MJDN({2023, 1, 2, 2)
Returns: MJDate 59954.5 (10/01/2023) ie. midday of the second Tuesday of January 2023
--------------------------------------------------------------------------------------------------------------*/
WEEKDAY_OF_MONTH_TO_MJDN = LAMBDA(Date_YMWD, [JulianCalendar],
    LET(
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,
       
        fnWeekdayMonthToMJDN, LAMBDA(_date_YMWD,
            IF(COLUMNS(_date_YMWD) > 4, {#REF!},
                IF(ARRAYS.IS_EMPTY(_date_YMWD), "",
                    LET(
                        _firstError, ARRAYS.H_ERROR(_date_YMWD),
                        IF(ISERROR(_firstError), _firstError * {1},
                            IF(NOT(ARRAYS.IS_NUMERIC_NULL(_date_YMWD)), {#VALUE!},
                                LET(
                                    _expandYMWD, EXPAND(_date_YMWD, 1, 4, 1),
                                    IF(NOT(ARRAYS.IS_INTEGER(TAKE(_expandYMWD, 1, 2))), {#NUM!},
                                        LET(
                                            _year, INDEX(_expandYMWD, 1, 1),
                                            _month, INDEX(_expandYMWD, 1, 2),
                                            _weekOfMonth, LET(
                                                _w, INDEX(_expandYMWD, 1, 3),
                                                IF(_w = "", 1, INT(_w))
                                            ),
                                            IF((_weekOfMonth > 5) + (_weekOfMonth < -4), {#NUM!},
                                                LET(
                                                    _weekday, LET(
                                                        _d, INDEX(_expandYMWD, 1, 4),
                                                        IF(_d = "", 1, INT(_d))
                                                    ),
                                                    IF((_weekday < 1) + (_weekday > 7), {#NUM!},
                                                        LET(
                                                            _monthOffset, _month + N(_weekOfMonth < 0) - 1,
                                                            _weekOffset, _weekOfMonth - N(_weekOfMonth >= 0),
                                                            _firstOfYear, CHRONO.MJDN(HSTACK(_year, 1, 1), _julianCalendar),
                                                            _firstOfMonth, CHRONO.MJDATE_ADDITION(_firstOfYear, _monthOffset, "L", _julianCalendar),
                                                            _firstDoW, CHRONO.MJDN_TO_WEEKDAY(_firstOfMonth),
                                                            _firstOfMonth + (_weekOffset * 7) + MOD(_weekday - _firstDoW, 7)
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ),
        
        _date_YMWD, FN.NULLIFY(Date_YMWD),
        BYROW(_date_YMWD,
            LAMBDA(_row,
                fnWeekdayMonthToMJDN(_row)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_ISO_WEEK_DATE

Parses an ISO formatted week date into respective parts of year, week and weekday.

Array compatible: Expression as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer         | YearCE
 2 | integer [1..53] | ISO week
 3 | integer [1..7]  | ISO week day

Parameters
----------------------------------------------------------------------------------------------------------------
Expression       | text   | Week date in ISO format ie. yyyy-Www-d
[JulianCalendar] | switch | Validate in the Julian proleptic calendar. Default is Gregorian
                 |        | proleptic calendar.

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_ISO_WEEK_DATE("2023-W05-1")
Returns: {2023, 5, 1}
--------------------------------------------------------------------------------------------------------------*/
PARSE_ISO_WEEK_DATE = LAMBDA(Expression, [JulianCalendar],
    LET(
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,
        _validCharSet, "0123456789W+-−", // − UNICHAR(8722)
        _valErr, {#VALUE!, #VALUE!, #VALUE!},
    
        fnParseISOWeekDate, LAMBDA(_expr,
            IF(ISERROR(_expr), _expr * {1, 2, 3},
                IF(_expr = "", {"", "", ""},
                    IF(NOT(FN.VALIDATE_CHARSET(_expr, _validCharSet)), _valErr,
                        LET(
                            _firstChar, LEFT(_expr),
                            _isSigned, SWITCH(_firstChar,
                                "+", TRUE,
                                "-", TRUE,
                                "−", TRUE, // − UNICHAR(8722)
                                FALSE
                            ),
                            _sign, IF(NOT(_isSigned), 1,
                                SWITCH(_firstChar,
                                    "-", -1,
                                    "−", -1, // − UNICHAR(8722)
                                    1
                                )
                            ),
                            _unSigned, IF(_isSigned,
                                RIGHT(_expr, LEN(_expr) - 1),
                                _expr
                            ),
                            _len, LEN(_unSigned),
                            _pattern, FN.REPLACE_CHARS(_unSigned, "0123456789", "_"),
            
                            fnTryParse10, LAMBDA(
                                IF(_pattern = RIGHT("_______________-W__-_", _len),
                                    HSTACK(
                                        _sign * VALUE(LEFT(_unSigned, _len - 6)),
                                        VALUE(MID(_unSigned, _len - 3, 2)),
                                        VALUE(RIGHT(_unSigned, 1))
                                    ),
                                    IF(_pattern = RIGHT("_______________-W__", _len),
                                        HSTACK(
                                            _sign * VALUE(LEFT(_unSigned, _len - 4)),
                                            VALUE(RIGHT(_unSigned, 2)),
                                            ""
                                        ),
                                        IF(_pattern = RIGHT("_______________W___", _len),
                                            HSTACK(
                                                _sign * VALUE(LEFT(_unSigned, _len - 4)),
                                                VALUE(MID(_unSigned, _len - 2, 2)),
                                                VALUE(RIGHT(_unSigned, 1))
                                            ),
                                            IF(_pattern = RIGHT("_______________W__", _len),
                                                HSTACK(
                                                    _sign * VALUE(LEFT(_unSigned, _len - 3)),
                                                    VALUE(RIGHT(_unSigned, 2)),
                                                    ""
                                                ),
                                                _valErr
                                            )
                                        )
                                    )
                                )
                            ),

                            fnTryParse8, LAMBDA(
                                IF(_pattern = RIGHT("_____-W__", _len),
                                    HSTACK(
                                        _sign * VALUE(LEFT(_unSigned, _len - 4)),
                                        VALUE(RIGHT(_unSigned, 2)),
                                        ""
                                    ),
                                    IF(_pattern = RIGHT("_____W___", _len),
                                        HSTACK(
                                            _sign * VALUE(LEFT(_unSigned, _len - 4)),
                                            VALUE(MID(_unSigned, _len - 2, 2)),
                                            VALUE(RIGHT(_unSigned, 1))
                                        ),
                                        IF(_pattern = RIGHT("______W__", _len),
                                            HSTACK(
                                                _sign * VALUE(LEFT(_unSigned, _len - 3)),
                                                VALUE(RIGHT(_unSigned, 2)),
                                                ""
                                            ),
                                            _valErr
                                        )
                                    )
                                )
                            ),

                            fnTryParse7, LAMBDA(
                                IF(_pattern = "____W__",
                                    HSTACK(
                                        _sign * VALUE(LEFT(_unSigned, _len - 3)),
                                        VALUE(RIGHT(_unSigned, 2)),
                                        ""
                                    ),
                                    _valErr
                                )
                            ),

                            fnTryParse4, LAMBDA(
                                IF(_pattern = RIGHT("_____", _len),
                                    HSTACK(
                                        _sign * VALUE(_unSigned),
                                        "",
                                        ""
                                    ),
                                    _valErr
                                )
                            ),
                            
                            _tryParse, IF(_len >= 10, fnTryParse10(),
                                IF(_len >= 8, fnTryParse8(),
                                    IF(_len = 7, fnTryParse7(),
                                        IF((_len = 5) + (_len = 4), fnTryParse4(),
                                            _valErr
                                        )
                                    )
                                )
                            ),
                            
                            IF(ISERROR(INDEX(_tryParse, 1, 1)), _tryParse,
                                CHRONO.VALIDATE_ISO_WEEK_DATE(_tryParse, _julianCalendar)
                            )
                        )
                    )
                )
            )
        ),

        _expression, FN.NULLIFY(INDEX(Expression, , 1)),
        _rowCount, ROWS(_expression),
        _byRow, REDUCE("", SEQUENCE(_rowCount),
            LAMBDA(_acc, _curr,
                VSTACK(
                    _acc,
                    fnParseISOWeekDate(INDEX(_expression, _curr, ))
                )
            )
        ),
        DROP(_byRow, 1)
    )
);


/*--------------------------------------------------------------------------------------------------------------
FORMAT_ISO_WEEK_DATE

Returns a week date as text in ISO format.

Array compatible: Date_YWD as columns

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | ISO formatted week date

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YWD         | array   C[1..3]  |
   YearCE        | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
   ISOWeek       | integer [1..53]  | ISO defined week of year.
   [Weekday]     | decimal [1..7)   | Weekday. Can be empty.
[Options]        | text             | [B][+]
                 |                  |   B : Display in basic ISO style.
                 |                  |   + : Display positive sign for non-negative years.
[JulianCalendar] | switch           | Calculate for the Julian proleptic calendar. Default is Gregorian
--------------------------------------------------------------------------------------------------------------*/
FORMAT_ISO_WEEK_DATE = LAMBDA(Date_YWD, [Options], [JulianCalendar],
    LET(
        _options, FN.NULLIFY(Options),
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,
        _basic, IFERROR(SEARCH("B", _options), 0) > 0,
        _alwaysSign, IFERROR(FIND("+", _options), 0) > 0, 
        _separator, IF(_basic, "", "-"),
        
        fnFormatISOWeekDate, LAMBDA(_date_YWD,
            IF(ARRAYS.IS_EMPTY(_date_YWD), "",
                LET(
                    _validateYWD, CHRONO.VALIDATE_ISO_WEEK_DATE(_date_YWD, _julianCalendar),
                    _firstError, ARRAYS.H_ERROR(_validateYWD),
                    IF(ISERROR(_firstError), _firstError * {1},
                        LET(
                            _sYear, CHRONO.FORMAT_ISO_YEAR(INDEX(_validateYWD, 1, 1), _alwaysSign), 
                            _sWeek, TEXT(INDEX(_validateYWD, 1, 2), "W00"),
                            IF(INDEX(_validateYWD, 1, 3) = "",
                                CONCAT(_sYear, _separator, _sWeek),
                                LET(
                                    _sDay, TEXT(INDEX(_validateYWD, 1, 3), "0"),
                                    CONCAT(_sYear, _separator, _sWeek, _separator, _sDay)
                                )
                            )
                        )
                    )
                )
            )
        ),

        _date_YWD, FN.NULLIFY(Date_YWD),
        BYROW(_date_YWD,
            LAMBDA(_row,
                fnFormatISOWeekDate(_row)
            )
        )
    )
);







/*##############################################################################################################
# QUARTER DATE                                                                                                 #
##############################################################################################################*/


/*--------------------------------------------------------------------------------------------------------------
DAYS_IN_QUARTER

Returns the count of days in a quarter of a given year in the specified calendar.

Array compatible: Quarter and FiscalYearCE as columns
                  Quarter as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [89..92]

Parameters
----------------------------------------------------------------------------------------------------------------
Quarter          | integer [1..4]  | Quarter of the year 1..4. Can exceed modulus.
[FiscalYearCE]   | integer         | Fiscal year. Optional. Assumed not a leap year if empty.
                 |                 | When month offset is non-zero the fiscal year spans calendar years and
                 |                 | is defined as the year where June falls.
[MonthOffset]    | integer [-6..3] | Quarter month offset from January. Defaults to 0.
                 |                 | Offsets by country:
                 |                 |   Australia  : -6
                 |                 |   Canada     :  0
                 |                 |   Germany    :  0
                 |                 |   UK         : +3
                 |                 |   US Federal : -3
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.

Examples
----------------------------------------------------------------------------------------------------------------
DAYS_IN_QUARTER(3, 2020, -6)
Returns: 91
i.e. 3rd quarter starting from July 2019, namely Jan, Feb, Mar 2020 with 31, 29, 31 days respectively
--------------------------------------------------------------------------------------------------------------*/
DAYS_IN_QUARTER = LAMBDA(Quarter, [FiscalYearCE], [MonthOffset], [JulianCalendar],
    LET(
        _monthOffset, LET(
            _mo, INT(FN.COERCE(MonthOffset)),
            IF((_mo >= -6) * (_mo <= 3), _mo, {#NUM!})
        ),
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,
        _daysInQuarterCyclical, {90,89,92,91,92,92,92,92,91,92,92,90},

        fnDaysInQuarter, LAMBDA(_quarter, _fiscalYear,
            IF(ISERROR(_monthOffset), _monthOffset * {1},
                IF(ISERROR(_quarter), _quarter * {1},
                    IF(ISERROR(_fiscalYear), _fiscalYear * {1},
                        IF(NOT(FN.IS_NUMERIC_NULL(_fiscalYear)), {#VALUE!},
                            IF(_quarter = "", "",
                                IF(NOT(ISNUMBER(_quarter)), {#VALUE!},
                                    LET(
                                        _nominalQuarter, INT(_quarter) - 1,
                                        _resolveQuarter, MOD(_nominalQuarter, 4), // 0..3
                                        _resolveYear, IF(_fiscalYear = "", "",
                                            INT(_fiscalYear) + INT(_nominalQuarter / 4)
                                        ),
                                        _quarterWithFeb, INT(MOD(1 - _monthOffset, 12) / 3),  // 0..3
                                        _quarterPrecession, MOD(_monthOffset + (_resolveQuarter * 3), 12) + 1,
                                        _nominalDaysInQuarter, INDEX(_daysInQuarterCyclical, 1, _quarterPrecession),
                                        _leapDay, IF(NOT(ISNUMBER(_resolveYear) * (_quarterWithFeb = _resolveQuarter)), 0,
                                            LET(
                                                _yearOfFeb, _resolveYear + N(_resolveQuarter = 3),
                                                N(IS_LEAP_YEAR(_yearOfFeb, _julianCalendar))
                                            )
                                        ),
                                        _nominalDaysInQuarter + _leapDay
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ),

        _quarter, FN.NULLIFY(INDEX(Quarter, , 1)),
        _fiscalYear, FN.NULLIFY(INDEX(FiscalYearCE, , 1)),
        _scalar, ROWS(_fiscalYear) = 1,
        _rowCount, MAX(ROWS(_quarter), ROWS(_fiscalYear)),

        _byRow, REDUCE("", SEQUENCE(_rowCount),
            LAMBDA(_acc, _curr,
                LET(
                    _fyIdx, IF(_scalar, 1, _curr),
                    _fy, INDEX(_fiscalYear, _fyIdx, 1),
                    _q, INDEX(_quarter, _curr, 1),
                    VSTACK(
                        _acc,
                        fnDaysInQuarter(_q, _fy)
                    )
                )
            )
        ),
        DROP(_byRow, 1)
    )
);


/*--------------------------------------------------------------------------------------------------------------
QUARTER_DATE_TO_MJDN
 
Returns the Modified Julian Day Number (MJDN) for a date expressed as fiscal year, quarter, and day of quarter
in the specified calendar.

Array compatible: DateYQD as columns

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Modified Julian Day Number

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YQD         | array   C[1..3] |
  FiscalYearCE   | integer         | Fiscal year
                 |                 | When month offset is non-zero the fiscal year spans calendar years and
                 |                 | is defined as the year where June falls.
  Quarter        | integer [1..4]  | Quarter of the year 1..4. Can exceed modulus.
  [DayOfQuarter] | integer [1..92] | Day of quarter. Can exceed modulus. Can be empty.
[MonthOffset]    | integer [-6..3] | Quarter month offset from January
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
QUARTER_DATE_TO_MJDN = LAMBDA(Date_YQD, [MonthOffset], [JulianCalendar],
    LET(
        _monthOffset, LET(
            _mo, INT(FN.COERCE(MonthOffset)),
            IF((_mo >= -6) * (_mo <= 3), _mo, {#NUM!})
        ),
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,
        
        fnQuarterDateToMJDN, LAMBDA(_YQD,
            IF(ARRAYS.IS_EMPTY(_YQD), "",
                LET(
                    _firstError, ARRAYS.H_ERROR(_YQD),
                    IF(ISERROR(_firstError), _firstError * {1},
                        IF(NOT(ISNUMBER(INDEX(_YQD, 1, 1))), {#VALUE!},
                            IF(ISERROR(_monthOffset), _monthOffset * {1},
                                LET(
                                    _expandYQD, EXPAND(_YQD, 1, 3, 1),
                                    _nominalYQD, IF(_expandYQD = "", 1, INT(_expandYQD)),
                                    _nominalQuarter, INDEX(_nominalYQD, 1, 2) - 1, // 0..3
                                    _shiftMonth, (_nominalQuarter * 3) + _monthOffset,
                                    _year, INDEX(_nominalYQD, 1, 1) + INT(_shiftMonth / 12),
                                    _month, MOD(_shiftMonth, 12) + 1,
                                    _MJDNofQuarter, CHRONO.MJDN(HSTACK(_year, _month, 1), _julianCalendar) - 1,
                                    _MJDNofQuarter + INDEX(_nominalYQD, 1, 3)
                                )
                            )
                        )
                    )
                )
            )
        ),

        _date_YQD, FN.NULLIFY(Date_YQD),
        BYROW(_date_YQD,
            LAMBDA(_row,
                fnQuarterDateToMJDN(_row)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
MJDN_TO_QUARTER_DATE

Converts Modified Julian Day Number (MJDN) to a date expressed as fiscal year, quarter and day of quarter in the
specified calendar.

Array compatible: MJDN as column

Output C[1..3]
----------------------------------------------------------------------------------------------------------------
 1 | integer          | Fiscal year
   |                  | When month offset is non-zero the fiscal year spans calendar years and
   |                  | is defined as the year where June falls.
 2 | integer [1..4]   | Quarter of the year 1..4.
 3 | integer [1..92]  | Day of quarter.
 4 | integer [89..92] | Day in quarter.

Parameters
----------------------------------------------------------------------------------------------------------------
MJDN             | integer         | Modified Julian Day Number
[MonthOffset]    | integer [-6..3] | Quarter month offset from January
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
MJDN_TO_QUARTER_DATE = LAMBDA(MJDN, [MonthOffset], [JulianCalendar],
    LET(
        _monthOffset, LET(
            _mo, INT(FN.COERCE(MonthOffset)),
            IF((_mo >= -6) * (_mo <= 3), _mo, {#NUM!})
        ),
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,
        
        fnMJDNtoYQD, LAMBDA(_MJDN,
            IF(ISERROR(_MJDN), _MJDN * {1, 2, 3, 4},
                IF(_MJDN = "", {"", "", "", ""},
                    IF(NOT(ISNUMBER(_MJDN)), {#VALUE!, #VALUE!, #VALUE!, #VALUE!},
                        IF(ISERROR(_monthOffset), _monthOffset * {1, 2, 3, 4},
                            LET(
                                _cDate, CHRONO.MJDN_TO_CALENDAR_DATE(MJDN, _julianCalendar),
                                _shiftMonth, INDEX(_cDate, 1, 2) - 1 - _monthOffset,
                                _fiscalYear, INDEX(_cDate, 1, 1) + INT(_shiftMonth / 12),
                                _zeroBasedFiscalMonth, MOD(_shiftMonth, 12),
                                _quarter, INT(_zeroBasedFiscalMonth / 3) + 1,
                                _MJDNofQuarter, CHRONO.QUARTER_DATE_TO_MJDN(HSTACK(_fiscalYear, _quarter, 1), _monthOffset, _julianCalendar),
                                _dayOfQuarter, MJDN - _MJDNofQuarter + 1,
                                _daysInQuarter, CHRONO.DAYS_IN_QUARTER(_quarter, _fiscalYear, _monthOffset, _julianCalendar),
                                HSTACK(_fiscalYear, _quarter, _dayOfQuarter, _daysInQuarter)
                            )
                        )
                    )
                )
            )
        ),

        _MJDN, FN.NULLIFY(INDEX(MJDN, , 1)),
        _rowCount, ROWS(_MJDN),
        _byRow, REDUCE("", SEQUENCE(_rowCount),
            LAMBDA(_acc, _curr,
                VSTACK(
                    _acc,
                    fnMJDNtoYQD(INDEX(_MJDN, _curr, 1))
                )
            )
        ),
        DROP(_byRow, 1)
    )
);













/*##############################################################################################################
# DELTAS                                                                                                       #
##############################################################################################################*/


/*--------------------------------------------------------------------------------------------------------------
DELTA_MONTHS

Returns the timespan difference between Modified Julian Dates in months. Calculated on basis of an average of
days per month for the calendar.

Array compatible: StartMJDate and EndMJDate as columns

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Difference in months

Parameters
----------------------------------------------------------------------------------------------------------------
StartMJDate      | decimal | Start Modified Julian Date 
EndMJDate        | decimal | End Modified Julian Date
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
DELTA_MONTHS = LAMBDA(StartMJDate, EndMJDate, [JulianCalendar],
    LET(
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,
        _avgMonthDaysGregorian, 30.436875,
        _avgMonthDaysJulian, 30.4375,
        _avgMonthDays, IF(_julianCalendar, _avgMonthDaysJulian, _avgMonthDaysGregorian),

        fnDeltaMonths, LAMBDA(_startMJDate, _endMJDate,
            IF(FN.IS_EMPTY(_startMJDate) * FN.IS_EMPTY(_endMJDate), "",
                LET(
                    _months, (_endMJDate - _startMJDate) / _avgMonthDays,
                    IF(ISERROR(_months), _months * {1},
                        _months
                    )
                )
            )
        ),

        _startMJDate, FN.NULLIFY(INDEX(StartMJDate, , 1)),
        _endMJDate , FN.NULLIFY(INDEX(EndMJDate, , 1)),

        _rowsStart, ROWS(_startMJDate),
        _rowsEnd, ROWS(_endMJDate),
        _rowCount, MAX(_rowsStart, _rowsEnd),

        _byRow, IF(_rowsStart = 1,
            REDUCE("", SEQUENCE(_rowCount),
                LAMBDA(_acc, _curr,
                    VSTACK(
                        _acc,
                        fnDeltaMonths(_startMJDate, INDEX(_endMJDate, _curr, 1))
                    )
                )
            ),
            IF(_rowsEnd = 1,
                REDUCE("", SEQUENCE(_rowCount),
                    LAMBDA(_acc, _curr,
                        VSTACK(
                            _acc,
                            fnDeltaMonths(INDEX(_startMJDate, _curr, 1), _endMJDate)
                        )
                    )
                ),
                REDUCE("", SEQUENCE(_rowCount),
                    LAMBDA(_acc, _curr,
                        VSTACK(
                            _acc,
                            fnDeltaMonths(INDEX(_startMJDate, _curr, 1), INDEX(_endMJDate, _curr, 1))
                        )
                    )
                )
            )
        ),

        DROP(_byRow, 1)
    )
);


/*--------------------------------------------------------------------------------------------------------------
DELTA_YEARS

Returns the timespan difference between Modified Julian Dates in years. Calculated on basis of an average of
days per year for the calendar.

Array compatible: StartMJDate and EndMJDate as columns

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Difference in years

Parameters
----------------------------------------------------------------------------------------------------------------
StartMJDate      | decimal | Start Modified Julian Date 
EndMJDate        | decimal | End Modified Julian Date
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
DELTA_YEARS = LAMBDA(StartMJDate, EndMJDate, [JulianCalendar],
    LET(
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,
        _avgYearDaysGregorian, 365.2425,
        _avgYearDaysJulian, 365.25,
        _avgYearDays, IF(_julianCalendar, _avgYearDaysJulian, _avgYearDaysGregorian),

        fnDeltaYears, LAMBDA(_startMJDate, _endMJDate,
            IF(FN.IS_EMPTY(_startMJDate) * FN.IS_EMPTY(_endMJDate), "",
                LET(
                    _years, (_endMJDate - _startMJDate) / _avgYearDays,
                    IF(ISERROR(_years), _years * {1},
                        _years
                    )
                )
            )
        ),

        _startMJDate, FN.NULLIFY(INDEX(StartMJDate, , 1)),
        _endMJDate , FN.NULLIFY(INDEX(EndMJDate, , 1)),

        _rowsStart, ROWS(_startMJDate),
        _rowsEnd, ROWS(_endMJDate),
        _rowCount, MAX(_rowsStart, _rowsEnd),

        _byRow, IF(_rowsStart = 1,
            REDUCE("", SEQUENCE(_rowCount),
                LAMBDA(_acc, _curr,
                    VSTACK(
                        _acc,
                        fnDeltaYears(_startMJDate, INDEX(_endMJDate, _curr, 1))
                    )
                )
            ),
            IF(_rowsEnd = 1,
                REDUCE("", SEQUENCE(_rowCount),
                    LAMBDA(_acc, _curr,
                        VSTACK(
                            _acc,
                            fnDeltaYears(INDEX(_startMJDate, _curr, 1), _endMJDate)
                        )
                    )
                ),
                REDUCE("", SEQUENCE(_rowCount),
                    LAMBDA(_acc, _curr,
                        VSTACK(
                            _acc,
                            fnDeltaYears(INDEX(_startMJDate, _curr, 1), INDEX(_endMJDate, _curr, 1))
                        )
                    )
                )
            )
        ),

        DROP(_byRow, 1)
    )
);


/*--------------------------------------------------------------------------------------------------------------
DELTA_YMD

Returns the timespan difference between Modified Julian Dates in years, months and days.
Due to months having different lengths, the result should not be used in further mathematical operations.

Array compatible: StartMJDate and EndMJDate as columns

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Delta years
 3 | integer [0..11]  | Delta months
 4 | decimal [0..31)  | Delta days

Parameters
----------------------------------------------------------------------------------------------------------------
StartMJDate      | decimal | Start Modified Julian Date 
EndMJDate        | decimal | End Modified Julian Date
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
DELTA_YMD = LAMBDA(StartMJDate, EndMJDate, [JulianCalendar],
    LET(
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,
        
        fnDeltaYMD, LAMBDA(_startMJDate, _endMJDate,
            IF(ISERROR(_startMJDate), _startMJDate * {1, 2, 3, 4},
                IF(ISERROR(_endMJDate), _endMJDate * {1, 2, 3, 4},
                    IF(FN.IS_EMPTY(_startMJDate) * FN.IS_EMPTY(_endMJDate), {"", "", "", ""},
                        IF(_startMJDate = _endMJDate, {0, 0, 0, 0},
                            LET(
                                _sign, IF(_startMJDate <= _endMJDate, 1, -1),
                                _date_A, CHRONO.MJDATE_TO_YMDT(
                                    IF(_sign = 1, _startMJDate, _endMJDate), , , ,
                                    _julianCalendar
                                ),
                                _date_B, CHRONO.MJDATE_TO_YMDT(
                                    IF(_sign = 1, _endMJDate, _startMJDate), , , ,
                                    _julianCalendar
                                ),
                                _diffDays, INDEX(_date_B, 1, 3) - INDEX(_date_A, 1, 3)
                                    + INDEX(_date_B, 1, 4) - INDEX(_date_A, 1, 4),
                                _deltaDay, IF(_diffDays >= 0, _diffDays,
                                    LET(
                                        _daysMonth_A, CHRONO.DAYS_IN_MONTH(INDEX(_date_A, 1, 2), INDEX(_date_A, 1, 1), _julianCalendar),
                                        MOD(_diffDays, _daysMonth_A)
                                    )
                                ),
                                _diffMonths, INDEX(_date_B, 1, 2) - INDEX(_date_A, 1, 2) - N(_diffDays < 0),
                                _deltaMonth, MOD(_diffMonths, 12),
                                _deltaYear, INDEX(_date_B, 1, 1) - INDEX(_date_A, 1, 1) - N(_diffMonths < 0),
                                HSTACK(_sign, _deltaYear, _deltaMonth, _deltaDay)
                            )
                        )
                    )
                )
            )
        ),

        _startMJDate, FN.NULLIFY(INDEX(StartMJDate, , 1)),
        _endMJDate , FN.NULLIFY(INDEX(EndMJDate, , 1)),

        _rowsStart, ROWS(_startMJDate),
        _rowsEnd, ROWS(_endMJDate),
        _rowCount, MAX(_rowsStart, _rowsEnd),

        _byRow, IF(_rowsStart = 1,
            REDUCE("", SEQUENCE(_rowCount),
                LAMBDA(_acc, _curr,
                    VSTACK(
                        _acc,
                        fnDeltaYMD(_startMJDate, INDEX(_endMJDate, _curr, 1))
                    )
                )
            ),
            IF(_rowsEnd = 1,
                REDUCE("", SEQUENCE(_rowCount),
                    LAMBDA(_acc, _curr,
                        VSTACK(
                            _acc,
                            fnDeltaYMD(INDEX(_startMJDate, _curr, 1), _endMJDate)
                        )
                    )
                ),
                REDUCE("", SEQUENCE(_rowCount),
                    LAMBDA(_acc, _curr,
                        VSTACK(
                            _acc,
                            fnDeltaYMD(INDEX(_startMJDate, _curr, 1), INDEX(_endMJDate, _curr, 1))
                        )
                    )
                )
            )
        ),

        DROP(_byRow, 1)
    )
);


/*--------------------------------------------------------------------------------------------------------------
DELTA_YWD

Returns the timespan difference between Modified Julian Dates in years, ISO weeks and days.
Due to years having differing numbers of ISO weeks, the result should not be used in further mathematical operations.

Array compatible: StartMJDate and EndMJDate as columns

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Delta years
 3 | integer [0..52]  | Delta weeks
 4 | decimal [0..31)  | Delta days

Parameters
----------------------------------------------------------------------------------------------------------------
StartMJDate      | decimal | Start Modified Julian Date 
EndMJDate        | decimal | End Modified Julian Date
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
DELTA_YWD = LAMBDA(StartMJDate, EndMJDate, [JulianCalendar],
    LET(
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,
        
        fnDeltaYWD, LAMBDA(_startMJDate, _endMJDate,
            IF(ISERROR(_startMJDate), _startMJDate * {1, 2, 3, 4},
                IF(ISERROR(_endMJDate), _endMJDate * {1, 2, 3, 4},
                    IF(FN.IS_EMPTY(_startMJDate) * FN.IS_EMPTY(_endMJDate), {"", "", "", ""},
                        IF(_startMJDate = _endMJDate, {0, 0, 0, 0},
                            LET(
                                _sign, IF(_startMJDate <= _endMJDate, 1, -1),
                                _date_A, CHRONO.MJDATE_TO_YMDT(
                                    IF(_sign = 1, _startMJDate, _endMJDate), , , ,
                                    _julianCalendar
                                ),
                                _date_B, CHRONO.MJDATE_TO_YMDT(
                                    IF(_sign = 1, _endMJDate, _startMJDate), , , ,
                                    _julianCalendar
                                ),
                                
                                _diffYears, INDEX(_date_B, 1, 1) - INDEX(_date_A, 1, 1),
                                _deltaYear, IF(_diffYears = 0, 0, _diffYears - 1),
                                _diffDays, IF(_diffYears = 0, _sign * (_endMJDate - _startMJDate),
                                    LET(
                                        _prevYear, INDEX(_date_B, 1, 1) - 1,
                                        _prevYearMJDate, CHRONO.MODIFIED_JULIAN_DATE(
                                            HSTACK(_prevYear, DROP(_date_A, , 1)),
                                            _julianCalendar
                                        ),
                                        IF(_sign = 1, _endMJDate, _startMJDate) - _prevYearMJDate
                                    )
                                ),

                                _deltaWeek, INT(_diffDays / 7),
                                _deltaDay, MOD(_diffDays, 7),
                                HSTACK(_sign, _deltaYear, _deltaWeek, _deltaDay)
                            )
                        )
                    )
                )
            )
        ),

        _startMJDate, FN.NULLIFY(INDEX(StartMJDate, , 1)),
        _endMJDate , FN.NULLIFY(INDEX(EndMJDate, , 1)),

        _rowsStart, ROWS(_startMJDate),
        _rowsEnd, ROWS(_endMJDate),
        _rowCount, MAX(_rowsStart, _rowsEnd),

        _byRow, IF(_rowsStart = 1,
            REDUCE("", SEQUENCE(_rowCount),
                LAMBDA(_acc, _curr,
                    VSTACK(
                        _acc,
                        fnDeltaYWD(_startMJDate, INDEX(_endMJDate, _curr, 1))
                    )
                )
            ),
            IF(_rowsEnd = 1,
                REDUCE("", SEQUENCE(_rowCount),
                    LAMBDA(_acc, _curr,
                        VSTACK(
                            _acc,
                            fnDeltaYWD(INDEX(_startMJDate, _curr, 1), _endMJDate)
                        )
                    )
                ),
                REDUCE("", SEQUENCE(_rowCount),
                    LAMBDA(_acc, _curr,
                        VSTACK(
                            _acc,
                            fnDeltaYWD(INDEX(_startMJDate, _curr, 1), INDEX(_endMJDate, _curr, 1))
                        )
                    )
                )
            )
        ),

        DROP(_byRow, 1)
    )
);








/*##############################################################################################################
# CONVERSIONS                                                                                                  #
##############################################################################################################*/


/*--------------------------------------------------------------------------------------------------------------
ISO_DATETIME_TO_MJDATE

Converts an ISO formatted date and time to a Modified Julian Date and time zone offset.

Array compatible: Expression as column.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal         | Local Modifed Julian Date
 2 | decimal         | Time zone offset from UTC as decimal fraction of a day.
   | [-0.625..0.625] | -15:00..+15:00

Parameters
----------------------------------------------------------------------------------------------------------------
Expression         | text   | Date, time and time zone offset in ISO format
[StrictISO]        | switch | Enforce strict ISO validation. No mixing of basic and extended formats. eg. yyyyMMddThh:mm
[JulianCalendar]   | switch | Calculate for the Julian proleptic calendar. Default is Gregorian
                   |        | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
ISO_DATETIME_TO_MJDATE = LAMBDA(Expression, [StrictISO], [JulianCalendar],
    LET(
        _strictISO, FN.COERCE(StrictISO) <> 0,
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,

        fnISOtoMJDate, LAMBDA(_expr,
            IF(FN.IS_EMPTY(_expr), {"", ""},
                LET(
                    _isoDateTime, CHRONO.PARSE_ISO_DATETIME(_expr, _strictISO, _julianCalendar),
                    _y, CHOOSECOLS(_isoDateTime, 1),
                    _t, CHOOSECOLS(_isoDateTime, 4),
                    _tzo, CHOOSECOLS(_isoDateTime, 5),
                    _dateValError, HSTACK({#VALUE!}, _tzo),
                    IF(ISERROR(_y), _dateValError,
                        IF(NOT(FN.IS_NUMERIC_NULL(_t)), _dateValError,
                            IF(FN.IS_EMPTY(_y), _dateValError,
                                LET(
                                    _MJDate, CHRONO.MODIFIED_JULIAN_DATE(DROP(_isoDateTime, , -1), _julianCalendar),
                                    HSTACK(_MJDate, _tzo)
                                )
                            )
                        )
                    )
                )
            )
        ),

        _expression, FN.NULLIFY(INDEX(Expression, , 1)),
        _rowCount, ROWS(_expression),
        _byRow, REDUCE("", SEQUENCE(_rowCount),
            LAMBDA(_acc, _curr,
                VSTACK(
                    _acc,
                    fnISOtoMJDate(INDEX(_expression, _curr, 1))
                )
            )
        ),
        DROP(_byRow, 1)
    )
);


/*--------------------------------------------------------------------------------------------------------------
MJDATE_TO_ISO_DATETIME

Converts a Modified Julian Date and time zone offset to an ISO formatted date and time.

Array compatible: MJDate only.

Output
----------------------------------------------------------------------------------------------------------------
 1 | text  | ISO formated date and time

Parameters
----------------------------------------------------------------------------------------------------------------
MJDate           | decimal     | Modified Julian Date
[TZOMinutes]     | decimal     | Time zone offset from UTC in minutes
                 | [-900..900] | [-15:00..+15:00]
[Options]        | text        | [B][+][Z][A][N|F][LowOrder][*][0-9]
                 |             |        B : Display in basic ISO style.
                 |             |        + : Display positive sign for non-negative years.
                 |             |        Z : Display 'Z' for Zulu time zone +00:00
                 |             |        A : Display a time value of 24:00 to represent midnight at the end of the calendar day.
                 |             |            Not applicable if LowOrder is D.
                 |             |     N, F : Override rounding behaviour. Default method rounds to nearest second, and
                 |             |            rounds down on other low order components.
                 |             |            N: always round to nearest.
                 |             |            F: always round down
                 |             | LowOrder : Low order component. Upper case to set explicitly. Lower case allows floating
                 |             |            from expressing in the given component down to seconds as needed.
                 |             |            Takes the following:
                 |             |            D, d : Day
                 |             |            H, h : Hour
                 |             |            M, m : Minute
                 |             |            S, s : Second 
                 |             |        * : Allows floating down the lowest order component needed, including the maximum precision
                 |             |            for seconds.
                 |             |      0-9 : Decimal places for seconds. * floats up to a maximum precision of 9.
[JulianCalendar] | switch      | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |             | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
MJDATE_TO_ISO_DATETIME = LAMBDA(MJDate, [TZOMinutes], [Options], [JulianCalendar],
    LET(
        _TZOMinutes, FN.NULLIFY(TZOMinutes),
        _options, FN.NULLIFY(Options),
        _julianCalendar, FN.COERCE(JulianCalendar) <> 0,
        
        fnISODateTime, LAMBDA(_MJDate,
            IF(ISERROR(_MJDate), _MJDate * {1},
                IF(_MJDate = "", "",
                    LET(
                        _date_YMDT, CHRONO.MJDATE_TO_YMDT(_MJDate, , , , _julianCalendar),
                        FORMAT_ISO_DATETIME(_date_YMDT, TZOMinutes, Options, _julianCalendar)
                    )
                )
            )
        ),

        MAP(FN.NULLIFY(MJDate),
            LAMBDA(_element,
                fnISODateTime(_element)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
EXCELDATE_TO_MJDATE

Converts an Excel Date/Time to a Modified Julian Date.
Note Excel Date/Time uses the Gregorian calendar.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal          | Modified Julian Date.
   | [15019..2973484) |

Parameters
----------------------------------------------------------------------------------------------------------------
ExcelDate | decimal      | Excel Date/Time
          | [1..2958466) | 1900-01-01..9999-12-31
--------------------------------------------------------------------------------------------------------------*/
EXCELDATE_TO_MJDATE = LAMBDA(ExcelDate,
    IF(FN.IS_EMPTY(ExcelDate), "", ExcelDate + 15018)
);


/*--------------------------------------------------------------------------------------------------------------
MJDATE_TO_EXCELDATE

Converts a Modified Julian Date to an Excel Date/Time.
Note Excel Date/Time uses the Gregorian calendar.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal         | Excel Date/Time.
   | [1..2958466)    | 1900-01-01..9999-12-31

Parameters
----------------------------------------------------------------------------------------------------------------
MJDate  | decimal          | Modified Julian Date
        | [15019..2973484) |
--------------------------------------------------------------------------------------------------------------*/
MJDATE_TO_EXCELDATE = LAMBDA(MJDate,
    IF(FN.IS_EMPTY(MJDate), "",
        IF(NOT((MJDate >= 15019) * (MJDate < 2973484)), {#NUM!},
            MJDate - 15018
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
ISO_DATETIME_TO_EXCELDATE

Converts an ISO formatted date and time to an Excel Date/Time and time zone offset.
Note Excel Date/Time uses the Gregorian calendar.

Array compatible: Expression as column.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal         | Excel Date/Time.
   | [1..2958466)    | 1900-01-01..9999-12-31
 2 | decimal         | Time zone offset from UTC as decimal fraction of a day.
   | [-0.625..0.625] | -15:00..+15:00

Parameters
----------------------------------------------------------------------------------------------------------------
Expression         | text   | Date, time and time zone offset in ISO format
                   |        | 1900-01-01T00:00:00 .. 9999-12-31T23:59:59
[StrictISO]        | switch | Enforce strict ISO validation. No mixing of basic and extended formats. eg. yyyyMMddThh:mm
--------------------------------------------------------------------------------------------------------------*/
ISO_DATETIME_TO_EXCELDATE = LAMBDA(Expression, [StrictISO],
    LET(
        _MJDateTZO, CHRONO.ISO_DATETIME_TO_MJDATE(Expression, StrictISO, FALSE),
        _excelDate, CHRONO.MJDATE_TO_EXCELDATE(CHOOSECOLS(_MJDateTZO, 1)),
        _TZO, CHOOSECOLS(_MJDateTZO, 2),
        HSTACK(_excelDate, _TZO)
    )
);


/*--------------------------------------------------------------------------------------------------------------
EXCELDATE_TO_ISO_DATETIME

Converts an Excel Date/Time and time zone offset to an ISO formatted date and time.
Note Excel Date/Time uses the Gregorian calendar.

Array compatible: ExcelDate only.

Output
----------------------------------------------------------------------------------------------------------------
 1 | text  | ISO formated date and time

Parameters
----------------------------------------------------------------------------------------------------------------
ExcelDate    | decimal      | Excel Date/Time.
             | [1..2958466) | 1900-01-01..9999-12-31
[TZOMinutes] | decimal      | Time zone offset from UTC in minutes
             | [-900..900]  | Assumed to be UTC if omitted. [-15:00..+15:00]
[Options]    | text         | [B][+][Z][A][N|F][LowOrder][*][0-9]
             |              |        B : Display in basic ISO style.
             |              |        + : Display positive sign for non-negative years.
             |              |        Z : Display 'Z' for Zulu time zone +00:00
             |              |        A : Display a time value of 24:00 to represent midnight at the end of the calendar day.
             |              |            Not applicable if LowOrder is D.
             |              |     N, F : Override rounding behaviour. Default method rounds to nearest second, and
             |              |            rounds down on other low order components.
             |              |            N: always round to nearest.
             |              |            F: always round down
             |              | LowOrder : Low order component. Upper case to set explicitly. Lower case allows floating
             |              |            from expressing in the given component down to seconds as needed.
             |              |            Takes the following:
             |              |            D, d : Day
             |              |            H, h : Hour
             |              |            M, m : Minute
             |              |            S, s : Second 
             |              |        * : Allows floating down the lowest order component needed, including the maximum precision
             |              |            for seconds.
             |              |      0-9 : Decimal places for seconds. * floats up to a maximum precision of 9.
--------------------------------------------------------------------------------------------------------------*/
EXCELDATE_TO_ISO_DATETIME = LAMBDA(ExcelDate, [TZOMinutes], [Options],
    LET(
        _MJDate, CHRONO.EXCELDATE_TO_MJDATE(ExcelDate),
        CHRONO.MJDATE_TO_ISO_DATETIME(_MJDate, TZOMinutes, Options, FALSE)
    )
);


/*--------------------------------------------------------------------------------------------------------------
USDATE_TO_EXCELDATE

Converts a US format date to an Excel Date/Time.
Note Excel Date/Time uses the Gregorian calendar.

Array compatible: Expression as column.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal      | Excel Date/Time.
   | [1..2958466) | 1900-01-01..9999-12-31

Parameters
----------------------------------------------------------------------------------------------------------------
USDate | text | Date in US format ie. MM/dd/yyyy hh:mm:ss
--------------------------------------------------------------------------------------------------------------*/
USDATE_TO_EXCELDATE = LAMBDA(Expression,
    IF(FN.IS_EMPTY(Expression), "",
        LET(
            _date_YMDT, CHRONO.PARSE_DATETIME(Expression, TRUE, FALSE),
            DATE(
                CHOOSECOLS(_date_YMDT, 1),
                CHOOSECOLS(_date_YMDT, 2),
                CHOOSECOLS(_date_YMDT, 3)
            ) + N(CHOOSECOLS(_date_YMDT, 4))
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
EXCELDATE_TO_USDATE

Converts an Excel Date/Time to a US format date.
Note Excel Date/Time uses the Gregorian calendar.

Array compatible: Expression as column.

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | US format date and time

Parameters
----------------------------------------------------------------------------------------------------------------
ExcelDate | decimal | Excel Date/Time.
[Options] | text    | String with elements: [<][LowOrder][DateSeparator][TimeSeparator]
          |         |      LowOrder : low order component to display
          |         |          Null : Defaults to minutes if time present, otherwise day
          |         |             D : Day
          |         |             H : Hour
          |         |             M : Minute
          |         |             S : Second
          |         |             T : Millisecond (ticks)
          |         |             < : Round by truncating components. Default is rounding to nearest.
          |         | DateSeparator : Character to separate date components. [,./-_]
          |         | TimeSeparator : Character to separate time components. [,.:-_]
--------------------------------------------------------------------------------------------------------------*/
EXCELDATE_TO_USDATE = LAMBDA(ExcelDate, [Options],
    LET(
        _options, "V" & FN.NULLIFY(Options),
        
        _YMDT, HSTACK(
            YEAR(ExcelDate),
            MONTH(ExcelDate),
            DAY(ExcelDate),
            MOD(ExcelDate, 1)
        ),
        CHRONO.FORMAT_DATETIME(_YMDT, _options, FALSE)
    )
);



/*##############################################################################################################
# END CALENDAR MODULE                                                                                          #
##############################################################################################################*/
