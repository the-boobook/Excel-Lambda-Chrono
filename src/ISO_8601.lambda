/*########################################################################################################
# ISO_8601 v1                                                                                            #   
#                                                                                                        #
# The ISO 8601 standard defines a universal notation of calendar date and times.                         #
# Dates are in the Gregorian calendar and times are based on the 24 hour timekeeping system with an      #
# optional time zone offset from UTC.                                                                    #
#                                                                                                        #
# Module Dependencies: None                                                                              #
#                                                                                                        #
# Logical Functions                                                                                      #
# ------------------------------------------------------------------------------------------------------ #
# IS_VALID_YEAR            Tests if a year is valid for ISO 8601.                                        # 
# IS_LEAP_YEAR             Tests if a year includes a leap day in the Gregorian calendar.                #
# IS_VALID_DATE            Tests if a date is valid for the Gregorian calendar.                          # 
# IS_VALID_TIME            Tests if a time is valid for the 24 hour timekeeping system.                  # 
# IS_VALID_TIME_ZONE       Tests if time zone offset in minutes is in valid range.                       #
# IS_VALID_ORDINAL_DATE    Tests if an ordinal date is valid for the Gregorian calendar.                 #
# IS_VALID_WEEK_DATE       Tests if a week date is valid for the Gregorian calendar.                     # 
#                                                                                                        #
# Calendar Functions                                                                                     #
# ------------------------------------------------------------------------------------------------------ #
# YEAR_DAY_COUNT           Returns the count of ordinal days for a given year.                           #
# YEAR_WEEK_COUNT          Returns the count of ISO defined weeks in a given year.                       #
# DAY_ORDINAL              Returns the ordinal day number of a date in the Gregorian calendar.           #
# FROM_ORDINAL_DATE        Returns the Gregorian calendar date from a given ordinal date.                #
# DAY_OF_WEEK              Returns the ISO defined day of week number for a given date.                  #
# DAY_OF_WEEK_FROM_ORDINAL Returns the ISO defined day of week number for a given ordinal date.          #
# WEEK_NUMBER              Returns the ISO defined week number of a given date.                          #
# WEEK_NUMBER_FROM_ORDINAL Returns the ISO defined week number of a given ordinal date.                  #
# TO_WEEK_DATE             Returns the ISO defined week number and day of week from a given date.        #
# FROM_WEEK_DATE           Returns the either a Gregorian calendar date or ordinal date from a given     #
#                          week and day of week.                                                         #
#                                                                                                        #
# Parsing Functions                                                                                      #
# ------------------------------------------------------------------------------------------------------ #
# VALIDATE_CHARACTERS      Tests if text contains only characters that are valid for ISO 8601.           #
# PARSE_DATE               Returns the year, month and day of a date from text in the ISO 8601 format.   #
# PARSE_TIME               Returns the hour, minute and second of time from text in the ISO 8601 format. #
# PARSE_TIME_ZONE          Returns the time zone offset in minutes from text in the ISO 8601 format.     #
# PARSE_PARTS              Splits ISO 8601 formatted text value into into respective parts of date,      #
#                          time and time zone.                                                           #
# PARSE_ISO8601            Returns the date and time complications from text in the ISO 8601 format.     #
#                                                                                                        #
# Formatting Functions                                                                                   #
# ------------------------------------------------------------------------------------------------------ #
# FORMAT_DATE              Returns a date as text in the ISO 8601 format.                                #
# FORMAT_TIME              Returns a time as text in the ISO 8601 format.                                #
# FORMAT_TIME_ZONE         Returns a time zone as text in the ISO 8601 format.                           #
# FORMAT_ORDINAL_DATE      Returns an ordinal date as text in the ISO 8601 format.                       #
# FORMAT_WEEK_DATE         Returns a week date as text in the ISO 8601 format.                           #
# FORMAT_ISO8601           Returns date and time complications as text in the ISO 8601 format.           #
#                                                                                                        #
# Conversion Functions                                                                                   #
# ------------------------------------------------------------------------------------------------------ #
# CONVERT_TO_DATE          Converts text in ISO format to an Excel date.                                 #
# CONVERT_FROM_DATE        Converts an Excel date to ISO formatted text.                                 #
#                                                                                                        #
########################################################################################################*/




/*########################################################################################################
# LOGICAL FUNCTIONS                                                                                      #
########################################################################################################*/


/*--------------------------------------------------------------------------------------------------------
IS_VALID_YEAR

Tests if a year is valid for ISO 8601. Note that 1 BC = 0 CE, 2 BC = -1 CE.

Output
----------------------------------------------------------------------------------------------------------
 1 | boolean

Parameters
----------------------------------------------------------------------------------------------------------
YearCE         | decimal | Year in Common Era -99999..+99999
[AllowDecimal] | switch  | Allow decimal value
--------------------------------------------------------------------------------------------------------*/
IS_VALID_YEAR = LAMBDA(YearCE, [AllowDecimal],
    IFS(
        NOT(ISNUMBER(YearCE)),
        FALSE,
        (N(AllowDecimal) = 0) * (YearCE <> INT(YearCE)),
        FALSE,
        TRUE,
        ABS(YearCE) < 100000
    )
);

/*--------------------------------------------------------------------------------------------------------
IS_LEAP_YEAR

Tests if a year includes a leap day in the Gregorian calendar.

Output
----------------------------------------------------------------------------------------------------------
 1 | boolean | #VALUE! if not a valid year.

Parameters
----------------------------------------------------------------------------------------------------------
YearCE    | decimal | Year in Common Era -99999..+99999
--------------------------------------------------------------------------------------------------------*/
IS_LEAP_YEAR = LAMBDA(YearCE,
    IF(
        NOT(IS_VALID_YEAR(YearCE, 1)),
        #VALUE!,
        LET(
            _yearCE, INT(YearCE),
            IF(MOD(_yearCE, 400) = 0, TRUE, IF(MOD(_yearCE, 100) = 0, FALSE, MOD(_yearCE, 4) = 0))
        )
    )
);

/*--------------------------------------------------------------------------------------------------------
IS_VALID_DATE

Tests if a date is valid for the Gregorian calendar.
If month and day missing, considered a year only date.
If only day is missing, considered a year and month date.
Only the last provided element can have a fractional value.

Output
----------------------------------------------------------------------------------------------------------
 1 | boolean

Parameters
----------------------------------------------------------------------------------------------------------
YearCE         | decimal | Year in Common Era -99999..+99999
Month          | decimal | Month of year
Day            | decimal | Day of month
[AllMandatory] | switch  | Disallow short forms: Year, Year and Month
--------------------------------------------------------------------------------------------------------*/
IS_VALID_DATE = LAMBDA(YearCE, Month, Day, [AllMandatory],
    LET(
        _elements, IFS(
            NOT(ISNUMBER(YearCE)),
            0,
            NOT(ISNUMBER(Month)) * ISNUMBER(Day),
            0,
            NOT(ISNUMBER(Month)) * NOT(ISNUMBER(Day)),
            1,
            NOT(ISNUMBER(Day)),
            2,
            TRUE,
            3
        ),
        IF(
            ((_elements = 0) + ((N(AllMandatory) <> 0) * (_elements < 3))) <> 0,
            // year is mandatory, and all elements mandatory if AllMandatory switch is set
            FALSE,
            IFS(
                _elements = 3, // year, month and day
                IF(
                    NOT(IS_VALID_YEAR(YearCE)),
                    FALSE,
                    IF(
                        Month <> INT(Month),
                        // month cannot be fractional
                        FALSE,
                        // test for month range 1..12
                        IF(
                            ((Month >= 1) * (Month <= 12)) = 0,
                            FALSE,
                            LET(
                                _day, INT(Day),
                                IFS(
                                    (Month = 2), // Feb
                                    ((_day >= 1) * (_day <= (28 + N(IS_LEAP_YEAR(YearCE))))) <> 0,
                                    (Month <= 7), // Jan, Mar, Apr, May, Jun, Jul
                                    ((_day >= 1) * (_day <= (30 + MOD(Month, 2)))) <> 0,
                                    (Month >= 8), // Aug, Sep, Oct, Nov, Dec
                                    (_day >= 1) * (_day <= (31 - MOD(Month, 2))) <> 0
                                )
                            )
                        )
                    )
                ),
                _elements = 2, // year and month
                IF(
                    NOT(IS_VALID_YEAR(YearCE)),
                    FALSE,
                    LET(
                        _month, INT(Month),
                        // test for month range 1..12
                        ((_month >= 1) * (_month <= 12)) <> 0
                    )
                ),
                _elements = 1, // year only
                IS_VALID_YEAR(YearCE, 1)
            )
        )
    )
);

/*--------------------------------------------------------------------------------------------------------
IS_VALID_TIME

Tests if a time is valid for the 24 hour timekeeping system.
Only the last provided element can have a fractional value.

Output
----------------------------------------------------------------------------------------------------------
 1 | boolean

Parameters
----------------------------------------------------------------------------------------------------------
Hour           | decimal | 0..24
Minute         | decimal | 0..59.999
Second         | decimal | 0..59.999
[AllMandatory] | switch  | Disallow short forms: Hour, Hour and Minute
--------------------------------------------------------------------------------------------------------*/
IS_VALID_TIME = LAMBDA(Hour, Minute, Second, [AllMandatory],
    LET(
        _elements, IFS(
            NOT(ISNUMBER(Hour)),
            0,
            NOT(ISNUMBER(Minute)) * ISNUMBER(Second),
            0,
            NOT(ISNUMBER(Minute)) * NOT(ISNUMBER(Second)),
            1,
            NOT(ISNUMBER(Second)),
            2,
            TRUE,
            3
        ),
        IF(
            ((_elements = 0) + ((N(AllMandatory) <> 0) * (_elements < 3))) <> 0,
            // hour is mandatory, and all elements mandatory if AllMandatory switch is set
            FALSE,
            IFS(
                _elements = 3, // hour, minute, second
                LET(
                    _secondX, ROUNDDOWN(Second * 10000, 0),
                    IFS(
                        // test hour is not fractional
                        Hour <> INT(Hour),
                        FALSE,
                        
                        // test hour in range 0..24
                        ((Hour >= 0) * (Hour <= 24)) = 0,
                        FALSE,
                        
                        // test minute is not fractional
                        Minute <> INT(Minute),
                        FALSE,
                        
                        // test minute in range 0..59
                        ((Minute >= 0) * (Minute <= 59)) = 0,
                        FALSE,
                        
                        // test zero minute and second for 24 hour
                        ((Hour = 24) * ((Minute <> 0) + (_secondX <> 0))) <> 0,
                        FALSE,
                        
                        // test second in range 0..59.999
                        ((_secondX >= 0) * (_secondX < 600000)) = 0,
                        FALSE,
                        TRUE,
                        TRUE
                    )
                ),
                _elements = 2, // hour and minute
                LET(
                    _minuteX, ROUNDDOWN(Minute * 600000, 0),
                    IFS(
                        // test hour is not fractional
                        Hour <> INT(Hour),
                        FALSE,
                        
                        // test hour in range 0..24
                        ((Hour >= 0) * (Hour <= 24)) = 0,
                        FALSE,
                        
                        // test zero minute for 24 hour
                        ((Hour = 24) * (_minuteX <> 0)) <> 0,
                        FALSE,
                        
                        // test minute in range 0..59.999
                        ((_minuteX >= 0) * (_minuteX < 36000000)) = 0,
                        FALSE,
                        TRUE,
                        TRUE
                    )
                ),
                _elements = 1, // hour only time
                LET(
                    _hourX, ROUNDDOWN(Hour * 36000000, 0),
                    // test hour in range 0..24
                    ((_hourX >= 0) * (_hourX <= 864000000)) <> 0
                )
            )
        )
    )
);

/*--------------------------------------------------------------------------------------------------------
IS_VALID_TIME_ZONE

Tests if time zone offset in minutes is in valid range.

Output
----------------------------------------------------------------------------------------------------------
 1 | boolean

Parameters
----------------------------------------------------------------------------------------------------------
OffsetMinutes | decimal | Range is -900..+900 -> -15:00..+15:00
--------------------------------------------------------------------------------------------------------*/
IS_VALID_TIME_ZONE = LAMBDA(OffsetMinutes,
    IF(NOT(ISNUMBER(OffsetMinutes)), FALSE, ((OffsetMinutes >= -900) * (OffsetMinutes <= 900)) <> 0)
);

/*--------------------------------------------------------------------------------------------------------
IS_VALID_ORDINAL_DATE

Tests if an ordinal date is valid for the Gregorian calendar.
Returns a boolean.

Parameters
----------------------------------------------------------------------------------------------------------
YearCE             | integer | Year in Common Era -99999..+99999
Ordinal            | decimal | Ordinal day of year
--------------------------------------------------------------------------------------------------------*/
IS_VALID_ORDINAL_DATE = LAMBDA(YearCE, Ordinal,
    IF(
        NOT(ISNUMBER(Ordinal)),
        FALSE, // Ordinal is mandatory
        IF(
            NOT(IS_VALID_YEAR(YearCE)),
            FALSE,
            LET(
                _ordinal, INT(Ordinal),
                _leapDay, N(IS_LEAP_YEAR(YearCE)),
                
                // test for valid ordinal date
                ((_ordinal >= 1) * (_ordinal <= (365 + _leapDay))) <> 0
            )
        )
    )
);

/*--------------------------------------------------------------------------------------------------------
IS_VALID_WEEK_DATE

Tests if a week date is valid for the Gregorian calendar.

Output
----------------------------------------------------------------------------------------------------------
 1 | boolean

Parameters
----------------------------------------------------------------------------------------------------------
YearCE               | integer | Year in Common Era -99999..+99999
Week                 | decimal | ISO defined week number of the year
DayOfWeek            | decimal | Day of the week where 1..7 -> Mon..Sun
[DayOfWeekMandatory] | switch  | DayOfWeek must be provided
--------------------------------------------------------------------------------------------------------*/
IS_VALID_WEEK_DATE = LAMBDA(YearCE, Week, DayOfWeek, [DayOfWeekMandatory],
    IF(
        NOT(IS_VALID_YEAR(YearCE)) + NOT(ISNUMBER(Week)),
        FALSE, // Year and Week mandatory
        LET(
            _ommitDoW, NOT(ISNUMBER(DayOfWeek)),
            IF(
                (N(DayOfWeekMandatory) <> 0) * _ommitDoW,
                FALSE, // DayOfWeekMandatory set and DayOfWeek is ommited
                LET(
                    // test if week in range
                    _week, INT(Week),
                    IF(
                        ((_week >= 1) * (_week <= YEAR_WEEK_COUNT(YearCE))) = 0,
                        FALSE,
                        IF(
                            _ommitDoW,
                            TRUE, // year and week
                            IF(
                                Week <> _week,
                                FALSE, // week has fractional value
                                LET(
                                    // test if day of week in range
                                    _dow, INT(DayOfWeek),
                                    ((_dow >= 1) * (_dow <= 7)) <> 0 // Test for DayOfWeek 1..7
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);



/*########################################################################################################
# CALENDAR FUNCTIONS                                                                                     #
########################################################################################################*/


/*--------------------------------------------------------------------------------------------------------
YEAR_DAY_COUNT

Returns the count of ordinal days for a given year.

Output
----------------------------------------------------------------------------------------------------------
 1 | integer | 365..366, #VALUE! if not a valid year

Parameters
----------------------------------------------------------------------------------------------------------
YearCE | decimal | Year in Common Era -99999..+99999
--------------------------------------------------------------------------------------------------------*/
YEAR_DAY_COUNT = LAMBDA(YearCE,
    IF(NOT(IS_VALID_YEAR(YearCE, 1)), #VALUE!, IF(IS_LEAP_YEAR(YearCE), 366, 365))
);

/*--------------------------------------------------------------------------------------------------------
YEAR_WEEK_COUNT

Returns the count of ISO defined weeks in a given year.

Output
----------------------------------------------------------------------------------------------------------
 1 | integer | 52..53, #VALUE! if not a valid year.

Parameters
----------------------------------------------------------------------------------------------------------
YearCE | decimal | Year in Common Era -99999..+99999
--------------------------------------------------------------------------------------------------------*/
YEAR_WEEK_COUNT = LAMBDA(YearCE,
    IF(
        NOT(IS_VALID_YEAR(YearCE, 1)),
        #VALUE!,
        LET(
            _yearCE, INT(YearCE),
            _dowLastDay, MOD(
                _yearCE + INT(_yearCE / 4) - INT(_yearCE / 100) + INT(_yearCE / 400),
                7
            ),
            IF(
                _dowLastDay = 4,
                // if last day of year is a Thursday, then has an extra week
                53,
                LET(
                    _lastYear, _yearCE - 1,
                    _dowLastDayPrev, MOD(
                        _lastYear + INT(_lastYear / 4) - INT(_lastYear / 100) +
                            INT(_lastYear / 400),
                        7
                    ),
                    IF(
                        _dowLastDayPrev = 3,
                        // if last day of previous year is a Wednesday, then has an extra week
                        53,
                        // otherwize
                        52
                    )
                )
            )
        )
    )
);

/*--------------------------------------------------------------------------------------------------------
DAY_ORDINAL

Returns the ordinal day number of a date in the Gregorian calendar.
Integer with range 1..366
#VALUE! if not a valid date.

Parameters
----------------------------------------------------------------------------------------------------------
YearCE | integer | Year in Common Era -99999..+99999
Month  | integer | Month of year
Day    | decimal | Day of month
--------------------------------------------------------------------------------------------------------*/
DAY_ORDINAL = LAMBDA(YearCE, Month, Day,
    IF(
        NOT(IS_VALID_DATE(YearCE, Month, Day, 1)),
        #VALUE!,
        LET(
            _monthOffset, {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334},
            _month, INT(Month),
            Day + INDEX(_monthOffset, , _month) + IF(_month <= 2, 0, N(IS_LEAP_YEAR(YearCE)))
        )
    )
);

/*--------------------------------------------------------------------------------------------------------
FROM_ORDINAL_DATE

Returns the Gregorian calendar date from a given ordinal date.
#VALUE! if not valid ordinal date.

Columns:
  1 | Year CE | integer | -99999..+99999
  2 | Month   | integer | 1..12
  3 | Day     | decimal | 1..31

Parameters
----------------------------------------------------------------------------------------------------------
YearCE  | integer | Year in Common Era -99999..+99999
Ordinal | decimal | Ordinal day of year
--------------------------------------------------------------------------------------------------------*/
FROM_ORDINAL_DATE = LAMBDA(YearCE, Ordinal,
    IF(
        NOT(IS_VALID_ORDINAL_DATE(YearCE, Ordinal)),
        #VALUE!,
        LET(
            _monthFirstOrdinal, IF(
                IS_LEAP_YEAR(YearCE),
                {1, 32, 61, 92, 122, 153, 183, 214, 245, 275, 306, 336},
                {1, 32, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335}
            ),
            _ordinal, INT(Ordinal),
            _month, XMATCH(_ordinal, _monthFirstOrdinal, -1, -1),
            _offset, INDEX(_monthFirstOrdinal, _month),
            _day, Ordinal - _offset + 1,
            HSTACK(YearCE, _month, _day)
        )
    )
);

/*--------------------------------------------------------------------------------------------------------
DAY_OF_WEEK

Returns the ISO defined day of week number for a given date.
  1 - Monday
  2 - Tuesday
  3 - Wednesday
  4 - Thurday
  5 - Friday
  6 - Saturday
  7 - Sunday
#VALUE! if not a valid date.

Parameters
----------------------------------------------------------------------------------------------------------
YearCE | integer | Year in Common Era -99999..+99999
Month  | integer | Month of year
Day    | decimal | Day of month
--------------------------------------------------------------------------------------------------------*/
DAY_OF_WEEK = LAMBDA(YearCE, Month, Day,
    IF(
        NOT(IS_VALID_DATE(YearCE, Month, Day, 1)),
        #VALUE!,
        LET(
            // Using Zeller Congruence, cf. https://en.wikipedia.org/wiki/Zeller%27s_congruence
            
            // Map months Mar..Feb -> 3..14
            _zellerMonth, MOD(INT(Month) - 3, 12) + 3,
            
            // Jan, Feb considered belonging to previous year
            _zellerYear, INT(YearCE) - INT(_zellerMonth / 13),
            _yearOfCent, MOD(_zellerYear, 100),
            _zeroBasedCent, INT(_zellerYear / 100),
            
            // Zeller Congruence for Gregorian calender
            // returns weekdays 0..6 -> Sat..Fri
            _zellerWeekDay, MOD(
                INT(Day) + INT(13 * (_zellerMonth + 1) / 5) + _yearOfCent + INT(_yearOfCent / 4) +
                    INT(_zeroBasedCent / 4) - 2 * _zeroBasedCent,
                7
            ),
            
            // Translate to ISO numbering 1..7 -> Mon..Sun
            MOD(_zellerWeekDay + 5, 7) + 1
        )
    )
);

/*--------------------------------------------------------------------------------------------------------
DAY_OF_WEEK_FROM_ORDINAL

Returns the ISO defined day of week number for a given ordinal date.
  1 - Monday
  2 - Tuesday
  3 - Wednesday
  4 - Thurday
  5 - Friday
  6 - Saturday
  7 - Sunday
#VALUE! if not a valid date.

Parameters
----------------------------------------------------------------------------------------------------------
YearCE  | integer | Year in Common Era -99999..+99999
Ordinal | decimal | Ordinal day of year
--------------------------------------------------------------------------------------------------------*/
DAY_OF_WEEK_FROM_ORDINAL = LAMBDA(YearCE, Ordinal,
    IF(
        NOT(IS_VALID_ORDINAL_DATE(YearCE, Ordinal)),
        #VALUE!,
        LET(
            _firstDayOfYear, DAY_OF_WEEK(YearCE, 1, 1),
            
            // Translate to ISO numbering 1..7 -> Mon..Sun
            MOD(_firstDayOfYear + INT(Ordinal) - 2, 7) + 1
        )
    )
);

/*--------------------------------------------------------------------------------------------------------
WEEK_NUMBER

Returns the ISO defined week number of a given date.
Integer with range 1..53
#VALUE! if not a valid date.

Parameters
----------------------------------------------------------------------------------------------------------
YearCE | integer | Year in Common Era -99999..+99999
Month  | integer | Month of year
Day    | decimal | Day of month
--------------------------------------------------------------------------------------------------------*/
WEEK_NUMBER = LAMBDA(YearCE, Month, Day,
    IF(
        NOT(IS_VALID_DATE(YearCE, Month, Day, 1)),
        #VALUE!,
        LET(
            _ordinal, DAY_ORDINAL(YearCE, Month, Day),
            _dayOfWeek, DAY_OF_WEEK(YearCE, Month, Day),
            _nominalWeek, INT((INT(_ordinal) - _dayOfWeek + 10) / 7),
            IFS(
                _nominalWeek = 0,
                // last week of previous year
                YEAR_WEEK_COUNT(YearCE - 1),
                _nominalWeek = 53,
                // if this year does not have 53 weeks, then is the first week of following year
                IF(YEAR_WEEK_COUNT(YearCE) = 53, 53, 1),
                TRUE,
                _nominalWeek
            )
        )
    )
);

/*--------------------------------------------------------------------------------------------------------
WEEK_NUMBER_FROM_ORDINAL

Returns the ISO defined week number of a given ordinal date.
Integer with range 1..53
#VALUE! if not a valid ordinal date.

Parameters
----------------------------------------------------------------------------------------------------------
YearCE  | integer | Year in Common Era -99999..+99999
Ordinal | decimal | Ordinal day of year
--------------------------------------------------------------------------------------------------------*/
WEEK_NUMBER_FROM_ORDINAL = LAMBDA(YearCE, Ordinal,
    IF(
        NOT(IS_VALID_ORDINAL_DATE(YearCE, Ordinal)),
        #VALUE!,
        LET(
            _dayOfWeek, DAY_OF_WEEK_FROM_ORDINAL(YearCE, Ordinal),
            _nominalWeek, INT((INT(Ordinal) - _dayOfWeek + 10) / 7),
            IFS(
                _nominalWeek = 0,
                // last week of previous year
                YEAR_WEEK_COUNT(YearCE - 1),
                _nominalWeek = 53,
                // if this year does not have 53 weeks, then is 1st week of following year
                IF(YEAR_WEEK_COUNT(YearCE) = 53, 53, 1),
                TRUE,
                _nominalWeek
            )
        )
    )
);

/*--------------------------------------------------------------------------------------------------------
TO_WEEK_DATE

Returns the ISO defined week number and day of week from a given date. The provided date can implicitly
be either a calendar date or ordininal date.

Output
----------------------------------------------------------------------------------------------------------
  1 | Year CE     | integer | -99999..+99999, #VALUE! if not a valid date
  2 | Week        | integer | 1..53
  3 | Day of week | decimal | 1..7 Mon..sun

Parameters
----------------------------------------------------------------------------------------------------------
YearCE  | integer | Year in Common Era -99999..+99999
Month   | integer | Month of the year. If ommitted, day is assumed to be ordinal.
Day     | decimal | Day of the month when month provided, otherwise ordinal day of the year.
--------------------------------------------------------------------------------------------------------*/
TO_WEEK_DATE = LAMBDA(YearCE, Month, Day,
    IF(
        ISNUMBER(Month),
        
        // parameters are a date
        IF(
            NOT(IS_VALID_DATE(YearCE, Month, Day, 1)),
            #VALUE!,
            LET(
                _fracDay, Day - INT(Day),
                _dow, DAY_OF_WEEK(YearCE, Month, Day),
                _week, WEEK_NUMBER(YearCE, Month, Day),
                _yearCE, INT(YearCE) +
                    IFS((_week = 1) * (Month = 12), 1, (_week >= 52) * (Month = 1), -1, TRUE, 0),
                HSTACK(_yearCE, _week, _dow + _fracDay)
            )
        ),
        
        // parameters are an ordinal date
        IF(
            NOT(IS_VALID_ORDINAL_DATE(YearCE, Day)),
            #VALUE!,
            LET(
                _fracDay, Day - INT(Day),
                _dow, DAY_OF_WEEK_FROM_ORDINAL(YearCE, Day),
                _week, WEEK_NUMBER_FROM_ORDINAL(YearCE, Day),
                _yearCE, INT(YearCE) +
                    IFS((_week = 1) * (Month = 12), 1, (_week >= 52) * (Month = 1), -1, TRUE, 0),
                HSTACK(_yearCE, _week, _dow + _fracDay)
            )
        )
    )
);

/*--------------------------------------------------------------------------------------------------------
FROM_WEEK_DATE

Returns the either a Gregorian calendar date or ordinal date from a given week and day of week.                                                                #

Output
----------------------------------------------------------------------------------------------------------
#VALUE! if not a valid week date.

ReturnOrdinal = FALSE
  1 | Year CE | integer | -99999..+99999
  2 | Month   | integer | 1..12
  3 | Day     | decimal | 1..31
ReturnOrdinal = TRUE
  1 | Year CE | integer | -99999..+99999
  2 | Ordinal | decimal | 1..366

Parameters
----------------------------------------------------------------------------------------------------------
YearCE          | integer | Year in Common Era -99999..+99999
Week            | integer | ISO defined week number of the year
DayOfWeek       | decimal | Day of the week where 1..7 -> Mon..Sun 
[ReturnOrdinal] | switch  | Return result as an ordinal date
--------------------------------------------------------------------------------------------------------*/
FROM_WEEK_DATE = LAMBDA(YearCE, Week, DayOfWeek, [ReturnOrdinal],
    IF(
        NOT(IS_VALID_WEEK_DATE(YearCE, Week, DayOfWeek, 1)),
        #VALUE!,
        LET(
            _yCorrection, DAY_OF_WEEK(YearCE, 1, 4) + 3,
            _ordinalDay, INT(Week) * 7 + DayOfWeek - _yCorrection,
            _intOrdinal, INT(_ordinalDay),
            IFS(
                _intOrdinal < 1,
                LET(
                    _prevYear, YearCE - 1,
                    _prevYearDayCount, YEAR_DAY_COUNT(_prevYear),
                    _adjustedOrdinalDay, _prevYearDayCount + _ordinalDay,
                    IF(
                        N(ReturnOrdinal) <> 0,
                        HSTACK(_prevYear, _adjustedOrdinalDay),
                        FROM_ORDINAL_DATE(_prevYear, _adjustedOrdinalDay)
                    )
                ),
                _intOrdinal <= 365,
                IF(
                    N(ReturnOrdinal) <> 0,
                    HSTACK(YearCE, _ordinalDay),
                    FROM_ORDINAL_DATE(YearCE, _ordinalDay)
                ),
                TRUE,
                LET(
                    _thisYearDayCount, YEAR_DAY_COUNT(YearCE),
                    IF(
                        _intOrdinal > _thisYearDayCount,
                        LET(
                            _nextYear, YearCE + 1,
                            _adjustedOrdinalDay, _ordinalDay - _thisYearDayCount,
                            IF(
                                N(ReturnOrdinal) <> 0,
                                HSTACK(_nextYear, _adjustedOrdinalDay),
                                FROM_ORDINAL_DATE(_nextYear, _adjustedOrdinalDay)
                            )
                        ),
                        
                        // last day of a leap year
                        IF(
                            N(ReturnOrdinal) <> 0,
                            HSTACK(YearCE, _ordinalDay),
                            FROM_ORDINAL_DATE(YearCE, _ordinalDay)
                        )
                    )
                )
            )
        )
    )
);



/*########################################################################################################
# PARSING FUNCTIONS                                                                                      #
########################################################################################################*/


/*--------------------------------------------------------------------------------------------------------
VALIDATE_CHARACTERS

Tests if text contains only characters that are valid for ISO 8601.

Output
----------------------------------------------------------------------------------------------------------
 1 | boolean, null if empty string provided

Parameters
----------------------------------------------------------------------------------------------------------
Text     | string  | ISO 8601 formatted text.
[Subset] | integer | Subset format to match
         |         |   0 - date, time and timezone  +,-.0123456789:TWZ− (default)
         |         |   1 - date                     +-0123456789W−
         |         |   2 - time                     ,.0123456789:T
         |         |   3 - time zone                +-0123456789:Z−
         |         |   4 - date and time            +,-.0123456789:TW−
         |         |   5 - time and time zone       +,-.0123456789:TZ−
         |         |   6 - duration                 ,-.0123456789:DHMPSTWY
         |         |   7 - interval                 +,-./0123456789:DHMPSTWYZ−
         |         |   8 - full                     +,-./0123456789:DHMPRSTWYZ−
--------------------------------------------------------------------------------------------------------*/
VALIDATE_CHARACTERS = LAMBDA(Text, [Subset],
    IF(
        Text = "",
        "",
        LET(
            _idx, INT(N(Subset)),
            _charSet, IFS(
                _idx <= 0,
                // date, time and time zone
                "+,-.0123456789:TWZ" & UNICHAR(8722),
                _idx = 1,
                // date
                "+-0123456789W" & UNICHAR(8722),
                _idx = 2,
                // time
                ",.0123456789:T",
                _idx = 3,
                // time zone
                "+-0123456789:Z" & UNICHAR(8722),
                _idx = 4,
                // date and time
                "+,-.0123456789:TW" & UNICHAR(8722),
                _idx = 5,
                // time and time zone
                "+,-.0123456789:TZ" & UNICHAR(8722),
                _idx = 6,
                // duration
                ",-.0123456789:DHMPSTWY",
                _idx = 7,
                // interval
                "+,-./0123456789:DHMPSTWYZ" & UNICHAR(8722),
                _idx >= 8,
                // full
                "+,-./0123456789:DHMPRSTWYZ" & UNICHAR(8722)
            ),
            _escapeText, SUBSTITUTE(SUBSTITUTE(Text, "&", "&amp;"), "<", "&lt;"),
            _xml, "<t><s>" & _escapeText & "</s></t>",
            _xpath, "//s[translate(.,'" & _charSet & "','')='']",
            NOT(ISERROR(FILTERXML(_xml, _xpath)))
        )
    )
);

/*--------------------------------------------------------------------------------------------------------
PARSE_DATE

Returns the year, month and day of a date from text in the ISO 8601 format.
Note YYYYMM is invalid, due to collision with truncated format YYMMDD in earlier versions of ISO 8601.

Output
----------------------------------------------------------------------------------------------------------
  1 | ISOCompliant | boolean | Flag if compliant to ISO 8601 standard
  2 | Precision    | integer | 0 - invalid value
    |              |         | 1 - year
    |              |         | 2 - month/week
    |              |         | 3 - day
  3 | Format       | integer | 1 - basic
    |              |         | 2 - extended
    |              |         | 3 - consistent with basic or extended
  4 | DateType     | integer | 1 - calendar date
    |              |         | 2 - ordinal date
    |              |         | 3 - week date
  5 | Year CE      | integer | -99999..+99999
  6 | DateArg1     | integer | Month 1..12 when DateType = 1
    |              |         | Empty when DateType = 2
    |              |         | Week 1..53 when DateType = 3
  7 | DateArg2     | integer | Day 1..31 when DateType = 1
    |              |         | Ordinal 1..366 when DateType = 2
    |              |         | Day of Week 1..7 -> Mon..Sun when DateType = 3
        
Parameters
----------------------------------------------------------------------------------------------------------
Text        | string | ISO 8601 formatted date.
            |        | Example formats:
            |        | +YYYYY-MM-DD, -YYYY-MM-DD, YYYY-MM-DD, YYYY-MM, YYYYMMDD, YYYY
--------------------------------------------------------------------------------------------------------*/
PARSE_DATE = LAMBDA(Text,
    LET(
        // Columns: Hash, Precision, Format, DateType, YearLen, DateArg1Pos, DateArg1Len, DateArg2Len
        // where Hash = (LEN * 4096) + (HyphenPos * 256) + (Hyphen2Pos * 16) + WPos 
        _fmtHashTable, {
            16384, 1, 3, 1, 4, 0, 0, 0;
            20480, 1, 3, 1, 5, 0, 0, 0;
            28672, 3, 1, 2, 4, 0, 0, 3;
            28677, 2, 1, 3, 4, 6, 2, 0;
            29952, 2, 2, 1, 4, 6, 2, 0;
            32768, 3, 1, 1, 4, 5, 2, 2;
            32773, 3, 1, 3, 4, 6, 2, 1;
            32774, 2, 1, 3, 5, 7, 2, 0;
            34048, 3, 2, 2, 4, 0, 0, 3;
            34054, 2, 2, 3, 4, 7, 2, 0;
            34304, 2, 2, 1, 5, 7, 2, 0;
            36864, 3, 1, 1, 5, 6, 2, 2;
            36870, 3, 1, 3, 5, 7, 2, 1;
            38400, 3, 2, 2, 5, 0, 0, 3;
            38407, 2, 2, 3, 5, 8, 2, 0;
            42368, 3, 2, 1, 4, 6, 2, 2;
            42390, 3, 2, 3, 4, 7, 2, 1;
            46736, 3, 2, 1, 5, 7, 2, 2;
            46759, 3, 2, 3, 5, 8, 2, 1
        },
        fnException, LAMBDA(_exception, [_precision], [_extended], [_dateType],
            // _exception  | string  | null  Empty text
            //             |         | N/A   Unable to parse
            //             |         | VALUE Invalid values
            // _precision  | integer | Precision of parsed values
            // _extended   | integer | Parsed extended format
            // _dateType   | integer | Calendar date, ordinal date, or week date
            IFS(
                _exception = "N/A",
                    {FALSE, "", "", "", "", "", ""},
                _exception = "VALUE",
                    IFS(
                        _precision = 1,
                            HSTACK(FALSE, 0, N(_extended), N(_dateType), {#VALUE!, "", ""}),
                        _precision = 2,
                            HSTACK(FALSE, 0, N(_extended), N(_dateType), {#VALUE!, #VALUE!, ""}),
                        TRUE, //_precision = 3
                            HSTACK(FALSE, 0, N(_extended), N(_dateType), {#VALUE!, #VALUE!, #VALUE!})
                    ),
                TRUE,
                    {"", "", "", "", "", "", ""}
            )
        ),

        IF(Text = "", fnException(""),
            IF(NOT(VALIDATE_CHARACTERS(Text, 1)), fnException("N/A"),
                LET(
                    _hasSign, IFS(
                        LEFT(Text, 1) = "+",
                        TRUE,
                        LEFT(Text, 1) = "-",
                        TRUE,
                        UNICODE(LEFT(Text, 1)) = 8722,
                        TRUE,
                        TRUE,
                        FALSE
                    ),
                    _yearSign, IFS(
                        LEFT(Text, 1) = "-",
                        -1,
                        UNICODE(LEFT(Text, 1)) = 8722,
                        -1,
                        TRUE,
                        1
                    ),
                    _len, LEN(Text) - N(_hasSign),
                    _sDate, IF(_hasSign, RIGHT(Text, _len), Text),
                    _Hyph1Pos, IFERROR(FIND("-", _sDate), 0),
                    _Hyph2Pos, IFERROR(FIND("-", _sDate, _Hyph1Pos + 1), 0),
                    _Wpos, IFERROR(FIND("W", _sDate), 0),
                    _hash, (_len * 4096) + (_Hyph1Pos * 256) + (_Hyph2Pos * 16) + _Wpos,
                    _hashLkup, IFNA(XMATCH(_hash, CHOOSECOLS(_fmtHashTable, 1), 0), 0),
                    IF(_hashLkup = 0, fnException("N/A"),
                        LET(
                            _defn, CHOOSEROWS(_fmtHashTable, _hashLkup),
                            _precision, INDEX(_defn, 1, 2),
                            _extended, INDEX(_defn, 1, 3),
                            _dateType, INDEX(_defn, 1, 4),
                            _yearCE, _yearSign * VALUE(LEFT(_sDate, INDEX(_defn, 1, 5))),
                            _dArg1, IF(
                                (_precision < 2) + (INDEX(_defn, 1, 6) = 0),
                                "",
                                VALUE(MID(_sDate, INDEX(_defn, 1, 6), INDEX(_defn, 1, 7)))
                            ),
                            _dArg2, IF(
                                _precision < 3,
                                "",
                                VALUE(RIGHT(_sDate, INDEX(_defn, 1, 8)))
                            ),
                            _valid, IFS(
                                _dateType = 1, IS_VALID_DATE(_yearCE, _dArg1, _dArg2),
                                _dateType = 2, IS_VALID_ORDINAL_DATE(_yearCE, _dArg2),
                                _dateType = 3, IS_VALID_WEEK_DATE(_yearCE, _dArg1, _dArg2),
                                TRUE, TRUE
                            ),
                            IF(_valid,
                                HSTACK(TRUE, _precision, _extended, _dateType, _yearCE, _dArg1, _dArg2),
                                fnException("VALUE", _precision, _extended, _dateType)
                            )
                        )
                    )
                )
            )
        )
    )
);

/*--------------------------------------------------------------------------------------------------------
PARSE_TIME

Returns the hour, minute and second of time from text in the ISO 8601 format.

Output
----------------------------------------------------------------------------------------------------------
  1 | ISOCompliant | boolean | Flag if compliant to ISO 8601 standard
  2 | Precision    | integer | 0 - invalid value
    |              |         | 1 - hour
    |              |         | 2 - minute
    |              |         | 3 - integer second
    |              |         | 4 - second 0.0
    |              |         | 5 - second 0.00
    |              |         | 6 - second 0.000
  3 | Format       | integer | 1 - basic
    |              |         | 2 - extended
    |              |         | 3 - consistent with basic or extended
  4 | Hour         | integer | 0..24
  5 | Minute       | integer | 0..59
  6 | Second       | decimal | 0..59.999

Parameters
----------------------------------------------------------------------------------------------------------
Text        | string | ISO 8601 formatted time.
            |        | Example formats:
            |        | Thh:mm:ss.sss, Thh:mm:ss, Thhmm, Thh
--------------------------------------------------------------------------------------------------------*/
PARSE_TIME = LAMBDA(Text,
    LET(
        // Columns: Hash, Precision, Format, MinutePos, SecondLen
        // where Hash = (LEN * 4096) + (Colon1Pos * 256) + (Colon2Pos * 16) + DecimalPos 
        _fmtHashTable, {
            8192, 1, 3, 0, 0;
            16384, 2, 1, 3, 0;
            24576, 3, 1, 3, 2;
            32775, 4, 1, 3, 4;
            36871, 5, 1, 3, 5;
            40967, 6, 1, 3, 6;
            21248, 2, 2, 4, 0;
            33632, 3, 2, 4, 2;
            41833, 4, 2, 4, 4;
            45929, 5, 2, 4, 5;
            50025, 6, 2, 4, 6
        },
        fnException, LAMBDA(_exception, [_precision], [_extended],
            // _exception  | string  | null  Empty text
            //             |         | N/A   Unable to parse
            //             |         | VALUE Invalid values
            // _precision  | integer | Precision of parsed values
            // _extended   | integer | Parsed extended format
            IFS(
                _exception = "N/A",
                    {FALSE, "", "", "", "", ""},
                _exception = "VALUE",
                    IFS(
                        _precision = 1,
                            HSTACK(FALSE, 0, N(_extended), {#VALUE!, "", ""}),
                        _precision = 2,
                            HSTACK(FALSE, 0, N(_extended), {#VALUE!, #VALUE!, ""}),
                        TRUE, //_precision = 3
                            HSTACK(FALSE, 0, N(_extended), {#VALUE!, #VALUE!, #VALUE!})
                    ),
                TRUE,
                    {"", "", "", "", "", ""}
            )
        ),
        fnCountChars, LAMBDA(CharArray, Text,
            IF(
                Text = "",
                0,
                LET(
                    _removed, REDUCE(
                        Text,
                        CharArray,
                        LAMBDA(_acc, _curr, SUBSTITUTE(_acc, _curr, ""))
                    ),
                    LEN(Text) - LEN(_removed)
                )
            )
        ),
        fnFindNthCharPos, LAMBDA(Chars, Text, N,
            LET(
                _charCount, LEN(Chars),
                _n, INT(N(N)),
                IF(
                    (_charCount = 0) + (_n = 0),
                    0,
                    LET(
                        _chars, MID(Chars, SEQUENCE(1, _charCount), 1),
                        _findCount, fnCountChars(_chars, Text),
                        IF(
                            _findCount < ABS(_n),
                            0,
                            LET(
                                // nth can count from end backwards
                                _nth, IF(_n > 0, _n, _findCount + _n + 1),
                                _nthPos, REDUCE(
                                    0,
                                    SEQUENCE(1, _nth),
                                    LAMBDA(_acc, _curr,
                                        IF(
                                            _acc < 0,
                                            -1,
                                            LET(
                                                _nextPosChars, IFERROR(
                                                    FIND(_chars, Text, _acc + 1),
                                                    0
                                                ),
                                                _nextPos, MIN(
                                                    FILTER(_nextPosChars, _nextPosChars > 0, 0)
                                                ),
                                                IF(_nextPos = 0, -1, _nextPos)
                                            )
                                        )
                                    )
                                ),
                                MAX(_nthPos, 0)
                            )
                        )
                    )
                )
            )
        ),
        IF(Text = "", fnException(""),
            IF(NOT(VALIDATE_CHARACTERS(Text, 2)), fnException("N/A"),
                LET(
                    _Tpos, IFERROR(FIND("T", Text), 0),
                    IF(_Tpos > 1, fnException("N/A"),
                        LET(
                            _sTime, IF(_Tpos = 1, RIGHT(Text, LEN(Text) - 1), Text),
                            _len, LEN(_sTime),
                            _colon1Pos, IFERROR(FIND(":", _sTime), 0),
                            _colon2Pos, IFERROR(FIND(":", _sTime, _colon1Pos + 1), 0),
                            _decimalPos, fnFindNthCharPos(".,", _sTime, 1),
                            _hash, (_len * 4096) + (_colon1Pos * 256) + (_colon2Pos * 16) + _decimalPos,
                            _hashLkup, IFNA(XMATCH(_hash, CHOOSECOLS(_fmtHashTable, 1), 0), 0),
                            IF(_hashLkup = 0, fnException("N/A"),
                                LET(
                                    _defn, CHOOSEROWS(_fmtHashTable, _hashLkup),
                                    _precision, INDEX(_defn, 1, 2),
                                    _extended, INDEX(_defn, 1, 3),
                                    _hour, VALUE(LEFT(_sTime, 2)),
                                    _minute, IF(_precision < 2, "", VALUE(MID(_sTime, INDEX(_defn, 1, 4), 2))),
                                    _secLen, INDEX(_defn, 1, 5),
                                    _second, IFS(
                                        _precision < 3, "",

                                        _precision = 3,
                                            VALUE(RIGHT(_sTime, _secLen)),
                                        
                                        TRUE, // _precision > 3
                                            LET(
                                                // canot assume VALUE function will use decimal character
                                                // when Excel has non-english Regional settings
                                                _sSec, RIGHT(_sTime, _secLen),
                                                _intSec, VALUE(LEFT(_sSec, 2)),
                                                _fracSec, VALUE(RIGHT(_sSec, _secLen - 3)),
                                                _decimalBase, INDEX({10, 100, 1000}, 1 ,_precision - 3),
                                                _intSec + (_fracSec / _decimalBase)
                                            )
                                    ),
                                    IF(NOT(IS_VALID_TIME(_hour, _minute, _second)), fnException("VALUE", _precision, _extended),
                                        HSTACK((_Tpos = 1), _precision, _extended, _hour, _minute, _second)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);

/*--------------------------------------------------------------------------------------------------------
PARSE_TIME_ZONE

Returns the time zone offset in minutes from text in the ISO 8601 format.

Output
----------------------------------------------------------------------------------------------------------
  1 | ISOCompliant  | boolean | Flag if compliant to ISO 8601 standard
  2 | Precision     | integer | 0 - invalid value
    |               |         | 1 - hour
    |               |         | 2 - minute
    |               |         | 3 - second
  3 | Format        | integer | 1 - basic
    |               |         | 2 - extended
    |               |         | 3 - consistent with basic or extended
  5 | OffsetMinutes | decimal | -900..+900

Parameters
----------------------------------------------------------------------------------------------------------
Text        | string | ISO 8601 formatted time zone.
            |        | Example formats:
            |        | +hh:mm, +hhmm, -hh, Z
--------------------------------------------------------------------------------------------------------*/
PARSE_TIME_ZONE = LAMBDA(Text,
    LET(
        // Columns: Hash, Precision, Extended, Z, MinPos
        // where hash = LEN * 1024 + Zonly * 512 + LastSignPosAt1 *256 + Colon1Pos * 16 + Colon2Pos
        _fmtHashTable, {
            1536, 3, 3, 1, 0;
            3328, 1, 3, 0, 0;
            5376, 2, 1, 0, 4;
            6464, 2, 2, 0, 5;
            7424, 3, 1, 0, 4;
            9543, 3, 2, 0, 5
        },
        fnException, LAMBDA(_exception, [_extended],
            // _exception  | string  | null  Empty text
            //             |         | N/A   Unable to parse
            //             |         | VALUE Invalid values
            // _extended   | integer | Parsed extended format
            IFS(
                _exception = "N/A",
                    {FALSE, "", "", ""},
                _exception = "VALUE",
                    HSTACK(FALSE, 0, N(_extended), {#VALUE!}),
                TRUE,
                    {"", "", "", ""}
            )
        ),
        
        fnCountChars, LAMBDA(CharArray, Text,
            IF(
                Text = "",
                0,
                LET(
                    _removed, REDUCE(
                        Text,
                        CharArray,
                        LAMBDA(_acc, _curr, SUBSTITUTE(_acc, _curr, ""))
                    ),
                    LEN(Text) - LEN(_removed)
                )
            )
        ),
        fnFindNthCharPos, LAMBDA(Chars, Text, N,
            LET(
                _charCount, LEN(Chars),
                _n, INT(N(N)),
                IF(
                    (_charCount = 0) + (_n = 0),
                    0,
                    LET(
                        _chars, MID(Chars, SEQUENCE(1, _charCount), 1),
                        _findCount, fnCountChars(_chars, Text),
                        IF(
                            _findCount < ABS(_n),
                            0,
                            LET(
                                // nth can count from end backwards
                                _nth, IF(_n > 0, _n, _findCount + _n + 1),
                                _nthPos, REDUCE(
                                    0,
                                    SEQUENCE(1, _nth),
                                    LAMBDA(_acc, _curr,
                                        IF(
                                            _acc < 0,
                                            -1,
                                            LET(
                                                _nextPosChars, IFERROR(
                                                    FIND(_chars, Text, _acc + 1),
                                                    0
                                                ),
                                                _nextPos, MIN(
                                                    FILTER(_nextPosChars, _nextPosChars > 0, 0)
                                                ),
                                                IF(_nextPos = 0, -1, _nextPos)
                                            )
                                        )
                                    )
                                ),
                                MAX(_nthPos, 0)
                            )
                        )
                    )
                )
            )
        ),

        IF(Text = "", fnException(""),
            IF(NOT(VALIDATE_CHARACTERS(Text, 3)), fnException("N/A"),
                LET(
                    _len, LEN(Text),
                    _Zonly, N((_len = 1) * (IFERROR(FIND("Z", Text), 0) = 1)),
                    _lastSignPosAt1, N(fnFindNthCharPos("+-" & UNICHAR(8722), Text, -1) = 1),
                    _colon1Pos, IFERROR(FIND(":", Text), 0),
                    _colon2Pos, IFERROR(FIND(":", Text, _colon1Pos + 1), 0),
                    _hash, (_len * 1024) + (_Zonly * 512) + (_lastSignPosAt1 * 256) + (_colon1Pos * 16) + _colon2Pos,
                    _hashLkup, IFNA(XMATCH(_hash, CHOOSECOLS(_fmtHashTable, 1), 0), 0),
                    IF(_hashLkup = 0, fnException("N/A"),
                        LET(
                            _defn, CHOOSEROWS(_fmtHashTable, _hashLkup),
                            _precision, INDEX(_defn, 1, 2),
                            _extended, INDEX(_defn, 1, 3),
                            IF(INDEX(_defn, 1, 4) > 0, // Z only
                                HSTACK(TRUE, _precision, _extended, 0),
                                LET(
                                    _sign, IFS(
                                        LEFT(Text, 1) = "-", -1,
                                        UNICODE(LEFT(Text, 1)) = 8722, -1,
                                        TRUE, 1
                                    ),
                                    _hour, _sign * VALUE(MID(Text, 2, 2)),
                                    _minute, IF(_precision < 2, "", VALUE(MID(Text, INDEX(_defn, 1, 5), 2))),
                                    _second, IF(_precision < 3, "", VALUE(RIGHT(Text, 2))),
                                    _tzoMinutes, INT((N(_hour) * 3600) + (N(_minute) * 60) + N(_second)) / 60,
                                    IF(NOT(IS_VALID_TIME_ZONE(_tzoMinutes)), fnException("VALUE", _extended),
                                        HSTACK(TRUE, _precision, _extended, _tzoMinutes)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);

/*--------------------------------------------------------------------------------------------------------
PARSE_PARTS

Splits ISO 8601 formatted text value into into respective parts of date, time and time zone.

Output
----------------------------------------------------------------------------------------------------------
  1 | ISOCompliant | boolean | Flag if compliant to ISO 8601 standard
  2 | Parts        | integer | Bitflag of parts 0..7
    |              |         | 0x04 - date
    |              |         | 0x02 - time
    |              |         | 0x01 - time zone
  3 | Date         | string  |
  4 | Time         | string  |
  5 | Time Zone    | string  |
      
Parameters
----------------------------------------------------------------------------------------------------------
Text         | string | ISO 8601 formatted value for date, time or time zone.
--------------------------------------------------------------------------------------------------------*/
PARSE_PARTS = LAMBDA(Text,
    LET(
        
        fnException, LAMBDA(_exception,
            // _exception  | string  | null  Empty text
            //             |         | N/A   Unable to parse
            IF(_exception = "N/A",
                {FALSE, 0, "", "", ""},
                {"", "", "", "", ""}
            )
        ),

        fnCountChars, LAMBDA(CharArray, Text,
            IF(
                Text = "",
                0,
                LET(
                    _removed, REDUCE(
                        Text,
                        CharArray,
                        LAMBDA(_acc, _curr, SUBSTITUTE(_acc, _curr, ""))
                    ),
                    LEN(Text) - LEN(_removed)
                )
            )
        ),

        fnFindNthCharPos, LAMBDA(Chars, Text, N, [StartPos],
            IF(N(StartPos) > LEN(Text), 0,
                LET(
                    _fromPos, IF(N(StartPos) <= 0, 0, N(StartPos) - 1), 
                    _text, IF(_fromPos = 0, Text,
                        RIGHT(Text, LEN(Text) - _fromPos)
                    ),
                    _charCount, LEN(Chars),
                    _n, INT(N(N)),
                    IF((_charCount = 0) + (_n = 0), 0,
                        LET(
                            _chars, MID(Chars, SEQUENCE(1, _charCount), 1),
                            _findCount, fnCountChars(_chars, _text),
                            IF(_findCount < ABS(_n), 0,
                                LET(
                                    // nth can count from end backwards
                                    _nth, IF(_n > 0, _n, _findCount + _n + 1),
                                    _nthPos, REDUCE(0, SEQUENCE(1, _nth),
                                        LAMBDA(_acc, _curr,
                                            IF(_acc < 0, -1,
                                                LET(
                                                    _nextPosChars, IFERROR(
                                                        FIND(_chars, _text, _acc + 1),
                                                        0
                                                    ),
                                                    _nextPos, MIN(
                                                        FILTER(_nextPosChars, _nextPosChars > 0, 0)
                                                    ),
                                                    IF(_nextPos = 0, -1, _nextPos)
                                                )
                                            )
                                        )
                                    ),
                                    IF(_nthPos > 0, _nthPos + _fromPos , 0)
                                )
                            )
                        )
                    )
                )
            )
        ),

        // 1 - T first             1 = At first position
        //                         2 = After first position
        // 2 - TZ marker after T   0 = No sign or Z
        //                         1 = First position following T
        //                         2 = After first position following T
        // 3 - Parts bit flag      0x04 - Date
        //                         0x02 - Time
        //                         0x01 - Time Zone
        WithT_Logic, {
            1, 0, 2;
            1, 1, 1;
            1, 2, 3;
            2, 0, 6;
            2, 1, 5;
            2, 2, 7
        },

        // 1 - TZ marker first     0 = No sign or Z
        //                         1 = First position
        //                         2 = After first position
        // 2 - TZ marker is Z (boolean)
        // 3 - Has Colon (boolean)
        // 4 - Time conditions (boolean)
        // 5 - Parts bit flag      0x04 - Date
        //                         0x02 - Time
        //                         0x01 - Time Zone
        WithoutT_Logic, {
            0, 0, 0, 0, 4;
            0, 0, 0, 1, 2;
            0, 0, 1, 0, 2;
            1, 0, 0, 0, 4;
            1, 0, 0, 1, 1;
            1, 0, 1, 0, 1;
            1, 1, 0, 0, 1;
            2, 0, 0, 0, 4;
            2, 0, 0, 1, 3;
            2, 0, 1, 0, 3;
            2, 0, 1, 1, 3;
            2, 1, 0, 1, 3;
            2, 1, 1, 0, 3
        },

        fnWithT_PartsLen, LAMBDA(_Tpos, _Tfirst,
            LET(
                _len, LEN(Text),
                _afterT, RIGHT(Text, _len - _Tpos),
                _TZmarkerPos, fnFindNthCharPos("Z+-" & UNICHAR(8722), _afterT, 1),
                _TZmarkFirst, IF(_TZmarkerPos > 1, 2, _TZmarkerPos),
                _partsFlag, FILTER(CHOOSECOLS(WithT_Logic, 3), (CHOOSECOLS(WithT_Logic, 1) = _Tfirst) * (CHOOSECOLS(WithT_Logic, 2) = _TZmarkFirst), #N/A),
                IF(ISNA(_partsFlag),
                    HSTACK(#N/A, 0, 0, 0),
                    LET(
                        _dateLen, _Tpos - 1,
                        _timeLen, IF(BITAND(_partsFlag, 2) = 2,
                            IF(BITAND(_partsFlag, 1) = 1,
                                _TZmarkerPos - 1,
                                _len - _Tpos
                            ),
                            0
                        ),
                        _tzLen, _len - _Tpos - _timeLen,
                        HSTACK(_partsFlag, _dateLen, _timeLen, _tzLen)
                    )
                )
            )
        ),

        fnWithoutT_PartsLen, LAMBDA(
            LET(
                _len, LEN(Text),
                _TZmarkPos, fnFindNthCharPos("Z+-" & UNICHAR(8722), Text, -1),
                _TZmarkFirst, IF(_TZmarkPos > 1, 2, _TZmarkPos),
                _TZmarkIsZ, IF(_TZmarkPos > 0, N(CODE(MID(Text, _TZmarkPos, 1)) = 90), 0), // CODE("Z") = 90 
                _HasColon, N(IFERROR(FIND(":", Text), 0) > 0),
                _lenBeforeTZ, IF(_TZmarkFirst = 0, _len, _TZmarkPos - 1),
                _timeConditional, IF(_TZmarkFirst = 1,
                    LET(
                        _lenAfterTZ, _len - _TZmarkPos,
                        IFS(_lenAfterTZ = 2, 1,
                            _lenAfterTZ = 6, 1,
                            TRUE, 0
                        )
                    ),
                    N(_lenBeforeTZ = 2)
                ),
                _match, (
                    (CHOOSECOLS(WithoutT_Logic, 1) = _TZmarkFirst)
                    * (CHOOSECOLS(WithoutT_Logic, 2) = _TZmarkIsZ)
                    * (CHOOSECOLS(WithoutT_Logic, 3) = _HasColon)
                    * (CHOOSECOLS(WithoutT_Logic, 4) = _timeConditional)
                ),

                _partsFlag, FILTER(CHOOSECOLS(WithoutT_Logic, 5), _match, #N/A),
                _dateLen, IF(BITAND(_partsFlag, 4) = 4, _len, 0),
                _timeLen, IF(BITAND(_partsFlag, 2) = 2, _lenBeforeTZ, 0),
                _tzLen, IF(BITAND(_partsFlag, 1) = 1, _len - _TZmarkPos + 1, 0),
                HSTACK(_partsFlag, _dateLen, _timeLen, _tzLen)
            )
        ),

        IF(Text = "", fnException(""),
            IF(NOT(VALIDATE_CHARACTERS(Text, 0)), fnException("N/A"),
                LET(
                    _Tpos, IFERROR(FIND("T", Text), 0),
                    IF(_Tpos = LEN(Text), fnException("N/A"),
                        LET(
                            _hasT, IF(_Tpos > 1, 2, _Tpos),
                            
                            _partsLen, IF(_hasT,
                                fnWithT_PartsLen(_Tpos, _hasT),
                                fnWithoutT_PartsLen()
                            ),
                            _partsFlag, INDEX(_partsLen, 1, 1),
                            IF(ISNA(_partsFlag), fnException("N/A"),
                                LET(
                                    _isoCompliant, IFS(
                                        _partsFlag = 1, FALSE,
                                        _partsFlag = 5, FALSE,
                                        _partsFlag = 4, TRUE,
                                        TRUE, (_hasT > 0)
                                    ),
                                    _datePart, IF(BITAND(_partsFlag, 4) = 4, LEFT(Text, INDEX(_partsLen, 1, 2)), ""),
                                    _timePart, IF(BITAND(_partsFlag, 2) = 2, "T" & MID(Text, _Tpos + 1, INDEX(_partsLen, 1, 3)), ""),
                                    _tzPart, IF(BITAND(_partsFlag, 1) = 1, RIGHT(Text, INDEX(_partsLen, 1, 4)), ""),
                                    HSTACK(_isoCompliant, _partsFlag, _datePart, _timePart, _tzPart)
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------
PARSE_ISO8601

Returns the date and time complications of text in the ISO8601 format.

Output
----------------------------------------------------------------------------------------------------------
  1 | ISOCompliant   | boolean | Flag if compliant to ISO 8601 standard
  2 | Parts          | integer | Bitflag of parts 0..7
    |                |         | 0x04 - date
    |                |         | 0x02 - time
    |                |         | 0x01 - time zone
  3 | Precision      | integer | 1 - year
    |                |         | 2 - month/week
    |                |         | 3 - day
    |                |         | 4 - hour
    |                |         | 5 - minute
    |                |         | 6 - integer second
    |                |         | 7 - second 0.0
    |                |         | 8 - second 0.00
    |                |         | 9 - second 0.000
  4 | Format         | integer | 1 - basic
    |                |         | 2 - extended
    |                |         | 3 - consistent with basic or extended
    |                |         | 4 - mixed
  5 | Date Type      | integer | 0 - no date present
    |                |         | 1 - calendar date
    |                |         | 2 - ordinal date
    |                |         | 3 - week date
  6 | Year CE        | integer | -99999..+99999
  7 | Month          | integer | 1..12
    | Week           | integer | 1..53
  8 | Day            | integer | 1..31
    | Ordinal        | integer | 1..366
    | Day of Week    | integer | 1..7 -> Mon..Sun
  9 | Hour           | integer | 0..24
 10 | Minute         | integer | 0..59
 11 | Second         | decimal | 0..59.999
 12 | Minutes Offset | decimal | -900..+900

Parameters
----------------------------------------------------------------------------------------------------------
Text               | string | ISO 8601 formatted date and time.
                   |        | Example formats:
                   |        | +YYYYY-MM-DDThh:mm:ss.sss+hh:mm:ss, YYYY-MM-DDThh:mm-hh, YYYY-Www-DThh:mmZ
[AllowMixedFormat] | switch | Allow a mix of basic and extended formats with no effect on ISO compliance.
--------------------------------------------------------------------------------------------------------*/
PARSE_ISO8601 = LAMBDA(Text, [AllowMixedFormat],
    LET(
        fnException, LAMBDA(_exception,
            // _exception   | string  | null  Empty text
            //              |         | N/A   Unable to parse
            IF(_exception = "N/A",
                {FALSE, 0, "", "", "", "", "", "", "", "", "", ""},
                // _exception = ""
                {"", "", "", "", "", "", "", "", "", "", "", ""}
            )
        ),
        
        fnPartsFlag, LAMBDA(_pDate, _pTime, _pTZ,
            LET(
                _datePart, N(INDEX(_pDate, 1, 1)) * 4,
                _timePart, N(INDEX(_pTime, 1, 1)) * 2,
                _tzPart, N(INDEX(_pTZ, 1, 1)) * 1,
                _datePart + _timePart + _tzPart
            )
        ),
        
        fnISOValueCompliance, LAMBDA(_pDate, _pTime, _pTZ,
            LET(
                _dateISOCompliant, IF(INDEX(_pDate, 1, 1) = "", TRUE, INDEX(_pDate, 1, 1)),
                _timeISOCompliant, IF(INDEX(_pTime, 1, 1) = "", TRUE, INDEX(_pTime, 1, 1)),
                _tzISOCompliant, IF(INDEX(_pTZ, 1, 1) = "", TRUE, INDEX(_pTZ, 1, 1)),
                (_dateISOCompliant * _timeISOCompliant * _tzISOCompliant) <> 0
            )
        ),

        fnISOFormatCompliance, LAMBDA(_pDate, _pTime, _pTZ, _allowMixedFormat,
            // Columns Out: ISOCompliant, ResolvedFormat
            LET(
                _dateFmt, N(INDEX(_pDate, 1, 3)),
                _timeFmt, N(INDEX(_pTime, 1, 3)),
                _tzoFmt, N(INDEX(_pTZ, 1, 3)),
                _resolveFmt, IFS(
                    (_dateFmt = 3) * (_timeFmt = 0) * (_tzoFmt = 0),
                    // only date provided, consistent with basic or extended
                    3,

                    (_dateFmt = 0) * (_timeFmt = 3) * (_tzoFmt = 0),
                    // only time provided, consistent with basic or extended
                    3,

                    (_dateFmt = 0) * (_timeFmt = 0) * (_tzoFmt = 3),
                    // only time zone provided, consistent with basic or extended
                    3,

                    (_dateFmt <> 2) * (_timeFmt <> 2) * (_tzoFmt <> 2),
                    // all basic format where present
                    1,
                    (_dateFmt <> 1) * (_timeFmt <> 1) * (_tzoFmt <> 1),
                    // all extended format where present 
                    2,

                    TRUE,
                    // mixed format
                    4
                ),
                _formatCompliant, IF(_allowMixedFormat, 1, N(_resolveFmt < 4)),
                HSTACK(_formatCompliant, _resolveFmt) 
            )
        ),

        fnISOPrecisionCompliance, LAMBDA(_pDate, _pTime, _pTZ,
            // Columns Out: ISOCompliant, Precision
            LET(
                _datePrec, N(INDEX(_pDate, 1, 2)),
                _timePrec, N(INDEX(_pTime, 1, 2)),
                _tzPrec, N(INDEX(_pTZ, 1, 2)),
                IFS(
                    _datePrec = 0,
                        IF(_timePrec = 0,
                            IF(_tzPrec = 0,
                                HSTACK(FALSE, 0),
                                HSTACK(TRUE, _tzPrec + 3)
                            ),
                            HSTACK(TRUE, _timePrec + 3)
                        ),
                    _datePrec < 3,
                        HSTACK((_timePrec = 0), _datePrec),
                    TRUE, // _datePrec = 3 
                        HSTACK(TRUE, _timePrec + 3)
                )
            )
        ),
        
        IF(Text = "", fnException(""),
            LET(
                _parts, PARSE_PARTS(Text),
                IF(N(INDEX(_parts, 1, 2)) = 0, fnException("N/A"),
                    LET(
                        _allowMixedFormat, N(AllowMixedFormat) <> 0,
                        _isoPartsCompliance, N(INDEX(_parts, 1, 1)),
                        _pDate, PARSE_DATE(INDEX(_parts, 1, 3)),
                        _pTime, PARSE_TIME(INDEX(_parts, 1, 4)),
                        _pTZ, PARSE_TIME_ZONE(INDEX(_parts, 1, 5)),
                        _isoValueCompliance, fnISOValueCompliance(_pDate, _pTime, _pTZ),
                        _isoFormatCompliance, fnISOFormatCompliance(_pDate, _pTime, _pTZ, _allowMixedFormat),
                        _isoPrecisionCompliance, fnISOPrecisionCompliance(_pDate, _pTime, _pTZ),
                        _outISOcompliance, (_isoValueCompliance * _isoPartsCompliance * INDEX(_isoFormatCompliance, 1, 1) * INDEX(_isoPrecisionCompliance, 1, 1)) <> 0,
                        _outDateType, N(INDEX(_pDate, 1, 4)),
                        _outDate, DROP(_pDate, , 4),
                        _outTime, DROP(_pTime, , 3),
                        _outTZ, DROP(_pTZ, , 3),
                        _outPartsFlag, fnPartsFlag(_pDate, _pTime, _pTZ),
                        HSTACK(_outISOcompliance, _outPartsFlag, INDEX(_isoPrecisionCompliance, 1, 2), INDEX(_isoFormatCompliance, 1, 2), _outDateType, _outDate, _outTime, _outTZ)
                    )
                )
            )
        )
    )
);



/*########################################################################################################
# FORMATTING FUNCTIONS                                                                                   #
########################################################################################################*/


/*--------------------------------------------------------------------------------------------------------
FORMAT_DATE

Returns a date as text in the ISO 8601 format.
Example formats (not exhaustive): +YYYYY-MM-DD, YYYY-MM-DD, YYYY-MM, +YYYYMM, YYYY

Output
----------------------------------------------------------------------------------------------------------
 1 | text | #VALUE! if an invalid date or ambiguous basic format. eg 202305

Parameters
----------------------------------------------------------------------------------------------------------
YearCE   | integer | Year in Common Era -99999..+99999
[Month]  | integer | Month of the year
[Day]    | integer | Day of the month
[Basic]  | switch  | Return in basic format eg YYYYMMDD
[Signed] | switch  | Always sign year value eg +YYYY-MM-DD
--------------------------------------------------------------------------------------------------------*/
FORMAT_DATE = LAMBDA(YearCE, [Month], [Day], [Basic], [Signed],
    IF(
        NOT(ISNUMBER(YearCE)) * NOT(ISNUMBER(Month)) * NOT(ISNUMBER(Day)),
        "",
        IF(
            NOT(IS_VALID_DATE(YearCE, Month, Day)),
            #VALUE!,
            LET(
                _basicFormat, N(Basic) <> 0,
                _signedYear, N(Signed) <> 0,
                IF(NOT(ISNUMBER(Day)) * _basicFormat, #VALUE!,
                    LET(
                        _y, INT(YearCE),
                        _yFmt, IFS(
                            ABS(_y) >= 10000,
                                "+00000;" & UNICHAR(8722) & "00000",
                            _signedYear,
                                "+0000;" & UNICHAR(8722) & "0000;+0000",
                            TRUE,
                                "0000;" & UNICHAR(8722) & "0000;0000"
                        ),
                        _sYear, TEXT(_y, _yFmt),
                        IF(
                            NOT(ISNUMBER(Month)),
                            _sYear,
                            LET(
                                _sMonth, TEXT(INT(Month), "00"),
                                IF(
                                    NOT(ISNUMBER(Day)),
                                    IF(_basicFormat, _sYear & _sMonth, _sYear & "-" & _sMonth),
                                    LET(
                                        _sDay, TEXT(INT(Day), "00"),
                                        IF(
                                            _basicFormat,
                                            _sYear & _sMonth & _sDay,
                                            _sYear & "-" & _sMonth & "-" & _sDay
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);

/*--------------------------------------------------------------------------------------------------------
FORMAT_TIME

Returns a time as text in the ISO 8601 format.
Example formats (not exhaustive): Thh:mm:ss.sss, Thh:mm:ss, Thh:mm, Thhmmss, Thh

Output
----------------------------------------------------------------------------------------------------------
 1 | text | #VALUE! if an invalid time

Parameters
----------------------------------------------------------------------------------------------------------
Hour        | integer | 0..24
Minute      | integer | 0..59
Second      | decimal | 0..59.999
[Basic]     | switch  | Return in basic format
[Precision] | integer | Select precision level
            |         |   0 - automatic
            |         |   1 - hours
            |         |   2 - minutes
            |         |   3 - integer seconds
            |         |   4 - fractional seconds
--------------------------------------------------------------------------------------------------------*/
FORMAT_TIME = LAMBDA(Hour, Minute, Second, [Basic], [Precision],
    IF(
        NOT(ISNUMBER(Hour)) * NOT(ISNUMBER(Minute)) * NOT(ISNUMBER(Second)),
        "",
        IF(
            NOT(IS_VALID_TIME(Hour, Minute, Second)),
            #VALUE!,
            LET(
                _basicFormat, N(Basic) <> 0,
                _s, ROUNDDOWN(N(Second), 3),
                _m, INT(N(Minute)),
                _h, INT(N(Hour)),
                _precision, MAX(INT(N(Precision)), 0),
                _usePrecision, IF(
                    _precision > 0,
                    _precision,
                    IFS(ISNUMBER(Second), IF(_s = INT(_s), 3, 4), ISNUMBER(Minute), 2, TRUE, 1)
                ),
                IFS(
                    _usePrecision = 1,
                    "T" & TEXT(_h, "00"),
                    _usePrecision = 2,
                    IF(
                        _basicFormat,
                        "T" & TEXT(_h, "00") & TEXT(_m, "00"),
                        "T" & TEXT(_h, "00") & ":" & TEXT(_m, "00")
                    ),
                    _usePrecision = 3,
                    IF(
                        _basicFormat,
                        "T" & TEXT(_h, "00") & TEXT(_m, "00") & TEXT(_s, "00"),
                        "T" & TEXT(_h, "00") & ":" & TEXT(_m, "00") & ":" & TEXT(_s, "00")
                    ),
                    
                    //_usePrecision = 4
                    TRUE,
                    IF(
                        _basicFormat,
                        "T" & TEXT(_h, "00") & TEXT(_m, "00") & TEXT(_s, "00.000"),
                        "T" & TEXT(_h, "00") & ":" & TEXT(_m, "00") & ":" & TEXT(_s, "00.000")
                    )
                )
            )
        )
    )
);

/*--------------------------------------------------------------------------------------------------------
FORMAT_TIME_ZONE

Returns a time zone as text in the ISO 8601 format.
Example formats (not exhaustive): +hh:mm:ss, -hh:mm, +hh, Z

Output
----------------------------------------------------------------------------------------------------------
 1 | text | #VALUE! if an invalid time zone

Parameters
----------------------------------------------------------------------------------------------------------
OffsetMinutes | decimal | Time zone offset from UTC in minutes -900..+900
[Basic]       | switch  | Return in basic format
[Precision]   | integer | Select precision level
              |         |   0 - automatic
              |         |   1 - hours
              |         |   2 - minutes
              |         |   3 - seconds
[NoZulu]      | switch  | Use +00:00 instead of Z for UTC time zone.
--------------------------------------------------------------------------------------------------------*/
FORMAT_TIME_ZONE = LAMBDA(OffsetMinutes, [Basic], [Precision], [NoZulu],
    IF(
        NOT(ISNUMBER(OffsetMinutes)),
        "",
        LET(
            _basicFormat, N(Basic) <> 0,
            _precision, MAX(INT(N(Precision)), 0),
            _nearZero, ROUNDDOWN(OffsetMinutes * 60, 0) = 0,
            IF(
                (N(NoZulu) = 0) * _nearZero,
                "Z",
                IF(
                    NOT(IS_VALID_TIME_ZONE(OffsetMinutes)),
                    #VALUE!,
                    LET(
                        _hasSecs, ROUNDDOWN(MOD(OffsetMinutes, 1) * 60, 0) > 0,
                        _sFmt, IFS(
                            _precision = 0,
                            IF(
                                _hasSecs,
                                IF(_basicFormat, "hhmmss", "hh:mm:ss"),
                                IF(_basicFormat, "hhmm", "hh:mm")
                            ),
                            _precision = 1,
                            "hh",
                            _precision = 2,
                            IF(_basicFormat, "hhmm", "hh:mm"),
                            
                            // _precision = 3
                            TRUE,
                            IF(_basicFormat, "hhmmss", "hh:mm:ss")
                        ),
                        _sign, IF(SIGN(OffsetMinutes) < 0, UNICHAR(8722), "+"),
                        _timeZoneOffset, ABS(OffsetMinutes) / 1440,
                        _sign & TEXT(_timeZoneOffset, _sFmt)
                    )
                )
            )
        )
    )
);

/*--------------------------------------------------------------------------------------------------------
FORMAT_ORDINAL_DATE

Returns an ordinal date as text in the ISO 8601 format.
Example formats (not exhaustive): YYYY-DDD, YYYYDDD

Output
----------------------------------------------------------------------------------------------------------
 1 | text |#VALUE! if an invalid ordinal date

Parameters
----------------------------------------------------------------------------------------------------------
YearCE   | integer | Year in Common Era -99999..+99999
Ordinal  | integer | Ordinal day of year
[Basic]  | switch  | Return in basic format eg YYYYDDD
[Signed] | switch  | Always sign year value eg +YYYY-MM-DD
--------------------------------------------------------------------------------------------------------*/
FORMAT_ORDINAL_DATE = LAMBDA(YearCE, Ordinal, [Basic], [Signed],
    IF(
        NOT(ISNUMBER(YearCE)) * NOT(ISNUMBER(Ordinal)),
        "",
        IF(
            NOT(IS_VALID_ORDINAL_DATE(YearCE, Ordinal)),
            #VALUE!,
            LET(
                _basicFormat, N(Basic) <> 0,
                _signedYEar, N(Signed) <> 0,
                _y, INT(YearCE),
                IF((ABS(_y) >= 10000) * _basicFormat, #VALUE!,
                    LET(                
                        _yFmt, IFS(
                            ABS(_y) >= 10000,
                                "+00000;" & UNICHAR(8722) & "00000",
                            _signedYear,
                                "+0000;" & UNICHAR(8722) & "0000;+0000",
                            TRUE,
                                "0000;" & UNICHAR(8722) & "0000;0000"
                        ),
                        _sYear, TEXT(_y, _yFmt),
                        _sOrdinal, TEXT(INT(Ordinal), "000"),
                        IF(_basicFormat, _sYear & _sOrdinal, _sYear & "-" & _sOrdinal)
                    )
                )
            )
        )
    )
);

/*--------------------------------------------------------------------------------------------------------
FORMAT_WEEK_DATE

Returns a week date as text in the ISO 8601 format.
Example formats (not exhaustive): YYYY-Www-D, YYYY-Www, YYYYWwwD, YYYYWww

Output
----------------------------------------------------------------------------------------------------------
 1 | text | #VALUE! if an invalid week date

Parameters
----------------------------------------------------------------------------------------------------------
YearCE    | integer | Year in Common Era -99999..+99999
Week      | integer | ISO defined week number of the year
DayOfWeek | integer | Day of the week where 1..7 -> Mon..Sun 
[Basic]   | switch  | Return in basic format eg YYYYWwwD
[Signed]  | switch  | Always sign year value eg +YYYY-Www-D
--------------------------------------------------------------------------------------------------------*/
FORMAT_WEEK_DATE = LAMBDA(YearCE, Week, DayOfWeek, [Basic], [Signed],
    IF(
        NOT(ISNUMBER(YearCE)) * NOT(ISNUMBER(Week)) * NOT(ISNUMBER(DayOfWeek)),
        "",
        IF(
            NOT(IS_VALID_WEEK_DATE(YearCE, Week, DayOfWeek)),
            #VALUE!,
            LET(
                _basicFormat, N(Basic) <> 0,
                _signedYear, N(Signed) <> 0,
                _y, INT(YearCE),
                _yFmt, IFS(
                    ABS(_y) >= 10000,
                        "+00000;" & UNICHAR(8722) & "00000",
                    _signedYear,
                        "+0000;" & UNICHAR(8722) & "0000;+0000",
                    TRUE,
                        "0000;" & UNICHAR(8722) & "0000;0000"
                ),
                _sYear, TEXT(_y, _yFmt),
                _sWeek, TEXT(INT(Week), "W00"),
                IF(
                    NOT(ISNUMBER(DayOfWeek)),
                    IF(_basicFormat, _sYear & _sWeek, _sYear & "-" & _sWeek),
                    IF(
                        _basicFormat,
                        _sYear & _sWeek & INT(DayOfWeek),
                        _sYear & "-" & _sWeek & "-" & INT(DayOfWeek)
                    )
                )
            )
        )
    )
);

/*--------------------------------------------------------------------------------------------------------
FORMAT_ISO8601

Returns date and time complications as text in the ISO 8601 format.
Example formats (not exhaustive): YYYY-MM-DDThh:mm:ss.sss+hh:mm:ss, YYYY-Www-DThh:mmZ, Thhmmss

Output
----------------------------------------------------------------------------------------------------------
 1 | text | #VALUE! if an invalid date, time or time zone

Parameters
----------------------------------------------------------------------------------------------------------
DateType         | integer | Date type represented in DateArg1 and DateArg2
                 |         |   0 - no date
                 |         |   1 - calendar date
                 |         |   2 - ordinal date
                 |         |   3 - week date
YearCE           | integer | Year in Common Era -99999..+99999
[DateArg1]       | integer | Month of year when DateType = 1         1..12
                 |         | Week of year when DateType = 3          1..53
[DateArg2]       | integer | Day of month when DateType = 1          1..31
                 |         | Ordinal day of year when DateType = 2   1..366
                 |         | Day of week when DateType = 3           1..7
[Hour]           | integer | 0..24
[Minute]         | integer | 0..59
[Second]         | decimal | 0..59.999
[TimeZoneOffset] | decimal | Time zone offset in minutes from UTC -900..+900
[Basic]          | switch  | Return in basic format eg YYYYMMDDT1045+0930
[Signed]         | switch  | Always sign year value eg +YYYY-MM-DD
[Precision]      | integer | Select precision level
                 |         |   0 - Automatic
                 |         |   1 - Year
                 |         |   2 - Month/Week
                 |         |   3 - Day/Ordinal
                 |         |   4 - Hour
                 |         |   5 - Minute
                 |         |   6 - Second
                 |         |   7 - Fractional
[NoTimeZone]     | switch  | Drop time zone from output.
[NoZulu]         | switch  | Use +00:00 instead of Z for UTC time zone.
--------------------------------------------------------------------------------------------------------*/
FORMAT_ISO8601 = LAMBDA(
    DateType,
    [YearCE],
    [DateArg1],
    [DateArg2],
    [Hour],
    [Minute],
    [Second],
    [TimeZoneOffset],
    [Basic],
    [Signed],
    [Precision],
    [NoTimeZone],
    [NoZulu],
    LET(
        _dateType, LET(_dt, MAX(INT(N(DateType)), 0), IF(_dt > 3, 0, _dt)),
        _hasDate, IF(
            _dateType = 0,
            FALSE,
            (ISNUMBER(YearCE) + ISNUMBER(DateArg1) + ISNUMBER(DateArg2)) <> 0
        ),
        _hasTime, (ISNUMBER(Hour) + ISNUMBER(Minute) + ISNUMBER(Second)) <> 0,
        _hasTimeZone, ISNUMBER(TimeZoneOffset),
        _showTimeZone, N(NoTimeZone) = 0,
        _isEmpty, _hasDate + _hasTime + (_hasTimeZone * _showTimeZone) = 0,
        IF(
            _isEmpty,
            "",
            IF(
                (_hasDate * _hasTimeZone * _showTimeZone) * NOT(_hasTime),
                #VALUE!,
                LET(
                    _precision, MAX(INT(N(Precision)), 0),
                    _sDate, IFS(
                        _dateType = 1,
                        IFS(
                            (_precision = 0) + (_precision >= 3),
                            FORMAT_DATE(YearCE, DateArg1, DateArg2, Basic, Signed),
                            _precision = 1,
                            FORMAT_DATE(YearCE, "", "", Basic, Signed),
                            _precision = 2,
                            FORMAT_DATE(YearCE, DateArg1, "", Basic, Signed)
                        ),
                        _dateType = 2,
                        IF(
                            (_precision = 0) + (_precision >= 3),
                            FORMAT_ORDINAL_DATE(YearCE, DateArg2, Basic, Signed),
                            FORMAT_ORDINAL_DATE(YearCE, "", Basic, Signed)
                        ),
                        _dateType = 3,
                        IFS(
                            (_precision = 0) + (_precision >= 3),
                            FORMAT_WEEK_DATE(YearCE, DateArg1, DateArg2, Basic, Signed),
                            _precision = 1,
                            FORMAT_WEEK_DATE(YearCE, "", "", Basic, Signed),
                            _precision = 2,
                            FORMAT_WEEK_DATE(YearCE, DateArg1, "", Basic, Signed)
                        ),
                        TRUE, //_dateType = 0,
                        ""
                    ),
                    _sTime, IF(
                        (_precision = 0) + (_precision >= 4),
                        FORMAT_TIME(Hour, Minute, Second, Basic, MAX(_precision - 3, 0)),
                        ""
                    ),
                    _sTZO, IF(
                        ((_precision = 0) + (_precision >= 4)) * _hasTimeZone * _showTimeZone,
                        LET(
                            _TZprecision, IFS(
                                _precision = 4,
                                0,
                                _precision = 5,
                                0,
                                _precision >= 6,
                                0,
                                TRUE,
                                0
                            ),
                            FORMAT_TIME_ZONE(TimeZoneOffset, Basic, 0, NoZulu)
                        ),
                        ""
                    ),
                    _sDate & _sTime & _sTZO
                )
            )
        )
    )
);



/*########################################################################################################
# CONVERSION FUNCTIONS                                                                                   #
########################################################################################################*/


/*--------------------------------------------------------------------------------------------------------
CONVERT_TO_DATE

Converts text in ISO format to an Excel date. 

Output
----------------------------------------------------------------------------------------------------------
  1 | Excel Date     | date    | 1900-01-01T00:00..9999-12-31T24:00
  2 | Minutes offset | decimal | -900..+900

Parameters
----------------------------------------------------------------------------------------------------------
Text      | string | ISO 8601 formatted date and time.
[Strict]  | switch | Enforce strict ISO 8601 parsing rules.
--------------------------------------------------------------------------------------------------------*/
CONVERT_TO_DATE = LAMBDA(Text, [Strict],
    LET(
        fnException, LAMBDA(_exception,
            // _exception   | string  | null  Empty text
            //              |         | N/A   Unable to parse
            //              |         | NUM   Out of Exel date range
            IFS(
                _exception = "N/A", {#N/A, #N/A},
                _exception = "NUM", {#NUM!, #NUM!},
                TRUE, // _exception = ""
                {"", ""}
            )
        ),
        
        IF(Text = "", fnException(""),
            LET(
                _strict, N(Strict) <> 0,
                _elements, PARSE_ISO8601(Text),
                IF(_strict * (INDEX(_elements, 1 , 1) = FALSE), fnException("N/A"),
                    LET(
                        _hasDate, BITAND(INDEX(_elements, 1, 2), 4) = 4,
                        _year, N(INDEX(_elements, 1, 6)),
                        IF(_hasDate * ((_year < 1900) + (_year > 9999)), fnException("NUM"),
                            LET(                       
                                _dateType, INDEX(_elements, 1, 5),
                                _date, IF(_hasDate,
                                    IFS(_dateType = 1, 
                                            DATE(
                                                _year,
                                                N(INDEX(_elements, 1, 7)),
                                                N(INDEX(_elements, 1, 8))
                                            ),
                                        _dateType = 2,
                                            LET(
                                                _cDate, FROM_ORDINAL_DATE(_year, N(INDEX(_elements, 1, 8))),
                                                DATE(
                                                    INDEX(_cDate, 1, 1),
                                                    INDEX(_cDate, 1, 2),
                                                    INDEX(_cDate, 1, 3)
                                                )
                                            ),
                                        _dateType = 3,
                                            LET(
                                                _cDate, FROM_WEEK_DATE(
                                                    _year,
                                                    N(INDEX(_elements, 1, 7)),
                                                    N(INDEX(_elements, 1, 8))
                                                ),
                                                DATE(
                                                    INDEX(_cDate, 1, 1),
                                                    INDEX(_cDate, 1, 2),
                                                    INDEX(_cDate, 1, 3)
                                                )
                                            )
                                    ),
                                    0
                                ),

                                _hasTime, BITAND(INDEX(_elements, 1, 2), 2) = 2,
                                _time, IF(_hasTime,
                                    TIME(
                                        N(INDEX(_elements, 1, 9)),
                                        N(INDEX(_elements, 1, 10)),
                                        N(INDEX(_elements, 1, 11))
                                    ),
                                    0
                                ),
                                
                                _dt, _date + _time,
                                _hasTZ, (BITAND(INDEX(_elements, 1, 2), 1) = 1),
                                _tzo, IF(_hasTZ, INDEX(_elements, 1, 12), ""),
                                HSTACK(_dt, _tzo)
                            )
                        )
                    )
                )
            )
        )
    )
);

/*--------------------------------------------------------------------------------------------------------
CONVERT_FROM_DATE

Converts an Excel date to ISO formatted text.
Example formats (not exhaustive): YYYY-MM-DDThh:mm:ss.sss+hh:mm:ss, YYYY-Www-DThh:mmZ, Thhmmss

Output
----------------------------------------------------------------------------------------------------------
 1 | text | null if a date is not provided

Parameters
----------------------------------------------------------------------------------------------------------
Date             | date    | An Excel date and/or time.
[TimeZoneOffset] | decimal | Time zone offset in minutes from UTC -900..+900 
[Basic]          | switch  | Return in basic format eg YYYYMMDDThhmm+hh
[Signed]         | switch  | Always sign year value eg +YYYY-MM-DD
[Precision]      | integer | Select precision level
                 |         |   0 - Automatic
                 |         |   1 - Year
                 |         |   2 - Month/Week
                 |         |   3 - Day/Ordinal
                 |         |   4 - Hour
                 |         |   5 - Minute
                 |         |   6 - Second
                 |         |   7 - Fractional
[NoTimeZone]     | switch  | Drop time zone from output.
[NoZulu]         | switch  | Use +00:00 instead of Z for UTC time zone.
--------------------------------------------------------------------------------------------------------*/
CONVERT_FROM_DATE = LAMBDA(Date, [TimeZoneOffset], [Basic], [Signed], [Precision], [NoTimeZone], [NoZulu],
    IF(
        NOT(ISNUMBER(Date)),
        "",
        LET(
            _hasDate, INT(N(Date) <> 0),
            _year, IF(_hasDate, YEAR(Date), ""),
            _month, IF(_hasDate, MONTH(Date), ""),
            _day, IF(_hasDate, DAY(Date), ""),
            _tSec1, ROUND((Date - INT(N(Date))) * 86400, 3),
            _hour, INT(_tSec1 / 3600),
            _tSec2, _tSec1 - (_hour * 3600),
            _minute, INT(_tSec2 / 60),
            _second, _tSec2 - (_minute * 60),
            FORMAT_ISO8601(
                N(_hasDate),
                _year,
                _month,
                _day,
                _hour,
                _minute,
                _second,
                TimeZoneOffset,
                Basic,
                Signed,
                Precision,
                NoTimeZone,
                NoZulu
            )
        )
    )
);

/*########################################################################################################
# END ISO_8601                                                                                           #
########################################################################################################*/
