/*##########################################################################################################
# CALENDAR v3.0                                                                                            #
#                                                                                                          #
# Module for working with dates in the Gregorian and Julian calendars outside the range of the Excel       #
# Date/Time type.                                                                                          #
#                                                                                                          #
# Module Dependencies: None                                                                                #
#                                                                                                          #
# GENERAL                                                                                                  #
# -------------------------------------------------------------------------------------------------------- #
# DECIMALS                Returns the number of decimal places for a rational number.                      #
# VALIDATE_CHARSET        Validates that the given text only contains characters in the specified          #
#                         character set. Matching is case sensitive.                                       #
# REPLACE_CHARS           Replaces each instance of a set of characters within text with another           #
#                         character. Matching is case sensitive.                                           #
# FIND_NTH_CHAR           Locates the position of the Nth count of any one of a set of characters within   #
#                         the given text. The search is case sensitive.                                    #
# SEARCH_NTH_CHAR         Locates the position of the Nth count of any one of a set of characters within   #
#                         the given text. The search is case insensitive                                   #
#                                                                                                          #
# LOGICAL                                                                                                  #
# -------------------------------------------------------------------------------------------------------- #
# IS_LEAP_YEAR            Tests if a year includes a leap day in the given calendar.                       #
# IS_VALID_DATE           Tests if a date is valid for the given calendar.                                 #
# IS_VALID_ORDINAL_DATE   Tests if an ordinal date is valid for the given calendar.                        #
# IS_VALID_WEEK_DATE      Tests if a week date is valid for the given calendar.                            #
# IS_VALID_TIME           Tests if a time is valid in the 24 hour timekeeping system.                      #
#                                                                                                          #
# TIMESPAN                                                                                                 #
# -------------------------------------------------------------------------------------------------------- #
#                                                                                                          #



# CALENDAR DATES                                                                                           #
# -------------------------------------------------------------------------------------------------------- #
# YEAR_COMMON_ERA         Returns year value relative to the Common Era.                                   #
# DAYS_IN_YEAR            Returns number of days in the given year of the specified calendar.              #
# DAYS_IN_MONTH           Returns number of days in the given month and year of the specified calendar.    #
# JULIAN_DAY_NUMBER       Returns the Julian Day Number (JDN) of the provided date in the specified        #
#                         calendar.                                                                        #
# GREGORIAN_TO_JULIAN     Translates a date in the Gregorian proleptic calendar to the Julian proleptic    #
#                         calendar.                                                                        #
# JULIAN_TO_GREGORIAN     Translates a date in the Julian proleptic calendar to the Gregorian proleptic    #
#                         calendar.                                                                        #
# SECULAR_DIFFERENCE      Returns the number of days the Gregorian proleptic calendar is ahead of the      #
#                         Julian proleptic calendar for a given date.                                      #




# DATE AND TIME                                                                                            #
# -------------------------------------------------------------------------------------------------------- #

# JULIAN_DATE             Returns the Julian Date (JDATE) of the provided date and time of day in the      #
#                         specified calendar. Note that the decimal time component of JDATE is based from  #
#                         midday.                                                                          #
# MODIFIED_JULIAN_DATE    Returns the Modified Julian Date (MJDATE) of the provided date and time of day   #
#                         in the specified calendar. Note that the decimal time component of MJDATE is     #
#                         based from midnight.                                                             #
# JDATE_TO_MODIFIED       Returns the Modified Julian Date (MJDATE) of the provided Julian Date. Note      #
#                         that the time component of MJDATE is based from midnight.                        #
# MODIFIED_TO_JDATE       Returns the Julian Date of the provided Modified Julian Date (MJDATE). Note      #
#                         that the time component of JDATE is based from midday.                           #
# JDN_TO_CALENDAR_DATE    Returns the date in the specified calendar from the given Julian Day Number.     #
# JDATE_TO_CALENDAR_DATE  Returns the date and time to an optional precision level in the specified        #
#                         calendar from the given Julian Date.                                             #
# MJDATE_TO_CALENDAR_DATE Returns the date and time to an optional precision level in the specified        #
#                         calendar from the given Modified Julian Date.                                    #
#                                                                                                          #
# ORDINAL DATES                                                                                            #
# -------------------------------------------------------------------------------------------------------- #
# MJDATE_TO_ORDINAL_DATE  Returns the year, ordinal day of year, time of day and days in the year to an    #
#                         optional precision level from the given Modified Julian Date in the specified    #
#                         calendar.                                                                        #
# ORDINAL_DATE_TO_MJDATE  Returns the Modified Julian Date from the given ordinal date and time in the     #
#                         specified calendar.                                                              #
#                                                                                                          #
# WEEKS                                                                                                    #
# -------------------------------------------------------------------------------------------------------- #
# DAY_OF_WEEK             Returns an integer for the day of the week for a given Modified Julian Date.     #
# CONVERT_WEEKDAY_NUMBER  Returns an integer for the day of the week from the traditonal numbering scheme  #
#                         to the ISO definition, or vice versa.                                            #
# WEEKDAY_OF_MONTH        Returns a Modified Julian Date for a given day of week, relative week for the    #
#                         month, year and time of day of the specified calendar.                           #
# WEEKS_IN_YEAR           Returns the count of ISO defined weeks in a given year of the specified calendar.#
# WEEK_DATE_TO_MJDATE     Returns the Modified Julian Date of the provided week date and time in the       #
#                         specified calendar.                                                              #
# MJDATE_TO_WEEK_DATE     Returns the year, ISO defined week number, ISO weekday, time, and weeks in the   #
#                         year to an optional precision level for the given Modified Julian Date in the    #
#                         specified calendar.                                                              #
# WEEK_NUMBER             Returns the ISO defined week number for a given Modified Julian Date in the      #
#                         specified calendar.                                                              #
#                                                                                                          #
# QUARTERS                                                                                                 #
# -------------------------------------------------------------------------------------------------------- #
# DAYS_IN_QUARTER         Returns the count of days in a quarter of a given year of the specified calendar.#
# QUARTER_DATE_TO_MJDATE  Returns the Modified Julian Date from the given quarter date in the specified    #
#                         calendar.                                                                        #
# MJDATE_TO_QUARTER_DATE  Returns the fiscal year, quarter, day of quarter, time and days in the quarter   #
#                         to an optional precision level for the given Modifed Julian Date in the          #
#                         specified calendar.                                                              #
#                                                                                                          #
# DATE AND TIME                                                                                            #
# -------------------------------------------------------------------------------------------------------- #
# TIMESPAN_TO_HMS        Returns the 24 hour timekeeping representation of a decimal timespan value.       #
# HMS_TO_TIMESPAN        Returns a decimal timespan as a fraction of a day from a 24 hour timekeeping      #
#                        value of time.                                                                    #
# ROUND_TIMESPAN         Returns a decimal timespan value rounded to the specified precision.              #
# RESOLVE_TIMESPAN       Returns the 24 hour timekeeping representation of a decimal timespan value        #
#                        rounded to the specified precision.                                               #
# MJDATE_ADDITION        Returns the addition of a timespan complication to a given Modified Julian Date   #
#                        expressed in local time.                                                          #
# RESOLVE_DATE           Returns a resolved calendar date from provided decimal years, months, days and    #
#                        time.                                                                             #
#                                                                                                          #
# DELTA                                                                                                    #
# -------------------------------------------------------------------------------------------------------- #
# DELTA_INTERVAL         Returns the timespan difference between Modified Julian Dates in the specified    #
#                        units.                                                                            #
# DELTA_HOURS            Returns the timespan difference between Julian Dates in hours.                    #
# DELTA_MINUTES          Returns the timespan difference between Julian Dates in minutes.                  #
# DELTA_SECONDS          Returns the timespan difference between Julian Dates in seconds.                  #
# DELTA_HOUR_MIN_SEC     Returns the timespan difference between Julian Dates in hours, minutes and        #
#                        seconds.                                                                          #
# DELTA_DAYS             Returns the timespan difference between Julian Dates in days.                     #
# DELTA_WEEKS            Returns the timespan difference between Julian Dates in weeks.                    #
# DELTA_MONTHS           Returns the timespan difference between Modified Julian Dates in months.          #
# DELTA_QUARTERS         Returns the timespan difference between Modified Julian Dates in quarters.        #
# DELTA_YEARS            Returns the timespan difference between Modified Julian Dates in years.           #
# DELTA_WEEK_DAYS        Returns the timespan difference between Julian Dates in weeks and days.           #
# DELTA_YEAR_WEEK_DAYS   Returns the timespan difference between Modified Julian Dates in years, weeks and #
#                        days.                                                                             #
# DELTA_MONTH_DAYS       Returns the timespan difference between Modified Julian Dates in months and days. #
# DELTA_QUARTER_DAYS     Returns the timespan difference between Modified Julian Dates in quarters and     #
#                        days.                                                                             #
#                                                                                                          #
# EXTENT                                                                                                   #
# -------------------------------------------------------------------------------------------------------- #
# EXTENT_OF_DAYS         Returns the inclusive extent of days spanned by two Modified Julian Dates         #
#                        expressed in local time.                                                          #
# EXTENT_OF_WEEKS        Returns the inclusive extent of weeks spanned by two Modified Julian Dates        #
#                        expressed in local time.                                                          #
# EXTENT_OF_MONTHS       Returns the inclusive extent of months spanned by two Modified Julian Dates       #
#                        expressed in local time.                                                          #
# EXTENT_OF_QUARTERS     Returns the inclusive extent of quarters spanned by two Modified Julian Dates     #
#                        expressed in local time.                                                          #
# EXTENT_OF_YEARS        Returns the inclusive extent of years spanned by two Modified Julian Dates        #
#                        expressed in local time.                                                          #
#                                                                                                          #
# PARSING                                                                                                  #
# -------------------------------------------------------------------------------------------------------- #
# PARSE_WEEKDAY          Returns a number representing the day of the week from a given text weekday name. #
# PARSE_MONTH            Returns a number representing the month of year from a given month name.          #
# PARSE_ISO_TIME         Parses an ISO formatted time of day into decimal time of day.                     #
# PARSE_ISO_TZO          Parses an ISO formatted time zone offset into a decimal timespan.                 #
# PARSE_ISO_DATE         Parses an ISO formatted date into its respective parts.                           #
# PARSE_ISO_DATETIME     Parses an ISO formatted date and time into respective date parts, time, and time  #
#                        zone offset from UTC. Providing a time zone offset on its own is invalid for this #
#                        function.                                                                         #
# PARSE_LITERARY_YEAR    Returns a number representing the year relative to the common era from a given    #
#                        literary year.                                                                    #
# PARSE_LITERARY_DATE    Parses a literary date into respective parts of year, month, day and time of day. #
# PARSE_US_DATE          Parses a US formatted date into respective parts of year, month, day and time of  #
#                        day.                                                                              #
# PARSE_MIL_DTG          Parses a date-time group in the format used by US Military message traffic, into  #
#                        respective parts of year, month, day, time of day and time zone offset in minutes #
#                        from UTC.                                                                         #
#                                                                                                          #
# TEXT                                                                                                     #
# -------------------------------------------------------------------------------------------------------- #
# WEEKDAY_NAME           Returns name of an ISO day of week number as text.                                #
# MONTH_NAME             Returns name of month.                                                            #
# FORMAT_TIMESPAN        Returns a timespan as text in ISO format from a given decimal timespan.           #
# FORMAT_ISO_TIME        Returns a date as text in ISO format.                                             #
# FORMAT_ISO_TZO         Returns a date as text in ISO format.                                             #
# FORMAT_ISO_DATE        Returns a date as text in ISO format.                                             #
# FORMAT_ISO_DATETIME    Returns a date as text in ISO format.                                             #
# FORMAT_LITERARY_YEAR   Returns a year formatted in literary style.                                       #
# FORMAT_LITERARY_DATE   Returns a date formatted in literary style.                                       #
# FORMAT_US_DATE         Returns a date formatted in the US style.                                         #
# FORMAT_MIL_DTG         Returns a date-time group formatted in US Military message traffic style.         #
#                                                                                                          #
# CONVERSION                                                                                               #
# -------------------------------------------------------------------------------------------------------- #
# MJDATE_TO_EDATE        Returns an Excel Date/Time for the provided Modified Julian Date. Note Excel      #
#                        Date/Time uses the Gregorian calendar.                                            #
# EDATE_TO_MJDATE        Returns the Modified Julian Date for the provided Excel Date/Time. Note Excel     #
#                        Date/Time uses the Gregorian calendar.                                            #



# ISODATETIME_TO_MJDATE  Returns the Modified Julian Date and time zone offset for a date and time         #
#                        provided in ISO format.                                                           #
# ISODATETIME_TO_EDATE   Returns an Excel Date/Time for a date and time provided in ISO format.            #
# MJDATE_TO_ISODATE      Returns ISO format date, time and time zone offset from a Modified Julian Date.   #


# JDN_LOCAL_TO_ISODATE   Returns ISO format date, time and time zone offset for the provided Julian Day    #
#                        Number and local time.                                                            #
#                                                                                                          #
# EDATE_TO_ISODATE       Returns ISO format date, time and time zone offset from an Excel Date/Time.       #
# EDATE_TO_JDATE         Returns the Julian Date for the provided Excel Date/Time.                         #
# EDATE_TO_JDN_LOCAL     Returns the Julian Day Number and local time for the provided Excel Date/Time.    #
#                                                                                                          #
# JDN_LOCAL_TO_EDATE     Returns an Excel Date/Time for the provided Julian Day Number and local time.     #
# JDATE_TO_EDATE         Returns an Excel Date/Time for the provided Julian Date.                          #
#                                                                                                          #
# USDATE_TO_EDATE        Returns an Excel Date/Time for the provided US format date and time.              #
# EDATE_TO_USDATE        Returns a US format date and time for the provided Excel Date/Time.               #
#                                                                                                          #
##########################################################################################################*/


/*##########################################################################################################
# GENERAL                                                                                                  #
##########################################################################################################*/


/*----------------------------------------------------------------------------------------------------------
NULLIFY

Ensures an empty cell reference is not resolved to zero.

Output
------------------------------------------------------------------------------------------------------------
 1 | variant | 

Parameters
------------------------------------------------------------------------------------------------------------
Value | variant |

Examples
------------------------------------------------------------------------------------------------------------
NULLIFY(A1), where A1 is empty
Returns ""
----------------------------------------------------------------------------------------------------------*/
NULLIFY = LAMBDA(Value,
    IF(ISBLANK(Value), "", Value)
);

/*----------------------------------------------------------------------------------------------------------
IS_EMPTY

Tests if the parameter has an empty value. Errors return FALSE.

Output
------------------------------------------------------------------------------------------------------------
 1 | boolean | 

Parameters
------------------------------------------------------------------------------------------------------------
Value | variant |

Examples
------------------------------------------------------------------------------------------------------------
IS_EMPTY("")
Returns TRUE

IS_EMPTY(1)
Returns FALSE

IS_EMPTY(#N/A)
Returns FALSE
----------------------------------------------------------------------------------------------------------*/
IS_EMPTY = LAMBDA(Value,
    IF(ISERROR(Value), FALSE,
        Value = ""
    )
);


/*----------------------------------------------------------------------------------------------------------
IS_NON_NUMERIC

Tests if the parameter has a value other than a number or empty.

Output
------------------------------------------------------------------------------------------------------------
 1 | boolean | 

Parameters
------------------------------------------------------------------------------------------------------------
Value | variant |

Examples
------------------------------------------------------------------------------------------------------------
IS_NON_NUMERIC(1)
Returns FALSE

IS_NON_NUMERIC("")
Returns FALSE

IS_NON_NUMERIC("X")
Returns TRUE

IS_NON_NUMERIC(#VALUE!)
Returns TRUE
----------------------------------------------------------------------------------------------------------*/
IS_NON_NUMERIC = LAMBDA(Value,
    IFS(
        ISERROR(Value), TRUE,
        Value = "", FALSE,
        ISNUMBER(Value), FALSE,
        TRUE, TRUE
    )    
);

/*----------------------------------------------------------------------------------------------------------
IS_NON_ZERO

Tests if the parameter has a value other than zero or empty.

Output
------------------------------------------------------------------------------------------------------------
 1 | boolean | 

Parameters
------------------------------------------------------------------------------------------------------------
N | Variant |

Examples
------------------------------------------------------------------------------------------------------------
IS_NON_ZERO("")
Returns FALSE

IS_NON_ZERO(4.5)
Returns TRUE

IS_NON_ZERO(0)
Returns FALSE

IS_NON_ZERO("3")
Returns TRUE
----------------------------------------------------------------------------------------------------------*/
IS_NON_ZERO = LAMBDA(N,
    IFS(
        ISERROR(N), TRUE,
        N = "", FALSE,
        NOT(ISNUMBER(N)), TRUE,
        N = 0, FALSE,
        TRUE, TRUE
    )
);

/*----------------------------------------------------------------------------------------------------------
IS_NON_NEGATIVE

Tests if the parameter has a value greater than zero. Non numeric values result in FALSE.

Output
------------------------------------------------------------------------------------------------------------
 1 | boolean | 

Parameters
------------------------------------------------------------------------------------------------------------
N | Variant |

Examples
------------------------------------------------------------------------------------------------------------
IS_NON_NEGATIVE("")
Returns FALSE

IS_NON_NEGATIVE(4.5)
Returns TRUE

IS_NON_NEGATIVE(0)
Returns TRUE

IS_NON_NEGATIVE(-1)
Returns FALSE
----------------------------------------------------------------------------------------------------------*/
IS_NON_NEGATIVE = LAMBDA(N,
    IFS(
        ISERROR(N), FALSE,
        N = "", FALSE,
        NOT(ISNUMBER(N)), FALSE,
        TRUE, N >= 0
    )
);


/*----------------------------------------------------------------------------------------------------------
IS_INTEGER

Tests if a number is an integer or very close to an integer. Use in place of MOD(N, 0) > 0 where N
can be within a large range of magnitudes.

Output
------------------------------------------------------------------------------------------------------------
 1 | boolean | 

Parameters
------------------------------------------------------------------------------------------------------------
N | decimal |

Examples
------------------------------------------------------------------------------------------------------------
IS_INTEGER(1)
Returns TRUE

IS_INTEGER(0.5)
Returns FALSE

IS_INTEGER("3")
Returns #VALUE!
----------------------------------------------------------------------------------------------------------*/
IS_INTEGER = LAMBDA(N,
    IF(NOT(ISNUMBER(N)), {#VALUE!},
        LET(
            _integer, INT(N),
            ROUNDDOWN(N - _integer, 15) = 0
        )
    )
);



/*----------------------------------------------------------------------------------------------------------
DECIMALS

Returns the number of decimal places for a rational number.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer [0..] | max value 15 for values > 1

Parameters
------------------------------------------------------------------------------------------------------------
N | decimal | 
----------------------------------------------------------------------------------------------------------*/
DECIMALS = LAMBDA(N,
    IFS(
        N = "", "",
        NOT(ISNumber(N)), {#VALUE!},
        N = 0, 0,
        TRUE, LET(
            // IEEE 754 floating point arithmetic introduces errors in the mathematical algorithm:
            // num -> frac = MOD(num, 1); smallest n where frac * 10^n = INT(frac * 10^n)
            // MOD involves subraction, which for a numbers >> 1 with a small decimal part produces
            // an error margin that results in a much larger n 
            // eg num = 10^12 + 0.1 ; MOD(num, 1) - 0.1 = -0.000244...
            // n should = 1, however the algorithm results in a run-away n
            // Using Excel string formatting instead
            _num1, ABS(N),
            _frac1, _num1 - INT(_num1),
            _shift, IFERROR(CEILING(-LOG10(_frac1), 1) - 1, 0),
            _num2, _num1 * POWER(10, _shift),
            _sNum2, TEXT(_num2,"0.000000000000000"),
            _sFrac, RIGHT(_sNum2, 15),
            IF(_sFrac = "000000000000000", 0,
                LET(
                    _last, REDUCE("", SEQUENCE(15,,15, -1),
                        LAMBDA(_acc, _curr,
                            IF(_acc <> "", _acc,
                                IF(MID(_sFrac, _curr, 1) = "0", "", _curr)
                            )
                        )
                    ),
                    _last + _shift
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
VALIDATE_CHARSET

Validates that the given text only contains characters in the specified character set.
Matching is case sensitive.

Output
------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
------------------------------------------------------------------------------------------------------------
CharSet | text | Valid characters
Text    | text | Text to validate
----------------------------------------------------------------------------------------------------------*/
VALIDATE_CHARSET = LAMBDA(CharSet, Text, [IgnoreCase],
    IF((CharSet = "") + (Text = ""), FALSE,
        LET(
            _ignoreCase, N(IgnoreCase) <> 0,
            _text, IF(_ignoreCase, UPPER(Text), Text),
            _chars, IF(_ignoreCase, UPPER(CharSet), CharSet),
            _escapeText, SUBSTITUTE(SUBSTITUTE(_text, "&", "&amp;"), "<", "&lt;"),
            _xml, "<xml><s>" & _escapeText & "</s></xml>",
            _xpath, "//s[translate(.,'" & _chars & "','')='']",
            NOT(ISERROR(FILTERXML(_xml, _xpath)))
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
REPLACE_CHARS

Replaces each instance of a set of characters within text with another character.
Matching is case sensitive. Note can be used to remove characters by supplying an empty CharReplaceWith.

Output
------------------------------------------------------------------------------------------------------------
 1 | text |

Parameters
------------------------------------------------------------------------------------------------------------
Text            | text | Text within which to replace characters
CharSet         | text | Set of characters to be replaced
CharReplaceWith | text | Target character with which to replace each character in CharSet

Examples
------------------------------------------------------------------------------------------------------------
REPLACE_CHARS("abc:def/g/h", ":/", "")
Returns: "abcdefgh"

REPLACE_CHARS("abc:def/g/h", ":/", "_")
Returns: "abc_def_g_h"
----------------------------------------------------------------------------------------------------------*/
REPLACE_CHARS = LAMBDA(Text, CharSet, CharReplaceWith,
    IFS(
        Text = "", "",
        CharSet = "", Text,
        TRUE, LET(
            _charNew, LEFT(CharReplaceWith),
            REDUCE(text, SEQUENCE(LEN(CharSet)),
                LAMBDA(acc, curr,
                    SUBSTITUTE(acc, MID(CharSet, curr, 1), _charNew)
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
FIND_NTH_CHAR

Locates the position of the Nth count of any one of a set of characters within the given text.
The search is case sensitive.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer | Character position in text. Negative if a negative StartPos was used.
 2 | char    | Character found. Returned if ReturnChar is set

Parameters
------------------------------------------------------------------------------------------------------------
Chars        | text             | Characters to search for
Text         | text             | Text to search within
N            | integer          | Nth count of any of the characters
             |                  | Negative values will perform a reverse search from the end of the text.
[ReturnChar] | switch           | Also return the character found
[LowerPos]   | integer          | Position to start the search from.
             | [1..LEN(Text)]   | Negative values are relative to the end of the text.
             | [-LEN(Text)..-1] | Defaults to beginning of the text.
[UpperPos]   | integer          | Position limit of the search.
             | [1..LEN(Text)]   | Negative values are relative to the end of the text.
             | [-LEN(Text)..-1] | Defaults to end of the text.

Examples
------------------------------------------------------------------------------------------------------------
FIND_NTH_CHAR("AB", "1234_A_B_A_0", 1)
Returns: 6 i.e. 1st A or B at position 6

FIND_NTH_CHAR("AB", "1234_A_B_A_0", 2)
Returns: 8 i.e. 2nd A or B at position 8

FIND_NTH_CHAR("AB", "1234_A_B_A_0", 2, 1, 7)
Returns: {10, "A"} i.e. 2nd A or B at position 10, searching from position 7. A was found

FIND_NTH_CHAR("AB", "1234_A_B_A_0", -2, 1, -4)
Returns: {6, "A"} i.e. 2nd A or B at position 6, using reverse search from 4 characters from end. A was found
----------------------------------------------------------------------------------------------------------*/
FIND_NTH_CHAR = LAMBDA(Chars, Text, N, [ReturnChar], [LowerPos], [UpperPos],
    LET(
        _n, INT(N(N)),
        _signN, SIGN(_n),
        _outChar, N(ReturnChar) <> 0,
        _len, LEN(Text),
        _startPos, IFS(
            NOT(ISNUMBER(LowerPos)), 1,
            LowerPos > 0, LowerPos,
            LowerPos < 0, _len + LowerPos + 1,
            LowerPos = 0, 1
        ),
        _endPos, IFS(
            NOT(ISNUMBER(UpperPos)), _len,
            UpperPos > 0, UpperPos,
            UpperPos < 0, _len + UpperPos + 1,
            UpperPos = 0, _len
        ),
        
        IF((_startPos > _len) + (_startPos > _endPos) + (Chars = "") + (_n = 0),
            IF(_outChar, {0, ""}, 0),
            LET(
                _text, MID(Text, _startPos, _endPos - _startPos + 1),
                _chars, MID(Chars, SEQUENCE(1, LEN(Chars)), 1),
                _findCount, LET(
                    _removed, REDUCE(Text, _chars,
                        LAMBDA(_acc, _curr, SUBSTITUTE(_acc, _curr, ""))
                    ),
                    _len - LEN(_removed)
                ),
                IF(_findCount < ABS(_n), IF(_outChar, {0, ""}, 0),
                    LET(
                        // nth can count from end backwards
                        _nth, IF(_n > 0, _n, _findCount + _n + 1),
                        _nthPos, REDUCE(0, SEQUENCE(1, _nth),
                            LAMBDA(_acc, _curr,
                                IF(_acc < 0, -1,
                                    LET(
                                        _nextPosChars, IFERROR(
                                            FIND(_chars, _text, _acc + 1),
                                            0
                                        ),
                                        _nextPos, MIN(
                                            FILTER(_nextPosChars, _nextPosChars > 0, 0)
                                        ),
                                        IF(_nextPos = 0, -1, _nextPos)
                                    )
                                )
                            )
                        ),
                        _outPos, _nthPos + _startPos - 1,
                        
                        IF(_outChar,
                            IF(_outPos = 0, {0, ""},
                                HSTACK(
                                    _outPos,
                                    MID(_text, _nthPos, 1)
                                )
                            ),
                            _outPos
                        )
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
SEARCH_NTH_CHAR

Locates the position of the Nth count of any one of a set of characters within the given text.
The search is case insensitive. 

Output
------------------------------------------------------------------------------------------------------------
 1 | integer | Character position in text. Negative if a negative StartPos was used.
 2 | char    | Character found. Returned if ReturnChar is set

Parameters
------------------------------------------------------------------------------------------------------------
Chars        | text             | Characters to search for
Text         | text             | Text to search within
N            | integer          | Nth count of any of the characters
             |                  | Negative values will perform a reverse search from the end of the text.
[ReturnChar] | switch           | Also return the character found
[LowerPos]   | integer          | Position to start the search from.
             | [1..LEN(Text)]   | Negative values are relative to the end of the text.
             | [-LEN(Text)..-1] | Defaults to beginning of the text.
[UpperPos]   | integer          | Position limit of the search.
             | [1..LEN(Text)]   | Negative values are relative to the end of the text.
             | [-LEN(Text)..-1] | Defaults to end of the text.

Examples
------------------------------------------------------------------------------------------------------------
SEARCH_NTH_CHAR("ab", "1234_A_B_A_0", 1)
Returns: 6 i.e. 1st A or B at position 6

SEARCH_NTH_CHAR("ab", "1234_A_B_A_0", 2)
Returns: 8 i.e. 2nd A or B at position 8

SEARCH_NTH_CHAR("ab", "1234_A_B_A_0", 2, 1, 7)
Returns: {10, "A"} i.e. 2nd A or B at position 10, searching from position 7. A was found

SEARCH_NTH_CHAR("ab", "1234_A_B_A_0", -2, 1, -4)
Returns: {6, "A"} i.e. 2nd A or B at position 6, using reverse search from 4 characters from end. A was found
----------------------------------------------------------------------------------------------------------*/
SEARCH_NTH_CHAR = LAMBDA(Chars, Text, N, [ReturnChar], [LowerPos], [UpperPos],
    LET(
        _n, INT(N(N)),
        _signN, SIGN(_n),
        _outChar, N(ReturnChar) <> 0,
        _len, LEN(Text),
        _startPos, IFS(
            NOT(ISNUMBER(LowerPos)), 1,
            LowerPos > 0, LowerPos,
            LowerPos < 0, _len + LowerPos + 1,
            LowerPos = 0, 1
        ),
        _endPos, IFS(
            NOT(ISNUMBER(UpperPos)), _len,
            UpperPos > 0, UpperPos,
            UpperPos < 0, _len + UpperPos + 1,
            UpperPos = 0, _len
        ),
        
        IF((_startPos > _len) + (_startPos > _endPos) + (Chars = "") + (_n = 0),
            IF(_outChar, {0, ""}, 0),
            LET(
                _text, MID(Text, _startPos, _endPos - _startPos + 1),
                _chars, MID(Chars, SEQUENCE(1, LEN(Chars)), 1),
                _findCount, LET(
                    _removed, REDUCE(UPPER(Text), UPPER(_chars),
                        LAMBDA(_acc, _curr, SUBSTITUTE(_acc, _curr, ""))
                    ),
                    _len - LEN(_removed)
                ),
                IF(_findCount < ABS(_n), IF(_outChar, {0, ""}, 0),
                    LET(
                        // nth can count from end backwards
                        _nth, IF(_n > 0, _n, _findCount + _n + 1),
                        _nthPos, REDUCE(0, SEQUENCE(1, _nth),
                            LAMBDA(_acc, _curr,
                                IF(_acc < 0, -1,
                                    LET(
                                        _nextPosChars, IFERROR(
                                            SEARCH(_chars, _text, _acc + 1),
                                            0
                                        ),
                                        _nextPos, MIN(
                                            FILTER(_nextPosChars, _nextPosChars > 0, 0)
                                        ),
                                        IF(_nextPos = 0, -1, _nextPos)
                                    )
                                )
                            )
                        ),
                        _outPos, _nthPos + _startPos - 1,
                        
                        IF(_outChar,
                            IF(_outPos = 0, {0, ""},
                                HSTACK(
                                    _outPos,
                                    MID(_text, _nthPos, 1)
                                )
                            ),
                            _outPos
                        )
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
SPLIT_BY_CHARS

Splits text at any one of the given set of characters. First element returned is the sequence of matched
characters, followed by each substring. Matching is case sensitive.

Output
------------------------------------------------------------------------------------------------------------
 1 | text | Array of substrings

Parameters
------------------------------------------------------------------------------------------------------------
Chars   | text    | Characters to split at
Text    | text    | Text to split
[Limit] | integer | Limit at which to stop splitting

Examples
------------------------------------------------------------------------------------------------------------
SPLIT_BY_CHARS_CI("_/", "1_2/34/56_7")
Returns: { "_//_"; "1"; "2"; "34"; "56"; "7"}
----------------------------------------------------------------------------------------------------------*/
SPLIT_BY_CHARS = LAMBDA(Chars, Text, [Limit],
    IF((Chars = "") + (Text = ""), VSTACK("", NULLIFY(Text)),
        LET(
            _chars, MID(Chars, SEQUENCE(1, LEN(Chars)), 1),
            _limit, MAX(INT(N(Limit)), 0),
            _len, LEN(Text),
            
            _findCount, LET(
                _removed, REDUCE(Text, _chars,
                    LAMBDA(_acc, _curr, SUBSTITUTE(_acc, _curr, ""))
                ),
                _len - LEN(_removed)
            ),

            _count, IF(_limit, MIN(_limit, _findCount), _findCount),
            _pos, VSTACK(
                REDUCE({0}, SEQUENCE(_count),
                    LAMBDA(_acc, _curr,
                        LET(
                            _startFrom, INDEX(_acc, ROWS(_acc), 1) + 1, 
                            _nextPosChars, IFERROR(
                                FIND(_chars, Text, _startFrom),
                                0
                            ),
                            _nextPos, MIN(
                                FILTER(_nextPosChars, _nextPosChars > 0, 0)
                            ),
                            VSTACK(_acc, _nextPos)
                        )
                    )
                ), _len + 1
            ),
            _sift, CONCAT(IFERROR(MID(Text, DROP(_pos, 1) , 1), "")),
            _idx, SEQUENCE(ROWS(_pos) - 1),
            VSTACK(
                _sift,
                IFERROR(MID(Text, INDEX(_pos, _idx) + 1, INDEX(_pos, _idx + 1) - INDEX(_pos, _idx) - 1), Text)
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
SPLIT_BY_CHARS_CI

Splits text at any one of the given set of characters. First element returned is the sequence of matched
characters, followed by each substring. Matching is case insensitive.

Output
------------------------------------------------------------------------------------------------------------
 1 | text | Array of substrings

Parameters
------------------------------------------------------------------------------------------------------------
Chars   | text    | Characters to split at
Text    | text    | Text to split
[Limit] | integer | Limit at which to stop splitting

Examples
------------------------------------------------------------------------------------------------------------
SPLIT_BY_CHARS_CI("AB", "A12b34B56")
Returns: { "AbB"; ""; "12"; "34"; "56"}
----------------------------------------------------------------------------------------------------------*/
SPLIT_BY_CHARS_CI = LAMBDA(Chars, Text, [Limit],
    IF((Chars = "") + (Text = ""), VSTACK("", NULLIFY(Text)),
        LET(
            _chars, MID(Chars, SEQUENCE(1, LEN(Chars)), 1),
            _limit, MAX(INT(N(Limit)), 0),
            _len, LEN(Text),
            
            _findCount, LET(
                _removed, REDUCE(UPPER(Text), UPPER(_chars),
                    LAMBDA(_acc, _curr, SUBSTITUTE(_acc, _curr, ""))
                ),
                _len - LEN(_removed)
            ),

            _count, IF(_limit, MIN(_limit, _findCount), _findCount),
            _pos, VSTACK(
                REDUCE({0}, SEQUENCE(_count),
                    LAMBDA(_acc, _curr,
                        LET(
                            _startFrom, INDEX(_acc, ROWS(_acc), 1) + 1, 
                            _nextPosChars, IFERROR(
                                SEARCH(_chars, Text, _startFrom),
                                0
                            ),
                            _nextPos, MIN(
                                FILTER(_nextPosChars, _nextPosChars > 0, 0)
                            ),
                            VSTACK(_acc, _nextPos)
                        )
                    )
                ), _len + 1
            ),
            _sift, CONCAT(IFERROR(MID(Text, DROP(_pos, 1) , 1), "")),
            _idx, SEQUENCE(ROWS(_pos) - 1),
            VSTACK(
                _sift,
                IFERROR(MID(Text, INDEX(_pos, _idx) + 1, INDEX(_pos, _idx + 1) - INDEX(_pos, _idx) - 1), Text)
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
SPLIT_AROUND_CHARS

Splits text at any character not in the given set. First element returned is the sequence of unmatched
characters, followed by each substring. Matching is case sensitive.

Output
------------------------------------------------------------------------------------------------------------
 1 | text | Array of substrings

Parameters
------------------------------------------------------------------------------------------------------------
Chars   | text    | Characters not split at
Text    | text    | Text to split
[Limit] | integer | Limit at which to stop splitting

Examples
------------------------------------------------------------------------------------------------------------
SPLIT_AROUND_CHARS("123456", "A12b34B56")
Returns: { "AbB"; ""; "12"; "34"; "56"}
----------------------------------------------------------------------------------------------------------*/
SPLIT_AROUND_CHARS = LAMBDA(Chars, Text, [Limit],
    IF((Chars = "") + (Text = ""), VSTACK("", NULLIFY(Text)),
        LET(
            _chars, MID(Chars, SEQUENCE(1, LEN(Chars)), 1),
            _limit, MAX(INT(N(Limit)), 0),
            _len, LEN(Text),
            _pos, VSTACK(
                REDUCE({0}, SEQUENCE(_len),
                    LAMBDA(_acc, _curr,
                        LET(
                            _isMatch, MAX(N(CODE(MID(Text, _curr, 1)) = CODE(_chars))),
                            IF(_isMatch, _acc,
                                VSTACK(_acc, _curr)
                            )
                        )
                    )
                )
            ),
            
            _count, IF(_limit, MIN(_limit, ROWS(_pos) - 1), ROWS(_pos) - 1),
            
            _limitPos, VSTACK(
                IFERROR(TAKE(_pos, _count + 1), 0),
                _len + 1
            ),
            _sift, CONCAT(IFERROR(MID(Text, DROP(_limitPos, 1), 1), "")),
            _idx, SEQUENCE(_count + 1),
            VSTACK(
               _sift,
               IFERROR(MID(Text, INDEX(_limitPos, _idx) + 1, INDEX(_limitPos, _idx + 1) - INDEX(_limitPos, _idx) - 1), Text)
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
SPLIT_AROUND_CHARS_CI

Splits text at any character not in the given set. First element returned is the sequence of unmatched
characters, followed by each substring. Matching is case insensitive.

Output
------------------------------------------------------------------------------------------------------------
 1 | text | Array of substrings

Parameters
------------------------------------------------------------------------------------------------------------
Chars   | text    | Characters not split at
Text    | text    | Text to split
[Limit] | integer | Limit at which to stop splitting

Examples
------------------------------------------------------------------------------------------------------------
SPLIT_AROUND_CHARS_CI("a123456", "A12b34B56")
Returns: { "bB"; ""; "a12"; "34"; "56"}
----------------------------------------------------------------------------------------------------------*/
SPLIT_AROUND_CHARS_CI = LAMBDA(Chars, Text, [Limit],
    IF((Chars = "") + (Text = ""), VSTACK("", NULLIFY(Text)),
        LET(
            _chars, MID(Chars, SEQUENCE(1, LEN(Chars)), 1),
            _limit, MAX(INT(N(Limit)), 0),
            _len, LEN(Text),
            _pos, VSTACK(
                REDUCE({0}, SEQUENCE(_len),
                    LAMBDA(_acc, _curr,
                        LET(
                            _isMatch, MAX(N(MID(Text, _curr, 1) = _chars)),
                            IF(_isMatch, _acc,
                                VSTACK(_acc, _curr)
                            )
                        )
                    )
                )
            ),
            
            _count, IF(_limit, MIN(_limit, ROWS(_pos) - 1), ROWS(_pos) - 1),
            
            _limitPos, VSTACK(
                IFERROR(TAKE(_pos, _count + 1), 0),
                _len + 1
            ),
            _sift, CONCAT(IFERROR(MID(Text, DROP(_limitPos, 1), 1), "")),
            _idx, SEQUENCE(_count + 1),
            VSTACK(
               _sift,
               IFERROR(MID(Text, INDEX(_limitPos, _idx) + 1, INDEX(_limitPos, _idx + 1) - INDEX(_limitPos, _idx) - 1), Text)
            )
        )
    )
);

















/*##########################################################################################################
# TIMESPAN                                                                                                 #
##########################################################################################################*/


/*----------------------------------------------------------------------------------------------------------
IS_VALID_TIMESPAN

Tests if sexagesimal representation of a timespan is valid.
An element can exceed its modulus if no higher order element is provided.

Output
------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
------------------------------------------------------------------------------------------------------------
Sign      | integer [-1,0,1] |
Days      | decimal [0..]    | Fractional allowed if hours, minutes and seconds empty.
[Hours]   | decimal [0..24)  | Fractional allowed if minutes and seconds empty.
[Minutes] | decimal [0..60)  | Fractional allowed if seconds empty.
[Seconds] | decimal [0..60)  | Fractional allowed
----------------------------------------------------------------------------------------------------------*/
IS_VALID_TIMESPAN = LAMBDA(Sign, Days, [Hours], [Minutes], [Seconds],
    IFS(
        ISERROR(Sign), FALSE,
        NOT(ISNUMBER(Sign)), FALSE,
        Sign < -1, FALSE,
        Sign > 1, FALSE,
        NOT(IS_INTEGER(Sign)), FALSE,
        TRUE, LET(
            _high, IFS(
                ISNUMBER(Days), 1,
                ISNUMBER(Hours), 2,
                ISNUMBER(Minutes), 3,
                ISNUMBER(Seconds), 4,
                TRUE, 0
            ),
            IF(_high = 0, FALSE,
                LET(
                    _low, IFS(
                        ISNUMBER(Seconds), 4,
                        ISNUMBER(Minutes), 3,
                        ISNUMBER(Hours), 2,
                        ISNUMBER(Days), 1
                    ),
                    
                    fnInvalidElement, LAMBDA(_element, _max, _level, _zeroSign,
                        IFS(
                            ISERROR(_element), TRUE,
                            (_element = "") * (_high < _level) * (_low > _level), TRUE,
                            _element = "", FALSE,
                            NOT(ISNUMBER(_element)), TRUE,
                            (_low > _level) * NOT(IS_INTEGER(_element)), TRUE,
                            _element < 0, TRUE,
                            _zeroSign * (_element > 0), TRUE,
                            IF(_max = "", 0, (_high < _level) * (_element >= _max)), TRUE,
                            TRUE, FALSE
                        )
                    ),
                    
                    _zeroSign, Sign = 0,
                    IFS(
                        fnInvalidElement(Days, "", 1, _zeroSign), FALSE,
                        fnInvalidElement(Hours, 24, 2, _zeroSign), FALSE,
                        fnInvalidElement(Minutes, 60, 3, _zeroSign), FALSE,
                        fnInvalidElement(Seconds, 60, 4, _zeroSign), FALSE,
                        TRUE, TRUE
                    )
                )
            )
        )
    )    
);


/*----------------------------------------------------------------------------------------------------------
VALIDATE_TIMESPAN

Validate each element of a sexagesimal representation of a timespan.
An element can exceed its modulus if no higher order element is provided.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | decimal [0..]    | Days
 3 | decimal [0..24)  | Hours
 4 | decimal [0..60)  | Minutes
 5 | decimal [0..60)  | Seconds

Parameters
------------------------------------------------------------------------------------------------------------
Sign      | integer [-1,0,1] |
Days      | decimal [0..]    | Fractional allowed if hours, minutes and seconds empty.
[Hours]   | decimal [0..24)  | Fractional allowed if minutes and seconds empty.
[Minutes] | decimal [0..60)  | Fractional allowed if seconds empty.
[Seconds] | decimal [0..60)  | Fractional allowed
----------------------------------------------------------------------------------------------------------*/
VALIDATE_TIMESPAN = LAMBDA(Sign, Days, [Hours], [Minutes], [Seconds],
    LET(
        _high, IFS(
            ISNUMBER(Days), 1,
            ISNUMBER(Hours), 2,
            ISNUMBER(Minutes), 3,
            ISNUMBER(Seconds), 4,
            TRUE, 0
        ),

        _low, IFS(
            ISNUMBER(Seconds), 4,
            ISNUMBER(Minutes), 3,
            ISNUMBER(Hours), 2,
            ISNUMBER(Days), 1,
            TRUE, 0
        ),
        
        fnCheckElement, LAMBDA(_element, _max, _level, _zeroSign,
            IFS(
                ISERROR(_element), _element,
                (_element = "") * (_high < _level) * (_low > _level), {#VALUE!},
                _element = "", "",
                NOT(ISNUMBER(_element)), {#VALUE!},
                (_low > _level) * NOT(IS_INTEGER(_element)), {#NUM!},
                _element < 0, {#NUM!},
                _zeroSign * (_element > 0), {#NUM!},
                IF(_max = "", 0, (_high < _level) * (_element >= _max)), {#NUM!},
                TRUE, _element
            )
        ),
        
        _sign, IFS(
            NOT(ISNUMBER(Sign)), {#VALUE!},
            Sign < -1, {#NUM!},
            Sign > 1, {#NUM!},
            NOT(IS_INTEGER(Sign)), {#NUM!},
            TRUE, Sign
        ),
        _zeroSign, IF(ISNUMBER(_sign), _sign = 0, FALSE),
        
        _days, fnCheckElement(Days, "", 1, _zeroSign),
        _hours, fnCheckElement(Hours, 24, 2, _zeroSign),
        _minutes, fnCheckElement(Minutes, 60, 3, _zeroSign),
        _seconds, fnCheckElement(Seconds, 60, 4, _zeroSign),
        IF(
            ISNUMBER(_sign) * IS_EMPTY(_days) * IS_EMPTY(_hours) * IS_EMPTY(_minutes) * IS_EMPTY(_seconds),
            HSTACK(_sign, {#VALUE!, #VALUE!, #VALUE!, #VALUE!}),
            HSTACK(_sign, _days, _hours, _minutes, _seconds)
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
TIMESPAN_LOW_ORDER

Returns a number representing the lowest order element of the sexagesimal representation of a timespan value.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer | Order, #N/A for zero
   |         |  1 - Day
   |         |  2 - Hour
   |         |  3 - Minute
   |         |  4 - Second

Parameters
------------------------------------------------------------------------------------------------------------
Days      | decimal         | Decimal timespan when omitting hours, minutes and seconds
[Hours]   | integer [0..23] |
[Minutes] | integer [0..59] |
[Seconds] | decimal [0..60) |
----------------------------------------------------------------------------------------------------------*/
TIMESPAN_LOW_ORDER = LAMBDA(Days, [Hours], [Minutes], [Seconds],
    IFS(
        IS_EMPTY(Days) * IS_EMPTY(Hours) * IS_EMPTY(Minutes) * IS_EMPTY(Seconds), "",
        ISNUMBER(Days) * IS_EMPTY(Hours) * IS_EMPTY(Minutes) * IS_EMPTY(Seconds), LET(
            Days = 0, {#N/A},
            NOT(IS_INTEGER(Days * 1440)), 4,
            NOT(IS_INTEGER(Days * 24)), 3,
            NOT(IS_INTEGER(Days)), 2,
            ISNUMBER(Days), 1,
            TRUE, {#N/A}
        ),
        IS_NUMBERIC(Days) + IS_NUMBERIC(Hours) + IS_NUMBERIC(Minutes) + IS_NUMBERIC(Seconds), IFS(
            ABS(N(Seconds)) > 0, 4,
            ABS(N(Minutes)) > 0, 3,
            ABS(N(Hours)) > 0, 2,
            ABS(N(Days)) > 0, 1,
            TRUE, {#N/A}
        ),
        TRUE, {#VALUE!}
    )
);


/*----------------------------------------------------------------------------------------------------------
TIMESPAN_HIGH_ORDER

Returns a number representing the highest order element of the sexagesimal representation of a timespan value.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer | Order, #N/A for zero
   |         |  1 - Day
   |         |  2 - Hour
   |         |  3 - Minute
   |         |  4 - Second

Parameters
------------------------------------------------------------------------------------------------------------
Days      | decimal         | Decimal timespan when omitting hours, minutes and seconds
[Hours]   | integer [0..23] |
[Minutes] | integer [0..59] |
[Seconds] | decimal [0..60) |
----------------------------------------------------------------------------------------------------------*/
TIMESPAN_HIGH_ORDER = LAMBDA(Days, [Hours], [Minutes], [Seconds],
    IFS(
        IS_EMPTY(Days) * IS_EMPTY(Hours) * IS_EMPTY(Minutes) * IS_EMPTY(Seconds), "",
        ISNUMBER(Days) * IS_EMPTY(Hours) * IS_EMPTY(Minutes) * IS_EMPTY(Seconds), LET(
            _absTimeSpan, ABS(Days),
            IFS(
                _absTimeSpan = 0, {#N/A},
                _absTimeSpan >= 1, 1,
                _absTimeSpan * 24 >= 1, 2,
                _absTimeSpan * 1440 >= 1, 3,
                TRUE, 4
            )
        ),
        IS_NUMBERIC(Days) + IS_NUMBERIC(Hours) + IS_NUMBERIC(Minutes) + IS_NUMBERIC(Seconds), IFS(
            ABS(N(Days)) > 0, 1,
            ABS(N(Hours)) > 0, 2,
            ABS(N(Minutes)) > 0, 3,
            ABS(N(Seconds)) > 0, 4,
            TRUE, {#N/A}
        ),
        TRUE, {#VALUE!}
    )
);


/*----------------------------------------------------------------------------------------------------------
TIMESPAN

Returns a decimal timespan as a fraction of a day from sexagesimal representation of time.
Note out-of-range parameters will carry.

Output
------------------------------------------------------------------------------------------------------------
 1 | decimal | Timespan as fraction of a day. Implicitly converts to Excel Date/Time type for non-negative
   |         | values.

Parameters
------------------------------------------------------------------------------------------------------------
Sign      | integer [-1,0,1] |
Days      | decimal [0..]    |
[Hours]   | decimal [0..23]  |
[Minutes] | decimal [0..59]  |
[Seconds] | decimal [0..60)  |
----------------------------------------------------------------------------------------------------------*/
TIMESPAN = LAMBDA(Sign, Days, [Hours], [Minutes], [Seconds],
    IFS(
        (Days = "") * (Hours = "") * (Minutes = "") * (Seconds = ""), "",
        NOT(ISNUMBER(Sign)), {#VALUE!},
        IS_NON_NUMERIC(Days), {#VALUE!},
        IS_NON_NUMERIC(Hours), {#VALUE!},
        IS_NON_NUMERIC(Minutes), {#VALUE!},
        IS_NON_NUMERIC(Seconds), {#VALUE!},
        TRUE, LET(
            _sign, IFS(
                Sign = 0, 0,
                Sign < 0, -1,
                TRUE, 1
            ),
            _sign * (N(Days) + (N(Hours) / 24) + (N(Minutes) / 1440) + (N(Seconds) / 86400))
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
ROUND_TIMESPAN

Returns a decimal timespan value rounded to the specified precision.

Output
------------------------------------------------------------------------------------------------------------
 1 | decimal | TimeSpan

Parameters
------------------------------------------------------------------------------------------------------------
TimeSpan      | decimal | Decimal timespan where a day = 1
[Precision]   | integer | Select precision level
              | [-3..9] | Null - Floating
              |         |   -3 - Day
              |         |   -2 - Hour
              |         |   -1 - Minute
              |         |    0 - Second
              |         |    1 - Decisecond
              |         |    2 - Centisecond
              |         |    3 - Millisecond
              |         |    ...
              |         |    9 - Nanosecond
[Truncate]    | switch  | Round to precision by truncating components. Default is rounding to nearest.
----------------------------------------------------------------------------------------------------------*/
ROUND_TIMESPAN = LAMBDA(TimeSpan, [Precision], [Truncate],
    IFS(
        TimeSpan = "", "",
        NOT(ISNUMBER(TimeSpan)), {#VALUE!},
        TimeSpan = 0, 0,
        TRUE, LET(
            _truncate, N(Truncate) <> 0,
            _precision, IFS(
                NOT(ISNUMBER(Precision)), "",
                Precision < -3, -3,
                Precision > 9, 9,
                TRUE, INT(Precision)
            ),
            IFS(
                _precision = "", TimeSpan,
                _truncate, IFS(
                    _precision = -3, ROUNDDOWN(TimeSpan, 0),
                    _precision = -2, ROUNDDOWN(TimeSpan * 24, 0) / 24,
                    _precision = -1, ROUNDDOWN(TimeSpan * 1440, 0) / 1440,
                    TRUE, ROUNDDOWN(TimeSpan * 86400, _precision) / 86400
                ),
                TRUE, IFS(
                    _precision = -3, ROUND(TimeSpan, 0),
                    _precision = -2, ROUND(TimeSpan * 24, 0) / 24,
                    _precision = -1, ROUND(TimeSpan * 1440, 0) / 1440,
                    TRUE, ROUND(TimeSpan * 86400, _precision) / 86400
                )
            )
        )
    )
);



/*----------------------------------------------------------------------------------------------------------
RESOLVE_TIMESPAN

Returns the sexagesimal representation of a timespan value with the given lowest order element rounded to the
specified precision.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Days
 3 | integer [0..23]  | Hours
 4 | integer [0..59]  | Minutes
 5 | decimal [0..60)  | Seconds

Parameters
------------------------------------------------------------------------------------------------------------
TimeSpan      | decimal | Decimal timespan where a day = 1
[LowOrder]    | integer | Lowest-order element. Defaults to Second.
              | [1..4]  |  1 - Day
              |         |  2 - Hour
              |         |  3 - Minute
              |         |  4 - Second
[Precision]   | integer | Select precision level
              | [0..9]  | Null - Floating
[Truncate]    | switch  | Round to precision by truncating components. Default is rounding to nearest.
----------------------------------------------------------------------------------------------------------*/
RESOLVE_TIMESPAN = LAMBDA(TimeSpan, [LowOrder], [Precision], [Truncate],
    LET(
        _lowOrder, IFS(
            NOT(ISNUMBER(LowOrder)), 4,
            LowOrder < 1, 4,
            LowOrder > 4, 4,
            TRUE, INT(LowOrder)
        ),
        IFS(
            TimeSpan = "", {"", "", "", "", ""},
            NOT(ISNUMBER(TimeSpan)), {#VALUE!, "", "", "", ""},
            TimeSpan = 0, CHOOSECOLS({0, 0, 0, 0, 0, "", "", ""}, SEQUENCE(1, 5, 5 - _lowOrder)), 
            TRUE, LET(
                _truncate, N(Truncate) <> 0,
                _absTimeSpan, ABS(TimeSpan),
                _sign, SIGN(TimeSpan),
                _precision, IFS(
                    Precision = "", "",
                    Precision < 0, 0,
                    Precision > 9, 9,
                    TRUE, INT(Precision)
                ),
                IFS(
                    _lowOrder = 4, LET(
                        _seconds, _absTimeSpan * 86400,
                        _minutes, INT(_seconds / 60),
                        _decSecond, _seconds - (_minutes * 60),
                        _hours, INT(_minutes / 60),
                        _rMinute, _minutes - (_hours * 60),
                        _rDay, INT(_hours / 24),
                        _rHour, _hours - (_rDay * 24),
                        // Round second last because arithmetic rounding of the timespan decimal value
                        // can bring in floating point errors.
                        // Sign checked for rounding down to zero.
                        // Second checked for rounding up to minute.
                        _rSecond, IFS(
                            _precision = "", _decSecond,
                            _truncate, ROUNDDOWN(_decSecond, _precision),
                            TRUE, ROUND(_decSecond, _precision)
                        ),
                        _rSign, IFS(
                            _rSecond > 0, _sign,
                            _rMinute > 0, _sign,
                            _rHour > 0, _sign,
                            _rDay > 0, _sign,
                            TRUE, 0
                        ),
                        IFS(
                            _rSecond < 60, HSTACK(_rSign, _rDay, _rHour, _rMinute, _rSecond),
                            _rMinute <= 58, HSTACK(_rSign, _rDay, _rHour, _rMinute + 1, 0),
                            _rHour <= 22, HSTACK(_rSign, _rDay, _rHour + 1, 0, 0),
                            TRUE, HSTACK(_rSign, _rDay + 1, 0, 0, 0)
                        )
                    ),
                
                    _lowOrder = 3, LET(
                        _minutes, _absTimeSpan * 1440,
                        _hours, INT(_minutes / 60),
                        _decMinute, _minutes - (_hours * 60),
                        _rDay, INT(_hours / 24),
                        _rHour, _hours - (_rDay * 24),
                        // Round minute last because arithmetic rounding of the timespan decimal value
                        // can bring in floating point errors.
                        // Sign checked for rounding down to zero.
                        // Minute checked for rounding up to hour.
                        _rMinute, IFS(
                            _precision = "", _decMinute,
                            _truncate, ROUNDDOWN(_decMinute, _precision),
                            TRUE, ROUND(_decMinute, _precision)
                        ),
                        _rSign, IFS(
                            _rMinute > 0, _sign,
                            _rHour > 0, _sign,
                            _rDay > 0, _sign,
                            TRUE, 0
                        ),
                        IFS(
                            _rMinute < 60, HSTACK(_rSign, _rDay, _rHour, _rMinute, ""),
                            _rHour <= 22, HSTACK(_rSign, _rDay, _rHour + 1, 0, ""),
                            TRUE, HSTACK(_rSign, _rDay + 1, 0, 0, "")
                        )
                    ),
                    _lowOrder = 2, LET(
                        _hours, _absTimeSpan * 24,
                        _rDay, INT(_hours / 24),
                        _decHour, _hours - (_rDay * 24),
                        // Round hour last because arithmetic rounding of the timespan decimal value
                        // can bring in floating point errors.
                        // Sign checked for rounding down to zero.
                        // Hour checked for rounding up to day.
                        _rHour, IFS(
                            _precision = "", _decHour,
                            _truncate, ROUNDDOWN(_decHour, _precision),
                            TRUE, ROUND(_decHour, _precision)
                        ),
                        _rSign, IFS(
                            _rHour > 0, _sign,
                            _rDay > 0, _sign,
                            TRUE, 0
                        ),
                        IFS(
                            _rHour < 24, HSTACK(_rSign, _rDay, _rHour, "", ""),
                            TRUE, HSTACK(_rSign, _rDay + 1, 0, "", "")
                        )
                    ),
                    _lowOrder = 1, LET(
                        _decDay, _absTimeSpan,
                        _rDay, IFS(
                            _precision = "", _decDay,
                            _truncate, ROUNDDOWN(_decDay, _precision),
                            TRUE, ROUND(_decDay, _precision)
                        ),
                        _rSign, IFS(
                            _rDay > 0, _sign,
                            TRUE, 0
                        ),
                        HSTACK(_rSign, _rDay, "", "", "")
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
PARSE_TIMESPAN

Parses a timespan into sexagesimal elements.

Output
------------------------------------------------------------------------------------------------------------
 1 | decimal [0..1] | Time of day as decimal fraction of a day.

Parameters
------------------------------------------------------------------------------------------------------------
TimeSpanText | text   | Formatted TimeSpan/*##########################################################################################################
# CALENDAR v3.0                                                                                            #
#                                                                                                          #
# Module for working with dates in the Gregorian and Julian calendars outside the range of the Excel       #
# Date/Time type.                                                                                          #
#                                                                                                          #
# Module Dependencies: None                                                                                #
#                                                                                                          #
# GENERAL                                                                                                  #
# -------------------------------------------------------------------------------------------------------- #
# DECIMALS                Returns the number of decimal places for a rational number.                      #
# VALIDATE_CHARSET        Validates that the given text only contains characters in the specified          #
#                         character set. Matching is case sensitive.                                       #
# REPLACE_CHARS           Replaces each instance of a set of characters within text with another           #
#                         character. Matching is case sensitive.                                           #
# FIND_NTH_CHAR           Locates the position of the Nth count of any one of a set of characters within   #
#                         the given text. The search is case sensitive.                                    #
# SEARCH_NTH_CHAR         Locates the position of the Nth count of any one of a set of characters within   #
#                         the given text. The search is case insensitive                                   #
#                                                                                                          #
# LOGICAL                                                                                                  #
# -------------------------------------------------------------------------------------------------------- #
# IS_LEAP_YEAR            Tests if a year includes a leap day in the given calendar.                       #
# IS_VALID_DATE           Tests if a date is valid for the given calendar.                                 #
# IS_VALID_ORDINAL_DATE   Tests if an ordinal date is valid for the given calendar.                        #
# IS_VALID_WEEK_DATE      Tests if a week date is valid for the given calendar.                            #
# IS_VALID_TIME           Tests if a time is valid in the 24 hour timekeeping system.                      #
#                                                                                                          #
# TIMESPAN                                                                                                 #
# -------------------------------------------------------------------------------------------------------- #
#                                                                                                          #



# CALENDAR DATES                                                                                           #
# -------------------------------------------------------------------------------------------------------- #
# YEAR_COMMON_ERA         Returns year value relative to the Common Era.                                   #
# DAYS_IN_YEAR            Returns number of days in the given year of the specified calendar.              #
# DAYS_IN_MONTH           Returns number of days in the given month and year of the specified calendar.    #
# JULIAN_DAY_NUMBER       Returns the Julian Day Number (JDN) of the provided date in the specified        #
#                         calendar.                                                                        #
# GREGORIAN_TO_JULIAN     Translates a date in the Gregorian proleptic calendar to the Julian proleptic    #
#                         calendar.                                                                        #
# JULIAN_TO_GREGORIAN     Translates a date in the Julian proleptic calendar to the Gregorian proleptic    #
#                         calendar.                                                                        #
# SECULAR_DIFFERENCE      Returns the number of days the Gregorian proleptic calendar is ahead of the      #
#                         Julian proleptic calendar for a given date.                                      #




# DATE AND TIME                                                                                            #
# -------------------------------------------------------------------------------------------------------- #

# JULIAN_DATE             Returns the Julian Date (JDATE) of the provided date and time of day in the      #
#                         specified calendar. Note that the decimal time component of JDATE is based from  #
#                         midday.                                                                          #
# MODIFIED_JULIAN_DATE    Returns the Modified Julian Date (MJDATE) of the provided date and time of day   #
#                         in the specified calendar. Note that the decimal time component of MJDATE is     #
#                         based from midnight.                                                             #
# JDATE_TO_MODIFIED       Returns the Modified Julian Date (MJDATE) of the provided Julian Date. Note      #
#                         that the time component of MJDATE is based from midnight.                        #
# MODIFIED_TO_JDATE       Returns the Julian Date of the provided Modified Julian Date (MJDATE). Note      #
#                         that the time component of JDATE is based from midday.                           #
# JDN_TO_CALENDAR_DATE    Returns the date in the specified calendar from the given Julian Day Number.     #
# JDATE_TO_CALENDAR_DATE  Returns the date and time to an optional precision level in the specified        #
#                         calendar from the given Julian Date.                                             #
# MJDATE_TO_CALENDAR_DATE Returns the date and time to an optional precision level in the specified        #
#                         calendar from the given Modified Julian Date.                                    #
#                                                                                                          #
# ORDINAL DATES                                                                                            #
# -------------------------------------------------------------------------------------------------------- #
# MJDATE_TO_ORDINAL_DATE  Returns the year, ordinal day of year, time of day and days in the year to an    #
#                         optional precision level from the given Modified Julian Date in the specified    #
#                         calendar.                                                                        #
# ORDINAL_DATE_TO_MJDATE  Returns the Modified Julian Date from the given ordinal date and time in the     #
#                         specified calendar.                                                              #
#                                                                                                          #
# WEEKS                                                                                                    #
# -------------------------------------------------------------------------------------------------------- #
# DAY_OF_WEEK             Returns an integer for the day of the week for a given Modified Julian Date.     #
# CONVERT_WEEKDAY_NUMBER  Returns an integer for the day of the week from the traditonal numbering scheme  #
#                         to the ISO definition, or vice versa.                                            #
# WEEKDAY_OF_MONTH        Returns a Modified Julian Date for a given day of week, relative week for the    #
#                         month, year and time of day of the specified calendar.                           #
# WEEKS_IN_YEAR           Returns the count of ISO defined weeks in a given year of the specified calendar.#
# WEEK_DATE_TO_MJDATE     Returns the Modified Julian Date of the provided week date and time in the       #
#                         specified calendar.                                                              #
# MJDATE_TO_WEEK_DATE     Returns the year, ISO defined week number, ISO weekday, time, and weeks in the   #
#                         year to an optional precision level for the given Modified Julian Date in the    #
#                         specified calendar.                                                              #
# WEEK_NUMBER             Returns the ISO defined week number for a given Modified Julian Date in the      #
#                         specified calendar.                                                              #
#                                                                                                          #
# QUARTERS                                                                                                 #
# -------------------------------------------------------------------------------------------------------- #
# DAYS_IN_QUARTER         Returns the count of days in a quarter of a given year of the specified calendar.#
# QUARTER_DATE_TO_MJDATE  Returns the Modified Julian Date from the given quarter date in the specified    #
#                         calendar.                                                                        #
# MJDATE_TO_QUARTER_DATE  Returns the fiscal year, quarter, day of quarter, time and days in the quarter   #
#                         to an optional precision level for the given Modifed Julian Date in the          #
#                         specified calendar.                                                              #
#                                                                                                          #
# DATE AND TIME                                                                                            #
# -------------------------------------------------------------------------------------------------------- #
# TIMESPAN_TO_HMS        Returns the 24 hour timekeeping representation of a decimal timespan value.       #
# HMS_TO_TIMESPAN        Returns a decimal timespan as a fraction of a day from a 24 hour timekeeping      #
#                        value of time.                                                                    #
# ROUND_TIMESPAN         Returns a decimal timespan value rounded to the specified precision.              #
# RESOLVE_TIMESPAN       Returns the 24 hour timekeeping representation of a decimal timespan value        #
#                        rounded to the specified precision.                                               #
# MJDATE_ADDITION        Returns the addition of a timespan complication to a given Modified Julian Date   #
#                        expressed in local time.                                                          #
# RESOLVE_DATE           Returns a resolved calendar date from provided decimal years, months, days and    #
#                        time.                                                                             #
#                                                                                                          #
# DELTA                                                                                                    #
# -------------------------------------------------------------------------------------------------------- #
# DELTA_INTERVAL         Returns the timespan difference between Modified Julian Dates in the specified    #
#                        units.                                                                            #
# DELTA_HOURS            Returns the timespan difference between Julian Dates in hours.                    #
# DELTA_MINUTES          Returns the timespan difference between Julian Dates in minutes.                  #
# DELTA_SECONDS          Returns the timespan difference between Julian Dates in seconds.                  #
# DELTA_HOUR_MIN_SEC     Returns the timespan difference between Julian Dates in hours, minutes and        #
#                        seconds.                                                                          #
# DELTA_DAYS             Returns the timespan difference between Julian Dates in days.                     #
# DELTA_WEEKS            Returns the timespan difference between Julian Dates in weeks.                    #
# DELTA_MONTHS           Returns the timespan difference between Modified Julian Dates in months.          #
# DELTA_QUARTERS         Returns the timespan difference between Modified Julian Dates in quarters.        #
# DELTA_YEARS            Returns the timespan difference between Modified Julian Dates in years.           #
# DELTA_WEEK_DAYS        Returns the timespan difference between Julian Dates in weeks and days.           #
# DELTA_YEAR_WEEK_DAYS   Returns the timespan difference between Modified Julian Dates in years, weeks and #
#                        days.                                                                             #
# DELTA_MONTH_DAYS       Returns the timespan difference between Modified Julian Dates in months and days. #
# DELTA_QUARTER_DAYS     Returns the timespan difference between Modified Julian Dates in quarters and     #
#                        days.                                                                             #
#                                                                                                          #
# EXTENT                                                                                                   #
# -------------------------------------------------------------------------------------------------------- #
# EXTENT_OF_DAYS         Returns the inclusive extent of days spanned by two Modified Julian Dates         #
#                        expressed in local time.                                                          #
# EXTENT_OF_WEEKS        Returns the inclusive extent of weeks spanned by two Modified Julian Dates        #
#                        expressed in local time.                                                          #
# EXTENT_OF_MONTHS       Returns the inclusive extent of months spanned by two Modified Julian Dates       #
#                        expressed in local time.                                                          #
# EXTENT_OF_QUARTERS     Returns the inclusive extent of quarters spanned by two Modified Julian Dates     #
#                        expressed in local time.                                                          #
# EXTENT_OF_YEARS        Returns the inclusive extent of years spanned by two Modified Julian Dates        #
#                        expressed in local time.                                                          #
#                                                                                                          #
# PARSING                                                                                                  #
# -------------------------------------------------------------------------------------------------------- #
# PARSE_WEEKDAY          Returns a number representing the day of the week from a given text weekday name. #
# PARSE_MONTH            Returns a number representing the month of year from a given month name.          #
# PARSE_ISO_TIME         Parses an ISO formatted time of day into decimal time of day.                     #
# PARSE_ISO_TZO          Parses an ISO formatted time zone offset into a decimal timespan.                 #
# PARSE_ISO_DATE         Parses an ISO formatted date into its respective parts.                           #
# PARSE_ISO_DATETIME     Parses an ISO formatted date and time into respective date parts, time, and time  #
#                        zone offset from UTC. Providing a time zone offset on its own is invalid for this #
#                        function.                                                                         #
# PARSE_LITERARY_YEAR    Returns a number representing the year relative to the common era from a given    #
#                        literary year.                                                                    #
# PARSE_LITERARY_DATE    Parses a literary date into respective parts of year, month, day and time of day. #
# PARSE_US_DATE          Parses a US formatted date into respective parts of year, month, day and time of  #
#                        day.                                                                              #
# PARSE_MIL_DTG          Parses a date-time group in the format used by US Military message traffic, into  #
#                        respective parts of year, month, day, time of day and time zone offset in minutes #
#                        from UTC.                                                                         #
#                                                                                                          #
# TEXT                                                                                                     #
# -------------------------------------------------------------------------------------------------------- #
# WEEKDAY_NAME           Returns name of an ISO day of week number as text.                                #
# MONTH_NAME             Returns name of month.                                                            #
# FORMAT_TIMESPAN        Returns a timespan as text in ISO format from a given decimal timespan.           #
# FORMAT_ISO_TIME        Returns a date as text in ISO format.                                             #
# FORMAT_ISO_TZO         Returns a date as text in ISO format.                                             #
# FORMAT_ISO_DATE        Returns a date as text in ISO format.                                             #
# FORMAT_ISO_DATETIME    Returns a date as text in ISO format.                                             #
# FORMAT_LITERARY_YEAR   Returns a year formatted in literary style.                                       #
# FORMAT_LITERARY_DATE   Returns a date formatted in literary style.                                       #
# FORMAT_US_DATE         Returns a date formatted in the US style.                                         #
# FORMAT_MIL_DTG         Returns a date-time group formatted in US Military message traffic style.         #
#                                                                                                          #
# CONVERSION                                                                                               #
# -------------------------------------------------------------------------------------------------------- #
# MJDATE_TO_EDATE        Returns an Excel Date/Time for the provided Modified Julian Date. Note Excel      #
#                        Date/Time uses the Gregorian calendar.                                            #
# EDATE_TO_MJDATE        Returns the Modified Julian Date for the provided Excel Date/Time. Note Excel     #
#                        Date/Time uses the Gregorian calendar.                                            #



# ISODATETIME_TO_MJDATE  Returns the Modified Julian Date and time zone offset for a date and time         #
#                        provided in ISO format.                                                           #
# ISODATETIME_TO_EDATE   Returns an Excel Date/Time for a date and time provided in ISO format.            #
# MJDATE_TO_ISODATE      Returns ISO format date, time and time zone offset from a Modified Julian Date.   #


# JDN_LOCAL_TO_ISODATE   Returns ISO format date, time and time zone offset for the provided Julian Day    #
#                        Number and local time.                                                            #
#                                                                                                          #
# EDATE_TO_ISODATE       Returns ISO format date, time and time zone offset from an Excel Date/Time.       #
# EDATE_TO_JDATE         Returns the Julian Date for the provided Excel Date/Time.                         #
# EDATE_TO_JDN_LOCAL     Returns the Julian Day Number and local time for the provided Excel Date/Time.    #
#                                                                                                          #
# JDN_LOCAL_TO_EDATE     Returns an Excel Date/Time for the provided Julian Day Number and local time.     #
# JDATE_TO_EDATE         Returns an Excel Date/Time for the provided Julian Date.                          #
#                                                                                                          #
# USDATE_TO_EDATE        Returns an Excel Date/Time for the provided US format date and time.              #
# EDATE_TO_USDATE        Returns a US format date and time for the provided Excel Date/Time.               #
#                                                                                                          #
##########################################################################################################*/


/*##########################################################################################################
# GENERAL                                                                                                  #
##########################################################################################################*/


/*----------------------------------------------------------------------------------------------------------
NULLIFY

Ensures an empty cell reference is not resolved to zero.

Output
------------------------------------------------------------------------------------------------------------
 1 | variant | 

Parameters
------------------------------------------------------------------------------------------------------------
Value | variant |

Examples
------------------------------------------------------------------------------------------------------------
NULLIFY(A1), where A1 is empty
Returns ""
----------------------------------------------------------------------------------------------------------*/
NULLIFY = LAMBDA(Value,
IF(ISBLANK(Value), "", Value)
);

/*----------------------------------------------------------------------------------------------------------
IS_EMPTY

Tests if the parameter has an empty value. Errors return FALSE.

Output
------------------------------------------------------------------------------------------------------------
1 | boolean | 

Parameters
------------------------------------------------------------------------------------------------------------
Value | variant |

Examples
------------------------------------------------------------------------------------------------------------
IS_EMPTY("")
Returns TRUE

IS_EMPTY(1)
Returns FALSE

IS_EMPTY(#N/A)
Returns FALSE
----------------------------------------------------------------------------------------------------------*/
IS_EMPTY = LAMBDA(Value,
IF(ISERROR(Value), FALSE,
    Value = ""
)
);


/*----------------------------------------------------------------------------------------------------------
IS_NON_NUMERIC

Tests if the parameter has a value other than a number or empty.

Output
------------------------------------------------------------------------------------------------------------
1 | boolean | 

Parameters
------------------------------------------------------------------------------------------------------------
Value | variant |

Examples
------------------------------------------------------------------------------------------------------------
IS_NON_NUMERIC(1)
Returns FALSE

IS_NON_NUMERIC("")
Returns FALSE

IS_NON_NUMERIC("X")
Returns TRUE

IS_NON_NUMERIC(#VALUE!)
Returns TRUE
----------------------------------------------------------------------------------------------------------*/
IS_NON_NUMERIC = LAMBDA(Value,
IFS(
    ISERROR(Value), TRUE,
    Value = "", FALSE,
    ISNUMBER(Value), FALSE,
    TRUE, TRUE
)    
);

/*----------------------------------------------------------------------------------------------------------
IS_NON_ZERO

Tests if the parameter has a value other than zero or empty.

Output
------------------------------------------------------------------------------------------------------------
1 | boolean | 

Parameters
------------------------------------------------------------------------------------------------------------
N | Variant |

Examples
------------------------------------------------------------------------------------------------------------
IS_NON_ZERO("")
Returns FALSE

IS_NON_ZERO(4.5)
Returns TRUE

IS_NON_ZERO(0)
Returns FALSE

IS_NON_ZERO("3")
Returns TRUE
----------------------------------------------------------------------------------------------------------*/
IS_NON_ZERO = LAMBDA(N,
IFS(
    ISERROR(N), TRUE,
    N = "", FALSE,
    NOT(ISNUMBER(N)), TRUE,
    N = 0, FALSE,
    TRUE, TRUE
)
);

/*----------------------------------------------------------------------------------------------------------
IS_NON_NEGATIVE

Tests if the parameter has a value greater than zero. Non numeric values result in FALSE.

Output
------------------------------------------------------------------------------------------------------------
1 | boolean | 

Parameters
------------------------------------------------------------------------------------------------------------
N | Variant |

Examples
------------------------------------------------------------------------------------------------------------
IS_NON_NEGATIVE("")
Returns FALSE

IS_NON_NEGATIVE(4.5)
Returns TRUE

IS_NON_NEGATIVE(0)
Returns TRUE

IS_NON_NEGATIVE(-1)
Returns FALSE
----------------------------------------------------------------------------------------------------------*/
IS_NON_NEGATIVE = LAMBDA(N,
IFS(
    ISERROR(N), FALSE,
    N = "", FALSE,
    NOT(ISNUMBER(N)), FALSE,
    TRUE, N >= 0
)
);


/*----------------------------------------------------------------------------------------------------------
IS_INTEGER

Tests if a number is an integer or very close to an integer. Use in place of MOD(N, 0) > 0 where N
can be within a large range of magnitudes.

Output
------------------------------------------------------------------------------------------------------------
1 | boolean | 

Parameters
------------------------------------------------------------------------------------------------------------
N | decimal |

Examples
------------------------------------------------------------------------------------------------------------
IS_INTEGER(1)
Returns TRUE

IS_INTEGER(0.5)
Returns FALSE

IS_INTEGER("3")
Returns #VALUE!
----------------------------------------------------------------------------------------------------------*/
IS_INTEGER = LAMBDA(N,
IF(NOT(ISNUMBER(N)), {#VALUE!},
    LET(
        _integer, INT(N),
        ROUNDDOWN(N - _integer, 15) = 0
    )
)
);



/*----------------------------------------------------------------------------------------------------------
DECIMALS

Returns the number of decimal places for a rational number.

Output
------------------------------------------------------------------------------------------------------------
1 | integer [0..] | max value 15 for values > 1

Parameters
------------------------------------------------------------------------------------------------------------
N | decimal | 
----------------------------------------------------------------------------------------------------------*/
DECIMALS = LAMBDA(N,
IFS(
    N = "", "",
    NOT(ISNumber(N)), {#VALUE!},
    N = 0, 0,
    TRUE, LET(
        // IEEE 754 floating point arithmetic introduces errors in the mathematical algorithm:
        // num -> frac = MOD(num, 1); smallest n where frac * 10^n = INT(frac * 10^n)
        // MOD involves subraction, which for a numbers >> 1 with a small decimal part produces
        // an error margin that results in a much larger n 
        // eg num = 10^12 + 0.1 ; MOD(num, 1) - 0.1 = -0.000244...
        // n should = 1, however the algorithm results in a run-away n
        // Using Excel string formatting instead
        _num1, ABS(N),
        _frac1, _num1 - INT(_num1),
        _shift, IFERROR(CEILING(-LOG10(_frac1), 1) - 1, 0),
        _num2, _num1 * POWER(10, _shift),
        _sNum2, TEXT(_num2,"0.000000000000000"),
        _sFrac, RIGHT(_sNum2, 15),
        IF(_sFrac = "000000000000000", 0,
            LET(
                _last, REDUCE("", SEQUENCE(15,,15, -1),
                    LAMBDA(_acc, _curr,
                        IF(_acc <> "", _acc,
                            IF(MID(_sFrac, _curr, 1) = "0", "", _curr)
                        )
                    )
                ),
                _last + _shift
            )
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
VALIDATE_CHARSET

Validates that the given text only contains characters in the specified character set.
Matching is case sensitive.

Output
------------------------------------------------------------------------------------------------------------
1 | boolean |

Parameters
------------------------------------------------------------------------------------------------------------
CharSet | text | Valid characters
Text    | text | Text to validate
----------------------------------------------------------------------------------------------------------*/
VALIDATE_CHARSET = LAMBDA(CharSet, Text, [IgnoreCase],
IF((CharSet = "") + (Text = ""), FALSE,
    LET(
        _ignoreCase, N(IgnoreCase) <> 0,
        _text, IF(_ignoreCase, UPPER(Text), Text),
        _chars, IF(_ignoreCase, UPPER(CharSet), CharSet),
        _escapeText, SUBSTITUTE(SUBSTITUTE(_text, "&", "&amp;"), "<", "&lt;"),
        _xml, "<xml><s>" & _escapeText & "</s></xml>",
        _xpath, "//s[translate(.,'" & _chars & "','')='']",
        NOT(ISERROR(FILTERXML(_xml, _xpath)))
    )
)
);


/*----------------------------------------------------------------------------------------------------------
REPLACE_CHARS

Replaces each instance of a set of characters within text with another character.
Matching is case sensitive. Note can be used to remove characters by supplying an empty CharReplaceWith.

Output
------------------------------------------------------------------------------------------------------------
1 | text |

Parameters
------------------------------------------------------------------------------------------------------------
Text            | text | Text within which to replace characters
CharSet         | text | Set of characters to be replaced
CharReplaceWith | text | Target character with which to replace each character in CharSet

Examples
------------------------------------------------------------------------------------------------------------
REPLACE_CHARS("abc:def/g/h", ":/", "")
Returns: "abcdefgh"

REPLACE_CHARS("abc:def/g/h", ":/", "_")
Returns: "abc_def_g_h"
----------------------------------------------------------------------------------------------------------*/
REPLACE_CHARS = LAMBDA(Text, CharSet, CharReplaceWith,
IFS(
    Text = "", "",
    CharSet = "", Text,
    TRUE, LET(
        _charNew, LEFT(CharReplaceWith),
        REDUCE(text, SEQUENCE(LEN(CharSet)),
            LAMBDA(acc, curr,
                SUBSTITUTE(acc, MID(CharSet, curr, 1), _charNew)
            )
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
FIND_NTH_CHAR

Locates the position of the Nth count of any one of a set of characters within the given text.
The search is case sensitive.

Output
------------------------------------------------------------------------------------------------------------
1 | integer | Character position in text. Negative if a negative StartPos was used.
2 | char    | Character found. Returned if ReturnChar is set

Parameters
------------------------------------------------------------------------------------------------------------
Chars        | text             | Characters to search for
Text         | text             | Text to search within
N            | integer          | Nth count of any of the characters
         |                  | Negative values will perform a reverse search from the end of the text.
[ReturnChar] | switch           | Also return the character found
[LowerPos]   | integer          | Position to start the search from.
         | [1..LEN(Text)]   | Negative values are relative to the end of the text.
         | [-LEN(Text)..-1] | Defaults to beginning of the text.
[UpperPos]   | integer          | Position limit of the search.
         | [1..LEN(Text)]   | Negative values are relative to the end of the text.
         | [-LEN(Text)..-1] | Defaults to end of the text.

Examples
------------------------------------------------------------------------------------------------------------
FIND_NTH_CHAR("AB", "1234_A_B_A_0", 1)
Returns: 6 i.e. 1st A or B at position 6

FIND_NTH_CHAR("AB", "1234_A_B_A_0", 2)
Returns: 8 i.e. 2nd A or B at position 8

FIND_NTH_CHAR("AB", "1234_A_B_A_0", 2, 1, 7)
Returns: {10, "A"} i.e. 2nd A or B at position 10, searching from position 7. A was found

FIND_NTH_CHAR("AB", "1234_A_B_A_0", -2, 1, -4)
Returns: {6, "A"} i.e. 2nd A or B at position 6, using reverse search from 4 characters from end. A was found
----------------------------------------------------------------------------------------------------------*/
FIND_NTH_CHAR = LAMBDA(Chars, Text, N, [ReturnChar], [LowerPos], [UpperPos],
LET(
    _n, INT(N(N)),
    _signN, SIGN(_n),
    _outChar, N(ReturnChar) <> 0,
    _len, LEN(Text),
    _startPos, IFS(
        NOT(ISNUMBER(LowerPos)), 1,
        LowerPos > 0, LowerPos,
        LowerPos < 0, _len + LowerPos + 1,
        LowerPos = 0, 1
    ),
    _endPos, IFS(
        NOT(ISNUMBER(UpperPos)), _len,
        UpperPos > 0, UpperPos,
        UpperPos < 0, _len + UpperPos + 1,
        UpperPos = 0, _len
    ),
    
    IF((_startPos > _len) + (_startPos > _endPos) + (Chars = "") + (_n = 0),
        IF(_outChar, {0, ""}, 0),
        LET(
            _text, MID(Text, _startPos, _endPos - _startPos + 1),
            _chars, MID(Chars, SEQUENCE(1, LEN(Chars)), 1),
            _findCount, LET(
                _removed, REDUCE(Text, _chars,
                    LAMBDA(_acc, _curr, SUBSTITUTE(_acc, _curr, ""))
                ),
                _len - LEN(_removed)
            ),
            IF(_findCount < ABS(_n), IF(_outChar, {0, ""}, 0),
                LET(
                    // nth can count from end backwards
                    _nth, IF(_n > 0, _n, _findCount + _n + 1),
                    _nthPos, REDUCE(0, SEQUENCE(1, _nth),
                        LAMBDA(_acc, _curr,
                            IF(_acc < 0, -1,
                                LET(
                                    _nextPosChars, IFERROR(
                                        FIND(_chars, _text, _acc + 1),
                                        0
                                    ),
                                    _nextPos, MIN(
                                        FILTER(_nextPosChars, _nextPosChars > 0, 0)
                                    ),
                                    IF(_nextPos = 0, -1, _nextPos)
                                )
                            )
                        )
                    ),
                    _outPos, _nthPos + _startPos - 1,
                    
                    IF(_outChar,
                        IF(_outPos = 0, {0, ""},
                            HSTACK(
                                _outPos,
                                MID(_text, _nthPos, 1)
                            )
                        ),
                        _outPos
                    )
                )
            )
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
SEARCH_NTH_CHAR

Locates the position of the Nth count of any one of a set of characters within the given text.
The search is case insensitive. 

Output
------------------------------------------------------------------------------------------------------------
1 | integer | Character position in text. Negative if a negative StartPos was used.
2 | char    | Character found. Returned if ReturnChar is set

Parameters
------------------------------------------------------------------------------------------------------------
Chars        | text             | Characters to search for
Text         | text             | Text to search within
N            | integer          | Nth count of any of the characters
         |                  | Negative values will perform a reverse search from the end of the text.
[ReturnChar] | switch           | Also return the character found
[LowerPos]   | integer          | Position to start the search from.
         | [1..LEN(Text)]   | Negative values are relative to the end of the text.
         | [-LEN(Text)..-1] | Defaults to beginning of the text.
[UpperPos]   | integer          | Position limit of the search.
         | [1..LEN(Text)]   | Negative values are relative to the end of the text.
         | [-LEN(Text)..-1] | Defaults to end of the text.

Examples
------------------------------------------------------------------------------------------------------------
SEARCH_NTH_CHAR("ab", "1234_A_B_A_0", 1)
Returns: 6 i.e. 1st A or B at position 6

SEARCH_NTH_CHAR("ab", "1234_A_B_A_0", 2)
Returns: 8 i.e. 2nd A or B at position 8

SEARCH_NTH_CHAR("ab", "1234_A_B_A_0", 2, 1, 7)
Returns: {10, "A"} i.e. 2nd A or B at position 10, searching from position 7. A was found

SEARCH_NTH_CHAR("ab", "1234_A_B_A_0", -2, 1, -4)
Returns: {6, "A"} i.e. 2nd A or B at position 6, using reverse search from 4 characters from end. A was found
----------------------------------------------------------------------------------------------------------*/
SEARCH_NTH_CHAR = LAMBDA(Chars, Text, N, [ReturnChar], [LowerPos], [UpperPos],
LET(
    _n, INT(N(N)),
    _signN, SIGN(_n),
    _outChar, N(ReturnChar) <> 0,
    _len, LEN(Text),
    _startPos, IFS(
        NOT(ISNUMBER(LowerPos)), 1,
        LowerPos > 0, LowerPos,
        LowerPos < 0, _len + LowerPos + 1,
        LowerPos = 0, 1
    ),
    _endPos, IFS(
        NOT(ISNUMBER(UpperPos)), _len,
        UpperPos > 0, UpperPos,
        UpperPos < 0, _len + UpperPos + 1,
        UpperPos = 0, _len
    ),
    
    IF((_startPos > _len) + (_startPos > _endPos) + (Chars = "") + (_n = 0),
        IF(_outChar, {0, ""}, 0),
        LET(
            _text, MID(Text, _startPos, _endPos - _startPos + 1),
            _chars, MID(Chars, SEQUENCE(1, LEN(Chars)), 1),
            _findCount, LET(
                _removed, REDUCE(UPPER(Text), UPPER(_chars),
                    LAMBDA(_acc, _curr, SUBSTITUTE(_acc, _curr, ""))
                ),
                _len - LEN(_removed)
            ),
            IF(_findCount < ABS(_n), IF(_outChar, {0, ""}, 0),
                LET(
                    // nth can count from end backwards
                    _nth, IF(_n > 0, _n, _findCount + _n + 1),
                    _nthPos, REDUCE(0, SEQUENCE(1, _nth),
                        LAMBDA(_acc, _curr,
                            IF(_acc < 0, -1,
                                LET(
                                    _nextPosChars, IFERROR(
                                        SEARCH(_chars, _text, _acc + 1),
                                        0
                                    ),
                                    _nextPos, MIN(
                                        FILTER(_nextPosChars, _nextPosChars > 0, 0)
                                    ),
                                    IF(_nextPos = 0, -1, _nextPos)
                                )
                            )
                        )
                    ),
                    _outPos, _nthPos + _startPos - 1,
                    
                    IF(_outChar,
                        IF(_outPos = 0, {0, ""},
                            HSTACK(
                                _outPos,
                                MID(_text, _nthPos, 1)
                            )
                        ),
                        _outPos
                    )
                )
            )
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
SPLIT_BY_CHARS

Splits text at any one of the given set of characters. First element returned is the sequence of matched
characters, followed by each substring. Matching is case sensitive.

Output
------------------------------------------------------------------------------------------------------------
1 | text | Array of substrings

Parameters
------------------------------------------------------------------------------------------------------------
Chars   | text    | Characters to split at
Text    | text    | Text to split
[Limit] | integer | Limit at which to stop splitting

Examples
------------------------------------------------------------------------------------------------------------
SPLIT_BY_CHARS_CI("_/", "1_2/34/56_7")
Returns: { "_//_"; "1"; "2"; "34"; "56"; "7"}
----------------------------------------------------------------------------------------------------------*/
SPLIT_BY_CHARS = LAMBDA(Chars, Text, [Limit],
IF((Chars = "") + (Text = ""), VSTACK("", NULLIFY(Text)),
    LET(
        _chars, MID(Chars, SEQUENCE(1, LEN(Chars)), 1),
        _limit, MAX(INT(N(Limit)), 0),
        _len, LEN(Text),
        
        _findCount, LET(
            _removed, REDUCE(Text, _chars,
                LAMBDA(_acc, _curr, SUBSTITUTE(_acc, _curr, ""))
            ),
            _len - LEN(_removed)
        ),

        _count, IF(_limit, MIN(_limit, _findCount), _findCount),
        _pos, VSTACK(
            REDUCE({0}, SEQUENCE(_count),
                LAMBDA(_acc, _curr,
                    LET(
                        _startFrom, INDEX(_acc, ROWS(_acc), 1) + 1, 
                        _nextPosChars, IFERROR(
                            FIND(_chars, Text, _startFrom),
                            0
                        ),
                        _nextPos, MIN(
                            FILTER(_nextPosChars, _nextPosChars > 0, 0)
                        ),
                        VSTACK(_acc, _nextPos)
                    )
                )
            ), _len + 1
        ),
        _sift, CONCAT(IFERROR(MID(Text, DROP(_pos, 1) , 1), "")),
        _idx, SEQUENCE(ROWS(_pos) - 1),
        VSTACK(
            _sift,
            IFERROR(MID(Text, INDEX(_pos, _idx) + 1, INDEX(_pos, _idx + 1) - INDEX(_pos, _idx) - 1), Text)
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
SPLIT_BY_CHARS_CI

Splits text at any one of the given set of characters. First element returned is the sequence of matched
characters, followed by each substring. Matching is case insensitive.

Output
------------------------------------------------------------------------------------------------------------
1 | text | Array of substrings

Parameters
------------------------------------------------------------------------------------------------------------
Chars   | text    | Characters to split at
Text    | text    | Text to split
[Limit] | integer | Limit at which to stop splitting

Examples
------------------------------------------------------------------------------------------------------------
SPLIT_BY_CHARS_CI("AB", "A12b34B56")
Returns: { "AbB"; ""; "12"; "34"; "56"}
----------------------------------------------------------------------------------------------------------*/
SPLIT_BY_CHARS_CI = LAMBDA(Chars, Text, [Limit],
IF((Chars = "") + (Text = ""), VSTACK("", NULLIFY(Text)),
    LET(
        _chars, MID(Chars, SEQUENCE(1, LEN(Chars)), 1),
        _limit, MAX(INT(N(Limit)), 0),
        _len, LEN(Text),
        
        _findCount, LET(
            _removed, REDUCE(UPPER(Text), UPPER(_chars),
                LAMBDA(_acc, _curr, SUBSTITUTE(_acc, _curr, ""))
            ),
            _len - LEN(_removed)
        ),

        _count, IF(_limit, MIN(_limit, _findCount), _findCount),
        _pos, VSTACK(
            REDUCE({0}, SEQUENCE(_count),
                LAMBDA(_acc, _curr,
                    LET(
                        _startFrom, INDEX(_acc, ROWS(_acc), 1) + 1, 
                        _nextPosChars, IFERROR(
                            SEARCH(_chars, Text, _startFrom),
                            0
                        ),
                        _nextPos, MIN(
                            FILTER(_nextPosChars, _nextPosChars > 0, 0)
                        ),
                        VSTACK(_acc, _nextPos)
                    )
                )
            ), _len + 1
        ),
        _sift, CONCAT(IFERROR(MID(Text, DROP(_pos, 1) , 1), "")),
        _idx, SEQUENCE(ROWS(_pos) - 1),
        VSTACK(
            _sift,
            IFERROR(MID(Text, INDEX(_pos, _idx) + 1, INDEX(_pos, _idx + 1) - INDEX(_pos, _idx) - 1), Text)
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
SPLIT_AROUND_CHARS

Splits text at any character not in the given set. First element returned is the sequence of unmatched
characters, followed by each substring. Matching is case sensitive.

Output
------------------------------------------------------------------------------------------------------------
1 | text | Array of substrings

Parameters
------------------------------------------------------------------------------------------------------------
Chars   | text    | Characters not split at
Text    | text    | Text to split
[Limit] | integer | Limit at which to stop splitting

Examples
------------------------------------------------------------------------------------------------------------
SPLIT_AROUND_CHARS("123456", "A12b34B56")
Returns: { "AbB"; ""; "12"; "34"; "56"}
----------------------------------------------------------------------------------------------------------*/
SPLIT_AROUND_CHARS = LAMBDA(Chars, Text, [Limit],
IF((Chars = "") + (Text = ""), VSTACK("", NULLIFY(Text)),
    LET(
        _chars, MID(Chars, SEQUENCE(1, LEN(Chars)), 1),
        _limit, MAX(INT(N(Limit)), 0),
        _len, LEN(Text),
        _pos, VSTACK(
            REDUCE({0}, SEQUENCE(_len),
                LAMBDA(_acc, _curr,
                    LET(
                        _isMatch, MAX(N(CODE(MID(Text, _curr, 1)) = CODE(_chars))),
                        IF(_isMatch, _acc,
                            VSTACK(_acc, _curr)
                        )
                    )
                )
            )
        ),
        
        _count, IF(_limit, MIN(_limit, ROWS(_pos) - 1), ROWS(_pos) - 1),
        
        _limitPos, VSTACK(
            IFERROR(TAKE(_pos, _count + 1), 0),
            _len + 1
        ),
        _sift, CONCAT(IFERROR(MID(Text, DROP(_limitPos, 1), 1), "")),
        _idx, SEQUENCE(_count + 1),
        VSTACK(
           _sift,
           IFERROR(MID(Text, INDEX(_limitPos, _idx) + 1, INDEX(_limitPos, _idx + 1) - INDEX(_limitPos, _idx) - 1), Text)
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
SPLIT_AROUND_CHARS_CI

Splits text at any character not in the given set. First element returned is the sequence of unmatched
characters, followed by each substring. Matching is case insensitive.

Output
------------------------------------------------------------------------------------------------------------
1 | text | Array of substrings

Parameters
------------------------------------------------------------------------------------------------------------
Chars   | text    | Characters not split at
Text    | text    | Text to split
[Limit] | integer | Limit at which to stop splitting

Examples
------------------------------------------------------------------------------------------------------------
SPLIT_AROUND_CHARS_CI("a123456", "A12b34B56")
Returns: { "bB"; ""; "a12"; "34"; "56"}
----------------------------------------------------------------------------------------------------------*/
SPLIT_AROUND_CHARS_CI = LAMBDA(Chars, Text, [Limit],
IF((Chars = "") + (Text = ""), VSTACK("", NULLIFY(Text)),
    LET(
        _chars, MID(Chars, SEQUENCE(1, LEN(Chars)), 1),
        _limit, MAX(INT(N(Limit)), 0),
        _len, LEN(Text),
        _pos, VSTACK(
            REDUCE({0}, SEQUENCE(_len),
                LAMBDA(_acc, _curr,
                    LET(
                        _isMatch, MAX(N(MID(Text, _curr, 1) = _chars)),
                        IF(_isMatch, _acc,
                            VSTACK(_acc, _curr)
                        )
                    )
                )
            )
        ),
        
        _count, IF(_limit, MIN(_limit, ROWS(_pos) - 1), ROWS(_pos) - 1),
        
        _limitPos, VSTACK(
            IFERROR(TAKE(_pos, _count + 1), 0),
            _len + 1
        ),
        _sift, CONCAT(IFERROR(MID(Text, DROP(_limitPos, 1), 1), "")),
        _idx, SEQUENCE(_count + 1),
        VSTACK(
           _sift,
           IFERROR(MID(Text, INDEX(_limitPos, _idx) + 1, INDEX(_limitPos, _idx + 1) - INDEX(_limitPos, _idx) - 1), Text)
        )
    )
)
);

















/*##########################################################################################################
# TIMESPAN                                                                                                 #
##########################################################################################################*/


/*----------------------------------------------------------------------------------------------------------
IS_VALID_TIMESPAN

Tests if sexagesimal representation of a timespan is valid.
An element can exceed its modulus if no higher order element is provided.

Output
------------------------------------------------------------------------------------------------------------
1 | boolean |

Parameters
------------------------------------------------------------------------------------------------------------
Sign      | integer [-1,0,1] |
Days      | decimal [0..]    | Fractional allowed if hours, minutes and seconds empty.
[Hours]   | decimal [0..24)  | Fractional allowed if minutes and seconds empty.
[Minutes] | decimal [0..60)  | Fractional allowed if seconds empty.
[Seconds] | decimal [0..60)  | Fractional allowed
----------------------------------------------------------------------------------------------------------*/
IS_VALID_TIMESPAN = LAMBDA(Sign, Days, [Hours], [Minutes], [Seconds],
IFS(
    ISERROR(Sign), FALSE,
    NOT(ISNUMBER(Sign)), FALSE,
    Sign < -1, FALSE,
    Sign > 1, FALSE,
    NOT(IS_INTEGER(Sign)), FALSE,
    TRUE, LET(
        _high, IFS(
            ISNUMBER(Days), 1,
            ISNUMBER(Hours), 2,
            ISNUMBER(Minutes), 3,
            ISNUMBER(Seconds), 4,
            TRUE, 0
        ),
        IF(_high = 0, FALSE,
            LET(
                _low, IFS(
                    ISNUMBER(Seconds), 4,
                    ISNUMBER(Minutes), 3,
                    ISNUMBER(Hours), 2,
                    ISNUMBER(Days), 1
                ),
                
                fnInvalidElement, LAMBDA(_element, _max, _level, _zeroSign,
                    IFS(
                        ISERROR(_element), TRUE,
                        (_element = "") * (_high < _level) * (_low > _level), TRUE,
                        _element = "", FALSE,
                        NOT(ISNUMBER(_element)), TRUE,
                        (_low > _level) * NOT(IS_INTEGER(_element)), TRUE,
                        _element < 0, TRUE,
                        _zeroSign * (_element > 0), TRUE,
                        IF(_max = "", 0, (_high < _level) * (_element >= _max)), TRUE,
                        TRUE, FALSE
                    )
                ),
                
                _zeroSign, Sign = 0,
                IFS(
                    fnInvalidElement(Days, "", 1, _zeroSign), FALSE,
                    fnInvalidElement(Hours, 24, 2, _zeroSign), FALSE,
                    fnInvalidElement(Minutes, 60, 3, _zeroSign), FALSE,
                    fnInvalidElement(Seconds, 60, 4, _zeroSign), FALSE,
                    TRUE, TRUE
                )
            )
        )
    )
)    
);


/*----------------------------------------------------------------------------------------------------------
VALIDATE_TIMESPAN

Validate each element of a sexagesimal representation of a timespan.
An element can exceed its modulus if no higher order element is provided.

Output
------------------------------------------------------------------------------------------------------------
1 | integer [-1,0,1] | Sign
2 | decimal [0..]    | Days
3 | decimal [0..24)  | Hours
4 | decimal [0..60)  | Minutes
5 | decimal [0..60)  | Seconds

Parameters
------------------------------------------------------------------------------------------------------------
Sign      | integer [-1,0,1] |
Days      | decimal [0..]    | Fractional allowed if hours, minutes and seconds empty.
[Hours]   | decimal [0..24)  | Fractional allowed if minutes and seconds empty.
[Minutes] | decimal [0..60)  | Fractional allowed if seconds empty.
[Seconds] | decimal [0..60)  | Fractional allowed
----------------------------------------------------------------------------------------------------------*/
VALIDATE_TIMESPAN = LAMBDA(Sign, Days, [Hours], [Minutes], [Seconds],
LET(
    _high, IFS(
        ISNUMBER(Days), 1,
        ISNUMBER(Hours), 2,
        ISNUMBER(Minutes), 3,
        ISNUMBER(Seconds), 4,
        TRUE, 0
    ),

    _low, IFS(
        ISNUMBER(Seconds), 4,
        ISNUMBER(Minutes), 3,
        ISNUMBER(Hours), 2,
        ISNUMBER(Days), 1,
        TRUE, 0
    ),
    
    fnCheckElement, LAMBDA(_element, _max, _level, _zeroSign,
        IFS(
            ISERROR(_element), _element,
            (_element = "") * (_high < _level) * (_low > _level), {#VALUE!},
            _element = "", "",
            NOT(ISNUMBER(_element)), {#VALUE!},
            (_low > _level) * NOT(IS_INTEGER(_element)), {#NUM!},
            _element < 0, {#NUM!},
            _zeroSign * (_element > 0), {#NUM!},
            IF(_max = "", 0, (_high < _level) * (_element >= _max)), {#NUM!},
            TRUE, _element
        )
    ),
    
    _sign, IFS(
        NOT(ISNUMBER(Sign)), {#VALUE!},
        Sign < -1, {#NUM!},
        Sign > 1, {#NUM!},
        NOT(IS_INTEGER(Sign)), {#NUM!},
        TRUE, Sign
    ),
    _zeroSign, IF(ISNUMBER(_sign), _sign = 0, FALSE),
    
    _days, fnCheckElement(Days, "", 1, _zeroSign),
    _hours, fnCheckElement(Hours, 24, 2, _zeroSign),
    _minutes, fnCheckElement(Minutes, 60, 3, _zeroSign),
    _seconds, fnCheckElement(Seconds, 60, 4, _zeroSign),
    IF(
        ISNUMBER(_sign) * IS_EMPTY(_days) * IS_EMPTY(_hours) * IS_EMPTY(_minutes) * IS_EMPTY(_seconds),
        HSTACK(_sign, {#VALUE!, #VALUE!, #VALUE!, #VALUE!}),
        HSTACK(_sign, _days, _hours, _minutes, _seconds)
    )
)
);


/*----------------------------------------------------------------------------------------------------------
TIMESPAN_LOW_ORDER

Returns a number representing the lowest order element of the sexagesimal representation of a timespan value.

Output
------------------------------------------------------------------------------------------------------------
1 | integer | Order, #N/A for zero
|         |  1 - Day
|         |  2 - Hour
|         |  3 - Minute
|         |  4 - Second

Parameters
------------------------------------------------------------------------------------------------------------
Days      | decimal         | Decimal timespan when omitting hours, minutes and seconds
[Hours]   | integer [0..23] |
[Minutes] | integer [0..59] |
[Seconds] | decimal [0..60) |
----------------------------------------------------------------------------------------------------------*/
TIMESPAN_LOW_ORDER = LAMBDA(Days, [Hours], [Minutes], [Seconds],
IFS(
    (Days = "") * (Hours = "") * (Minutes = "") * (Seconds = ""), "",
    ISNUMBER(Days) * IS_EMPTY(Hours) * IS_EMPTY(Minutes) * IS_EMPTY(Seconds), IFS(
        Days = 0, {#N/A},
        NOT(IS_INTEGER(Days * 1440)), 4,
        NOT(IS_INTEGER(Days * 24)), 3,
        NOT(IS_INTEGER(Days)), 2,
        ISNUMBER(Days), 1,
        TRUE, {#N/A}
    ),
    ISNUMBER(Hours) + ISNUMBER(Minutes) + ISNUMBER(Seconds), IFS(
        ABS(N(Seconds)) > 0, 4,
        ABS(N(Minutes)) > 0, 3,
        ABS(N(Hours)) > 0, 2,
        ABS(N(Days)) > 0, 1,
        TRUE, {#N/A}
    ),
    TRUE, {#VALUE!}
)
);


/*----------------------------------------------------------------------------------------------------------
TIMESPAN_HIGH_ORDER

Returns a number representing the highest order element of the sexagesimal representation of a timespan value.

Output
------------------------------------------------------------------------------------------------------------
1 | integer | Order, #N/A for zero
|         |  1 - Day
|         |  2 - Hour
|         |  3 - Minute
|         |  4 - Second

Parameters
------------------------------------------------------------------------------------------------------------
Days      | decimal         | Decimal timespan when omitting hours, minutes and seconds
[Hours]   | integer [0..23] |
[Minutes] | integer [0..59] |
[Seconds] | decimal [0..60) |
----------------------------------------------------------------------------------------------------------*/
TIMESPAN_HIGH_ORDER = LAMBDA(Days, [Hours], [Minutes], [Seconds],
IFS(
    (Days = "") * (Hours = "") * (Minutes = "") * (Seconds = ""), "",
    ISNUMBER(Days) * IS_EMPTY(Hours) * IS_EMPTY(Minutes) * IS_EMPTY(Seconds), LET(
        _absTimeSpan, ABS(Days),
        IFS(
            _absTimeSpan = 0, {#N/A},
            _absTimeSpan >= 1, 1,
            _absTimeSpan * 24 >= 1, 2,
            _absTimeSpan * 1440 >= 1, 3,
            TRUE, 4
        )
    ),
    ISNUMBER(Days) + ISNUMBER(Hours) + ISNUMBER(Minutes) + ISNUMBER(Seconds), IFS(
        ABS(N(Days)) > 0, 1,
        ABS(N(Hours)) > 0, 2,
        ABS(N(Minutes)) > 0, 3,
        ABS(N(Seconds)) > 0, 4,
        TRUE, {#N/A}
    ),
    TRUE, {#VALUE!}
)
);


/*----------------------------------------------------------------------------------------------------------
TIMESPAN

Returns a decimal timespan as a fraction of a day from sexagesimal representation of time.
Note out-of-range parameters will carry.

Output
------------------------------------------------------------------------------------------------------------
1 | decimal | Timespan as fraction of a day. Implicitly converts to Excel Date/Time type for non-negative
|         | values.

Parameters
------------------------------------------------------------------------------------------------------------
Sign      | integer [-1,0,1] |
Days      | decimal [0..]    |
[Hours]   | decimal [0..23]  |
[Minutes] | decimal [0..59]  |
[Seconds] | decimal [0..60)  |
----------------------------------------------------------------------------------------------------------*/
TIMESPAN = LAMBDA(Sign, Days, [Hours], [Minutes], [Seconds],
IFS(
    IS_EMPTY(Days) * IS_EMPTY(Hours) * IS_EMPTY(Minutes) * IS_EMPTY(Seconds), "",
    ISERROR(Sign), Sign,
    ISERROR(Days), Days,
    ISERROR(Hours), Hours,
    ISERROR(Minutes), Minutes,
    ISERROR(Seconds), Seconds,
    IS_NON_NUMERIC(Sign), {#VALUE!},
    IS_NON_NUMERIC(Days), {#VALUE!},
    IS_NON_NUMERIC(Hours), {#VALUE!},
    IS_NON_NUMERIC(Minutes), {#VALUE!},
    IS_NON_NUMERIC(Seconds), {#VALUE!},
    TRUE, LET(
        _sign, IFS(
            Sign = 0, 0,
            Sign < 0, -1,
            TRUE, 1
        ),
        _sign * (N(Days) + (N(Hours) / 24) + (N(Minutes) / 1440) + (N(Seconds) / 86400))
    )
)
);


/*----------------------------------------------------------------------------------------------------------
ROUND_TIMESPAN

Returns a decimal timespan value rounded to the specified precision.

Output
------------------------------------------------------------------------------------------------------------
1 | decimal | TimeSpan

Parameters
------------------------------------------------------------------------------------------------------------
TimeSpan      | decimal | Decimal timespan where a day = 1
[Precision]   | integer | Select precision level
          | [-3..9] | Null - Floating
          |         |   -3 - Day
          |         |   -2 - Hour
          |         |   -1 - Minute
          |         |    0 - Second
          |         |    1 - Decisecond
          |         |    2 - Centisecond
          |         |    3 - Millisecond
          |         |    ...
          |         |    9 - Nanosecond
[Truncate]    | switch  | Round to precision by truncating components. Default is rounding to nearest.
----------------------------------------------------------------------------------------------------------*/
ROUND_TIMESPAN = LAMBDA(TimeSpan, [Precision], [Truncate],
IFS(
    TimeSpan = "", "",
    NOT(ISNUMBER(TimeSpan)), {#VALUE!},
    TimeSpan = 0, 0,
    TRUE, LET(
        _truncate, N(Truncate) <> 0,
        _precision, IFS(
            NOT(ISNUMBER(Precision)), "",
            Precision < -3, -3,
            Precision > 9, 9,
            TRUE, INT(Precision)
        ),
        IFS(
            _precision = "", TimeSpan,
            _truncate, IFS(
                _precision = -3, ROUNDDOWN(TimeSpan, 0),
                _precision = -2, ROUNDDOWN(TimeSpan * 24, 0) / 24,
                _precision = -1, ROUNDDOWN(TimeSpan * 1440, 0) / 1440,
                TRUE, ROUNDDOWN(TimeSpan * 86400, _precision) / 86400
            ),
            TRUE, IFS(
                _precision = -3, ROUND(TimeSpan, 0),
                _precision = -2, ROUND(TimeSpan * 24, 0) / 24,
                _precision = -1, ROUND(TimeSpan * 1440, 0) / 1440,
                TRUE, ROUND(TimeSpan * 86400, _precision) / 86400
            )
        )
    )
)
);



/*----------------------------------------------------------------------------------------------------------
RESOLVE_TIMESPAN

Returns the sexagesimal representation of a timespan value with the given lowest order element rounded to the
specified precision.

Output
------------------------------------------------------------------------------------------------------------
1 | integer [-1,0,1] | Sign
2 | integer [0..]    | Days
3 | integer [0..23]  | Hours
4 | integer [0..59]  | Minutes
5 | decimal [0..60)  | Seconds

Parameters
------------------------------------------------------------------------------------------------------------
TimeSpan      | decimal | Decimal timespan where a day = 1
[HighOrder]   | integer | Highest-order element. Defaults to Day.
          | [1..4]  |  1 - Day
          |         |  2 - Hour
          |         |  3 - Minute
          |         |  4 - Second
[LowOrder]    | integer | Lowest-order element. Defaults to Second.
          | [1..4]  |  1 - Day
          |         |  2 - Hour
          |         |  3 - Minute
          |         |  4 - Second
[Precision]   | integer | Select precision level
          | [0..9]  | Null - Floating
[Truncate]    | switch  | Round to precision by truncating components. Default is rounding to nearest.
----------------------------------------------------------------------------------------------------------*/
RESOLVE_TIMESPAN = LAMBDA(TimeSpan, [HighOrder], [LowOrder], [Precision], [Truncate],
LET(
    _lowOrder, IFS(
        NOT(ISNUMBER(LowOrder)), 4,
        LowOrder < 1, 4,
        LowOrder > 4, 4,
        TRUE, INT(LowOrder)
    ),
    
    _highOrder, LET(
        _high, IFS(
            NOT(ISNUMBER(HighOrder)), 1,
            HighOrder < 1, 1,
            HighOrder > 4, 4,
            TRUE, INT(HighOrder)
        ),
        IF(_high > _lowOrder, _lowOrder, _high)
    ),
    
    IFS(
        TimeSpan = "", {"", "", "", "", ""},
        NOT(ISNUMBER(TimeSpan)), {#VALUE!, "", "", "", ""},
        TimeSpan = 0, CHOOSECOLS({0, 0, 0, 0, 0, "", "", ""}, SEQUENCE(1, 5, 5 - _lowOrder)), 
        TRUE, LET(
            _truncate, N(Truncate) <> 0,
            _absTimeSpan, ABS(TimeSpan),
            _sign, SIGN(TimeSpan),
            _precision, IFS(
                Precision = "", "",
                Precision < 0, 0,
                Precision > 9, 9,
                TRUE, INT(Precision)
            ),
            IFS(
                _highOrder = 1, IFS(
                    _lowOrder = 4, LET(
                        _seconds, _absTimeSpan * 86400,
                        _minutes, INT(_seconds / 60),
                        _decSecond, _seconds - (_minutes * 60),
                        _hours, INT(_minutes / 60),
                        _rMinute, _minutes - (_hours * 60),
                        _rDay, INT(_hours / 24),
                        _rHour, _hours - (_rDay * 24),
                        // Round second last because arithmetic rounding of the timespan decimal value
                        // can bring in floating point errors.
                        // Sign checked for rounding down to zero.
                        // Second checked for rounding up to minute.
                        _rSecond, IFS(
                            _precision = "", _decSecond,
                            _truncate, ROUNDDOWN(_decSecond, _precision),
                            TRUE, ROUND(_decSecond, _precision)
                        ),
                        _rSign, IFS(
                            _rSecond > 0, _sign,
                            _rMinute > 0, _sign,
                            _rHour > 0, _sign,
                            _rDay > 0, _sign,
                            TRUE, 0
                        ),
                        IFS(
                            _rSecond < 60, HSTACK(_rSign, _rDay, _rHour, _rMinute, _rSecond),
                            _rMinute <= 58, HSTACK(_rSign, _rDay, _rHour, _rMinute + 1, 0),
                            _rHour <= 22, HSTACK(_rSign, _rDay, _rHour + 1, 0, 0),
                            TRUE, HSTACK(_rSign, _rDay + 1, 0, 0, 0)
                        )
                    ),
                
                    _lowOrder = 3, LET(
                        _minutes, _absTimeSpan * 1440,
                        _hours, INT(_minutes / 60),
                        _decMinute, _minutes - (_hours * 60),
                        _rDay, INT(_hours / 24),
                        _rHour, _hours - (_rDay * 24),
                        // Round minute last because arithmetic rounding of the timespan decimal value
                        // can bring in floating point errors.
                        // Sign checked for rounding down to zero.
                        // Minute checked for rounding up to hour.
                        _rMinute, IFS(
                            _precision = "", _decMinute,
                            _truncate, ROUNDDOWN(_decMinute, _precision),
                            TRUE, ROUND(_decMinute, _precision)
                        ),
                        _rSign, IFS(
                            _rMinute > 0, _sign,
                            _rHour > 0, _sign,
                            _rDay > 0, _sign,
                            TRUE, 0
                        ),
                        IFS(
                            _rMinute < 60, HSTACK(_rSign, _rDay, _rHour, _rMinute, ""),
                            _rHour <= 22, HSTACK(_rSign, _rDay, _rHour + 1, 0, ""),
                            TRUE, HSTACK(_rSign, _rDay + 1, 0, 0, "")
                        )
                    ),
                    _lowOrder = 2, LET(
                        _hours, _absTimeSpan * 24,
                        _rDay, INT(_hours / 24),
                        _decHour, _hours - (_rDay * 24),
                        // Round hour last because arithmetic rounding of the timespan decimal value
                        // can bring in floating point errors.
                        // Sign checked for rounding down to zero.
                        // Hour checked for rounding up to day.
                        _rHour, IFS(
                            _precision = "", _decHour,
                            _truncate, ROUNDDOWN(_decHour, _precision),
                            TRUE, ROUND(_decHour, _precision)
                        ),
                        _rSign, IFS(
                            _rHour > 0, _sign,
                            _rDay > 0, _sign,
                            TRUE, 0
                        ),
                        IFS(
                            _rHour < 24, HSTACK(_rSign, _rDay, _rHour, "", ""),
                            TRUE, HSTACK(_rSign, _rDay + 1, 0, "", "")
                        )
                    ),
                    _lowOrder = 1, LET(
                        _decDay, _absTimeSpan,
                        _rDay, IFS(
                            _precision = "", _decDay,
                            _truncate, ROUNDDOWN(_decDay, _precision),
                            TRUE, ROUND(_decDay, _precision)
                        ),
                        _rSign, IFS(
                            _rDay > 0, _sign,
                            TRUE, 0
                        ),
                        HSTACK(_rSign, _rDay, "", "", "")
                    )
                ),

                _highOrder = 2, IFS(
                    _lowOrder = 4, LET(
                        _seconds, _absTimeSpan * 86400,
                        _minutes, INT(_seconds / 60),
                        _decSecond, _seconds - (_minutes * 60),
                        _rHour, INT(_minutes / 60),
                        _rMinute, _minutes - (_rHour * 60),
                        // Round second last because arithmetic rounding of the timespan decimal value
                        // can bring in floating point errors.
                        // Sign checked for rounding down to zero.
                        // Second checked for rounding up to minute.
                        _rSecond, IFS(
                            _precision = "", _decSecond,
                            _truncate, ROUNDDOWN(_decSecond, _precision),
                            TRUE, ROUND(_decSecond, _precision)
                        ),
                        _rSign, IFS(
                            _rSecond > 0, _sign,
                            _rMinute > 0, _sign,
                            _rHour > 0, _sign,
                            TRUE, 0
                        ),
                        IFS(
                            _rSecond < 60, HSTACK(_rSign, "", _rHour, _rMinute, _rSecond),
                            _rMinute <= 58, HSTACK(_rSign, "", _rHour, _rMinute + 1, 0),
                            TRUE, HSTACK(_rSign, "", _rHour + 1, 0, 0)
                        )
                    ),
                
                    _lowOrder = 3, LET(
                        _minutes, _absTimeSpan * 1440,
                        _rHour, INT(_minutes / 60),
                        _decMinute, _minutes - (_rHour * 60),
                        // Round minute last because arithmetic rounding of the timespan decimal value
                        // can bring in floating point errors.
                        // Sign checked for rounding down to zero.
                        // Minute checked for rounding up to hour.
                        _rMinute, IFS(
                            _precision = "", _decMinute,
                            _truncate, ROUNDDOWN(_decMinute, _precision),
                            TRUE, ROUND(_decMinute, _precision)
                        ),
                        _rSign, IFS(
                            _rMinute > 0, _sign,
                            _rHour > 0, _sign,
                            TRUE, 0
                        ),
                        IF(_rMinute < 60,
                            HSTACK(_rSign, "", _rHour, _rMinute, ""),
                            HSTACK(_rSign, "", _rHour + 1, 0, "")
                        )
                    ),
                    _lowOrder = 2, LET(
                        _decHour, _absTimeSpan * 24,
                        // Round hour last because arithmetic rounding of the timespan decimal value
                        // can bring in floating point errors.
                        // Sign checked for rounding down to zero.
                        // Hour checked for rounding up to day.
                        _rHour, IFS(
                            _precision = "", _decHour,
                            _truncate, ROUNDDOWN(_decHour, _precision),
                            TRUE, ROUND(_decHour, _precision)
                        ),
                        _rSign, IF(_rHour > 0,
                            _sign,
                            0
                        ),
                        HSTACK(_rSign, "", _rHour, "", "")
                    )
                ),

                _highOrder = 3, IFS(
                    _lowOrder = 4, LET(
                        _seconds, _absTimeSpan * 86400,
                        _rMinute, INT(_seconds / 60),
                        _decSecond, _seconds - (_rMinute * 60),
                        // Round second last because arithmetic rounding of the timespan decimal value
                        // can bring in floating point errors.
                        // Sign checked for rounding down to zero.
                        // Second checked for rounding up to minute.
                        _rSecond, IFS(
                            _precision = "", _decSecond,
                            _truncate, ROUNDDOWN(_decSecond, _precision),
                            TRUE, ROUND(_decSecond, _precision)
                        ),
                        _rSign, IFS(
                            _rSecond > 0, _sign,
                            _rMinute > 0, _sign,
                            TRUE, 0
                        ),
                        IF(_rSecond < 60,
                            HSTACK(_rSign, "", "", _rMinute, _rSecond),
                            HSTACK(_rSign, "", "", _rMinute + 1, 0)
                        )
                    ),
                
                    _lowOrder = 3, LET(
                        _minutes, _absTimeSpan * 1440,
                        _rHour, INT(_minutes / 60),
                        _decMinute, _minutes - (_rHour * 60),
                        // Round minute last because arithmetic rounding of the timespan decimal value
                        // can bring in floating point errors.
                        // Sign checked for rounding down to zero.
                        // Minute checked for rounding up to hour.
                        _rMinute, IFS(
                            _precision = "", _decMinute,
                            _truncate, ROUNDDOWN(_decMinute, _precision),
                            TRUE, ROUND(_decMinute, _precision)
                        ),
                        _rSign, IFS(
                            _rMinute > 0, _sign,
                            _rHour > 0, _sign,
                            TRUE, 0
                        ),
                        IF(_rMinute < 60,
                            HSTACK(_rSign, "", _rHour, _rMinute, ""),
                            HSTACK(_rSign, "", _rHour + 1, 0, "")
                        )
                    )
                ),

                _highOrder = 4, IFS(
                    _lowOrder = 4, LET(
                        _decSecond, _absTimeSpan * 86400,
                        // Round second last because arithmetic rounding of the timespan decimal value
                        // can bring in floating point errors.
                        // Sign checked for rounding down to zero.
                        // Second checked for rounding up to minute.
                        _rSecond, IFS(
                            _precision = "", _decSecond,
                            _truncate, ROUNDDOWN(_decSecond, _precision),
                            TRUE, ROUND(_decSecond, _precision)
                        ),
                        _rSign, IF(_rSecond > 0,
                            _sign,
                            0
                        ),
                        HSTACK(_rSign, "", "", "", _rSecond)
                    )
                )
            )                    
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
PARSE_TIMESPAN

Parses a timespan into sexagesimal elements.

Output
------------------------------------------------------------------------------------------------------------
1 | decimal [0..1] | Time of day as decimal fraction of a day.

Parameters
------------------------------------------------------------------------------------------------------------
TimeSpanText | text   | Formatted TimeSpan

Examples
------------------------------------------------------------------------------------------------------------
PARSE_TIMESPAN("12:00")
Returns: 0.5

PARSE_TIMESPAN("24:00:01")
Returns: #NUM!  i.e. range is 0 to 24 hours 
----------------------------------------------------------------------------------------------------------*/
PARSE_TIMESPAN = LAMBDA(TimeSpanText, [AsComplication],
LET(
    _asValue, N(AsComplication) = 0,
    IFS(
        TimeSpanText = "", IF(_asValue, "", {"", "", "", "", ""}),
        _asValue * ISNUMBER(TimeSpanText), TimeSpanText, 
        TRUE, LET(
            fnParseModernFmt, LAMBDA(_text,
                LET(
                    _split, SPLIT_AROUND_CHARS("0123456789", _text),
                    _pattern, INDEX(_split, 1),
                    IFS(
                        // d.hh:mm:ss.000
                        _pattern = ".::.", HSTACK(
                            VALUE(INDEX(_split, 2)),
                            VALUE(INDEX(_split, 3)),
                            VALUE(INDEX(_split, 4)),
                            VALUE(INDEX(_split, 5) & "." & LEFT(INDEX(_split, 6), 9))
                        ),
                        // d.hh:mm:ss
                        _pattern = ".::", HSTACK(
                            VALUE(INDEX(_split, 2)),
                            VALUE(INDEX(_split, 3)),
                            VALUE(INDEX(_split, 4)),
                            VALUE(INDEX(_split, 5))
                        ),
                        // d.hh:mm
                        _pattern = ".:", HSTACK(
                            VALUE(INDEX(_split, 2)),
                            VALUE(INDEX(_split, 3)),
                            VALUE(INDEX(_split, 4)),
                            ""
                        ),
                        // h:mm:ss.000
                        _pattern = "::.", HSTACK(
                            "",
                            VALUE(INDEX(_split, 2)),
                            VALUE(INDEX(_split, 3)),
                            VALUE(INDEX(_split, 4) & "." & LEFT(INDEX(_split, 5), 9))
                        ),
                        // h:mm:ss
                        _pattern = "::", HSTACK(
                            "",
                            VALUE(INDEX(_split, 2)),
                            VALUE(INDEX(_split, 3)),
                            VALUE(INDEX(_split, 4))
                        ),
                        // m:ss.000
                        _pattern = ":.", HSTACK(
                            "",
                            "",
                            VALUE(INDEX(_split, 2)),
                            VALUE(INDEX(_split, 3) & "." & LEFT(INDEX(_split, 4), 9))
                        ),
                        // h:mm
                        _pattern = ":", HSTACK(
                            "",
                            VALUE(INDEX(_split, 2)),
                            VALUE(INDEX(_split, 3)),
                            ""
                        ),
                        // d.000
                        _pattern = ".", HSTACK(
                            VALUE(INDEX(_split, 2) & "." & INDEX(_split, 3)),
                            "",
                            "",
                            ""
                        ),
                        TRUE, {#VALUE!}
                    )
                )
            ),

            fnParseTraditionalFmt, LAMBDA(_text,
                LET(
                    _split, SPLIT_AROUND_CHARS(".0123456789", _text),
                    _pattern, INDEX(_split, 1),
                    IFS(
                        // 0d00h00'00.000"
                        _pattern = "dh'""", HSTACK(
                            VALUE(INDEX(_split, 2)),
                            VALUE(INDEX(_split, 3)),
                            VALUE(INDEX(_split, 4)),
                            ROUNDDOWN(VALUE(INDEX(_split, 5)), 9)
                        ),
                        // 0d00h00.000'
                        _pattern = "dh'", HSTACK(
                            VALUE(INDEX(_split, 2)),
                            VALUE(INDEX(_split, 3)),
                            ROUNDDOWN(VALUE(INDEX(_split, 4)), 9),
                            ""
                        ),
                        // 0d00.000h
                        _pattern = "dh", HSTACK(
                            VALUE(INDEX(_split, 2)),
                            ROUNDDOWN(VALUE(INDEX(_split, 3)), 9),
                            "",
                            ""
                        ),
                        // 0.000d
                        _pattern = "d", HSTACK(
                            ROUNDDOWN(VALUE(INDEX(_split, 2)), 9),
                            "",
                            "",
                            ""
                        ),
                        // 0h00'00.000"
                        _pattern = "h'""", HSTACK(
                            "",
                            VALUE(INDEX(_split, 2)),
                            VALUE(INDEX(_split, 3)),
                            ROUNDDOWN(VALUE(INDEX(_split, 4)), 9)
                        ),
                        // 0h00.000'
                        _pattern = "h'", HSTACK(
                            "",
                            VALUE(INDEX(_split, 2)),
                            ROUNDDOWN(VALUE(INDEX(_split, 3)), 9),
                            ""
                        ),
                        // 0.000h
                        _pattern = "h", HSTACK(
                            "",
                            ROUNDDOWN(VALUE(INDEX(_split, 2)), 9),
                            "",
                            ""
                        ),
                        // 0'00.000"
                        _pattern = "'""", HSTACK(
                            "",
                            "", 
                            VALUE(INDEX(_split, 2)),
                            ROUNDDOWN(VALUE(INDEX(_split, 3)), 9)
                        ),
                        // 0.000'
                        _pattern = "'", HSTACK(
                            "",
                            "",
                            ROUNDDOWN(VALUE(INDEX(_split, 2)), 9),
                            ""
                        ),
                        // 0.000"
                        _pattern = """", HSTACK(
                            "",
                            "",
                            "",
                            ROUNDDOWN(VALUE(INDEX(_split, 2)), 9)
                        ),
                        // 0.000
                        _pattern = "", HSTACK(
                            ROUNDDOWN(VALUE(INDEX(_split, 2)), 9),
                            "",
                            "",
                            ""
                        ),
                        TRUE, {#VALUE!}
                    )
                )
            ),

            _complication, IF(ISNUMBER(TimeSpanText), RESOLVE_TIMESPAN(TimeSpanText),
                LET(
                    _isModernFmt, IFERROR(FIND(":", TimeSpanText), 0) > 0,
                    _timeSpanText, IF(_isModernFmt, TimeSpanText, SUBSTITUTE(TimeSpanText, " ", "")),
                    _firstChar, LEFT(_timeSpanText, 1),
                    _hasSign, IFS(
                        _firstChar = "+", TRUE,
                        _firstChar = "-", TRUE,
                        _firstChar = UNICHAR(8722), TRUE,
                        TRUE, FALSE
                    ),
                    _nominalSign, IFS(
                        _firstChar = "-", -1,
                        _firstChar = UNICHAR(8722), -1,
                        TRUE, 1
                    ),
                    _uTimeSpan, IF(_hasSign, MID(_timeSpanText, 2, LEN(_timeSpanText) - 1), _timeSpanText),
                    
                    _tryParse, IF(_isModernFmt, fnParseModernFmt(_uTimeSpan), fnParseTraditionalFmt(_uTimeSpan)),
                    IF(ISERROR(INDEX(_tryParse, 1, 1)), {#VALUE!, "", "", "", ""},
                        LET(
                            _sign, IFS(
                                INDEX(_tryParse, 1, 1) > 0, _nominalSign,
                                INDEX(_tryParse, 1, 2) > 0, _nominalSign,
                                INDEX(_tryParse, 1, 3) > 0, _nominalSign,
                                INDEX(_tryParse, 1, 4) > 0, _nominalSign,
                                TRUE, 0
                            ),
                            VALIDATE_TIMESPAN(
                                _sign,
                                INDEX(_tryParse, 1, 1),
                                INDEX(_tryParse, 1, 2),
                                INDEX(_tryParse, 1, 3),
                                INDEX(_tryParse, 1, 4)
                            )
                        )
                    )
                )
            ),

            IF(_asValue,
                TIMESPAN(
                    INDEX(_complication, 1, 1),
                    INDEX(_complication, 1, 2),
                    INDEX(_complication, 1, 3),
                    INDEX(_complication, 1, 4),
                    INDEX(_complication, 1, 5)
                ),
                _complication
            )
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
FORMAT_TIMESPAN

Returns a timespan as text in the specified format from a given decimal timespan.

Output
------------------------------------------------------------------------------------------------------------
1 | text    | Formatted timespan d.HH:mm:ss.000

Parameters
------------------------------------------------------------------------------------------------------------
TimeSpan       | decimal | Decimal timespan where a day = 1
[Options]      | text    | String with elements: [Style][+][P][<][~][MostSig][LeastSig]
           |         |    Style : null = Standard, I = ISO, E = European, L = Literary
           |         |        + : Display positive sign for non-negative values
           |         |        P : Pad leading values < 10 with zero. For example 1 hour -> 01
           |         |          : Note inapplicable to Literary style.
           |         |        < : Round by truncating components. Default is rounding to nearest.
           |         |        ~ : Floating display starting from MostSig, to no futher than LeastSig
           |         |          : If ommitted, default behaviour is fully expressed display from MostSig to LeastSig
           |         |  MostSig : most significant component
           |         | LeastSig : least significant component 
           |         | MostSig and LeastSig elements take the following:
           |         |        D : Day
           |         |        H : Hour
           |         |        M : Minute
           |         |        S : Second
           |         |        1 : Decisecond
           |         |        2 : Centisecond
           |         |        3 : Millisecond

Examples
------------------------------------------------------------------------------------------------------------
FORMAT_TIMESPAN(1.7865, "")
Returns: 1.18:52:33.600

FORMAT_TIMESPAN(1.7865, "H:S")
Returns: 42:52:34

FORMAT_TIMESPAN(1.7865, "IH:S<")
Returns: 42h52m33s

FORMAT_TIMESPAN(1.7865, "E+H:S")
Returns: +42h52'34"

FORMAT_TIMESPAN(1.7865, "H~S")
Returns: +42h52'34"
----------------------------------------------------------------------------------------------------------*/
FORMAT_TIMESPAN = LAMBDA(TimeSpan, [Options],
IFS(
    IS_EMPTY(TimeSpan), "",
    NOT(ISNUMBER(TimeSpan)), {#VALUE!},
    TRUE, LET(
        _modernStyle, IFERROR(SEARCH("T", Options), 0) = 0,
        _fixed, IFERROR(FIND("~", Options), 0) = 0,
        _signPositive, IFERROR(FIND("+", Options), 0) > 0,
        _padding, IFERROR(SEARCH("P", Options), 0) > 0,
        _truncate, IFERROR(FIND("<", Options), 0) > 0,
        _spaced, IF(_modernStyle, FALSE, IFERROR(SEARCH("_", Options), 0) > 0),

        // day, hour, minute, second, null if not provided
        _tryHighOrderChar, SEARCH_NTH_CHAR("DHMS", Options, 1, 1),
        _passedHighOrder, IFS(
            INDEX(_tryHighOrderChar, 1, 1) = 0, "",
            INDEX(_tryHighOrderChar, 1, 2) = "D", 1,
            INDEX(_tryHighOrderChar, 1, 2) = "H", 2,
            INDEX(_tryHighOrderChar, 1, 2) = "M", 3,
            INDEX(_tryHighOrderChar, 1, 2) = "S", 4
        ),

        // day, hour, minute, second, decimals, null if not provided
        _passedLowOrder, LET(
            _tryLowOrderChar, SEARCH_NTH_CHAR("DHMS", Options, 1, 1, INDEX(_tryHighOrderChar, 1, 1) + 1),
            IFS(
                INDEX(_tryLowOrderChar, 1, 1) = 0, "",
                INDEX(_tryLowOrderChar, 1, 2) = "D", 1,
                INDEX(_tryLowOrderChar, 1, 2) = "H", 2,
                INDEX(_tryLowOrderChar, 1, 2) = "M", 3,
                INDEX(_tryLowOrderChar, 1, 2) = "S", 4
            )
        ),
        
        // precision (max 9 decimals for nanoseconds)
        _tryPrecision, SEARCH_NTH_CHAR("0123456789", Options, 1, 1),
        _passedPrecision, IF(INDEX(_tryPrecision, 1, 1) = 0, "", VALUE(INDEX(_tryPrecision, 1, 2))),

        // switch if needed
        _passedLowOrder1, IF(ISNUMBER(_passedLowOrder) * ISNUMBER(_passedHighOrder),
            IF(_passedLowOrder < _passedHighOrder, _passedHighOrder, _passedLowOrder),
            _passedLowOrder
        ),
        _passedHighOrder1, IF(ISNUMBER(_passedLowOrder) * ISNUMBER(_passedHighOrder),
            IF(_passedLowOrder < _passedHighOrder, _passedLowOrder, _passedHighOrder),
            _passedHighOrder
        ),
        
        // for modern style high order can be days or hours
        _useHighOrder, IFS(
            _passedHighOrder1 = "", 1,
            NOT(_modernStyle), _passedHighOrder1,
            ISNUMBER(_passedHighOrder1) * (_passedHighOrder1 > 2), 2,
            TRUE, _passedHighOrder1
        ),

        // for modern style low order can be minutes or seconds
        _useLowOrder, IFS(
            _passedLowOrder1 = "", 4,
            NOT(_modernStyle), _passedLowOrder1,
            _passedLowOrder1 < 3, 3,
            TRUE, _passedLowOrder1
        ),

        _usePrecision, IFS(
            _modernStyle * (_useLowOrder = 4) * (_passedPrecision = ""), 9, 
            _modernStyle * (_useLowOrder < 4), 0,
            (_passedPrecision = ""), 9,
            TRUE, _passedPrecision
        ),

        _rTimeSpan, RESOLVE_TIMESPAN(TimeSpan, _useHighOrder, _useLowOrder, _usePrecision, _truncate),

        _showHighOrder, IF(_fixed, _useHighOrder,
            LET(
                // floating
                _hasHighOrder, IFERROR(
                    TIMESPAN_HIGH_ORDER(
                        INDEX(_rTimeSpan, 1, 2),
                        INDEX(_rTimeSpan, 1, 3),
                        INDEX(_rTimeSpan, 1, 4),
                        INDEX(_rTimeSpan, 1, 5)
                    ), 4
                ),
                IF(_modernStyle,
                    IF(_passedHighOrder1 = "", MIN(2, _hasHighOrder), MIN(2, _hasHighOrder, _passedHighOrder1)),
                    IF(_passedHighOrder1 = "", _hasHighOrder, MIN(_hasHighOrder, _passedHighOrder1))
                )
            )
        ),

        _showLowOrder, IF(_fixed, _useLowOrder,
            LET(
                // floating
                _hasLowOrder, IFERROR(
                    TIMESPAN_LOW_ORDER(
                        INDEX(_rTimeSpan, 1, 2),
                        INDEX(_rTimeSpan, 1, 3),
                        INDEX(_rTimeSpan, 1, 4),
                        INDEX(_rTimeSpan, 1, 5)
                    ), 1
                ),
                IF(_modernStyle,
                    IF(_passedLowOrder1 = "", MAX(3, _hasLowOrder), MAX(3, _hasLowOrder, _passedLowOrder1)),
                    IF(_passedLowOrder1 = "", _hasLowOrder, MAX(_hasLowOrder, _passedLowOrder1))
                )
            )
        ),

        _showHighOrder1, IF(_showHighOrder > _showLowOrder, _showLowOrder, _showHighOrder),

        _showPrecision, IFS(
            _modernStyle * (_useLowOrder < 4), 0,
            ISNUMBER(_passedPrecision), _passedPrecision,
            TRUE, MIN(9, DECIMALS(INDEX(_rTimeSpan, 1, _useLowOrder + 1)))
        ),

        // Resolve sign
        _sign, IF(INDEX(_rTimeSpan, 1, 1) < 0,
            UNICHAR(8722) & IF(_spaced, " ", ""),
            IF(_signPositive, "+" & IF(_spaced, " ", ""), "")
        ),

        // Number of columns to display from resolved timespan [1..4]
        _n, (_showLowOrder - _showHighOrder1) + 1,
        
        _delims, IFS(
            _modernStyle, CHOOSECOLS({".", ":", ":", ""}, SEQUENCE(1, _n - 1, _showHighOrder1), 4),
            _spaced, CHOOSECOLS({"d", "h", "'", """"}, SEQUENCE(1, _n, _showHighOrder1)) & TAKE({" ", " ", " ", ""}, 1, -_n),
            TRUE, CHOOSECOLS({"d", "h", "'", """"}, SEQUENCE(1, _n, _showHighOrder1))
        ),

        _leadFmt, IF(_padding, "00", "0"),
        _midFmt, IF(NOT(_modernStyle) * NOT(_padding), "0", "00"),
        _lastFmt, IF(_showPrecision = 0, _midFmt,
            _midFmt & LEFT(".000000000", _showPrecision + 1)
        ),
        
        _elements, MAP(SEQUENCE(1, _n), 
            LAMBDA(_e,
                LET(
                    _fmt, IFS(
                        _e = _n, _lastFmt,
                        _e = 1, _leadFmt,
                        TRUE, _midFmt
                    ),
                    TEXT(INDEX(_rTimeSpan, 1, _showHighOrder1 + _e), _fmt) & INDEX(_delims, 1, _e)
                )
            )
        ),

        CONCAT(_sign, _elements)
    )
)
);



FORMAT_TIMESPAN_STANDARD = LAMBDA(TimeSpan, MostSig, LeastSig, Options,
LET(
    _maxPrecision, 9,
    _defaultPrecision, 0,
    _lowestSig, -2,
    _fixed, IFERROR(FIND("~", Options), 0) = 0,
    _truncate, IFERROR(FIND("<", Options), 0) > 0,
    _signPositive, IFERROR(FIND("+", Options), 0) > 0,
    _padLeading, IFERROR(FIND("P", Options), 0) > 0,
    
    // Precision at which to resolve the TimeSpan
    // If fixed style and not provided then set to default precision
    _rPrecision, IF(_fixed * (LeastSig = ""), _defaultPrecision, LeastSig),
    _rTimeSpan, RESOLVE_TIMESPAN(TimeSpan, _rPrecision, _truncate),
        
    // Display at precision, fixed style remains the same
    // if floating style allow to fall back to MostSig
    _showPrecision, IF(_fixed, _rPrecision,
        LET(
            _hasPrecision, TIMESPAN_LOW_ORDER(
                INDEX(_rTimeSpan, 1, 2),
                INDEX(_rTimeSpan, 1, 3),
                INDEX(_rTimeSpan, 1, 4),
                INDEX(_rTimeSpan, 1, 5)
            ),
            MAX(IF(MostSig = "", -3, MostSig), MIN(IF(_rPrecision = "", _maxPrecision, _rPrecision), _hasPrecision, _maxPrecision))
        )
    ),

    // Resolve sign
    _sign, IF(INDEX(_rTimeSpan, 1, 1) < 0,
        UNICHAR(8722),
        IF(_signPositive, "+", "")
    ),

    // If floating style, allow high end to float if MostSig not provided
    _high, IFS(
        _fixed, IF(MostSig = "", -3, MostSig),
        MostSig <> "", MostSig,
        TRUE, LET(
            _float, IFS(
                INDEX(_rTimeSpan, 1, 2) > 0, -3,
                INDEX(_rTimeSpan, 1, 3) > 0, -2,
                INDEX(_rTimeSpan, 1, 4) > 0, -1,
                TRUE, 0
            ),
            MIN(_float, _showPrecision, _lowestSig)
        )
    ),

    // Translate high significance to resolved timespan column [2..5]
    _leadCol, _high + 5,
    // Number of columns to display from resolved timespan [1..4]
    _n, MIN(_showPrecision, 0) - _high + 1,
    
    // Corresponding delims
    _prefix, TAKE({"", "", "", ""}, 1, _n), 
    // Last suffix is dropped
    _suffix, CHOOSECOLS(
        HSTACK(
            TAKE({".", ":", ":", ""}, 1, _n),
            {"", "", ""}
        ),
        SEQUENCE(1, _n, _leadCol - 1)
    ),
    
    _leadFmt, IF(_padLeading, "00", "0"),
    _midFmt, "00",
    _lastFmt, IF(_showPrecision < 0, "00",
        LET(
            _useSecFmt, IF(_leadCol = 5, _leadFmt, _midFmt),
            IF(_showPrecision = 0, _useSecFmt,
                _useSecFmt & LEFT(".000000000", _showPrecision + 1)
            )
        )
    ),
    
    // General formatter
    fnFormat1(_rTimeSpan,
        HSTACK(
            _leadCol,
            _n,
            _sign,
            _leadFmt,
            _midFmt,
            _lastFmt,
            _prefix,
            _suffix
        )
    )
)
);


















/*##########################################################################################################
# CALENDAR DATES                                                                                           #
##########################################################################################################*/


/*----------------------------------------------------------------------------------------------------------
YEAR_COMMON_ERA

Returns year value relative to the Common Era.

Output
------------------------------------------------------------------------------------------------------------
1 | integer | 1 CE = 1, 1 BCE = 0, 2 BCE = -1

Parameters
------------------------------------------------------------------------------------------------------------
Year  | integer [1..] | Positive non-zero integer.
BCE   | switch        | Before Common Era.
----------------------------------------------------------------------------------------------------------*/
YEAR_COMMON_ERA = LAMBDA(Year, BCE,
IFS(
    Year = "", "",
    NOT(ISNUMBER(Year)), {#VALUE!},
    TRUE, LET(
        _year, INT(Year),
        IF(_year < 1, {#NUM!},
            IF(N(BCE), 1 - _year, _year)
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
IS_LEAP_YEAR

Tests if a year includes a leap day in the given calendar.

Output
------------------------------------------------------------------------------------------------------------
1 | boolean | null if empty

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | decimal | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
             |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
IS_LEAP_YEAR = LAMBDA(YearCE, [JulianCalendar],
IFS(
    YearCE = "", "",
    NOT(ISNUMBER(YearCE)), {#VALUE!},
    TRUE, LET(
        _yearCE, INT(YearCE),
        IF(
            N(JulianCalendar) = 0,
            IFS(MOD(_yearCE, 400) = 0, TRUE,
                MOD(_yearCE, 100) = 0, FALSE,
                TRUE, MOD(_yearCE, 4) = 0
            ),
            MOD(_yearCE, 4) = 0
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
IS_VALID_DATE

Tests if a date is valid for the given calendar.

Output
------------------------------------------------------------------------------------------------------------
1 | boolean |

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] | Month of year
[Day]            | decimal [1..32) | Day of month
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
             |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
IS_VALID_DATE = LAMBDA(YearCE, Month, [Day], [JulianCalendar],
IFS(
    NOT(ISNUMBER(YearCE)) + NOT(ISNUMBER(Month)), FALSE, // cannot ommit year or month
    NOT(IS_INTEGER(YearCE) * IS_INTEGER(Month)), FALSE, // year and month cannot be fractional
    (Month < 1) + (Month > 12), FALSE, 
    Day = "", TRUE,
    TRUE, LET(
        _day, INT(Day),
        IF(_day < 1, FALSE,
            LET(
                _daysInMonth, DAYS_IN_MONTH(Month, YearCE, JulianCalendar),
                IF(ISERROR(_daysInMonth), FALSE,
                    _day <= _daysInMonth
                )
            )
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
DAYS_IN_YEAR

Returns number of days in the given year of the specified calendar.

Output
------------------------------------------------------------------------------------------------------------
1 | integer [365,366]

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | integer | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian proleptic
             |         | calendar.
----------------------------------------------------------------------------------------------------------*/
DAYS_IN_YEAR = LAMBDA(YearCE, [JulianCalendar],
IFS(
    YearCE = "", "",
    NOT(ISNUMBER(YearCE)), {#VALUE!},
    IS_LEAP_YEAR(YearCE, JulianCalendar), 366,
    TRUE, 365
)
);


/*----------------------------------------------------------------------------------------------------------
DAYS_IN_MONTH

Returns number of days in the given month and year of the specified calendar.

Output
------------------------------------------------------------------------------------------------------------
1 | integer [1..31]

Parameters
------------------------------------------------------------------------------------------------------------
Month            | integer [1..12] | Month of year
[YearCE]         | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
             |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
DAYS_IN_MONTH = LAMBDA(Month, [YearCE], [JulianCalendar],
IFS(
    Month = "", "",
    NOT(ISNUMBER(Month)), {#VALUE!},
    TRUE, LET(
        _month, INT(Month),
        IFS(
            _month < 1, {#NUM!},
            _month > 12, {#NUM!},

            // February
            _month = 2,
                LET(
                    _leapDay, IF(ISNUMBER(YearCE),
                        N(IS_LEAP_YEAR(YearCE, JulianCalendar)),
                        0
                    ),
                    28 + _leapDay
                ),

            // Jan, Mar, Apr, May, Jun, Jul
            _month <= 7, 30 + MOD(_month, 2),
            
            // Aug, Sep, Oct, Nov, Dec
            TRUE, 31 - MOD(_month, 2)
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
JULIAN_DAY_NUMBER

Returns the Julian Day Number (JDN) of the provided date in the specified calendar.
Note the Julian Day Number is an integer type and is an ordinal day number referenced from January 1,
4713 BC in the proleptic Julian calendar. It does not include any value for time of day.

Output
------------------------------------------------------------------------------------------------------------
1 | integer | Julian Day Number

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] | Month of year
Day              | integer [1..31] | Day of month
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
             |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
JULIAN_DAY_NUMBER = LAMBDA(YearCE, Month, Day, [JulianCalendar],
IFS(
    (YearCE = "") * (Month = "") * (Day = ""), "",
    NOT(IS_VALID_DATE(YearCE, Month, Day, JulianCalendar)), {#NUM!},
    TRUE, LET(
        _day, INT(Day),
        _gregorian, N(JulianCalendar) = 0,
        _YEAR4801BCE, -4800,
        _G4801BCE_JD, -32045,
        _J4801BCE_JD, -32083,
        _DaysIn5MonthsFromMarch, 153,
        _MarchShiftYear, INT((14 - Month) / 12),
        _years, YearCE - _YEAR4801BCE - _MarchShiftYear,
        _MarchShiftMonth, Month + (12 * _MarchShiftYear) - 3,
        _days, 365 * _years + INT(_years / 4) + INT((_DaysIn5MonthsFromMarch * _MarchShiftMonth + 2) / 5) + _day,
        _days + IF(_gregorian,
            _G4801BCE_JD - INT(_years / 100) + INT(_years / 400),
            _J4801BCE_JD
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
MODIFIED_JULIAN_DAY_NUMBER

Returns the Modified Julian Day Number (MJDN) of the provided date in the specified calendar.
Note the Modified Julian Day Number is an integer type and is an ordinal day number referenced from November 17,
1858 in the proleptic Gregorian calendar. It does not include any value for time of day.

Output
------------------------------------------------------------------------------------------------------------
1 | integer | Modified Julian Day Number

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] | Month of year
Day              | integer [1..31] | Day of month
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
             |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
MODIFIED_JULIAN_DAY_NUMBER = LAMBDA(YearCE, Month, Day, [JulianCalendar],
LET(
    _JDN, JULIAN_DAY_NUMBER(YearCE, Month, Day, JulianCalendar),
    IF(NOT(ISNUMBER(_JDN)), _JDN,
        JDN_TO_MODIFIED(_JDN)
    )
)
);


/*----------------------------------------------------------------------------------------------------------
JDN_TO_MODIFIED

Returns the Modified Julian Day Number (MJDN) of the provided Julian Day Number (JDN).

Output
------------------------------------------------------------------------------------------------------------
1 | integer | Modified Julian Day Number

Parameters
------------------------------------------------------------------------------------------------------------
JDN | integer | Julian Day Number
----------------------------------------------------------------------------------------------------------*/
JDN_TO_MODIFIED = LAMBDA(JDN,
IF(JDN = "", "",
    INT(JDN) - 2400001
)
);


/*----------------------------------------------------------------------------------------------------------
MODIFIED_TO_JDN

Returns the Julian Day Number (JDN) of the provided Modified Julian Day Number (MJDN).

Output
------------------------------------------------------------------------------------------------------------
1 | integer | Julian Day Number

Parameters
------------------------------------------------------------------------------------------------------------
MJDN | integer | Modified Julian Day Number
----------------------------------------------------------------------------------------------------------*/
MODIFIED_TO_JDN = LAMBDA(MJDN,
IF(MJDN = "", "",
    INT(MJDN) + 2400001
)
);


/*----------------------------------------------------------------------------------------------------------
JDN_TO_CALENDAR_DATE

Returns the date in the specified calendar from the given Julian Day Number.

Output
------------------------------------------------------------------------------------------------------------
1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
2 | integer [1..12] | Month
3 | integer [1..31] | Day of month

Parameters
------------------------------------------------------------------------------------------------------------
JDN              | integer | Julian Day Number
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
             |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
JDN_TO_CALENDAR_DATE = LAMBDA(JDN, [JulianCalendar],
IFS(
    JDN = "", {"", "", ""},
    NOT(ISNUMBER(JDN)), {#VALUE!, "", ""},
    TRUE, LET(
        _JDN, INT(JDN),
        _gregorian, N(JulianCalendar) = 0,
        _YEAR4801BCE, -4800,
        _DaysIn4Year, 1461,
        _DaysInYear, 365,
        _MonthCorrectionDays, 308,
        _DaysIn4Months, 122,
        _DaysIn5MonthsFromMarch, 153,
        IF(_gregorian,
            LET(
                _G4801BCE_JD0, -32045,
                _GregDaysIn400Year, 146097,
                _GregDaysIn100Year, 36524,
                _days0, _jdn - _G4801BCE_JD0 - 1,
                _quadCent, INT(_days0 / _GregDaysIn400Year),
                _days1, _days0 - _quadCent * _GregDaysIn400Year,
                _remCent, INT((INT(_days1 / _GregDaysIn100Year) + 1) * 0.75),
                _days2, _days1 - _remCent * _GregDaysIn100Year,
                _quadYr, INT(_days2 / _DaysIn4Year),
                _days3, _days2 - _quadYr * _DaysIn4Year,
                _remYr, INT((INT(_days3 / _DaysInYear) + 1) * 0.75),
                _days4, _days3 - _remYr * _DaysInYear,
                _y, _quadCent * 400 + _remCent * 100 + _quadYr * 4 + _remYr,
                _m, INT((_days4 * 5 + _MonthCorrectionDays) / _DaysIn5MonthsFromMarch) - 2,
                _day, _days4 - INT((_m + 4) * _DaysIn5MonthsFromMarch / 5) +
                    _DaysIn4Months + 1,
                _year, _YEAR4801BCE + _y + INT((_m + 2) / 12),
                _month, MOD(_m + 2, 12) + 1,
                HSTACK(_year, _month, _day)
            ),
            LET(
                _J4801BCE_JD0, -32083,
                _days0, _jdn - _J4801BCE_JD0 - 1,
                _quadYr, INT(_days0 / _DaysIn4Year),
                _days1, _days0 - _quadYr * _DaysIn4Year,
                _remYr, INT((INT(_days1 / _DaysInYear) + 1) * 0.75),
                _days2, _days1 - _remYr * _DaysInYear,
                _y, _quadYr * 4 + _remYr,
                _m, INT((_days2 * 5 + _MonthCorrectionDays) / _DaysIn5MonthsFromMarch) - 2,
                _day, _days2 - INT((_m + 4) * _DaysIn5MonthsFromMarch / 5) +
                    _DaysIn4Months + 1,
                _year, _YEAR4801BCE + _y + INT((_m + 2) / 12),
                _month, MOD(_m + 2, 12) + 1,
                HSTACK(_year, _month, _day)
            )
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
MJDN_TO_CALENDAR_DATE

Returns the date in the specified calendar from the given Midified Julian Day Number.

Output
------------------------------------------------------------------------------------------------------------
1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
2 | integer [1..12] | Month
3 | integer [1..31] | Day of month

Parameters
------------------------------------------------------------------------------------------------------------
MJDN             | integer | Modified Julian Day Number
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
             |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
MJDN_TO_CALENDAR_DATE = LAMBDA(MJDN, [JulianCalendar],
LET(
    _JDN, MODIFIED_TO_JDN(MJDN),
    IF(NOT(ISNUMBER(_JDN)), _JDN,
        JDN_TO_CALENDAR_DATE(_JDN, JulianCalendar)
    )
)
);

/*----------------------------------------------------------------------------------------------------------
GREGORIAN_TO_JULIAN

Translates a date in the Gregorian proleptic calendar to the Julian proleptic calendar.

Output
------------------------------------------------------------------------------------------------------------
1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
2 | integer [1..12] | Month
3 | integer [1..31] | Day

Parameters
------------------------------------------------------------------------------------------------------------
YearCE | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month  | integer [1..12] | 
Day    | integer [1..31] |
----------------------------------------------------------------------------------------------------------*/
GREGORIAN_TO_JULIAN = LAMBDA(YearCE, Month, Day,
LET(
    _JDN, JULIAN_DAY_NUMBER(YearCE, Month, Day, 0),
    IFS(ISERROR(_JDN), {#VALUE!, "", ""},
        _JDN = "", {"", "", ""},
        TRUE, JDN_TO_CALENDAR_DATE(_JDN, 1)
    )
)
);


/*----------------------------------------------------------------------------------------------------------
JULIAN_TO_GREGORIAN

Translates a date in the Julian proleptic calendar to the Gregorian proleptic calendar.

Output
------------------------------------------------------------------------------------------------------------
1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
2 | integer [1..12] | Month
3 | integer [1..31] | Day

Parameters
------------------------------------------------------------------------------------------------------------
YearCE | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month  | integer [1..12] | 
Day    | integer [1..31] | 
----------------------------------------------------------------------------------------------------------*/
JULIAN_TO_GREGORIAN = LAMBDA(YearCE, Month, Day,
LET(
    _JDN, JULIAN_DAY_NUMBER(YearCE, Month, Day, 1),
    IFS(ISERROR(_JDN), {#VALUE!, "", ""},
        _JDN = "", {"", "", ""},
        TRUE, JDN_TO_CALENDAR_DATE(_JDN, 0)
    )
)
);


/*----------------------------------------------------------------------------------------------------------
SECULAR_DIFFERENCE

Returns the number of days the Gregorian proleptic calendar is ahead of the Julian proleptic calendar for
a given date.

Output
------------------------------------------------------------------------------------------------------------
1 | integer | Days difference. Negative values are when the Julian proleptic calender is ahead.

Parameters
------------------------------------------------------------------------------------------------------------
YearCE               | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month                | integer [1..12] | 
Day                  | integer [1..31] | 
[FromJulianCalendar] | switch          | Provided date is in Julian calendar.
                 |                 | Default is the Gregorian calendar.
----------------------------------------------------------------------------------------------------------*/
SECULAR_DIFFERENCE = LAMBDA(YearCE, Month, Day, [FromJulianCalendar],
IF(N(FromJulianCalendar) = 0,
    // From Gregorian calendar
    LET(
        _JDN_G, JULIAN_DAY_NUMBER(YearCE, Month, Day, 0),
        IF(ISERROR(_JDN_G), {#VALUE!},
            IF(_JDN_G = "", "",
                LET(
                    _JDN_J, IF((Month = 2) * (Day = 29),
                        IF(IS_LEAP_YEAR(YearCE, 1),
                            JULIAN_DAY_NUMBER(YearCE, 2, 29, 1),
                            JULIAN_DAY_NUMBER(YearCE, 2, 28, 1)
                        ),
                        JULIAN_DAY_NUMBER(YearCE, Month, Day, 1)
                    ),
                    _JDN_J - _JDN_G
                )
            )
        )
    ),
    
    // From Julian calendar
    LET(
        _date_G, JULIAN_TO_GREGORIAN(YearCE, Month, Day),
        IF(ISERROR(INDEX(_date_G, 1, 1)), {#VALUE!},
            IF(INDEX(_date_G, 1, 1) = "", "",
                SECULAR_DIFFERENCE(
                    INDEX(_date_G, 1, 1),
                    INDEX(_date_G, 1, 2),
                    INDEX(_date_G, 1, 3),
                    0
                )
            )
        )
    )
)
);











/*##########################################################################################################
# DATE AND TIME                                                                                            #
##########################################################################################################*/


/*----------------------------------------------------------------------------------------------------------
IS_VALID_TIME_OF_DAY

Tests if sexagesimal representation of time is valid for a 24 hour day.

Output
------------------------------------------------------------------------------------------------------------
1 | boolean |

Parameters
------------------------------------------------------------------------------------------------------------
Hour           | decimal [0..24) | Fractional allowed if minute and second empty.
Minute         | decimal [0..60) | Fractional allowed if second empty.
Second         | decimal [0..60) | Fractional allowed
[Accept24Hour] | switch          | Accept time of 24:00:00 to represent midnight next day.
----------------------------------------------------------------------------------------------------------*/
IS_VALID_TIME_OF_DAY = LAMBDA(Hour, Minute, Second, [Accept24Hour],
LET(
    _accept24hour, N(Accept24Hour) <> 0,
    IFS(
        ISNUMBER(Hour) * ISNUMBER(Minute) * ISNUMBER(Second),
            IFS(
                (_accept24hour * (Hour = 24) * (Minute = 0) * (Second = 0)) > 0, TRUE,
                NOT(IS_INTEGER(Hour) * IS_INTEGER(Minute)), FALSE,
                (Hour < 0) + (Hour > 23), FALSE,
                (Minute < 0) + (Minute > 59), FALSE,
                (Second < 0) + (Second >= 60), FALSE,
                TRUE, TRUE
            ),
        ISNUMBER(Hour) * ISNUMBER(Minute) * (Second = ""),
            IFS(
                (_accept24hour * (Hour = 24) * (Minute = 0)) > 0, TRUE,
                NOT(IS_INTEGER(Hour)), FALSE,
                (Hour < 0) + (Hour > 23), FALSE,
                (Minute < 0) + (Minute >= 60), FALSE,
                TRUE, TRUE
            ),
        ISNUMBER(Hour) * (Minute = "") * (Second = ""),
            IF((_accept24hour * (Hour = 24)) > 0, TRUE,
                ((Hour >= 0) * (Hour < 24)) > 0
            ),
        (Hour = "") * ISNUMBER(Minute) * ISNUMBER(Second),
            IFS(
                NOT(IS_INTEGER(Minute)), FALSE,
                (Minute < 0) + (Minute > 59), FALSE,
                (Second < 0) + (Second >= 60), FALSE,
                TRUE, TRUE
            ),
        (Hour = "") * ISNUMBER(Minute) * (Second = ""),
            ((Minute >= 0) * (Minute < 60)) <> 0,
        (Hour = "") * (Minute = "") * ISNUMBER(Second),
            ((Second >= 0) * (Second < 60)) <> 0,
        TRUE, FALSE
    )
)
);


/*----------------------------------------------------------------------------------------------------------
JULIAN_DATE

Returns the Julian Date of the provided date and time of day in the specified calendar.
Note that the decimal time component of Julian Date is based from midday.

Output
------------------------------------------------------------------------------------------------------------
1 | decimal | Julian Date

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] | Month of year
Day              | intger  [1..31] | Day of month
]Time]           | decimal [0..1)  | Time of day
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
             |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
JULIAN_DATE = LAMBDA(YearCE, Month, Day, [Time], [JulianCalendar],
LET(
    _JDN, JULIAN_DAY_NUMBER(YearCE, Month, Day, JulianCalendar),
    IF(NOT(ISNUMBER(_JDN)), _JDN,
        LET(
            _timeAfterMidday, N(Time) - 0.5,
            _JDN + _timeAfterMidday
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
MODIFIED_JULIAN_DATE

Returns the Modified Julian Date of the provided date and time of day in the specified calendar.
Note that the time component of Modified Julian Date is based from midnight.

Output
------------------------------------------------------------------------------------------------------------
1 | decimal | Modified Julian Date

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] | Month of year
Day              | intger  [1..31] | Day of month
[Time]           | decimal [0..1)  | Time of day
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
             |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
MODIFIED_JULIAN_DATE = LAMBDA(YearCE, Month, Day, [Time], [JulianCalendar],
LET(
    _MJDN, MODIFIED_JULIAN_DAY_NUMBER(YearCE, Month, Day, JulianCalendar),
    IF(NOT(ISNUMBER(_MJDN)), _MJDN,
        _MJDN + N(Time)
    )
)
);


/*----------------------------------------------------------------------------------------------------------
JDATE_TO_MODIFIED

Returns the Modified Julian Date (MJDATE) of the provided Julian Date.
Note that the time component of MJDATE is based from midnight.

Output
------------------------------------------------------------------------------------------------------------
1 | decimal | Modified Julian Date

Parameters
------------------------------------------------------------------------------------------------------------
JDate | decimal | Julian Date
----------------------------------------------------------------------------------------------------------*/
JDATE_TO_MODIFIED = LAMBDA(JDate,
IF(JDate = "", "",
    JDate - 2400000.5
)
);


/*----------------------------------------------------------------------------------------------------------
MODIFIED_TO_JDATE

Returns the Julian Date of the provided Modified Julian Date (MJDATE).
Note that the time component of JDATE is based from midday.

Output
------------------------------------------------------------------------------------------------------------
1 | decimal | Julian Date

Parameters
------------------------------------------------------------------------------------------------------------
MJDate | decimal | Modified Julian Date
----------------------------------------------------------------------------------------------------------*/
MODIFIED_TO_JDATE = LAMBDA(MJDate,
IF(MJDate = "", "",
    MJDate + 2400000.5
)
);


/*----------------------------------------------------------------------------------------------------------
JDATE_TO_CALENDAR_DATE

Returns the date and time in the specified calendar from the given Julian Date.

Output
------------------------------------------------------------------------------------------------------------
1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
2 | integer [1..12] | Month
3 | integer [1..31] | Day of month
4 | decimal [0..1)  | Time of day

Parameters
------------------------------------------------------------------------------------------------------------
JDate            | decimal | Julian Date
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
             |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
JDATE_TO_CALENDAR_DATE = LAMBDA(JDate, [JulianCalendar],
IFS(
    JDate = "", {"", "", "", ""},
    NOT(ISNUMBER(JDate)), {#VALUE!, "", "", ""},
    TRUE, LET(
        _JDN, INT(JDate + 0.5),
        _timeOfDay, JDate - _JDN + 0.5,
        _cDate, JDN_TO_CALENDAR_DATE(_JDN, JulianCalendar),
        HSTACK(_cDate, _timeOfDay)
    )
)
);


/*----------------------------------------------------------------------------------------------------------
MJDATE_TO_CALENDAR_DATE

Returns the date and time in the specified calendar from the given Modified Julian Date.

Output
------------------------------------------------------------------------------------------------------------
1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
2 | integer [1..12] | Month
3 | integer [1..31] | Day of month
4 | decimal [0..1)  | Time of day

Parameters
------------------------------------------------------------------------------------------------------------
MJDate           | decimal | Modified Julian Date
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
             |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
MJDATE_TO_CALENDAR_DATE = LAMBDA(MJDate, [JulianCalendar],
IF(MJDate = "", {"", "", "", ""},
    IF(NOT(ISNUMBER(MJDate)), {#VALUE!, "", "", ""},
        LET(
            _JDate, MODIFIED_TO_JDATE(MJDate),
            JDATE_TO_CALENDAR_DATE(_JDate, JulianCalendar)
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
RESOLVE_MJDATE

Returns the date and sexagesimal representation of the time value with the given lowest order element rounded
to the specified precision.

Output - LowOrder = 6
------------------------------------------------------------------------------------------------------------
1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
2 | integer [1..12] | Month
3 | integer [1..31] | Day of month
4 | integer [0..23] | Hour
5 | integer [0..59] | Minute
6 | decimal [0..60) | Second

Output - LowOrder = 5
------------------------------------------------------------------------------------------------------------
1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
2 | integer [1..12] | Month
3 | integer [1..31] | Day of month
4 | integer [0..23] | Hour
5 | decimal [0..60) | Minute

Output - LowOrder = 4
------------------------------------------------------------------------------------------------------------
1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
2 | integer [1..12] | Month
3 | integer [1..31] | Day of month
4 | decimal [0..24) | Hour

Output - LowOrder = 3
------------------------------------------------------------------------------------------------------------
1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
2 | integer [1..12] | Month
3 | decimal [1..32) | Day of month

Output - LowOrder = 2
------------------------------------------------------------------------------------------------------------
1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
2 | integer [1..12] | Month

Output - LowOrder = 1
------------------------------------------------------------------------------------------------------------
1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE

Parameters
------------------------------------------------------------------------------------------------------------
MJDate           | decimal        | Modified Julian Date
[LowOrder]       | integer [1..6] | Low-order element
             |                |  1 - YearCE
             |                |  2 - Month
             |                |  3 - Day
             |                |  4 - Hour
             |                |  5 - Minute
             |                |  6 - Second
[Precision]      | integer [0..9] | Select precision level. Not applicable when LowOrder = 1,2
             |                | Null - Floating
[Truncate]       | switch         | Round to precision by truncating components. Default is rounding to nearest.
[JulianCalendar] | switch         | Calculate for the Julian proleptic calendar. Default is Gregorian
             |                | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
RESOLVE_MJDATE = LAMBDA(MJDate, [LowOrder], [Precision], [Truncate], [JulianCalendar],
LET(
    _lowOrder, IFS(
        NOT(ISNUMBER(LowOrder)), 6,
        LowOrder < 1, 6,
        LowOrder > 6, 6,
        TRUE, INT(LowOrder)
    ),
    _precision, IFS(
        NOT(ISNUMBER(Precision)), "",
        Precision < 0, 0,
        Precision > 9, 9,
        TRUE, INT(Precision)
    ),
    _truncate, N(Truncate) <> 0,
    IFS(
        MJDate = "", TAKE({"", "", "", "", "", ""}, 1, _lowOrder),
        NOT(ISNUMBER(MJDate)), TAKE({#VALUE!, "", "", "", "", ""}, 1, _lowOrder),
        _lowOrder = 1, LET(
            _cDate, MJDN_TO_CALENDAR_DATE(MJDate, JulianCalendar),
            IF(_truncate,
                INDEX(_cDate, 1, 1),
                INDEX(_cDate, 1, 1) + N(INDEX(_cDate, 1, 2) > 6)
            )
        ),
        _lowOrder = 2, LET(
            _cDate, MJDATE_TO_CALENDAR_DATE(MJDate, JulianCalendar),
            IF(_truncate,
                TAKE(_cDate, 1, 2),
                LET(
                    _daysInMonth, DAYS_IN_MONTH(INDEX(_cDate, 1, 2), INDEX(_cDate, 1, 1)),
                    _carryMonth, ROUND(((INDEX(_cDate, 1, 3) - 1 + INDEX(_cDate, 1, 4)) / _daysInMonth), 0),
                    IFS(
                        _carryMonth = 0, TAKE(_cDate, 1, 2),
                        INDEX(_cDate, 1, 2) = 12, HSTACK(INDEX(_cDate, 1, 1) + 1, 1),
                        TRUE, HSTACK(INDEX(_cDate, 1, 1), INDEX(_cDate, 1, 2) + 1)
                    )
                )
            )
        ),
        _lowOrder = 3, LET(
            _MJDN, INT(MJDate),
            _time, MJDate - _MJDN,
            _rTime, IFS(
                _precision = "", _time,
                _truncate, ROUNDDOWN(_time, _precision),
                TRUE, ROUND(_time, _precision)
            ),
            IF(_rTime = 1,
                MJDN_TO_CALENDAR_DATE(_MJDN + 1, JulianCalendar),
                LET(
                    _cDate, MJDN_TO_CALENDAR_DATE(_MJDN, JulianCalendar),
                    HSTACK(
                        INDEX(_cDate, 1, 1),
                        INDEX(_cDate, 1, 2),
                        INDEX(_cDate, 1, 3) + _rTime
                    )
                )
            )
        ),
        TRUE, LET(
            _MJDN, INT(MJDate),
            _time, MJDate - _MJDN,
            _rTime, RESOLVE_TIMESPAN(_time, _lowOrder - 2, _precision, _truncate),
            _carryDay, INDEX(_rTime, 2),
            _rDate, MJDN_TO_CALENDAR_DATE(_MJDN + _carryDay, JulianCalendar),
            HSTACK(_rDate, DROP(_rTime, , 2))
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
MJDATE_ADDITION

Returns the addition of a timespan complication to a given Modified Julian Date.
Note if date parts of years, quarters or months are added for a MJDate expressed in UTC rather than local
time, then inconsistent results can be produced due to the bounds of calendar days.

Output
------------------------------------------------------------------------------------------------------------
1 | decimal | Modified Julian Date

Parameters
------------------------------------------------------------------------------------------------------------
LocalMJDate      | decimal     | Modifed Julian Date in local time zone
[AddTimeSpan]    | decimal     | Add timespan.
[AddWeeks]       | decimal     | Add weeks timespan. Fractional part carries to day.
[AddMonths]      | decimal     | Add months timespan. Fractional part carries to day.
[AddQuarters]    | decimal     | Add quarters timespan. Fractional part carries to month and day.
[AddYears]       | decimal     | Add years timespan. Fractional part carries to month and day.
[JulianCalendar] | switch      | Calculate in the Julian proleptic calendar. Default is Gregorian
             |             | proleptic calendar. Only needed if date parts of years, quarters or months
             |             | are added.
----------------------------------------------------------------------------------------------------------*/
MJDATE_ADDITION = LAMBDA(LocalMJDate, [AddTimeSpan], [AddWeeks], [AddMonths], [AddQuarters], [AddYears], [JulianCalendar],
IFS(
    LocalMJDate = "", "",
    NOT(ISNUMBER(LocalMJDate)), {#VALUE!},
    (N(AddTimeSpan) = 0) * (N(AddWeeks) = 0) * (N(AddMonths) = 0) * (N(AddQuarters) = 0) * (N(AddYears) = 0), LocalMJDate,
    TRUE, LET(
        _hasDatePartsAdded, ((N(AddMonths) <> 0) + (N(AddQuarters) <> 0) + (N(AddYears) <> 0)) <> 0,
        _baseMJDate, IF(NOT(_hasDatePartsAdded), LocalMJDate,
            LET(
                _decMonths, (N(AddYears) * 12) + (N(AddQuarters) * 3) + N(AddMonths),
                _addTotalMonths, INT(_decMonths),
                _partialMonths, _decMonths - _addTotalMonths,
                _startDate, MJDATE_TO_CALENDAR_DATE(LocalMJDate, JulianCalendar),
                _shiftMonths, INDEX(_startDate, 1, 2) - 1 + _addTotalMonths,
                _resultYear, INDEX(_startDate, 1, 1) + INT(_shiftMonths / 12),
                _resultMonth, MOD(_shiftMonths, 12) + 1,
                _MJDateMonth, MODIFIED_JULIAN_DATE(_resultYear, _resultMonth, 1, 0, JulianCalendar) - 1,
                _avgDaysMonth, IF(N(JulianCalendar), 30.4375, 30.436875),
                _MJDateMonth + INDEX(_startDate, 1, 3) + ROUND(_partialMonths * _avgDaysMonth, 0) + INDEX(_startDate, 1, 4)
            )
        ),
        _baseMJDate + N(AddTimeSpan) + ROUND(N(AddWeeks) * 7, 0)
    )
)
);









/*##########################################################################################################
# ORDINAL DATES                                                                                            #
##########################################################################################################*/


/*----------------------------------------------------------------------------------------------------------
IS_VALID_ORDINAL_DATE

Tests if an ordinal date is valid for the given calendar.

Output
------------------------------------------------------------------------------------------------------------
1 | boolean |

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
OrdinalDay       | decimal [1..367) | Day of year
[JulianCalendar] | switch           | Calculate for the Julian proleptic calendar. Default is Gregorian
             |                  | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
IS_VALID_ORDINAL_DATE = LAMBDA(YearCE, OrdinalDay, [JulianCalendar],
IFS(
    NOT(ISNUMBER(YearCE)) + NOT(ISNUMBER(OrdinalDay)), FALSE, // cannot ommit year or ordinal day
    NOT(IS_INTEGER(YearCE)), FALSE, // year cannot be fractional
    TRUE, LET(
        _ordinalDay, INT(OrdinalDay),
        IF(_ordinalDay < 1, FALSE,
            LET(
                _daysInYear, DAYS_IN_YEAR(YearCE, JulianCalendar),
                _ordinalDay <= _daysInYear
            )
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
ORDINAL_DATE_TO_MJDATE

Returns the Modified Julian Date from the given ordinal date and time in the specified calendar.

Output
------------------------------------------------------------------------------------------------------------
1 | integer | Modified Julian Date

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
OrdinalDay       | integer [1..366] | Day of year, carries if range exceeded
[Time]           | decimal [0..1)   | Time of day
[JulianCalendar] | switch           | Calculate for the Julian proleptic calendar. Default is Gregorian
             |                  | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
ORDINAL_DATE_TO_MJDATE = LAMBDA(YearCE, OrdinalDay, [Time], [JulianCalendar],
IFS(
    (YearCE = "") * (OrdinalDay = "") * (Time = ""), "",
    NOT(ISNUMBER(YearCE)) + NOT(ISNUMBER(OrdinalDay)), {#VALUE!},
    TRUE, LET(
        _ordinalDay, INT(OrdinalDay),
        _MJDNYear, MODIFIED_JULIAN_DAY_NUMBER(YearCE, 1, 1, JulianCalendar) - 1,
        _MJDNYear + _ordinalDay + N(Time)
    )
)
);


/*----------------------------------------------------------------------------------------------------------
MJDATE_TO_ORDINAL_DATE

Returns the year, ordinal day of year, time of day and days in the year in the specified calendar.

Output
------------------------------------------------------------------------------------------------------------
1 | integer           | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
2 | integer [1..366]  | Ordinal day
3 | decimal [0..1)    | Time of day
4 | integer [365,366] | Days in year

Parameters
------------------------------------------------------------------------------------------------------------
MJDate           | decimal | Modified Julian Date
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
             |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
MJDATE_TO_ORDINAL_DATE = LAMBDA(MJDate, [JulianCalendar],
IFS(
    MJDate = "", {"", "", "", ""},
    NOT(ISNUMBER(MJDate)), {#VALUE!, "", "", ""},
    TRUE, LET(
        _cDate, MJDATE_TO_CALENDAR_DATE(MJDate, JulianCalendar),
        _yearCE, INDEX(_cDate, 1, 1),
        _MJDNYear, MODIFIED_JULIAN_DAY_NUMBER(_yearCE, 1, 1, JulianCalendar) - 1,
        _ordinalDay, INT(MJDate - _MJDNYear),
        _daysInYear, DAYS_IN_YEAR(_yearCE, JulianCalendar),
        HSTACK(
            _yearCE,
            _ordinalDay,
            INDEX(_cDate, 1, 4),
            _daysInYear
        )
    )
)
);








/*##########################################################################################################
# WEEKS                                                                                                    #
##########################################################################################################*/


/*----------------------------------------------------------------------------------------------------------
DAY_OF_WEEK

Returns an integer for the day of the week for a given Modified Julian Date.

Output
------------------------------------------------------------------------------------------------------------
1 | integer [1..7] | ISO day of week number
|                | Monday..Sunday

Parameters
------------------------------------------------------------------------------------------------------------
MJDate | decimal | Modified Julian Date
----------------------------------------------------------------------------------------------------------*/
DAY_OF_WEEK = LAMBDA(MJDate,
IFS(
    MJDate = "", "",
    NOT(ISNUMBER(MJDate)), {#VALUE!},
    TRUE, LET(
        _MJDN, INT(MJDate),
        MOD(_MJDN + 2, 7) + 1
    )
)
);


/*----------------------------------------------------------------------------------------------------------
CONVERT_WEEKDAY_NUMBER

Returns an integer for the day of the week from the traditonal numbering scheme to the ISO definition, or
vice versa.

Output
------------------------------------------------------------------------------------------------------------
1 | integer | Weekday number
| [1..7]  |    | ISO       | Traditioal
|         | ---------------------------
|         |  1 | Monday    | Sunday 
|         |  2 | Tuesday   | Monday 
|         |  3 | Wednesday | Tuesday
|         |  4 | Thursday  | Wednesday
|         |  5 | Friday    | Thursday
|         |  6 | Saturday  | Friday
|         |  7 | Sunday    | Saturday

Parameters
------------------------------------------------------------------------------------------------------------
DayOfWeek          | integer [1..7] | Day of week number
[ISOtoTraditional] | switch         | Return day of week using traditional numbering scheme, assuming 
               |                | DayOfWeek was provided according to ISO definition.
               |                | Default is to return in ISO definition, assuming DayOfWeek was
               |                | provided according to the traditional numbering scheme.
----------------------------------------------------------------------------------------------------------*/
CONVERT_WEEKDAY_NUMBER = LAMBDA(DayOfWeek, [ISOtoTraditional],
IFS(
    DayOfWeek = "", "",
    NOT(ISNUMBER(DayOfWeek)), {#VALUE!},
    TRUE, LET(
        _givenDoW, INT(N(DayOfWeek)),
        _fromISO, N(ISOtoTraditional) <> 0, 
        _shiftDoW, _givenDow + IF(_fromISO, 0, -2),
        MOD(_shiftDow, 7) + 1
    )
)
);


/*----------------------------------------------------------------------------------------------------------
WEEKDAY_OF_MONTH

Returns a Modified Julian Date for a given day of week, relative week for the month, year and time of day
of the specified calendar.

Output
------------------------------------------------------------------------------------------------------------
1 | decimal | Modified Julian Date

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] | Month of the year
WeekOfMonth      | integer [-4..5] | Week in the month.
             |                 | Note if the reference exceeds the bounds of the month, another month
             |                 | will be returned.
             |                 |  0 - last week of previous month
             |                 |  1 - first week
             |                 |  2 - second week
             |                 |  3 - third week
             |                 |  4 - fourth week
             |                 |  5 - fifth week
             |                 | -1 - last week
             |                 | -2 - second to last week
             |                 | -3 - third to last week
             |                 | -4 - fourth to last week
ISOWeekDay       | integer [1..7]  | ISO day of week number Monday..Sunday
[Time]           | decimal [0..1)  | Time of day
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
             |                 | proleptic calendar.

Examples
------------------------------------------------------------------------------------------------------------
WEEKDAY_OF_MONTH(2023, 6, 0, 7)
Returns: MJDate 60120.0 (25/06/2023) ie. the last Sunday of June 2023

WEEKDAY_OF_MONTH(2023, 1, 2, 2, 0.5)
Returns: MJDate 59954.5 (10/01/2023 12pm) ie. midday of the second Tuesday of January 2023
----------------------------------------------------------------------------------------------------------*/
WEEKDAY_OF_MONTH = LAMBDA(YearCE, Month, WeekOfMonth, ISOWeekDay, [Time], [JulianCalendar],
IFS(
    (YearCE = "") * (Month = "") * (WeekOfMonth = "") * (ISOWeekDay = ""), "",
    NOT(ISNUMBER(YearCE)) + NOT(ISNUMBER(Month)) + NOT(ISNUMBER(WeekOfMonth)) + NOT(ISNUMBER(ISOWeekDay)), {#VALUE!},
    NOT(IS_INTEGER(YearCE) * IS_INTEGER(Month) * IS_INTEGER(WeekOfMonth) * IS_INTEGER(ISOWeekDay)), {#NUM!},
    (WeekOfMonth < -4) + (WeekOfMonth > 5), {#NUM!},
    TRUE, LET(
        _month, Month + N(WeekOfMonth < 0),
        _weekOffset, WeekOfMonth - N(WeekOfMonth >= 0),
        _isoDoW, MOD(ISOWeekDay - 1, 7) + 1,
        _firstOfMonth, MODIFIED_JULIAN_DATE(YearCE, _month, 1, 0, JulianCalendar),
        _firstDoW, DAY_OF_WEEK(_firstOfMonth),
        _firstOfMonth + (_weekOffset * 7) + MOD(_isoDow - _firstDoW, 7) + N(Time)
    )
)
);


/*----------------------------------------------------------------------------------------------------------
IS_VALID_WEEK_DATE

Tests if a week date is valid for the given calendar.

Output
------------------------------------------------------------------------------------------------------------
1 | boolean |

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
ISOWeek          | integer [1..53] | ISO defined week number of the year
[ISOWeekDay]     | integer [1..7]  | ISO defined day of week Monday..Sunday
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
             |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
IS_VALID_WEEK_DATE = LAMBDA(YearCE, ISOWeek, [ISOWeekDay], [JulianCalendar],
IFS(
    NOT(ISNUMBER(YearCE)) + NOT(ISNUMBER(ISOWeek)), FALSE, // cannot ommit year or week
    NOT(IS_INTEGER(YearCE) * IS_INTEGER(ISOWeek)), FALSE, // year and week cannot be fractional
    TRUE, LET(
        _validWeek, IFS(
            ISOWeek < 1, FALSE,
            ISOWeek <= 52, TRUE,
            ISOWeek = 53, (WEEKS_IN_YEAR(YearCE, JulianCalendar) = 53),
            TRUE, FALSE
        ),
        IF(NOT(_validWeek), FALSE,
            IF(NOT(ISNUMBER(ISOWeekDay)), TRUE,
                LET(
                    _weekDay, INT(ISOWeekDay),
                    (_weekDay >= 1) * (_weekDay <= 7) <> 0
                )
            )
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
WEEKS_IN_YEAR

Returns the count of ISO defined weeks in a given year of the specified calendar.

Output
------------------------------------------------------------------------------------------------------------
1 | integer [52,53]

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | integer | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
             |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
WEEKS_IN_YEAR = LAMBDA(YearCE, [JulianCalendar],
IFS(
    YearCE = "", "",
    NOT(ISNUMBER(YearCE)), {#VALUE!},
    TRUE, LET(
        _gregorian, N(JulianCalendar) = 0,
        fnLastWeekDayOfYear, LAMBDA(_yearCE,
            LET(
                _dayPrecession, IF(_gregorian,
                    _yearCE + INT(_yearCE / 4) - INT(_yearCE / 100) + INT(_yearCE / 400) + 6,
                    _yearCE + INT(_yearCE / 4) + 4
                ),
                MOD(_dayPrecession, 7) + 1
            )
        ),

        _yearCE, INT(YearCE),
        _dowLastDay, fnLastWeekDayOfYear(_yearCE),
        IF(
            _dowLastDay = 4,
            // if last day of year is a Thursday, then has an extra week
            53,
            LET(
                _dowLastDayPrev, fnLastWeekDayOfYear(_yearCE - 1) ,
                IF(
                    _dowLastDayPrev = 3,
                    // if last day of previous year is a Wednesday, then has an extra week
                    53,
                    // otherwise
                    52
                )
            )
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
WEEK_DATE_TO_MJDATE

Returns the Modified Julian Date of the provided week date and time in the specified calendar.

Output
------------------------------------------------------------------------------------------------------------
1 | decimal | Modified Julian Date

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
ISOWeek          | integer [1..53] | ISO defined week number of the year
ISOWeekDay       | integer [1..7]  | ISO defined day of week Monday..Sunday
[Time]           | decimal [0..1)  | Time of day
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
             |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
WEEK_DATE_TO_MJDATE = LAMBDA(YearCE, ISOWeek, ISOWeekDay, [Time], [JulianCalendar],
IFS(
    (YearCE = "") * (ISOWeek = "") * (ISOWeekDay = ""), "",
    NOT(ISNUMBER(YearCE)) + NOT(ISNUMBER(ISOWeek)) + NOT(ISNUMBER(ISOWeekDay)), {#VALUE!},
    TRUE, LET(
        _invalid, IFS(
            NOT(IS_INTEGER(YearCE)), TRUE,
            NOT(IS_INTEGER(ISOWeek)), TRUE,
            ISOWeek < 1, TRUE,
            ISOWeek > 53, TRUE,
            ISOWeek = 53, (WEEKS_IN_YEAR(YearCE, JulianCalendar) < 53),
            TRUE, FALSE
        ),
        IF(_invalid, {#NUM!},
            LET(
                _shiftByWeeks, (ISOWeek - 1) * 7,
                _shiftDayOfWeek, MOD(INT(ISOWeekDay) - 1, 7),
                _firstDayYear, MODIFIED_JULIAN_DAY_NUMBER(YearCE, 1, 1, JulianCalendar),
                _firstWeekDay, DAY_OF_WEEK(_firstDayYear),
                _yearCorrection, MOD(4 - _firstWeekDay, 7) - 3,
                _firstDayYear + _yearCorrection + _shiftByWeeks + _shiftDayOfWeek + N(Time) 
            )
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
MJDATE_TO_WEEK_DATE

Returns the year, ISO defined week number, ISO weekday, time, and weeks in the year for the given Modified
Julian Date in the specified calendar.

Output
------------------------------------------------------------------------------------------------------------
1 | integer         | YearCE
2 | integer [1..53] | ISO week number
3 | integer [1..7]  | ISO day of week Monday..Sunday
4 | decimal [0..1)  | Time of day
5 | integer [52,53] | ISO weeks in year

Parameters
------------------------------------------------------------------------------------------------------------
MJDate           | decimal | Modified Julian Date
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
             |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
MJDATE_TO_WEEK_DATE = LAMBDA(MJDate, [JulianCalendar],
IFS(
    MJDate = "", {"", "", "", "", ""},
    NOT(ISNUMBER(MJDate)), {#VALUE!, "", "", "", ""},
    TRUE, LET(
        _cDate, MJDATE_TO_CALENDAR_DATE(MJDate, JulianCalendar),
        _yearCE, INDEX(_cDate, 1, 1),
        _dayOfWeek, DAY_OF_WEEK(MJDate),
        _MJDNYear, MODIFIED_JULIAN_DAY_NUMBER(_yearCE, 1, 1, JulianCalendar) - 1,
        _dayOfYear, INT(MJDate - _MJDNYear),
        _nominalWeek, INT((_dayOfYear - _dayOfWeek + 10) / 7),
        IFS(
            // last week of previous year
            _nominalWeek = 0, LET(
                _weeksInYear, WEEKS_IN_YEAR(_yearCE - 1, JulianCalendar), 
                HSTACK(
                    _yearCE - 1,
                    _weeksInYear,
                    _dayOfWeek,
                    INDEX(_cDate, 1, 4),
                    _weeksInYear
                )
            ),
            
            // auxiliary week
            _nominalWeek = 53, IF(WEEKS_IN_YEAR(_yearCE, JulianCalendar) = 53,
                HSTACK(
                    _yearCE,
                    53,
                    _dayOfWeek,
                    INDEX(_cDate, 1, 4),
                    53
                ),
                // if this year does not have 53 weeks, then is the first week of following year
                LET(
                    _weeksInYear, WEEKS_IN_YEAR(_yearCE + 1, JulianCalendar),
                    HSTACK(
                        _yearCE + 1,
                        1,
                        _dayOfWeek,
                        INDEX(_cDate, 1, 4),
                        _weeksInYear
                    )
                )
            ),
            
            // any other week in the year
            TRUE, LET(
                _weeksInYear, WEEKS_IN_YEAR(_yearCE, JulianCalendar),
                HSTACK(
                    _yearCE,
                    _nominalWeek,
                    _dayOfWeek,
                    INDEX(_cDate, 1, 4),
                    _weeksInYear
                )
            )
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
WEEK_NUMBER

Returns the ISO defined week number for a given Modified Julian Date in the specified calendar.

Output
------------------------------------------------------------------------------------------------------------
1 | integer [1..53] | ISO week number

Parameters
------------------------------------------------------------------------------------------------------------
MJDate           | decimal | Modifed Julian Date
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
             |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
WEEK_NUMBER = LAMBDA(MJDate, [JulianCalendar],
IFS(
    MJDate = "", "",
    NOT(ISNUMBER(MJDate)), {#VALUE!},
    TRUE, LET(
        _weekDate, MJDATE_TO_WEEK_DATE(MJDate, JulianCalendar),
        CHOOSECOLS(_weekDate, 2)
    )
)
);










/*##########################################################################################################
# QUARTERS                                                                                                 #
##########################################################################################################*/


/*----------------------------------------------------------------------------------------------------------
DAYS_IN_QUARTER

Returns the count of days in a quarter of a given year of the specified calendar.

Output
------------------------------------------------------------------------------------------------------------
1 | integer [89..92]

Parameters
------------------------------------------------------------------------------------------------------------
Quarter          | integer [1..4]  | Quarter of the year 1..4, transitive, exceeding range will carry to year.
[FiscalYearCE]   | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
             |                 | When month offset is non-zero the fiscal year spans calendar years and
             |                 | is defined as the year where June falls.
[MonthOffset]    | integer [-6..3] | Quarter month offset from Januaray
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
             |                 | proleptic calendar.

Examples
------------------------------------------------------------------------------------------------------------
DAYS_IN_QUARTER(3, 2020, -6)
Returns: 91
i.e. 3rd quarter starting from July 2019, namely Jan, Feb, Mar 2020 with 31, 29, 31 days respectively
----------------------------------------------------------------------------------------------------------*/
DAYS_IN_QUARTER = LAMBDA(Quarter, [FiscalYearCE], [MonthOffset], [JulianCalendar],
IFS(
    Quarter = "", "",
    NOT(ISNUMBER(Quarter)), {#VALUE!},
    NOT(IS_INTEGER(Quarter)), {#NUM!},
    TRUE, LET(
        _monthOffset, ROUND(N(MonthOffset), 0),
        IF((_monthOffset < -6) + (_monthOffset > 3), {#NUM!},
            LET(
                _quarter, MOD(INT(Quarter) - 1, 4), // 0..3
                _daysInQuarterCyclical, {90,89,92,91,92,92,92,92,91,92,92,90},
                _quarterWithFeb, INT(MOD(1 - _monthOffset, 12) / 3),  // 0..3
                _quarterPrecession, MOD(_monthOffset + (_quarter * 3), 12) + 1,
                _nominalDaysInQuarter, INDEX(_daysInQuarterCyclical, 1, _quarterPrecession),
                _leapDay, IF(ISNUMBER(FiscalYearCE) * (_quarterWithFeb = _quarter),
                    LET(
                        _yearOfFeb, INT(FiscalYearCE) + N(_quarter = 3),
                        N(IS_LEAP_YEAR(_yearOfFeb, JulianCalendar))
                    ),
                    0
                ),
                _nominalDaysInQuarter + _leapDay
            )
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
QUARTER_DATE_TO_MJDATE

Returns the Modified Julian Date from the given quarter date in the specified calendar.

Output
------------------------------------------------------------------------------------------------------------
1 | decimal | Modified Julian Date

Parameters
------------------------------------------------------------------------------------------------------------
FiscalYearCE     | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
             |                 | When month offset is non-zero the fiscal year spans calendar years and
             |                 | is defined as the year where June falls.
Quarter          | integer [1..4]  | Quarter of the year 1..4, transitive, exceeding range will carry to year.
DayOfQuarter     | integer [1..92] | Ordinal day of the quarter, exceeding range will carry
[Time]           | decimal [0..1)  | Time of day
[MonthOffset]    | integer [-6..3] | Quarter month offset from January
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
             |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
QUARTER_DATE_TO_MJDATE = LAMBDA(FiscalYearCE, Quarter, DayOfQuarter, [Time], [MonthOffset], [JulianCalendar],
IFS(
    (FiscalYearCE = "") * (Quarter = "") * (DayOfQuarter = ""), "",
    NOT(ISNUMBER(FiscalYearCE)), {#VALUE!},
    NOT(ISNUMBER(Quarter)), {#VALUE!},
    NOT(ISNUMBER(DayOfQuarter)), {#VALUE!},
    NOT(IS_INTEGER(Quarter)), {#NUM!},
    TRUE, LET(
        _monthOffset, ROUND(N(MonthOffset), 0),
        IF((_monthOffset < -6) + (_monthOffset > 3), {#NUM!},
            LET(
                _fiscalYearCE, INT(FiscalYearCE),
                _quarter, INT(Quarter),
                _shiftMonth, (_quarter - 1) * 3 + _monthOffset,
                _yearCE, _fiscalYearCE + INT(_shiftMonth / 12),
                _month, MOD(_shiftMonth, 12) + 1,
                _MJDNQuarter, MODIFIED_JULIAN_DAY_NUMBER(_yearCE, _month, 1, JulianCalendar) - 1,
                _MJDNQuarter + INT(DayOfQuarter) + N(Time)
            )
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
MJDATE_TO_QUARTER_DATE

Returns the fiscal year, quarter, day of quarter, time and days in the quarter for the given Modifed Julian
Date in the specified calendar.

Output
------------------------------------------------------------------------------------------------------------
1 | integer          | FiscalYearCE
|                  | When month offset is non-zero the fiscal year spans calendar years and
|                  | is defined as the year where June falls.
2 | integer [1..4]   | Quarter
3 | integer [1..92]  | Day of quarter
4 | decimal [0..1)   | Time of day
5 | integer [89..92] | Days in quarter

Parameters
------------------------------------------------------------------------------------------------------------
MJDate           | decimal         | Modifed Julian Date
[MonthOffset]    | integer [-6..3] | Quarter month offset from January
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
             |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
MJDATE_TO_QUARTER_DATE = LAMBDA(MJDate, [MonthOffset], [JulianCalendar],
IFS(
    MJDate = "", {"", "", "", "", ""},
    NOT(ISNUMBER(MJDate)), {#VALUE!, "", "", "", ""},
    TRUE, LET(
        _monthOffset, ROUND(N(MonthOffset), 0),
        IFS(
            _monthOffset < -6, {#NUM!, "", "", "", ""},
            _monthOffset > 3, {#NUM!, "", "", "", ""},
            TRUE, LET(
                _cDate, MJDATE_TO_CALENDAR_DATE(MJDate, JulianCalendar),
                _shiftMonth, INDEX(_cDate, 1, 2) - 1 - _monthOffset,
                _fiscalYear, INDEX(_cDate, 1, 1) + INT(_shiftMonth / 12),
                _zeroBasedFiscalMonth, MOD(_shiftMonth, 12),
                _quarter, INT(_zeroBasedFiscalMonth / 3) + 1,
                _MJDNQuarter, QUARTER_DATE_TO_MJDATE(_fiscalYear, _quarter, 1, 0, _monthOffset, JulianCalendar) - 1,
                _dayOfQuarter, INT(MJDate - _MJDNQuarter),
                _daysInQuarter, DAYS_IN_QUARTER(_quarter, _fiscalYear, _monthOffset, JulianCalendar),
                HSTACK(
                    _fiscalYear,
                    _quarter,
                    _dayOfQuarter,
                    INDEX(_cDate, 1, 4),
                    _daysInQuarter
                )
            )
        )
    )
)
);











/*##########################################################################################################
# DELTAS                                                                                                   #
##########################################################################################################*/


/*----------------------------------------------------------------------------------------------------------
DELTA_HOURS

Returns the timespan difference between Modified Julian Dates in hours.
Can also accept standard Julian Dates, provided types are not mixed.

Output
------------------------------------------------------------------------------------------------------------
1 | decimal | Difference in hours

Parameters
------------------------------------------------------------------------------------------------------------
MJDateStart | decimal | Starting Modified Julian Date 
MJDateEnd   | decimal | Ending Modified Julian Date
----------------------------------------------------------------------------------------------------------*/
DELTA_HOURS = LAMBDA(MJDateStart, MJDateEnd,
IFS(
    (MJDateStart = "") * (MJDateEnd = ""), "",
    NOT(ISNUMBER(MJDateStart)), {#VALUE!},
    NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
    TRUE, (MJDateEnd - MJDateStart) * 24
)
);


/*----------------------------------------------------------------------------------------------------------
DELTA_MINUTES

Returns the timespan difference between Modified Julian Dates in minutes.
Can also accept standard Julian Dates, provided types are not mixed.

Output
------------------------------------------------------------------------------------------------------------
1 | decimal | Difference in minutes

Parameters
------------------------------------------------------------------------------------------------------------
MJDateStart | decimal | Starting Modified Julian Date 
MJDateEnd   | decimal | Ending Modified Julian Date
----------------------------------------------------------------------------------------------------------*/
DELTA_MINUTES = LAMBDA(MJDateStart, MJDateEnd,
IFS(
    (MJDateStart = "") * (MJDateEnd = ""), "",
    NOT(ISNUMBER(MJDateStart)), {#VALUE!},
    NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
    TRUE, (MJDateEnd - MJDateStart) * 1440
)
);


/*----------------------------------------------------------------------------------------------------------
DELTA_SECONDS

Returns the timespan difference between Modified Julian Dates in seconds.
Can also accept standard Julian Dates, provided types are not mixed.

Output
------------------------------------------------------------------------------------------------------------
1 | decimal | Difference in seconds

Parameters
------------------------------------------------------------------------------------------------------------
MJDateStart | decimal | Starting Modified Julian Date 
MJDateEnd   | decimal | Ending Modified Julian Date
----------------------------------------------------------------------------------------------------------*/
DELTA_SECONDS = LAMBDA(MJDateStart, MJDateEnd,
IFS(
    (MJDateStart = "") * (MJDateEnd = ""), "",
    NOT(ISNUMBER(MJDateStart)), {#VALUE!},
    NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
    TRUE, (MJDateEnd - MJDateStart) * 86400
)
);


/*----------------------------------------------------------------------------------------------------------
DELTA_DHMS

Returns the sexagesimal difference between Modified Julian Dates with the given lowest order element rounded
to the specified precision.
Can also accept standard Julian Dates, provided types are not mixed.

Output - LowOrder = 4 (default)
------------------------------------------------------------------------------------------------------------
1 | integer [-1,0,1] | Sign
2 | integer [0..]    | Days
3 | integer [0..23]  | Hours
4 | integer [0..59]  | Minutes
5 | decimal [0..60)  | Seconds

Output - LowOrder = 3
------------------------------------------------------------------------------------------------------------
1 | integer [-1,0,1] | Sign
2 | integer [0..]    | Days
3 | integer [0..23]  | Hours
4 | decimal [0..60)  | Minutes

Output - LowOrder = 2
------------------------------------------------------------------------------------------------------------
1 | integer [-1,0,1] | Sign
2 | integer [0..]    | Days
3 | decimal [0..24)  | Hours

Output - LowOrder = 1
------------------------------------------------------------------------------------------------------------
1 | integer [-1,0,1] | Sign
2 | decimal [0..]    | Days

Parameters
------------------------------------------------------------------------------------------------------------
MJDateStart   | decimal | Starting Modified Julian Date 
MJDateEnd     | decimal | Ending Modified Julian Date
[LowOrder]    | integer | Lowest-order element. Defaults to Second.
          | [1..4]  |  1 - Day
          |         |  2 - Hour
          |         |  3 - Minute
          |         |  4 - Second
[Precision]   | integer | Select precision level
          | [0..9]  | Null - Floating
[Truncate]    | switch  | Round to precision by truncating components. Default is rounding to nearest.
----------------------------------------------------------------------------------------------------------*/
DELTA_DHMS = LAMBDA(MJDateStart, MJDateEnd, [LowOrder], [Precision], [Truncate],
IFS(
    (MJDateStart = "") * (MJDateEnd = ""), {"","","",""},
    NOT(ISNUMBER(MJDateStart)), {#VALUE!, "", "", ""},
    NOT(ISNUMBER(MJDateEnd)), {#VALUE!, "", "", ""},
    TRUE, RESOLVE_TIMESPAN(MJDateEnd - MJDateStart, LowOrder, Precision, Truncate)
)
);


/*----------------------------------------------------------------------------------------------------------
DELTA_TIMESPAN

Returns the timespan difference between Modified Julian Dates.
Can also accept standard Julian Dates, provided types are not mixed.

Output
------------------------------------------------------------------------------------------------------------
1 | decimal | Timespan difference, day = 1

Parameters
------------------------------------------------------------------------------------------------------------
MJDateStart | decimal | Starting Modified Julian Date 
MJDateEnd   | decimal | Ending Modified Julian Date
----------------------------------------------------------------------------------------------------------*/
DELTA_TIMESPAN = LAMBDA(MJDateStart, MJDateEnd,
IFS(
    (MJDateStart = "") * (MJDateEnd = ""), "",
    NOT(ISNUMBER(MJDateStart)), {#VALUE!},
    NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
    TRUE, (MJDateEnd - MJDateStart)
)
);


/*----------------------------------------------------------------------------------------------------------
DELTA_WEEKS

Returns the timespan difference between Modified Julian Dates in weeks.
Can also accept standard Julian Dates, provided types are not mixed.

Output
------------------------------------------------------------------------------------------------------------
1 | decimal | Difference in weeks

Parameters
------------------------------------------------------------------------------------------------------------
MJDateStart | decimal | Starting Modified Julian Date 
MJDateEnd   | decimal | Ending Modified Julian Date
----------------------------------------------------------------------------------------------------------*/
DELTA_WEEKS = LAMBDA(MJDateStart, MJDateEnd,
IFS(
    (MJDateStart = "") * (MJDateEnd = ""), "",
    NOT(ISNUMBER(MJDateStart)), {#VALUE!},
    NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
    TRUE, (MJDateEnd - MJDateStart) / 7
)
);


/*----------------------------------------------------------------------------------------------------------
DELTA_MONTHS

Returns the timespan difference between Modified Julian Dates in months.
Where the difference includes partial months, the fraction is calculated on the basis of days in the month
of the calendar. If the Modifed Julian Dates are expressed in UTC rather than local time then a small margin
of error will be introduced due to the bounds of calendar days.

Output
------------------------------------------------------------------------------------------------------------
1 | decimal | Difference in months

Parameters
------------------------------------------------------------------------------------------------------------
MJDateStart      | decimal | Starting Modified Julian Date 
MJDateEnd        | decimal | Ending Modified Julian Date
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
             |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
DELTA_MONTHS = LAMBDA(MJDateStart, MJDateEnd, [JulianCalendar],
IFS(
    (MJDateStart = "") * (MJDateEnd = ""), "",
    NOT(ISNUMBER(MJDateStart)), {#VALUE!},
    NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
    TRUE, IF(MJDateStart = MJDateEnd, 0,
        LET(
            _sign, IF(MJDateEnd >= MJDateStart, 1, -1),
            _date_A, MJDATE_TO_CALENDAR_DATE(
                IF(_sign = 1, MJDateStart, MJDateEnd),
                JulianCalendar
            ),
            _date_B, MJDATE_TO_CALENDAR_DATE(
                IF(_sign = 1, MJDateEnd, MJDateStart),
                JulianCalendar
            ),
            _deltaYear, INDEX(_date_B, 1, 1) - INDEX(_date_A, 1, 1),
            _deltaMonth, INDEX(_date_B, 1, 2) - INDEX(_date_A, 1, 2),
            _diffMonths, (_deltaYear * 12) + _deltaMonth,
            _daysMonth_A, DAYS_IN_MONTH(INDEX(_date_A, 1, 2), INDEX(_date_A, 1, 1), JulianCalendar),
            _daysMonth_B, DAYS_IN_MONTH(INDEX(_date_B, 1, 2), INDEX(_date_B, 1, 1), JulianCalendar),
            _partialMonth_A, (INDEX(_date_A, 1, 3) - 1 + INDEX(_date_A, 1, 4)) / _daysMonth_A,
            _partialMonth_B, (INDEX(_date_B, 1, 3) - 1 + INDEX(_date_B, 1, 4)) / _daysMonth_B,
            _sign * (_diffMonths - _partialMonth_A + _partialMonth_B)
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
DELTA_QUARTERS

Returns the timespan difference between Modified Julian Dates in quarters.
Where the difference includes partial quarters, the fraction is calculated on the basis of days in the
quarter of the calendar. If the Modifed Julian Dates are expressed in UTC rather than local time then a
small margin of error will be introduced due to the bounds of calendar days.

Output
------------------------------------------------------------------------------------------------------------
1 | decimal | Difference in quarters

Parameters
------------------------------------------------------------------------------------------------------------
MJDateStart      | decimal         | Starting Modified Julian Date 
MJDateEnd        | decimal         | Ending Modified Julian Date
[MonthOffset]    | integer [-6..3] | Quarter month offset from January.
[JulianCalendar] | switch          | Calculate in the Julian proleptic calendar. Default is Gregorian
             |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
DELTA_QUARTERS = LAMBDA(MJDateStart, MJDateEnd, [MonthOffset], [JulianCalendar],
IFS(
    (MJDateStart = "") * (MJDateEnd = ""), "",
    NOT(ISNUMBER(MJDateStart)), {#VALUE!},
    NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
    TRUE, LET(
        _monthOffset, ROUND(N(MonthOffset), 0),
        IFS(
            _monthOffset < -6, {#NUM!},
            _monthOffset > 3, {#NUM!},
            MJDateStart = MJDateEnd, 0,
            TRUE, LET(
                _sign, IF(MJDateEnd >= MJDateStart, 1, -1),
                _quarterDate_A, MJDATE_TO_QUARTER_DATE(
                    IF(_sign = 1, MJDateStart, MJDateEnd),
                    _monthOffset, JulianCalendar
                ),
                _quarterDate_B, MJDATE_TO_QUARTER_DATE(
                    IF(_sign = 1, MJDateEnd, MJDateStart),
                    _monthOffset, JulianCalendar
                ),
                _deltaYear, INDEX(_quarterDate_B, 1, 1) - INDEX(_quarterDate_A, 1, 1),
                _deltaQuarter, INDEX(_quarterDate_B, 1, 2) - INDEX(_quarterDate_A, 1, 2),
                _diffQuarters, (_deltaYear * 4) + _deltaQuarter,
                _partialQuarter_A, (INDEX(_quarterDate_A, 1, 3) - 1 + INDEX(_quarterDate_A, 1, 4)) / INDEX(_quarterDate_A, 1, 5),
                _partialQuarter_B, (INDEX(_quarterDate_B, 1, 3) - 1 + INDEX(_quarterDate_B, 1, 4)) / INDEX(_quarterDate_B, 1, 5),
                _sign * (_diffQuarters - _partialQuarter_A + _partialQuarter_B)
            )
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
DELTA_YEARS

Returns the timespan difference between Modified Julian Dates in years.
Where the difference includes partial years, the fraction is calculated on the basis of days in the
year of the calendar. If the Modifed Julian Dates are expressed in UTC rather than local time then a
small margin of error will be introduced due to the bounds of calendar days.

Output
------------------------------------------------------------------------------------------------------------
1 | decimal | Difference in years

Parameters
------------------------------------------------------------------------------------------------------------
MJDateStart      | decimal | Starting Modified Julian Date 
MJDateEnd        | decimal | Ending Modified Julian Date
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
             |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
DELTA_YEARS = LAMBDA(MJDateStart, MJDateEnd, [JulianCalendar],
IFS(
    (MJDateStart = "") * (MJDateEnd = ""), "",
    NOT(ISNUMBER(MJDateStart)), {#VALUE!},
    NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
    MJDateStart = MJDateEnd, 0,
    TRUE, LET(
        _sign, IF(MJDateEnd >= MJDateStart, 1, -1),
        _ordinalDate_A, MJDATE_TO_ORDINAL_DATE(
            IF(_sign = 1, MJDateStart, MJDateEnd),
            JulianCalendar
        ),
        _ordinalDate_B, MJDATE_TO_ORDINAL_DATE(
            IF(_sign = 1, MJDateEnd, MJDateStart),
            JulianCalendar
        ),
        _deltaYear, INDEX(_ordinalDate_B, 1, 1) - INDEX(_ordinalDate_A, 1, 1),
        _partialYear_A, (INDEX(_ordinalDate_A, 1, 2) - 1 + INDEX(_ordinalDate_A, 1, 3)) / INDEX(_ordinalDate_A, 1, 4),
        _partialYear_B, (INDEX(_ordinalDate_B, 1, 2) - 1 + INDEX(_ordinalDate_B, 1, 3)) / INDEX(_ordinalDate_B, 1, 4),
        _sign * (_deltaYear - _partialYear_A + _partialYear_B)
    )
)
);


/*----------------------------------------------------------------------------------------------------------
DELTA_WEEK_DAYS

Returns the timespan difference between Modified Julian Dates in weeks and days.
Can also accept standard Julian Dates, provided types are not mixed.

Output
------------------------------------------------------------------------------------------------------------
1 | integer [-1,0,1] | Sign
2 | integer [0..]    | Delta weeks 
3 | integer [0..6]   | Delta days
4 | decimal [0..1)   | Delta time

Parameters
------------------------------------------------------------------------------------------------------------
MJDateStart | decimal | Starting Modified Julian Date 
MJDateEnd   | decimal | Ending Modified Julian Date
----------------------------------------------------------------------------------------------------------*/
DELTA_WEEK_DAYS = LAMBDA(MJDateStart, MJDateEnd,
IFS(
    (MJDateStart = "") * (MJDateEnd = ""), {"", "", "", ""},
    NOT(ISNUMBER(MJDateStart)), {#VALUE!, "", "", ""},
    NOT(ISNUMBER(MJDateEnd)), {#VALUE!, "", "", ""},
    TRUE, LET(
        _diffDays, (MJDateEnd - MJDateStart),
        IF(_diffDays = 0, {0, 0, 0, 0},
            LET(
                _sign, IF(_diffDays >= 0, 1, -1),
                _absDiffDays, _sign * _diffDays,
                _deltaWeek, INT(_absDiffDays / 7),
                _remDays, _absDiffDays - _deltaWeek * 7,
                _deltaDay, INT(_remDays),
                _deltaTime, _remDays - _deltaDay,
                HSTACK(
                    _sign,
                    _deltaWeek,
                    _deltaDay,
                    _deltaTime
                )
            )
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
DELTA_YEAR_WEEK_DAYS

Returns the timespan difference between Modified Julian Dates in years, weeks, and days.
Note the number of weeks per year can vary between 52 and 53. If an absolute number of weeks is being sought
then use either DELTA_WEEK_DAYS or DELTA_WEEKS functions. If the Modifed Julian Dates are expressed in UTC
rather than local time then a small margin of error will be introduced due to the bounds of calendar days.

Output
------------------------------------------------------------------------------------------------------------
1 | integer [-1,0,1] | Sign
2 | integer [0..]    | Delta years
3 | integer [0..52]  | Delta weeks 
4 | decimal [0..6]   | Delta days
5 | decimal [0..1)   | Delta time

Parameters
------------------------------------------------------------------------------------------------------------
MJDateStart      | decimal | Starting Modified Julian Date 
MJDateEnd        | decimal | Ending Modified Julian Date
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
             |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
DELTA_YEAR_WEEK_DAYS = LAMBDA(MJDateStart, MJDateEnd, [JulianCalendar],
IFS(
    (MJDateStart = "") * (MJDateEnd = ""), {"", "", "", "", ""},
    NOT(ISNUMBER(MJDateStart)), {#VALUE!, "", "", "", ""},
    NOT(ISNUMBER(MJDateEnd)), {#VALUE!, "", "", "", ""},
    MJDateStart = MJDateEnd, {0, 0, 0, 0, 0},
    TRUE, LET(
        _sign, IF(MJDateEnd >= MJDateStart, 1, -1),
        _weekDate_A, MJDATE_TO_WEEK_DATE(
            IF(_sign = 1, MJDateStart, MJDateEnd),
            JulianCalendar
        ),
        _weekDate_B, MJDATE_TO_WEEK_DATE(
            IF(_sign = 1, MJDateEnd, MJDateStart),
            JulianCalendar
        ),
        _deltaYear, INDEX(_weekDate_B, 1, 1) - INDEX(_weekDate_A, 1, 1),
        _deltaWeek, INDEX(_weekDate_B, 1, 2) - INDEX(_weekDate_A, 1, 2),
        _diffDays, INDEX(_weekDate_B, 1, 3) - INDEX(_weekDate_A, 1, 3)
            + INDEX(_weekDate_B, 1, 4) - INDEX(_weekDate_A, 1, 4),
        _carryWeek, INT(_diffDays / 7),
        _remDays, _diffDays - _carryWeek * 7,
        _deltaWeek2, _deltaWeek + _carryWeek,
        _deltaDay, INT(_remDays),
        _deltaTime, _remDays - _deltaDay,
        IF(_deltaWeek2 >= 0,
            HSTACK(
                _sign,
                _deltaYear,
                _deltaWeek2,
                _deltaDay,
                _deltaTime
            ),
            HSTACK(
                _sign,
                _deltaYear - 1,
                _deltaWeek2 + INDEX(_weekDate_A, 1, 5),
                _deltaDay,
                _deltaTime
            )
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
DELTA_MONTH_DAYS

Returns the timespan difference between Modified Julian Dates in months and days.
If the Modifed Julian Dates are expressed in UTC rather than local time then a small margin of error will
be introduced due to the bounds of calendar days.

Output
------------------------------------------------------------------------------------------------------------
1 | integer [-1,0,1] | Sign
2 | integer [0..]    | Delta months
3 | integer [0..30]  | Delta days
4 | decimal [0..1)   | Delta time

Parameters
------------------------------------------------------------------------------------------------------------
MJDateStart      | decimal | Starting Modified Julian Date 
MJDateEnd        | decimal | Ending Modified Julian Date
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
             |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
DELTA_MONTH_DAYS = LAMBDA(MJDateStart, MJDateEnd, [JulianCalendar],
IFS(
    (MJDateStart = "") * (MJDateEnd = ""), {"", "", "", ""},
    NOT(ISNUMBER(MJDateStart)), {#VALUE!, "", "", ""},
    NOT(ISNUMBER(MJDateEnd)), {#VALUE!, "", "", ""},
    MJDateStart = MJDateEnd, {0, 0, 0, 0},
    TRUE, LET(
        _sign, IF(MJDateEnd >= MJDateStart, 1, -1),
        _date_A, MJDATE_TO_CALENDAR_DATE(
            IF(_sign = 1, MJDateStart, MJDateEnd),
            JulianCalendar
        ),
        _date_B, MJDATE_TO_CALENDAR_DATE(
            IF(_sign = 1, MJDateEnd, MJDateStart),
            JulianCalendar
        ),
        _deltaYear, INDEX(_date_B, 1, 1) - INDEX(_date_A, 1, 1),
        _deltaMonth, INDEX(_date_B, 1, 2) - INDEX(_date_A, 1, 2),
        _diffMonths, (_deltaYear * 12) + _deltaMonth,
        _diffDays, INDEX(_date_B, 1, 3) - INDEX(_date_A, 1, 3)
            + INDEX(_date_B, 1, 4) - INDEX(_date_A, 1, 4),
        IF(_diffDays >= 0,
            LET(
                _deltaDay, INT(_diffDays),
                _deltaTime, _diffDays - _deltaDay,
                HSTACK(
                    _sign,
                    _diffMonths,
                    _deltaDay,
                    _deltaTime
                )
            ),
            LET(
                _daysMonth_A, DAYS_IN_MONTH(INDEX(_date_A, 1, 2), INDEX(_date_A, 1, 1), JulianCalendar),
                _diffDays2, _diffDays + _daysMonth_A,  
                _deltaDay, INT(_diffDays2),
                _deltaTime, _diffDays2 - _deltaDay,
                HSTACK(
                    _sign,
                    _diffMonths - 1,
                    _deltaDay,
                    _deltaTime
                )
            )
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
DELTA_QUARTER_DAYS

Returns the timespan difference between Modified Julian Dates in quarters and days.
If the Modifed Julian Dates are expressed in UTC rather than local time then a small margin of error will
be introduced due to the bounds of calendar days.

Output
------------------------------------------------------------------------------------------------------------
1 | integer [-1,0,1] | Sign
2 | integer [0..]    | Delta quarters
3 | decimal [0..92)  | Delta days

Parameters
------------------------------------------------------------------------------------------------------------
MJDateStart      | decimal         | Starting Modified Julian Date 
MJDateEnd        | decimal         | Ending Modified Julian Date
[MonthOffset]    | integer [-6..3] | Quarter month offset from January.
[JulianCalendar] | switch          | Calculate in the Julian proleptic calendar. Default is Gregorian
             |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
DELTA_QUARTER_DAYS = LAMBDA(MJDateStart, MJDateEnd, [MonthOffset], [JulianCalendar],
IFS(
    (MJDateStart = "") * (MJDateEnd = ""), {"", "", "", ""},
    NOT(ISNUMBER(MJDateStart)), {#VALUE!, "", "", ""},
    NOT(ISNUMBER(MJDateEnd)), {#VALUE!, "", "", ""},
    TRUE, LET(
        _monthOffset, ROUND(N(MonthOffset), 0),
        IFS(
            _monthOffset < -6, {#NUM!, "", "", ""},
            _monthOffset > 3, {#NUM!, "", "", ""},
            MJDateStart = MJDateEnd, {0, 0, 0, 0},
            TRUE, LET(
                _sign, IF(MJDateEnd >= MJDateStart, 1, -1),
                _quarterDate_A, MJDATE_TO_QUARTER_DATE(
                    IF(_sign = 1, MJDateStart, MJDateEnd),
                    _monthOffset, JulianCalendar
                ),
                _quarterDate_B, MJDATE_TO_QUARTER_DATE(
                    IF(_sign = 1, MJDateEnd, MJDateStart),
                    _monthOffset, JulianCalendar
                ),
                _deltaYear, INDEX(_quarterDate_B, 1, 1) - INDEX(_quarterDate_A, 1, 1),
                _deltaQuarter, INDEX(_quarterDate_B, 1, 2) - INDEX(_quarterDate_A, 1, 2),
                _diffQuarters, (_deltaYear * 4) + _deltaQuarter,
                _diffDays, INDEX(_quarterDate_B, 1, 3) - INDEX(_quarterDate_A, 1, 3)
                    + INDEX(_quarterDate_B, 1, 4) - INDEX(_quarterDate_A, 1, 4),
                IF(_diffDays >= 0,
                    LET(
                        _deltaDay, INT(_diffDays),
                        _deltaTime, _diffDays - _deltaDay,
                        HSTACK(
                            _sign,
                            _diffQuarters,
                            _deltaDay,
                            _deltaTime
                        )
                    ),
                    LET(
                        _diffDays2, _diffDays + INDEX(_quarterDate_A, 1, 5),
                        _deltaDay, INT(_diffDays2),
                        _deltaTime, _diffDays2 - _deltaDay,
                        HSTACK(
                            _sign,
                            _diffQuarters - 1,
                            _deltaDay,
                            _deltaTime
                        )
                    )
                )
            )
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
DELTA_INTERVAL

Returns the timespan difference between Modified Julian Dates in the specified units.

Output where Units = H, N, S, D, W, M, Q, Y
------------------------------------------------------------------------------------------------------------
1 | decimal | Delta units decimal

Output where Units = HMS
------------------------------------------------------------------------------------------------------------
1 | integer [-1,0,1] | Sign
2 | integer [0..]    | Delta hours
3 | integer [0..59]  | Delta minutes
4 | decimal [0..60)  | Delta seconds

Output where Units = DHMS
------------------------------------------------------------------------------------------------------------
1 | integer [-1,0,1] | Sign
2 | integer [0..]    | Delta days
3 | integer [0..23]  | Delta hours
4 | integer [0..59]  | Delta minutes
5 | decimal [0..60)  | Delta seconds

Output where Units = WD, MD, QD
------------------------------------------------------------------------------------------------------------
1 | integer [-1,0,1]     | Sign
2 | integer [0..]        | Delta weeks/months/quarters
3 | integer [0..6/30/91] | Delta days
4 | decimal [0..1)       | Delta time

Output where Units = YWD, YMD, YQD
------------------------------------------------------------------------------------------------------------
1 | integer [-1,0,1]     | Sign
2 | integer [0..]        | Delta years
3 | integer [0..52/12/4] | Delta weeks/months/quarters
4 | integer [0..6/30/91] | Delta days
5 | decimal [0..1)       | Delta time

Output where Units = YMDHMS
------------------------------------------------------------------------------------------------------------
1 | integer [-1,0,1] | Sign
2 | integer [0..]    | Delta years
3 | integer [0..12]  | Delta months
4 | integer [0..30]  | Delta days
5 | integer [0..23]  | Delta hours
6 | integer [0..59]  | Delta minutes
7 | decimal [0..60)  | Delta seconds

Parameters
------------------------------------------------------------------------------------------------------------
Units            | text            |      H - hours decimal
             |                 |      N - minutes decimal
             |                 |      S - seconds decimal
             |                 |      T - timespan decimal
             |                 |      W - weeks decimal
             |                 |      M - months decimal
             |                 |      Q - quarters decimal
             |                 |      Y - years decimal
             |                 |    HMS - hours, minutes, seconds
             |                 |   DHMS - days, hours, minutes, seconds
             |                 |     WD - weeks and days
             |                 |     MD - months and days
             |                 |     QD - quarters and days
             |                 |    YWD - years, weeks, days
             |                 |    YMD - years, months, days
             |                 |    YQD - years, quarters, days
             |                 | YMDHMS - years, months, days, hours, minutes, seconds
MJDateStart      | decimal         | Starting Modified Julian Date 
MJDateEnd        | decimal         | Ending Modified Julian Date
[MonthOffset]    | integer [-6..3] | Quarter month offset from January.
[JulianCalendar] | switch          | Calculate in the Julian proleptic calendar. Default is Gregorian
             |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
DELTA_INTERVAL = LAMBDA(Units, MJDateStart, MJDateEnd, [MonthOffset], [JulianCalendar],
IFS(
    Units = "", {#VALUE!},
    Units = "H", DELTA_HOURS(MJDateStart, MJDateEnd),
    Units = "N", DELTA_MINUTES(MJDateStart, MJDateEnd),
    Units = "S", DELTA_SECONDS(MJDateStart, MJDateEnd),
    Units = "DHMS", DELTA_DHMS(MJDateStart, MJDateEnd, 4),
    Units = "T", DELTA_TIMESPAN(MJDateStart, MJDateEnd),
    Units = "W", DELTA_WEEKS(MJDateStart, MJDateEnd),
    Units = "M", DELTA_MONTHS(MJDateStart, MJDateEnd, JulianCalendar),
    Units = "Q", DELTA_QUARTERS(MJDateStart, MJDateEnd, MonthOffset, JulianCalendar),
    Units = "Y", DELTA_YEARS(MJDateStart, MJDateEnd, JulianCalendar),
    Units = "WD", DELTA_WEEK_DAYS(MJDateStart, MJDateEnd),
    Units = "YWD", DELTA_YEAR_WEEK_DAYS(MJDateStart, MJDateEnd, JulianCalendar),
    Units = "MD", DELTA_MONTH_DAYS(MJDateStart, MJDateEnd, JulianCalendar),
    Units = "QD", DELTA_QUARTER_DAYS(MJDateStart, MJDateEnd, MonthOffset, JulianCalendar),
    Units = "HMS", LET(
            _dhms, DELTA_DHMS(MJDateStart, MJDateEnd, 4),
            _hours, INDEX(_dhms, 1, 3) + (24 * INDEX(_dhms, 1, 2)),
            HSTACK(
                INDEX(_dhms, 1, 1),
                _hours,
                INDEX(_dhms, 1, 4),
                INDEX(_dhms, 1, 5)
            )
        ),
    Units = "YMD", LET(
            _monthDays, DELTA_MONTH_DAYS(MJDateStart, MJDateEnd, JulianCalendar),
            _years, INT(INDEX(_monthDays, 1, 2) / 12),
            _months, INDEX(_monthDays, 1, 2) - _years * 12,
            HSTACK(
                INDEX(_monthDays, 1, 1),
                _years,
                _months,
                INDEX(_monthDays, 1, 3),
                INDEX(_monthDays, 1, 4)
            )
        ),
    Units = "YQD", LET(
            _quarterDays, DELTA_QUARTER_DAYS(MJDateStart, MJDateEnd, MonthOffset, JulianCalendar),
            _years, INT(INDEX(_quarterDays, 1, 2) / 4),
            _quarters, INDEX(_quarterDays, 1, 2) - _years * 4,
            HSTACK(
                INDEX(_quarterDays, 1, 1),
                _years,
                _quarters,
                INDEX(_quarterDays, 1, 3),
                INDEX(_quarterDays, 1, 4)
            )
        ),
    Units = "YMDHMS", LET(
            _monthDays, DELTA_MONTH_DAYS(MJDateStart, MJDateEnd, JulianCalendar),
            _years, INT(INDEX(_monthDays, 1, 2) / 12),
            _months, INDEX(_monthDays, 1, 2) - _years * 12,
            _hms, RESOLVE_TIMESPAN(INDEX(_monthDays, 1, 4), 4),
            HSTACK(
                INDEX(_monthDays, 1, 1),
                _years,
                _months,
                INDEX(_monthDays, 1, 3),
                DROP(_hms,, 2)
            )
        ),
    TRUE, {#VALUE!}
)
);












/*##########################################################################################################
# EXTENTS                                                                                                  #
##########################################################################################################*/


/*----------------------------------------------------------------------------------------------------------
EXTENT_OF_DAYS

Returns the inclusive extent of days spanned by two Modified Julian Dates expressed in local time.
If the Modifed Julian Dates are expressed in UTC rather than local time then inconsistent results may be
produced due to the bounds of calendar days.

Output
------------------------------------------------------------------------------------------------------------
1 | integer | Extent of days

Parameters
------------------------------------------------------------------------------------------------------------
LocalMJDateStart | decimal | Starting Modified Julian Date in local time 
LocalMJDateEnd   | decimal | Ending Modified Julian Date in local time

Examples
------------------------------------------------------------------------------------------------------------
EXTENT_DAYS(MODIFIED_JULIAN_DATE(2023,1,1,TIME(23,59,55)), MODIFIED_JULIAN_DATE(2023,1,2,TIME(0,0,5)))
= 2  i.e. 2 days because the 10 second timespan crosses the day boundary
----------------------------------------------------------------------------------------------------------*/
EXTENT_OF_DAYS = LAMBDA(LocalMJDateStart, LocalMJDateEnd,
IFS(
    (LocalMJDateStart = "") * (LocalMJDateEnd = ""), "",
    NOT(ISNUMBER(LocalMJDateStart)), {#VALUE!},
    NOT(ISNUMBER(LocalMJDateEnd)), {#VALUE!},
    TRUE, LET(
        _sign, IF(LocalMJDateEnd >= LocalMJDateStart, 1, -1),
        _deltaDay, INT(LocalMJDateEnd) - INT(LocalMJDateStart),
        _sign * (ABS(_deltaDay) + 1)
    )
)
);


/*----------------------------------------------------------------------------------------------------------
EXTENT_OF_WEEKS

Returns the inclusive extent of weeks spanned by two Modified Julian Dates expressed in local time.
If the Modifed Julian Dates are expressed in UTC rather than local time then inconsistent results may be
produced due to the bounds of calendar days.

Output
------------------------------------------------------------------------------------------------------------
1 | integer | Extent of weeks

Parameters
------------------------------------------------------------------------------------------------------------
LocalMJDateStart | decimal | Starting Modified Julian Date in local time 
LocalMJDateEnd   | decimal | Ending Modified Julian Date in local time

Examples
------------------------------------------------------------------------------------------------------------
EXTENT_WEEKS(MODIFIED_JULIAN_DATE(2023,6,4,TIME(23,59,55)), MODIFIED_JULIAN_DATE(2023,6,5,TIME(0,0,5)))
= 2  i.e. 2 weeks because the 10 second timespan crosses the week boundary
----------------------------------------------------------------------------------------------------------*/
EXTENT_OF_WEEKS = LAMBDA(LocalMJDateStart, LocalMJDateEnd,
IFS(
    (LocalMJDateStart = "") * (LocalMJDateEnd = ""), "",
    NOT(ISNUMBER(LocalMJDateStart)), {#VALUE!},
    NOT(ISNUMBER(LocalMJDateEnd)), {#VALUE!},
    TRUE, LET(
        _sign, IF(LocalMJDateEnd >= LocalMJDateStart, 1, -1),
        _startMonday, INT(LocalMJDateStart) + 1 - DAY_OF_WEEK(LocalMJDateStart),
        _endMonday, INT(LocalMJDateEnd) + 1 - DAY_OF_WEEK(LocalMJDateEnd),
        _sign * (INT(ABS(_endMonday - _startMonday) / 7) + 1)
    )
)
);


/*----------------------------------------------------------------------------------------------------------
EXTENT_OF_MONTHS

Returns the inclusive extent of months spanned by two Modified Julian Dates expressed in local time.
If the Modifed Julian Dates are expressed in UTC rather than local time then inconsistent results may be
produced due to the bounds of calendar days.

Output
------------------------------------------------------------------------------------------------------------
1 | integer | Extent of months

Parameters
------------------------------------------------------------------------------------------------------------
LocalMJDateStart | decimal | Starting Modified Julian Date in local time 
LocalMJDateEnd   | decimal | Ending Modified Julian Date in local time
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
             |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
EXTENT_OF_MONTHS = LAMBDA(LocalMJDateStart, LocalMJDateEnd, [JulianCalendar],
IFS(
    (LocalMJDateStart = "") * (LocalMJDateEnd = ""), "",
    NOT(ISNUMBER(LocalMJDateStart)), {#VALUE!},
    NOT(ISNUMBER(LocalMJDateEnd)), {#VALUE!},
    TRUE, LET(
        _sign, IF(LocalMJDateEnd >= LocalMJDateStart, 1, -1),
        _date_A, MJDATE_TO_CALENDAR_DATE(
            IF(_sign = 1, LocalMJDateStart, LocalMJDateEnd),
            JulianCalendar
        ),
        _date_B, MJDATE_TO_CALENDAR_DATE(
            IF(_sign = 1, LocalMJDateEnd, LocalMJDateStart),
            JulianCalendar
        ),
        _deltaYear, INDEX(_date_B, 1, 1) - INDEX(_date_A, 1, 1),
        _deltaMonth, INDEX(_date_B, 1, 2) - INDEX(_date_A, 1, 2),
        _diffMonths, (_deltaYear * 12) + _deltaMonth,
        _sign * (_diffMonths + 1)
    )
)
);


/*----------------------------------------------------------------------------------------------------------
EXTENT_OF_QUARTERS

Returns the inclusive extent of quarters spanned by two Modified Julian Dates expressed in local time.
If the Modifed Julian Dates are expressed in UTC rather than local time then inconsistent results may be
produced due to the bounds of calendar days.

Output
------------------------------------------------------------------------------------------------------------
1 | integer | Extent of quarters

Parameters
------------------------------------------------------------------------------------------------------------
LocalMJDateStart | decimal         | Starting Modified Julian Date in local time 
LocalMJDateEnd   | decimal         | Ending Modified Julian Date in local time
[MonthOffset]    | integer [-6..3] | Quarter month offset from January.
[JulianCalendar] | switch          | Calculate in the Julian proleptic calendar. Default is Gregorian
             |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
EXTENT_OF_QUARTERS = LAMBDA(LocalMJDateStart, LocalMJDateEnd, [MonthOffset], [JulianCalendar],
IFS(
    (LocalMJDateStart = "") * (LocalMJDateEnd = ""), "",
    NOT(ISNUMBER(LocalMJDateStart)), {#VALUE!},
    NOT(ISNUMBER(LocalMJDateEnd)), {#VALUE!},
    TRUE, LET(
        _monthOffset, ROUND(N(MonthOffset), 0),
        IFS(
            _monthOffset < -6, {#NUM!},
            _monthOffset > 3, {#NUM!},
            TRUE, LET(
                _sign, IF(LocalMJDateEnd >= LocalMJDateStart, 1, -1),
                _quarterDate_A, MJDATE_TO_QUARTER_DATE(
                    IF(_sign = 1, LocalMJDateStart, LocalMJDateEnd),
                    _monthOffset, JulianCalendar
                ),
                _quarterDate_B, MJDATE_TO_QUARTER_DATE(
                    IF(_sign = 1, LocalMJDateEnd, LocalMJDateStart),
                    _monthOffset, JulianCalendar
                ),
                _deltaYear, INDEX(_quarterDate_B, 1, 1) - INDEX(_quarterDate_A, 1, 1),
                _deltaQuarter, INDEX(_quarterDate_B, 1, 2) - INDEX(_quarterDate_A, 1, 2),
                _diffQuarters, (_deltaYear * 4) + _deltaQuarter,
                _sign * (_diffQuarters + 1)
            )
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
EXTENT_OF_YEARS

Returns the inclusive extent of years spanned by two Modified Julian Dates expressed in local time.
If the Modifed Julian Dates are expressed in UTC rather than local time then inconsistent results may be
produced due to the bounds of calendar days.

Output
------------------------------------------------------------------------------------------------------------
1 | integer | Extent of quarters

Parameters
------------------------------------------------------------------------------------------------------------
LocalMJDateStart | decimal | Starting Modified Julian Date in local time 
LocalMJDateEnd   | decimal | Ending Modified Julian Date in local time
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
             |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
EXTENT_OF_YEARS = LAMBDA(LocalMJDateStart, LocalMJDateEnd, [JulianCalendar],
IFS(
    (LocalMJDateStart = "") * (LocalMJDateEnd = ""), "",
    NOT(ISNUMBER(LocalMJDateStart)), {#VALUE!},
    NOT(ISNUMBER(LocalMJDateEnd)), {#VALUE!},
    TRUE, LET(
        _sign, IF(LocalMJDateEnd >= LocalMJDateStart, 1, -1),
        _date_A, MJDATE_TO_CALENDAR_DATE(
            IF(_sign = 1, LocalMJDateStart, LocalMJDateEnd),
            JulianCalendar
        ),
        _date_B, MJDATE_TO_CALENDAR_DATE(
            IF(_sign = 1, LocalMJDateEnd, LocalMJDateStart),
            JulianCalendar
        ),
        _deltaYear, INDEX(_date_B, 1, 1) - INDEX(_date_A, 1, 1),
        _sign * (_deltaYear + 1)
    )
)
);








/*##########################################################################################################
# PARSING                                                                                                  #
##########################################################################################################*/


/*----------------------------------------------------------------------------------------------------------
PARSE_WEEKDAY

Returns a number representing the day of the week from a given text weekday name.

Output
------------------------------------------------------------------------------------------------------------
1 | integer | Weekday number
| [1..7]  |    | ISO       | Traditioal
|         | ---------------------------
|         |  1 | Monday    | Sunday 
|         |  2 | Tuesday   | Monday 
|         |  3 | Wednesday | Tuesday
|         |  4 | Thursday  | Wednesday
|         |  5 | Friday    | Thursday
|         |  6 | Saturday  | Friday
|         |  7 | Sunday    | Saturday

Parameters
------------------------------------------------------------------------------------------------------------
DayOfWeekText | text   | Day of week name
[Traditional] | switch | Return day of week using traditional numbering scheme.

Examples
------------------------------------------------------------------------------------------------------------
PARSE_WEEKDAY("Saturday")
Returns: 6

PARSE_WEEKDAY("Mon", 1)
Returns: 2

PARSE_WEEKDAY("Thurs")
Returns: #VALUE!

PARSE_WEEKDAY("Ven")
Returns: 5 (Friday, if local language is set to Italian)
----------------------------------------------------------------------------------------------------------*/
PARSE_WEEKDAY = LAMBDA(DayOfWeekText, [Traditional],
IF(DayOfWeekText = "", "",
    LET(
        fnMatchIntEng, LAMBDA(DoW,
            LET(
                _dow, IF(LEN(DayOfWeekText) = 3,
                    XMATCH(
                        DayOfWeekText,
                        {
                            "Mon";
                            "Tue";
                            "Wed";
                            "Thu";
                            "Fri";
                            "Sat";
                            "Sun"
                        }
                    ),
                    XMATCH(
                        DayOfWeekText,
                        {
                            "Monday";
                            "Tuesday";
                            "Wednesday";
                            "Thursday";
                            "Friday";
                            "Saturday";
                            "Sunday"
                        }
                    )
                ),
                IFNA(_dow, 0)
            )
        ),
        fnMatchLocalLang, LAMBDA(DoW,
            LET(
                _days, SEQUENCE(7, 1, 36528),
                _dow, IF(LEN(DayOfWeekText) = 3,
                    XMATCH(DayOfWeekText, TEXT(_days, "ddd")),
                    XMATCH(DayOfWeekText, TEXT(_days, "dddd"))
                ),
                IFNA(_dow, 0)
            )
        ),
        _ISOWeekday, LET(
            _idx, fnMatchIntEng(DayOfWeekText),
            IF(_idx > 0, _idx, fnMatchLocalLang(DayOfWeekText))
        ),
        IFS(_ISOWeekday = 0, {#VALUE!},
            N(Traditional) = 0, _ISOWeekday,
            TRUE, MOD(_ISOWeekday, 7) + 1
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
PARSE_MONTH

Returns a number representing the month of year from a given text month name.

Output
------------------------------------------------------------------------------------------------------------
1 | integer [1..12] | Month

Parameters
------------------------------------------------------------------------------------------------------------
MonthText | text | Month name

Examples
------------------------------------------------------------------------------------------------------------
PARSE_MONTH("Feb")
Returns: 2

PARSE_MONTH("January")
Returns: 1

PARSE_MONTH("J")
Returns: #VALUE!

PARSE_MONTH("Marzo")
Returns: 3 (if local language is set to Italian)
----------------------------------------------------------------------------------------------------------*/
PARSE_MONTH = LAMBDA(MonthText,
IF(MonthText = "", "",
    MONTH(DATEVALUE(MonthText & " 2000"))
)
);





/*----------------------------------------------------------------------------------------------------------
PARSE_ISO_TIME

Parses an ISO formatted time of day into decimal time of day.

Output
------------------------------------------------------------------------------------------------------------
1 | decimal [0..1] | Time of day as decimal fraction of a day.

Parameters
------------------------------------------------------------------------------------------------------------
ISOTime | text   | Time in ISO format ie. hh:mm:ss.000

Examples
------------------------------------------------------------------------------------------------------------
PARSE_ISO_TIME("12:00")
Returns: 0.5

PARSE_ISO_TIME("24:00:01")
Returns: #NUM!  i.e. range is 0 to 24 hours 
----------------------------------------------------------------------------------------------------------*/
PARSE_ISO_TIME = LAMBDA(ISOTime,
IFS(
    ISOTime = "", "",
    CODE(ISOTime) <> 84, {#VALUE!},
    TRUE, LET(
        _len, LEN(ISOTime) - 1,
        _timePart, RIGHT(ISOTime, _len),
        _pattern, REPLACE_CHARS(_timePart, "0123456789", "_"),
        _tryParse, IFS(
            LEFT(_pattern, 10) = "__:__:__._",
                HSTACK(
                    VALUE(LEFT(_timePart, 2)),
                    VALUE(MID(_timePart, 4, 2)),
                    VALUE(MID(_timePart, 7, 2)),
                    VALUE(RIGHT(_timePart, _len - 9)) * 10 ^ (12 - _len)
                ),
            _pattern = "__:__:__",
                HSTACK(
                    VALUE(LEFT(_timePart, 2)),
                    VALUE(MID(_timePart, 4, 2)),
                    VALUE(RIGHT(_timePart, 2)),
                    0
                ),
            _pattern = "__:__",
                HSTACK(
                    VALUE(LEFT(_timePart, 2)),
                    VALUE(RIGHT(_timePart, 2)),
                    0, 0
                ),
            LEFT(_pattern, 8) = "______._",
                HSTACK(
                    VALUE(LEFT(_timePart, 2)),
                    VALUE(MID(_timePart, 3, 2)),
                    VALUE(MID(_timePart, 5, 2)),
                    VALUE(RIGHT(_timePart, _len - 7)) * 10 ^ (10 - _len)
                ),
            _pattern = "______",
                HSTACK(
                    VALUE(LEFT(_timePart, 2)),
                    VALUE(MID(_timePart, 3, 2)),
                    VALUE(RIGHT(_timePart, 2)),
                    0
                ),
            _pattern = "____",
                HSTACK(
                    VALUE(LEFT(_timePart, 2)),
                    VALUE(RIGHT(_timePart, 2)),
                    0, 0
                ),
            _pattern = "__",
                HSTACK(
                    VALUE(_timePart), 0, 0, 0
                ),
            TRUE, ""
        ),
        IF(INDEX(_tryParse, 1, 1) = "", {#VALUE!},
            LET(
                _hour, INDEX(_tryParse, 1, 1),
                _minute, INDEX(_tryParse, 1, 2),
                _second, INDEX(_tryParse, 1, 3) + INDEX(_tryParse, 1, 4) / 1000,
                IF(NOT(IS_VALID_TIME_OF_DAY(_hour, _minute, _second, 1)), {#NUM!},
                    TIMESPAN(1, 0, _hour, _minute, _second)
                )
            )
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
PARSE_ISO_TZO

Parses an ISO formatted time zone offset into a decimal timespan.

Output
------------------------------------------------------------------------------------------------------------
1 | decimal [-0.625..0.625] | Time zone offset as decimal fraction of a day

Parameters
------------------------------------------------------------------------------------------------------------
ISOTimeZoneOffset | text   | Time zone offset in ISO format ie. hh:mm

Examples
------------------------------------------------------------------------------------------------------------
PARSE_ISO_TZO("Z")
Returns: 0 i.e. UTC time zone (Zulu)

PARSE_ISO_TIME("06:00")
Returns: -0.25

PARSE_ISO_TIME("+16:00")
Returns: #NUM! i.e. range is 15:00 to +15:00
----------------------------------------------------------------------------------------------------------*/
PARSE_ISO_TZO = LAMBDA(ISOTimeZoneOffset,
IF(ISOTimeZoneOffset = "", "",
    LET(
        _len, LEN(ISOTimeZoneOffset),
        IF((_len = 1) * (CODE(ISOTimeZoneOffset) = 90), 0,
            LET(
                _sChar, LEFT(ISOTimeZoneOffset, 1),
                _sign, IFS(
                    _sChar = "+", 1,
                    _sChar = "-", -1,
                    UNICODE(_sChar) = 8722, -1,
                    TRUE, 0
                ),
                IF(_sign = 0, {#VALUE!},
                    LET(
                        _tz, MID(ISOTimeZoneOffset, 2, _len - 1),
                        _pattern, REPLACE_CHARS(_tz, "0123456789", "_"),
                        _tryParse, IFS(
                            _pattern = "__:__:__",
                                HSTACK(
                                    VALUE(LEFT(_tz, 2)),
                                    VALUE(MID(_tz, 4, 2)),
                                    VALUE(RIGHT(_tz, 2))
                                ),
                            _pattern = "__:__",
                                HSTACK(
                                    VALUE(LEFT(_tz, 2)),
                                    VALUE(RIGHT(_tz, 2)),
                                    0
                                ),
                            _pattern = "______",
                                HSTACK(
                                    VALUE(LEFT(_tz, 2)),
                                    VALUE(MID(_tz, 3, 2)),
                                    VALUE(RIGHT(_tz, 2))
                                ),
                            _pattern = "____",
                                HSTACK(
                                    VALUE(LEFT(_tz, 2)),
                                    VALUE(RIGHT(_tz, 2)),
                                    0
                                ),
                            _pattern = "__",
                                HSTACK(VALUE(_tz), 0, 0),
                            TRUE, ""
                        ),
                        
                        IF(INDEX(_tryParse, 1, 1) = "", {#VALUE!},
                            LET(
                                _hour, INDEX(_tryParse, 1, 1),
                                _minute, INDEX(_tryParse, 1, 2),
                                _second, INDEX(_tryParse, 1, 3),
                                IF(NOT(IS_VALID_TIME_OF_DAY(_hour, _minute, _second)), {#NUM!},
                                    LET(
                                        _absTZO, TIMESPAN(1, 0, _hour, _minute, _second),
                                        IF(_absTZO > 0.625, {#NUM!},
                                            _sign * _absTZO
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
PARSE_ISO_CALENDAR_DATE

Parses an ISO formatted calendar date into respective parts of year, month and day.

Output
------------------------------------------------------------------------------------------------------------
1 | integer | YearCE
2 | integer | Month
3 | integer | Day

Parameters
------------------------------------------------------------------------------------------------------------
ISOCalendarDate  | text   | Date in ISO format ie. yyyy-MM-dd
[JulianCalendar] | switch | Validate in the Julian proleptic calendar. Default is Gregorian
             |        | proleptic calendar.

Examples
------------------------------------------------------------------------------------------------------------
PARSE_ISO_CALENDAR_DATE("2023-05-23")
Returns: {2023, 5, 23}

PARSE_ISO_CALENDAR_DATE("1900-02-29", 1)
Returns: {2023, 2, 29} i.e. Feb 29, 1900 is valid in the Julian calendar
----------------------------------------------------------------------------------------------------------*/
PARSE_ISO_CALENDAR_DATE = LAMBDA(ISOCalendarDate, [JulianCalendar],
IFS(
    ISOCalendarDate = "", {"", "", ""},
    NOT(VALIDATE_CHARSET("+-0123456789" & UNICHAR(8722), ISOCalendarDate)), {#VALUE!, "", ""},
    TRUE, LET(
        _firstChar, LEFT(ISOCalendarDate, 1),
        _isSigned, IFS(
            _firstChar = "+", TRUE,
            _firstChar = "-", TRUE,
            _firstChar = UNICHAR(8722), TRUE,
            TRUE, FALSE
        ),
        _sign, IFS(
            NOT(_isSigned), 1,
            _firstChar = "-", -1,
            _firstChar = UNICHAR(8722), -1,
            TRUE, 1
        ),
        _unSigned, IF(_isSigned,
            RIGHT(ISOCalendarDate, LEN(ISOCalendarDate) - 1),
            ISOCalendarDate
        ),
        _len, LEN(_unSigned),
        _pattern, REPLACE_CHARS(_unSigned, "0123456789", "_"),
        _tryParse, IFS(
            _len >= 10, IFS(
                _pattern = RIGHT("_______________-__-__", _len),
                HSTACK(
                    VALUE(LEFT(_unSigned, _len - 6)),
                    VALUE(MID(_unSigned, _len - 4, 2)),
                    VALUE(RIGHT(_unSigned, 2))
                ),
                _pattern = RIGHT("_______________-__", _len),
                HSTACK(
                    VALUE(LEFT(_unSigned, _len - 3)),
                    VALUE(RIGHT(_unSigned, 2)),
                    ""
                ),
                _pattern = RIGHT("___________________", _len),
                HSTACK(
                    VALUE(LEFT(_unSigned, _len - 4)),
                    VALUE(MID(_unSigned, _len - 3, 2)),
                    VALUE(RIGHT(_unSigned, 2))
                ),
                TRUE, ""
            ),
            _len >= 8, IFS(
                _pattern = RIGHT("______-__", _len),
                HSTACK(
                    VALUE(LEFT(_unSigned, _len - 3)),
                    VALUE(RIGHT(_unSigned, 2)),
                    ""
                ),
                _pattern = RIGHT("_________", _len),
                HSTACK(
                    VALUE(LEFT(_unSigned, _len - 4)),
                    VALUE(MID(_unSigned, _len - 3, 2)),
                    VALUE(RIGHT(_unSigned, 2))
                ),
                TRUE, ""
            ),
            _len = 7, IF(
                _pattern = "____-__",
                HSTACK(
                    VALUE(LEFT(_unSigned, 4)),
                    VALUE(RIGHT(_unSigned, 2)),
                    ""
                ),
                ""
            ),
            (_len >= 4) * (_len <= 5),  IF(
                _pattern = RIGHT("_____", _len),
                HSTACK(
                    VALUE(_unSigned),
                    "",
                    ""
                ),
                ""
            ),
            TRUE, ""
        ),

        IF(INDEX(_tryParse, 1, 1) = "", {#VALUE!, "", ""},
            LET(
                _year, _sign * INDEX(_tryParse, 1, 1),
                _month, INDEX(_tryParse, 1, 2),
                IFS(
                    _month = "", HSTACK(_year, "", ""),
                    (_month < 1) + (_month > 12), HSTACK(_year, {#NUM!}, ""),
                    TRUE, LET(
                        _day, INDEX(_tryParse, 1, 3),
                        IF(_day = "",
                            HSTACK(_year, _month, ""),    
                            IF(IS_VALID_DATE(_year, _month, _day, JulianCalendar),
                                HSTACK(_year, _month, _day),
                                HSTACK(_year, _month, {#NUM!})
                            )
                        )
                    )
                )
            )
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
PARSE_ISO_ORDINAL_DATE

Parses an ISO formatted ordinal date into respective parts of year, and ordinal day.

Output
------------------------------------------------------------------------------------------------------------
1 | integer          | YearCE
2 | integer [1..366] | Ordinal day

Parameters
------------------------------------------------------------------------------------------------------------
ISOOrdinalDate   | text   | Date in ISO format ie. yyyy-ddd
[JulianCalendar] | switch | Validate in the Julian proleptic calendar. Default is Gregorian
             |        | proleptic calendar.

Examples
------------------------------------------------------------------------------------------------------------
PARSE_ISO_ORDINAL_DATE("2023-223")
Returns: {2023, 223}

PARSE_ISO_ORDINAL_DATE("1900-366", 1)
Returns: {2023, 366} i.e. 1900 was a leap year in the Julian calendar
----------------------------------------------------------------------------------------------------------*/
PARSE_ISO_ORDINAL_DATE = LAMBDA(ISOOrdinalDate, [JulianCalendar],
IFS(
    ISOOrdinalDate = "", {"", ""},
    NOT(VALIDATE_CHARSET("+-0123456789" & UNICHAR(8722), ISOOrdinalDate)), {#VALUE!, ""},
    TRUE, LET(
        _firstChar, LEFT(ISOOrdinalDate, 1),
        _isSigned, IFS(
            _firstChar = "+", TRUE,
            _firstChar = "-", TRUE,
            _firstChar = UNICHAR(8722), TRUE,
            TRUE, FALSE
        ),
        _sign, IFS(
            NOT(_isSigned), 1,
            _firstChar = "-", -1,
            _firstChar = UNICHAR(8722), -1,
            TRUE, 1
        ),
        _unSigned, IF(_isSigned,
            RIGHT(ISOOrdinalDate, LEN(ISOOrdinalDate) - 1),
            ISOOrdinalDate
        ),
        _len, LEN(_unSigned),
        _pattern, REPLACE_CHARS(_unSigned, "0123456789", "_"),
        _tryParse, IFS(
            _len >= 8, IF(
                _pattern = RIGHT("_______________-___", _len),
                HSTACK(
                    VALUE(LEFT(_unSigned, _len - 4)),
                    VALUE(RIGHT(_unSigned, 3))
                ),
                ""
            ),
            _len = 7, IF(
                _pattern = "_______",
                HSTACK(
                    VALUE(LEFT(_unSigned, _len - 3)),
                    VALUE(RIGHT(_unSigned, 3))
                ),
                ""
            ),
            (_len >= 4) * (_len <= 5), IF(
                _pattern = RIGHT("_____", _len),
                HSTACK(
                    VALUE(_unSigned),
                    ""
                ),
                ""
            ),
            TRUE, ""
        ),

        IF(INDEX(_tryParse, 1, 1) = "", {#VALUE!, ""},
            LET(
                _year, _sign * INDEX(_tryParse, 1, 1),
                _ordinalDay, INDEX(_tryParse, 1, 2),
                IFS(
                    _ordinalDay = "", HSTACK(_year, ""),
                    IS_VALID_ORDINAL_DATE(_year, _ordinalDay, JulianCalendar),
                        HSTACK(_year, _ordinalDay),
                    TRUE,
                        HSTACK(_year, {#NUM!})
                )
            )
        )
    )
)
);
       

/*----------------------------------------------------------------------------------------------------------
PARSE_ISO_WEEK_DATE

Parses an ISO formatted week date into respective parts of year, week and weekday.

Output
------------------------------------------------------------------------------------------------------------
1 | integer | YearCE
2 | integer | ISO week
3 | integer | ISO week day

Parameters
------------------------------------------------------------------------------------------------------------
ISOWeekDate      | text   | Week date in ISO format ie. yyyy-Www-d
[JulianCalendar] | switch | Validate in the Julian proleptic calendar. Default is Gregorian
             |        | proleptic calendar.

Examples
------------------------------------------------------------------------------------------------------------
PARSE_ISO_WEEK_DATE("2023-W05-1")
Returns: {2023, 5, 1}
----------------------------------------------------------------------------------------------------------*/
PARSE_ISO_WEEK_DATE = LAMBDA(ISOWeekDate, [JulianCalendar],
IFS(
    ISOWeekDate = "", {"", "", ""},
    NOT(VALIDATE_CHARSET("+-0123456789W" & UNICHAR(8722), ISOWeekDate)), {#VALUE!, "", ""},
    TRUE, LET(
        _firstChar, LEFT(ISOWeekDate, 1),
        _isSigned, IFS(
            _firstChar = "+", TRUE,
            _firstChar = "-", TRUE,
            _firstChar = UNICHAR(8722), TRUE,
            TRUE, FALSE
        ),
        _sign, IFS(
            NOT(_isSigned), 1,
            _firstChar = "-", -1,
            _firstChar = UNICHAR(8722), -1,
            TRUE, 1
        ),
        _unSigned, IF(_isSigned,
            RIGHT(ISOWeekDate, LEN(ISOWeekDate) - 1),
            ISOWeekDate
        ),
        _len, LEN(_unSigned),
        _pattern, REPLACE_CHARS(_unSigned, "0123456789", "_"),
        _tryParse, IFS(
            _len >= 10, IFS(
                _pattern = RIGHT("_______________-W__-_", _len),
                HSTACK(
                    VALUE(LEFT(_unSigned, _len - 6)),
                    VALUE(MID(_unSigned, _len - 3, 2)),
                    VALUE(RIGHT(_unSigned, 1))
                ),
                _pattern = RIGHT("_______________-W__", _len),
                HSTACK(
                    VALUE(LEFT(_unSigned, _len - 4)),
                    VALUE(RIGHT(_unSigned, 2)),
                    ""
                ),
                _pattern = RIGHT("_______________W___", _len),
                HSTACK(
                    VALUE(LEFT(_unSigned, _len - 4)),
                    VALUE(MID(_unSigned, _len - 2, 2)),
                    VALUE(RIGHT(_unSigned, 1))
                ),
                _pattern = RIGHT("_______________W__", _len),
                HSTACK(
                    VALUE(LEFT(_unSigned, _len - 3)),
                    VALUE(RIGHT(_unSigned, 2)),
                    ""
                ),
                TRUE, ""
            ),
            _len >= 8, IFS(
                _pattern = RIGHT("_____-W__", _len),
                HSTACK(
                    VALUE(LEFT(_unSigned, _len - 4)),
                    VALUE(RIGHT(_unSigned, 2)),
                    ""
                ),
                _pattern = RIGHT("_____W___", _len),
                HSTACK(
                    VALUE(LEFT(_unSigned, _len - 4)),
                    VALUE(MID(_unSigned, _len - 2, 2)),
                    VALUE(RIGHT(_unSigned, 1))
                ),
                _pattern = RIGHT("______W__", _len),
                HSTACK(
                    VALUE(LEFT(_unSigned, _len - 3)),
                    VALUE(RIGHT(_unSigned, 2)),
                    ""
                ),
                TRUE, ""
            ),
            _len = 7, IF(
                _pattern = "____W__",
                HSTACK(
                    VALUE(LEFT(_unSigned, _len - 3)),
                    VALUE(RIGHT(_unSigned, 2)),
                    ""
                ),
                ""
            ),
            (_len >= 4) * (_len <= 5), IF(
                _pattern = RIGHT("_____", _len),
                HSTACK(
                    VALUE(_unSigned),
                    "",
                    ""
                ),
                ""
            ),
            TRUE, ""
        ),

        IF(INDEX(_tryParse, 1, 1) = "", {#VALUE!, "", ""},
            LET(
                _year, _sign * INDEX(_tryParse, 1, 1),
                _week, INDEX(_tryParse, 1, 2),
                IF(_week = "", HSTACK(_year, "", ""),
                    LET(
                        _invalidWeek, IFS(
                            _week < 1, TRUE,
                            _week <= 52, FALSE,
                            _week > 53, TRUE,
                            TRUE, WEEKS_IN_YEAR(_year, JulianCalendar) < 53
                        ),
                        IF(_invalidWeek, HSTACK(_year, {#NUM!}, ""),
                            LET(
                                _day, INDEX(_tryParse, 1, 3),
                                IF(_day = "", HSTACK(_year, _week, ""),
                                    IF((_day >= 1) * (_day <= 7),
                                        HSTACK(_year, _week, _day),
                                        HSTACK(_year, _week, {#NUM!})
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
PARSE_ISO_DATE

Parses an ISO formatted date into its respective parts.

Output
------------------------------------------------------------------------------------------------------------
1 | text    | Type of date:
|         |  C - calendar date
|         |  O - ordinal date
|         |  W - week date
|         |  Y - year only
2 | integer | Year
3 | integer | Month / Week
4 | integer | Day / Ordinal day / Week day

Parameters
------------------------------------------------------------------------------------------------------------
ISODate          | text   | Date in ISO format ie. yyyy-MM-dd
[JulianCalendar] | switch | Validate in the Julian proleptic calendar. Default is Gregorian
             |        | proleptic calendar.

Examples
------------------------------------------------------------------------------------------------------------
PARSE_ISO_DATE("2023-05-23")
Returns: {"C", 2023, 5, 23}

PARSE_ISO_DATE("1900-02-29", 1)
Returns: {"C", 2023, 2, 29} i.e. Feb 29, 1900 is valid in the Julian calendar

PARSE_ISO_DATE("2023-W12-2")
Returns: {"W", 2023, 12, 2}
----------------------------------------------------------------------------------------------------------*/
PARSE_ISO_DATE = LAMBDA(ISODate, [JulianCalendar],
IFS(
    ISODate = "", {"", "", "", ""},
    NOT(VALIDATE_CHARSET("+-0123456789W" & UNICHAR(8722), ISODate)), {#VALUE!, "", "", ""},
    IFERROR(FIND("W", ISODate), 0) > 0, HSTACK("W", PARSE_ISO_WEEK_DATE(ISODate, JulianCalendar)),
    TRUE, LET(
        _len, LEN(ISODate),
        _lastHyphen, FIND_NTH_CHAR("-", ISODate, -1),
        IFS(
            _len - _lastHyphen = 3, LET(
                _Odate, PARSE_ISO_ORDINAL_DATE(ISODate, JulianCalendar),
                HSTACK(
                    "O",
                    INDEX(_Odate, 1, 1),
                    "",
                    INDEX(_Odate, 1, 2)
                )
            ),
            _len - _lastHyphen = 2,
            HSTACK("C", PARSE_ISO_CALENDAR_DATE(ISODate, JulianCalendar)),
            TRUE, LET(
                _firstChar, LEFT(ISODate, 1),
                _isSigned, IFS(
                    _firstChar = "+", TRUE,
                    _firstChar = "-", TRUE,
                    _firstChar = UNICHAR(8722), TRUE,
                    TRUE, FALSE
                ),
                _sign, IFS(
                    NOT(_isSigned), 1,
                    _firstChar = "-", -1,
                    _firstChar = UNICHAR(8722), -1,
                    TRUE, 1
                ),
                _unSigned, IF(_isSigned,
                    RIGHT(ISODate, LEN(ISODate) - 1),
                    ISODate
                ),
                _len, LEN(_unSigned),
                _type, IFS(
                    _len >= 8, "C",
                    _len = 7, "O",
                    (_len >= 4) * (_len <= 5), "Y",
                    TRUE, ""
                ),
                IFS(
                    _type = "", {#VALUE!, "", "", ""},
                    _type = "O", LET(
                        _Odate, PARSE_ISO_ORDINAL_DATE(ISODate, JulianCalendar),
                        IF(ISERROR(INDEX(_Odate, 1, 1)), {#VALUE!, "", "", ""},
                            HSTACK("O",
                                INDEX(_Odate, 1, 1),
                                "",
                                INDEX(_Odate, 1, 2)
                            )
                        )
                    ),
                    TRUE, LET(
                        _Cdate, PARSE_ISO_CALENDAR_DATE(ISODate, JulianCalendar),
                        IF(ISERROR(INDEX(_Cdate, 1, 1)), {#VALUE!, "", "", ""},
                            HSTACK(_type, _Cdate)
                        )
                    )
                )
            )
        )
    )
)
);



/*----------------------------------------------------------------------------------------------------------
PARSE_ISO_DATETIME

Parses an ISO formatted date and time into respective date parts, time, and time zone offset from UTC.
Providing a time zone offset on its own is invalid for this function.

Output
------------------------------------------------------------------------------------------------------------
1 | integer         | Year
2 | integer         | Month
3 | integer         | Day
4 | decimal [0..1]  | Time
5 | decimal         | Time zone offset from UTC
| [-0.625..0.625] | 

Parameters
------------------------------------------------------------------------------------------------------------
ISODateTime      | text   | Date time in ISO format ie. yyyy-MM-ddThh:mm:ss+hh:mm
[NoMixedFormat]  | switch | Validate no mix of basic and extended formats. eg. yyyyMMddThh:mm 
[JulianCalendar] | switch | Validate in the Julian proleptic calendar. Default is Gregorian
             |        | proleptic calendar.

Examples
------------------------------------------------------------------------------------------------------------
PARSE_ISO_DATETIME("2023-05-23")
Returns: {2023, 5, 23, "", ""}

PARSE_ISO_DATETIME("2023-05-23T06:00")
Returns: {2023, 5, 23, 0.25, ""}

PARSE_ISO_DATETIME("T12:00")
Returns: {"", "", "", 0.5, ""}

PARSE_ISO_DATETIME("T12:0006:00")
Returns: {"", "", "", 0.5, -0.25}

PARSE_ISO_DATETIME("2023-05-23T+09:00")
Returns: {2023, 5, 23, "", 0.375}
----------------------------------------------------------------------------------------------------------*/
PARSE_ISO_DATETIME = LAMBDA(ISODateTime, [AllowMixedStyles], [JulianCalendar],
IFS(
    ISODateTime = "", {"", "", "", "", ""},
    NOT(VALIDATE_CHARSET("+,-.0123456789:TWZ" & UNICHAR(8722), ISODateTime)), {#VALUE!, "", "", "", ""},
    TRUE, LET(
        _Tpos, IFERROR(FIND("T", ISODateTime), 0),
        _parts, IF(_Tpos = 0, 
            HSTACK(ISODateTime, "", ""),
            LET(
                _len, LEN(ISODateTime),
                _datePart, LEFT(ISODateTime, _Tpos - 1),
                _TZpos, FIND_NTH_CHAR("Z+-" & UNICHAR(8722), ISODateTime, 1, 0, _Tpos + 1),
                IFS(
                    _TZpos = 0,
                    HSTACK(
                        _datePart,
                        RIGHT(ISODateTime, _len - _Tpos + 1),
                        ""
                    ),
                    _TZpos = _Tpos + 1,
                    HSTACK(
                        _datePart,
                        "",
                        RIGHT(ISODateTime, _len - _TZpos + 1)
                    ),
                    TRUE,
                    HSTACK(
                        _datePart,
                        MID(ISODateTime, _Tpos, _TZPos - _Tpos),
                        RIGHT(ISODateTime, _len - _TZpos + 1)
                    )
                )
            )
        ),
        _failStyleCheck, IF(N(AllowMixedStyles) <> 0, FALSE,
            LET(
                _fmtDate, IFS(
                    INDEX(_parts, 1, 1) = "", 3,
                    IFERROR(FIND("-", INDEX(_parts, 1, 1), 5), 0) > 0, 2,
                    TRUE, 1
                ),
                _fmtTime, IFS(
                    INDEX(_parts, 1, 2) = "", 3,
                    LEN(INDEX(_parts, 1, 2)) = 3, 3,
                    IFERROR(FIND(":", INDEX(_parts, 1, 2), 4), 0) > 0, 2,
                    TRUE, 1
                ),
                _fmtTZO, IFS(
                    INDEX(_parts, 1, 3) = "", 3,
                    CODE(INDEX(_parts, 1, 3)) = 90, 3,
                    LEN(INDEX(_parts, 1, 3)) = 3, 3,
                    IFERROR(FIND(":", INDEX(_parts, 1, 3), 4), 0) > 0, 2,
                    TRUE, 1
                ),
                IFS(
                    BITAND(_fmtDate, _fmtTime) = 0, TRUE,
                    BITAND(_fmtDate, _fmtTZO) = 0, TRUE,
                    BITAND(_fmtTime, _fmtTZO) = 0, TRUE,
                    TRUE, FALSE
                )
            )
        ),
        IF(_failStyleCheck, {#N/A, "", "", "", ""},
            LET(
                _time, PARSE_ISO_TIME(INDEX(_parts, 1, 2)),
                _tzo, PARSE_ISO_TZO(INDEX(_parts, 1, 3)),
                IF(INDEX(_parts, 1, 1) = "",
                    IF((_time = "") * (_tzo <> ""), {#VALUE!, "", "", "", ""},
                        HSTACK("", "", "", _time, _tzo)
                    ),
                    LET(
                        _date, PARSE_ISO_CALENDAR_DATE(INDEX(_parts, 1, 1), JulianCalendar),
                        HSTACK(_date, _time, _tzo)
                    )
                )
            )
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
PARSE_LITERARY_YEAR

Returns a number representing the year relative to the common era from a given literary year.

Output
------------------------------------------------------------------------------------------------------------
1 | integer | YearCE. Note that 1 BC = 0 CE, 2 BC = -1 CE

Parameters
------------------------------------------------------------------------------------------------------------
LiteraryYear | text | Literary year
----------------------------------------------------------------------------------------------------------*/
PARSE_LITERARY_YEAR = LAMBDA(LiteraryYear,
IF(LiteraryYear = "", "",
    IF(NOT(VALIDATE_CHARSET(" -+0123456789BCE" & UNICHAR(8722), LiteraryYear)), {#VALUE!},
        LET(
            fnYearValue, LAMBDA(_text,
                LET(
                    _char1, LEFT(_text, 1),
                    _sign, IFS(
                        _char1 = "+", 1,
                        _char1 = "-", -1,
                        UNICODE(_char1) = 8722, -1,
                        TRUE, ""
                    ),
                    IF(_sign = "",
                        INT(VALUE(_text)),
                        _sign * INT(VALUE(RIGHT(_text, LEN(_text) -1)))
                    )
                )
            ),

            _litYear, SUBSTITUTE(SUBSTITUTE(LiteraryYear, ",", ""), " ", ""),
            _yearCE, IFS(
                RIGHT(_litYear, 3) = "BCE",
                    LET(
                        _sYear, LEFT(_litYear, LEN(_litYear) - 3),
                        1 - fnYearValue(_sYear)
                    ),
                RIGHT(_litYear, 2) = "CE",
                    LET(
                        _sYear, LEFT(_litYear, LEN(_litYear) - 2),
                        fnYearValue(_sYear)
                    ),
                TRUE, fnYearValue(_litYear)
            ),
            
            IFERROR(_yearCE, {#VALUE!})
        )
    )
)
);

/*----------------------------------------------------------------------------------------------------------
PARSE_LITERARY_DATE

Parses a literary date into respective parts of year, month, day and time of day.

Output
------------------------------------------------------------------------------------------------------------
1 | integer         | Year
2 | integer [1..12] | Month
3 | integer [1..31] | Day
4 | decimal [0..1]  | Time

Parameters
------------------------------------------------------------------------------------------------------------
LiteraryDate | text | Literary date and time

Examples
------------------------------------------------------------------------------------------------------------
PARSE_LITERARY_DATE("Feb 25, 2014, 6:00")
Returns: {2014, 2, 25, 0.25}

PARSE_LITERARY_DATE("Dec 31, 2023, 24:00")
Returns: {2023, 12, 31, 1}

PARSE_LITERARY_DATE("Feb 25")
Returns: {"" , 2, 25, ""}
----------------------------------------------------------------------------------------------------------*/
PARSE_LITERARY_DATE = LAMBDA(LiteraryDate,
IF(LiteraryDate = "", {"", "", "", ""},
    LET(
        fnParseTime, LAMBDA(_timePart,
            LET(
                _tryTime, DATEVALUE(_timePart) + TIMEVALUE(_timePart),
                IFS(
                    ISERROR(_tryTime), "",
                    _tryTime > 1, {#NUM!},
                    TRUE, _tryTime
                )
            )
        ),

        fnParseDay, LAMBDA(_dayPart, _year, _month,
            LET(
                _day, INT(VALUE(_dayPart)),
                IFS(
                    _day <= 0, {#NUM!},
                    _day <= DAYS_IN_MONTH(_month, _year, _year <= 1582), _day,
                    TRUE, {#NUM!}
                )
            )
        ),

        _parts, TRIM(TEXTSPLIT(LiteraryDate, ",")),
        _cols, COLUMNS(_parts),
        IFS(_cols = 1,
            LET(
                _part1, INDEX(_parts, 1, 1),
                _spacePos, IFERROR(FIND(" ", _part1), 0),
                IF(_spacePos = 0, {#VALUE!, "", "", ""},
                    LET(
                        _month, PARSE_MONTH(LEFT(_part1, _spacePos - 1)),
                        _daysInMonth, DAYS_IN_MONTH(_month, 2000),
                        _remain, MID(_part1, _spacePos + 1, LEN(_part1) - _spacePos),
                        _denotedYear, IFERROR(FIND("C", _remain), 0) > 0,
                        _val, IF(_denotedYear, PARSE_LITERARY_YEAR(_remain),
                            INT(VALUE(_remain))
                        ), 
                        _day, IFS(_denotedYear, "",
                            _val <= 0, "",
                            _val <= _daysInMonth, _val,
                            TRUE, ""
                        ),
                        _year, IFS(_denotedYear, _val,
                            _val <= 0, _val,
                            _val <= _daysInMonth, "",
                            TRUE, _val
                        ),
                        HSTACK(_year, _month, _day, "")
                    )
                )
            ),
            _cols = 2,
            LET(
                _p1, INDEX(_parts, 1, 1),
                _spacePos, IFERROR(FIND(" ", _p1), 0),
                IF(_spacePos = 0, {#VALUE!, "", "", ""},
                    LET(
                        _month, PARSE_MONTH(LEFT(_p1, _spacePos - 1)),
                        _p2, INDEX(_parts, 1, 2),
                        _time, fnParseTime(_p2),
                        _year, IF(NOT(ISNUMBER(_time)), PARSE_LITERARY_YEAR(_p2), ""),
                        _dayPart, MID(_p1, _spacePos + 1, LEN(_p1) - _spacePos),
                        _day, fnParseDay(_dayPart, _year, _month),
                        HSTACK(_year, _month, _day, _time)
                    )
                )
            ),
            _cols = 3,
            LET(
                _year, PARSE_LITERARY_YEAR(INDEX(_parts, 1, 2)),
                _time, fnParseTime(INDEX(_parts, 1, 3)),
                _p1, INDEX(_parts, 1, 1),
                _spacePos, IFERROR(FIND(" ", _p1), 0),
                IF(_spacePos = 0, {#VALUE!, "", "", ""},
                    LET(
                        _month, PARSE_MONTH(LEFT(_p1, _spacePos - 1)),
                        _dayPart, MID(_p1, _spacePos + 1, LEN(_p1) - _spacePos),
                        _day, fnParseDay(_dayPart, 2000, _month),
                        HSTACK(_year, _month, _day, _time)
                    )
                )
            ),
            TRUE, {#VALUE!, "", "", ""}
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
PARSE_US_DATE

Parses a US formated date into respective parts of year, month, day and time of day.

Output
------------------------------------------------------------------------------------------------------------
1 | integer         | Year
2 | integer [1..12] | Month
3 | integer [1..31] | Day
4 | decimal [0..1)  | Time

Parameters
------------------------------------------------------------------------------------------------------------
USDate | text | Date in US format ie. MM/dd/yyyy hh:mm:ss

Examples
------------------------------------------------------------------------------------------------------------
PARSE_US_DATE("1/25/2014 6:00")
Returns: {2014, 1, 25, 0.25}

PARSE_US_DATE("12/31/2023 24:00")
Returns: {2023, 12, 31, 1}
----------------------------------------------------------------------------------------------------------*/
PARSE_US_DATE = LAMBDA(USDate,
IFS(
    USDate = "", {"", "", "", ""},
    NOT(VALIDATE_CHARSET(" ,-./0123456789:AMPTamp_" & UNICHAR(8722), USDate)), {#VALUE!},
    TRUE, LET(
        fnYearValue, LAMBDA(_text,
            LET(
                _char1, LEFT(_text, 1),
                _sign, IFS(
                    _char1 = "+", 1,
                    _char1 = "-", -1,
                    UNICODE(_char1) = 8722, -1,
                    TRUE, ""
                ),
                IF(_sign = "",
                    INT(VALUE(_text)),
                    _sign * INT(VALUE(RIGHT(_text, LEN(_text) -1)))
                )
            )
        ),

        _pos1, FIND_NTH_CHAR(",./-_", USDate, 1),
        _pos2, FIND_NTH_CHAR(",./-_", USDate, 2),
        _pos3, IF(_pos2 = 0, 0, FIND_NTH_CHAR(",./-_T ", USDate, 1, 0, _pos2 + 2)),
        _pos4, IF(_pos3 = 0, 0, FIND_NTH_CHAR("0123456789", USDate, 1, 0, MAX(_pos2, _pos3) + 1)),
        _month, IF(_pos1 = 0, {#VALUE!},
            INT(VALUE(LEFT(USDate, _pos1 - 1)))
        ),
        _day, IF(_pos2 = 0, {#VALUE!},
            INT(VALUE(MID(USDate, _pos1 + 1, _pos2 - _pos1 - 1)))
        ),
        _year, fnYearValue(
            IF(_pos3 = 0,
                RIGHT(USDate, LEN(USDate) - _pos2),
                MID(USDate, _pos2 + 1, _pos3 - _pos2 - 1)
            )
        ),
        _time, IF(_pos4 = 0, "",
            LET(
                _timePart, RIGHT(USDate, LEN(USDate) - _pos4 + 1),
                _timeVal, DATEVALUE(_timePart) + TIMEVALUE(_timePart),
                IF(_timeVal >= 1, {#NUM!}, _timeVal)
            )
        ),
        HSTACK(_year, _month, _day, _time)
    )
)
);


/*----------------------------------------------------------------------------------------------------------
PARSE_MIL_DTG

Parses a date-time group in the format used by US Military message traffic, into respective parts of year,
month, day, time of day and time zone offset in minutes.

Output
------------------------------------------------------------------------------------------------------------
1 | integer [1951..2050] | Year
2 | integer [1..12]      | Month
3 | integer [1..31]      | Day
4 | decimal [0..1)       | Time
5 | decimal [-900..900]  | Time zone offset minutes

Parameters
------------------------------------------------------------------------------------------------------------
DTG | text | Date-time group in US Military format ie. ddHHmmssZmmmYY

Examples
------------------------------------------------------------------------------------------------------------
PARSE_MIL_DTG("12 15 30 45 B MAY 23")
Returns: {2023, 5, 12, 0.77118055, 120}

PARSE_MIL_DTG("05064515KJUN00")
Returns: {2000, 6, 5, 0.281423611, 600}

PARSE_MIL_DTG("150600Z")
Returns: {"", "", 15, 0.25, 0}
----------------------------------------------------------------------------------------------------------*/
PARSE_MIL_DTG = LAMBDA(DTG,
IF(DTG = "", {"", "", "", "", ""},
    LET(
        _DTG, SUBSTITUTE(DTG, " ", ""),
        IF(NOT(VALIDATE_CHARSET("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ", _DTG)), {#VALUE!, "", "", "", ""},
            LET(
                fnYear, LAMBDA(_sYear,
                    LET(
                        _yy, VALUE(_sYear),
                        IF(_yy < 51, 2000 + _yy, 1900 + _yy)
                    )
                ),

                fnTime, LAMBDA(_hour, _minute, _second,
                    IF(NOT(IS_VALID_TIME_OF_DAY(_hour, _minute, _second, 0)), {#NUM!},
                        TIMESPAN(1, 0, _hour, _minute, _second)
                    )
                ),

                fnParseTZ, LAMBDA(_tzChar,
                    LET(
                        _code, CODE(_tzChar) - 64,
                        IFS(
                            _code = 26, 0, // Z = UTC
                            _code = 10, "", // J = Local Time
                            _code <= 0, {#VALUE!},
                            _code <= 9, _code / 24, // ABCDEFGHI -> +1..+9
                            _code <= 13, (_code - 1) / 24,  // KLM -> +10..+12
                            _code <= 25, (13 - _code) / 24, // NOPQRSTUVWXY -> -1..-12
                            TRUE, {#VALUE!}
                        )
                    )
                ),

                fnParseFull, LAMBDA(_DTG,
                    LET(
                        _day, VALUE(LEFT(_DTG, 2)),
                        _month, PARSE_MONTH(MID(_DTG, 10, 3)),
                        _year, fnYear(RIGHT(_DTG, 2)),
                        IF(NOT(IS_VALID_DATE(_year, _month, _day, 0)), {#VALUE!, "", "", "", ""},
                            LET(
                                _hour, VALUE(MID(_DTG, 3, 2)),
                                _minute, VALUE(MID(_DTG, 5, 2)),
                                _second, VALUE(MID(_DTG, 7, 2)),
                                _time, fnTime(_hour, _minute, _second),
                                _tz, fnParseTZ(MID(_DTG, 9, 1)),
                                HSTACK(
                                    _year,
                                    _month,
                                    _day,
                                    _time,
                                    _tz
                                )
                            )
                        )
                    )
                ),

                fnParseShort, LAMBDA(_DTG,
                    LET(
                        _day, VALUE(LEFT(_DTG, 2)),
                        _month, PARSE_MONTH(MID(_DTG, 8, 3)),
                        _year, fnYear(RIGHT(_DTG, 2)),
                        IF(NOT(IS_VALID_DATE(_year, _month, _day, 0)), {#VALUE!, "", "", "", ""},
                            LET(
                                _hour, VALUE(MID(_DTG, 3, 2)),
                                _minute, VALUE(MID(_DTG, 5, 2)),
                                _time, fnTime(_hour, _minute, 0),
                                _tz, fnParseTZ(MID(_DTG, 7, 1)),
                                HSTACK(
                                    _year,
                                    _month,
                                    _day,
                                    _time,
                                    _tz
                                )
                            )
                        )
                    )
                ),

                fnParsePlan, LAMBDA(_DTG,
                    LET(
                        _day, VALUE(LEFT(_DTG, 2)),
                        _hour, VALUE(MID(_DTG, 3, 2)),
                        _minute, VALUE(MID(_DTG, 5, 2)),
                        _time, fnTime(_hour, _minute, 0),
                        _tz, fnParseTZ(MID(_DTG, 7, 1)),
                        HSTACK(
                            "",
                            "",
                            _day,
                            _time,
                            _tz
                        )
                    )
                ),

                _len, LEN(_DTG),
                _fmt, IFS(_len = 14, 1, 
                    _len = 12, 2,
                    _len = 7, 3,
                    TRUE, 0
                ),
                IF(_fmt = 0, {#VALUE!, "", "", "", ""},
                    IFS(
                        _fmt = 1, fnParseFull(_DTG),
                        _fmt = 2, fnParseShort(_DTG),
                        _fmt = 3, fnParsePlan(_DTG)
                    )
                )
            )
        )
    )
)
);













/*##########################################################################################################
# TEXT                                                                                                     #
##########################################################################################################*/


/*----------------------------------------------------------------------------------------------------------
WEEKDAY_NAME

Returns name of an ISO day of week number as text.

Output
------------------------------------------------------------------------------------------------------------
1 | text | Weekday

Parameters
------------------------------------------------------------------------------------------------------------
ISOWeekDay             | integer [1..7] | ISO day of week number
[Short]                | switch         | Return short format Mon..Sun
[InternationalEnglish] | switch         | International English instead of local language set in Excel
----------------------------------------------------------------------------------------------------------*/
WEEKDAY_NAME = LAMBDA(ISOWeekDay, [Short], [InternationalEnglish],
IFS(
    ISOWeekDay = "", "",
    NOT(ISNUMBER(ISOWeekDay)), {#VALUE!},
    TRUE, LET(
        _useShort, N(Short) <> 0,
        _useLocalLang, N(InternationalEnglish) = 0,
        _isoDoW, MOD(INT(ISOWeekDay) - 1, 7) + 1, 
        IF(_useLocalLang,
            LET(
                _y2krefDay, 36527 + _isoDoW,
                _fmt, IF(_useShort, "ddd", "dddd"),
                TEXT(_y2krefDay, _fmt)
            ),
            IF(
                _useShort,
                CHOOSE(_isoDoW,
                    "Mon",
                    "Tue",
                    "Wed",
                    "Thu",
                    "Fri",
                    "Sat",
                    "Sun"
                ),
                CHOOSE(_isoDoW,
                    "Monday",
                    "Tuesday",
                    "Wednesday",
                    "Thursday",
                    "Friday",
                    "Saturday",
                    "Sunday"
                )
            )
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
MONTH_NAME

Returns a month as text.

Output
------------------------------------------------------------------------------------------------------------
1 | text | Month name

Parameters
------------------------------------------------------------------------------------------------------------
Month                  | integer [1..12] | Month
[Short]                | switch          | Return short format Jan..Dec
[InternationalEnglish] | switch          | International English instead of local language set in Excel
----------------------------------------------------------------------------------------------------------*/
MONTH_NAME = LAMBDA(Month, [Short], [InternationalEnglish],
IFS(
    Month = "", "",
    NOT(ISNUMBER(Month)), #VALUE!,
    TRUE, LET(
        _useShort, N(Short) <> 0,
        _useLocalLang, N(InternationalEnglish) = 0,
        _month, INT(Month),
        IF(_useLocalLang,
            LET(
                _dayOfMonth, DATE(2000, _month, 1),
                _fmt, IF(_useShort, "MMM", "MMMM"),
                TEXT(_dayOfMonth, _fmt)
            ),
            IF(
                _useShort,
                INDEX(
                    {
                        "Jan";
                        "Feb";
                        "Mar";
                        "Apr";
                        "May";
                        "Jun";
                        "Jul";
                        "Aug";
                        "Sep";
                        "Oct";
                        "Nov";
                        "Dec"
                    },
                    _month
                ),
                INDEX(
                    {
                        "January";
                        "February";
                        "March";
                        "April";
                        "May";
                        "June";
                        "July";
                        "August";
                        "September";
                        "October";
                        "November";
                        "December"
                    },
                    _month
                )
            )
        )
    )
)
);






FORMAT_TIMESPAN_ISO = LAMBDA(TimeSpan, MostSig, LeastSig, Options,
LET(
    _maxPrecision, 9,
    _defaultPrecision, 0,
    _lowestSig, 0,
    _fixed, IFERROR(FIND("~", Options), 0) = 0,
    _truncate, IFERROR(FIND("<", Options), 0) > 0,
    _padLeading, IFERROR(FIND("P", Options), 0) > 0,
    
    // Precision at which to resolve the TimeSpan
    // If fixed style and not provided then set to default precision
    _rPrecision, IF(_fixed * (LeastSig = ""), _defaultPrecision, LeastSig),
    _rTimeSpan, RESOLVE_TIMESPAN(TimeSpan, _rPrecision, _truncate),
        
    // Display at precision, fixed style remains the same
    // if floating style allow to fall back to MostSig
    _showPrecision, IF(_fixed, _rPrecision,
        LET(
            _hasPrecision, TIME_SIGNIFICANCE(
                INDEX(_rTimeSpan, 1, 1),
                INDEX(_rTimeSpan, 1, 3),
                INDEX(_rTimeSpan, 1, 4),
                INDEX(_rTimeSpan, 1, 5)
            ),
            MAX(IF(MostSig = "", -3, MostSig), MIN(IF(_rPrecision = "", _maxPrecision, _rPrecision), _hasPrecision, _maxPrecision))
        )
    ),

    // If floating style, allow high end to float if MostSig not provided
    _high, IFS(
        _fixed, IF(MostSig = "", -3, MostSig),
        MostSig <> "", MostSig,
        TRUE, LET(
            _float, IFS(
                INDEX(_rTimeSpan, 1, 2) > 0, -3,
                INDEX(_rTimeSpan, 1, 3) > 0, -2,
                INDEX(_rTimeSpan, 1, 4) > 0, -1,
                TRUE, 0
            ),
            MIN(_float, _showPrecision, _lowestSig)
        )
    ),

    // Translate high significance to resolved timespan column [2..5]
    _leadCol, _high + 5,
    // Number of columns to display from resolved timespan [1..4]
    _n, MIN(_showPrecision, 0) - _high + 1,
    
    // Corresponding delims
    _prefix, CHOOSECOLS(
        {"", "T", "", ""},
        SEQUENCE(1, _n, 2 - N(_leadCol = 2))
    ),
    _suffix, CHOOSECOLS(
        {"D", "H", "M", "S"},
        SEQUENCE(1, _n, _leadCol - 1)
    ),
    
    _numFmt, IF(_padLeading, "00", "0"),
    _lastFmt, IF(_showPrecision <= 0, _numFmt,
        _numFmt & LEFT(".000000000", _showPrecision + 1)
    ),
    
    // General formatter
    fnFormat1(_rTimeSpan,
        HSTACK(
            _leadCol,
            _n,
            "P",
            _numFmt,
            _numFmt,
            _lastFmt,
            _prefix,
            _suffix
        )
    )
)
);


FORMAT_TIMESPAN_EURO = LAMBDA(TimeSpan, MostSig, LeastSig, Options,
LET(
    _maxPrecision, 9,
    _defaultPrecision, 0,
    _lowestSig, -2,
    _fixed, IFERROR(FIND("~", Options), 0) = 0,
    _truncate, IFERROR(FIND("<", Options), 0) > 0,
    _signPositive, IFERROR(FIND("+", Options), 0) > 0,
    _padLeading, IFERROR(FIND("P", Options), 0) > 0,
    
    // Precision at which to resolve the TimeSpan
    // If fixed style and not provided then set to default precision
    _rPrecision, IF(_fixed * (LeastSig = ""), _defaultPrecision, LeastSig),
    _rTimeSpan, RESOLVE_TIMESPAN(TimeSpan, _rPrecision, _truncate),
        
    // Display at precision, fixed style remains the same
    // if floating style allow to fall back to MostSig
    _showPrecision, IF(_fixed, _rPrecision,
        LET(
            _hasPrecision, TIME_SIGNIFICANCE(
                INDEX(_rTimeSpan, 1, 1),
                INDEX(_rTimeSpan, 1, 3),
                INDEX(_rTimeSpan, 1, 4),
                INDEX(_rTimeSpan, 1, 5)
            ),
            MAX(IF(MostSig = "", -3, MostSig), MIN(IF(_rPrecision = "", _maxPrecision, _rPrecision), _hasPrecision, _maxPrecision))
        )
    ),

    // Resolve sign
    _sign, IF(INDEX(_rTimeSpan, 1, 1) < 0,
        UNICHAR(8722),
        IF(_signPositive, "+", "")
    ),

    // If floating style, allow high end to float if MostSig not provided
    _high, IFS(
        _fixed, IF(MostSig = "", -3, MostSig),
        MostSig <> "", MostSig,
        TRUE, LET(
            _float, IFS(
                INDEX(_rTimeSpan, 1, 2) > 0, -3,
                INDEX(_rTimeSpan, 1, 3) > 0, -2,
                INDEX(_rTimeSpan, 1, 4) > 0, -1,
                TRUE, 0
            ),
            MIN(_float, _showPrecision, _lowestSig)
        )
    ),

    // Translate high significance to resolved timespan column [2..5]
    _leadCol, _high + 5,
    // Number of columns to display from resolved timespan [1..4]
    _n, MIN(_showPrecision, 0) - _high + 1,
    
    // Corresponding delims
    _prefix, TAKE({"", "", "", ""}, 1, _n), 
    _suffix, CHOOSECOLS(
        {"d", "h", "'", """"},
        SEQUENCE(1, _n, _leadCol - 1)
    ),
    
    _leadFmt, IF(_padLeading, "00", "0"),
    _midFmt, "00",
    _lastFmt, IF(_showPrecision < 0, "00",
        LET(
            _useSecFmt, IF(_leadCol = 5, _leadFmt, _midFmt),
            IF(_showPrecision = 0, _useSecFmt,
                _useSecFmt & LEFT(".000000000", _showPrecision + 1)
            )
        )
    ),
    
    // General formatter
    fnFormat1(_rTimeSpan,
        HSTACK(
            _leadCol,
            _n,
            _sign,
            _leadFmt,
            _midFmt,
            _lastFmt,
            _prefix,
            _suffix
        )
    )
)
);


FORMAT_TIMESPAN_LITERARY = LAMBDA(TimeSpan, MostSig, LeastSig, Options,
LET(
    _maxPrecision, 9,
    _defaultPrecision, 0,
    _lowestSig, 0,
    _fixed, 0,
    _truncate, 1,
    _padLeading, 0,
    
    // Precision at which to resolve the TimeSpan
    // If fixed style and not provided then set to default precision
    _rPrecision, IF(_fixed * (LeastSig = ""), _defaultPrecision, LeastSig),
    _rTimeSpan, RESOLVE_TIMESPAN(TimeSpan, _rPrecision, _truncate),
        
    // Display at precision, fixed style remains the same
    // if floating style allow to fall back to MostSig
    _showPrecision, IF(_fixed, _rPrecision,
        LET(
            _hasPrecision, TIME_SIGNIFICANCE(
                INDEX(_rTimeSpan, 1, 1),
                INDEX(_rTimeSpan, 1, 3),
                INDEX(_rTimeSpan, 1, 4),
                INDEX(_rTimeSpan, 1, 5)
            ),
            MAX(IF(MostSig = "", -3, MostSig), MIN(IF(_rPrecision = "", _maxPrecision, _rPrecision), _hasPrecision, _maxPrecision))
        )
    ),

    // If floating style, allow high end to float if MostSig not provided
    _high, IFS(
        _fixed, IF(MostSig = "", -3, MostSig),
        MostSig <> "", MostSig,
        TRUE, LET(
            _float, IFS(
                INDEX(_rTimeSpan, 1, 2) > 0, -3,
                INDEX(_rTimeSpan, 1, 3) > 0, -2,
                INDEX(_rTimeSpan, 1, 4) > 0, -1,
                TRUE, 0
            ),
            MIN(_float, _showPrecision, _lowestSig)
        )
    ),

    // Translate high significance to resolved timespan column [2..5]
    _leadCol, _high + 5,
    // Number of columns to display from resolved timespan [1..4]
    _n, MIN(_showPrecision, 0) - _high + 1,
    
    // Corresponding delims
    _prefix, CHOOSECOLS(
        {"", "T", "", ""},
        SEQUENCE(1, _n, 2 - N(_leadCol = 2))
    ),
    _suffix, CHOOSECOLS(
        {" days", " hours", " minutes", "seconds"},
        SEQUENCE(1, _n, _leadCol - 1)
    ),
    
    _numFmt, IF(_padLeading, "00", "0"),
    _lastFmt, IF(_showPrecision <= 0, _numFmt,
        _numFmt & LEFT(".000000000", _showPrecision + 1)
    ),
    
    // General formatter
    fnFormat1(_rTimeSpan,
        HSTACK(
            _leadCol,
            _n,
            "P",
            _numFmt,
            _numFmt,
            _lastFmt,
            _prefix,
            _suffix
        )
    )
)
);


fnFmtProvider_E = LAMBDA(_rTimeSpan, _fixed, _mostSig, _precision, _options,
LET(
    _signPositive, IFERROR(FIND("+", _options), 0) > 0,
    _padLeading, IFERROR(FIND("P", _options), 0) > 0,

    _sign, IF(INDEX(_rTimeSpan, 1, 1) < 0,
        UNICHAR(8722),
        IF(_signPositive, "+", "")
    ),

    _high, IFS(
        _fixed, IF(_mostSig = "", -3, _mostSig),
        _mostSig <> "", _mostSig,
        TRUE, LET(
            _float, IFS(
                INDEX(_rTimeSpan, 1, 2) > 0, -3,
                INDEX(_rTimeSpan, 1, 3) > 0, -2,
                INDEX(_rTimeSpan, 1, 4) > 0, -1,
                TRUE, 0
            ),
            MIN(_float, _precision, 0)
        )
    ),

    _leadCol, _high + 5,
    _n, MIN(_precision, 0) - _high + 1,
    
    _delims, CHOOSECOLS(
        {"d", "h", "'", """"},
        SEQUENCE(1, _n, _leadCol - 1)
    ),
    
    _leadFmt, IF(_padLeading, "00", "0"),
    _midFmt, "00",
    _lastFmt, IF(_precision < 0, "00",
        LET(
            _useSecFmt, IF(_leadCol = 5, _leadFmt, _midFmt),
            IF(_precision = 0, _useSecFmt,
                _useSecFmt & LEFT(".000000000", _precision + 1)
            )
        )
    ),
    
    HSTACK(
        _leadCol,
        _n,
        _sign,
        _leadFmt,
        _midFmt,
        _lastFmt,
        _delims
    )
)
);


fnFmtProvider_L = LAMBDA(_rTimeSpan, _fixed, _mostSig, _precision, _options,
LET(
    _signPositive, IFERROR(FIND("+", _options), 0) > 0,
    
    _sign, IF(INDEX(_rTimeSpan, 1, 1) < 0,
        UNICHAR(8722) & " ",
        IF(_signPositive, "+ ", "")
    ),

    _high, IF(_mostSig <> "", _mostSig,
        LET(
            _float, IFS(
                INDEX(_rTimeSpan, 1, 2) > 0, -3,
                INDEX(_rTimeSpan, 1, 3) > 0, -2,
                INDEX(_rTimeSpan, 1, 4) > 0, -1,
                TRUE, 0
            ),
            MIN(_float, _precision, 0)
        )
    ),

    _leadCol, _high + 5,
    _n, MIN(_precision, 0) - _high + 1,
    
    _delims, CHOOSECOLS(
        {" days ", " hours ", " minutes ", " seconds "},
        SEQUENCE(1, _n, _leadCol - 1)
    ),
    
    _numFmt, "0",
    _lastFmt, IF(_precision <= 0, _numFmt,
        _numFmt & LEFT(".000000000", _precision + 1)
    ),
    
    HSTACK(
        _leadCol,
        _n,
        _sign,
        _numFmt,
        _numFmt,
        _lastFmt,
        _delims
    )
)
);


fnFormat1 = LAMBDA(_rTimeSpan, _fmtProvider,
LET(
    _leadCol, INDEX(_fmtProvider, 1, 1),
    _n, INDEX(_fmtProvider, 1, 2),
    _designator, INDEX(_fmtProvider, 1, 3),
    _leadFmt, INDEX(_fmtProvider, 1, 4),
    _midFmt, INDEX(_fmtProvider, 1, 5),
    _lastFmt, INDEX(_fmtProvider, 1, 6),
    _prefix, CHOOSECOLS(_fmtProvider, SEQUENCE(1, _n, 7)),
    _suffix, CHOOSECOLS(_fmtProvider, SEQUENCE(1, _n, 7 + _n)),
    
    _leadElement, IFS(
        _leadCol = 2, INDEX(_rTimeSpan, 1, 2),
        _leadCol = 3, (INDEX(_rTimeSpan, 1, 2) * 24) + INDEX(_rTimeSpan, 1, 3),
        _leadCol = 4, (INDEX(_rTimeSpan, 1, 2) * 1440) + (INDEX(_rTimeSpan, 1, 3) * 60) + INDEX(_rTimeSpan, 1, 4),
        _leadCol = 5, (INDEX(_rTimeSpan, 1, 2) * 86400) + (INDEX(_rTimeSpan, 1, 3) * 3600) + (INDEX(_rTimeSpan, 1, 4) * 60) + INDEX(_rTimeSpan, 1, 5)
    ),
        
    _elements, IF(_n = 1, _leadElement,
        LET(
            _cols, SEQUENCE(1, _n - 1, _leadCol + 1),
            HSTACK(_leadElement, CHOOSECOLS(_rTimeSpan, _cols))
        )
    ),

    _fmts, IFS(
        _n = 1, HSTACK(_lastFmt),
        _n = 2, HSTACK(_leadFmt, _lastFmt),
        _n = 3, HSTACK(_leadFmt, _midFmt, _lastFmt),
        _n = 4, HSTACK(_leadFmt, _midFmt, _midFmt, _lastFmt),
        _n = 5, HSTACK(_leadFmt, _midFmt, _midFmt, _midFmt, _lastFmt)
    ),
    
    CONCAT(_designator, _prefix & TEXT(_elements, _fmts) & _suffix)
)
);



fnFormat = LAMBDA(_rTimeSpan, _fmtProvider,
LET(
    _day, INDEX(_rTimeSpan, 1, 2),
    _hour, INDEX(_rTimeSpan, 1, 3),
    _minute, INDEX(_rTimeSpan, 1, 4),
    _second, INDEX(_rTimeSpan, 1, 5),
    _high, INDEX(_fmtProvider, 1, 1),
    _low, INDEX(_fmtProvider, 1, 2),
    _sign, INDEX(_fmtProvider, 1, 3),
    _leadFmt, INDEX(_fmtProvider, 1, 4),
    _midFmt, INDEX(_fmtProvider, 1, 5),
    _secFmt, INDEX(_fmtProvider, 1, 6),
    _dMark, INDEX(_fmtProvider, 1, 7),
    _hMark, INDEX(_fmtProvider, 1, 8),
    _mMark, INDEX(_fmtProvider, 1, 9),
    _sMark, INDEX(_fmtProvider, 1, 10),
    IFS(
        _high = -3, IFS(
            _low >= 0,
                CONCAT(
                    _sign,
                    TEXT(_day, _leadFmt),
                    _dMark,
                    TEXT(_hour, _midFmt),
                    _hMark,
                    TEXT(_minute, _midFmt),
                    _mMark,
                    TEXT(_second, _secFmt),
                    _sMark
                ),
            _low = -1,
                CONCAT(
                    _sign,
                    TEXT(_day, _leadFmt),
                    _dMark,
                    TEXT(_hour, _midFmt),
                    _hMark,
                    TEXT(_minute, _midFmt),
                    _mMark
                ),
            _low = -2,
                CONCAT(
                    _sign,
                    TEXT(_day, _leadFmt),
                    _dMark,
                    TEXT(_hour, _midFmt),
                    _hMark
                ),
            _low = -3,
                CONCAT(
                    _sign,
                    TEXT(_day, _leadFmt),
                    _dMark
                ),
            TRUE, "#TIMESPAN!"
        ),
        _high = -2, LET(
            _hours, (_day * 24) + _hour,
            IFS(
                _low >= 0,
                    CONCAT(
                        _sign,
                        TEXT(_hour, _leadFmt),
                        _hMark,
                        TEXT(_minute, _midFmt),
                        _mMark,
                        TEXT(_second, _secFmt),
                        _sMark
                    ),
                _low = -1,
                    CONCAT(
                        _sign,
                        TEXT(_hour, _leadFmt),
                        _hMark,
                        TEXT(_minute, _midFmt),
                        _mMark
                    ),
                _low = -2,
                    CONCAT(
                        _sign,
                        TEXT(_hour, _leadFmt),
                        _hMark
                    ),
                TRUE, "#TIMESPAN!"
            )
        ),
        _high = -1, LET(
            _minutes, (_day * 1440) + (_hour * 60) + _minute,
            IFS(
                _low >= 0,
                    CONCAT(
                        _sign,
                        TEXT(_minutes, _leadFmt),
                        _mMark,
                        TEXT(_second, _secFmt),
                        _sMark
                    ),
                _low = -1,
                    CONCAT(
                        _sign,
                        TEXT(_minutes, _leadFmt),
                        _mMark
                    ),
                TRUE, "#TIMESPAN!"
            )
        ),
        _high = 0, LET(
            _seconds, (_day * 86400) + (_hour * 3600) + (_minute * 60) + _second,
            IF(_low >= 0,
                CONCAT(
                    _sign,
                    TEXT(_seconds , _secFmt),
                    _sMark
                ),
                "#TIMESPAN!"
            )
        ),
        TRUE, "#TIMESPAN!"
    )
)
);




/*----------------------------------------------------------------------------------------------------------
FORMAT_ISO_TIME

Returns a time as text in ISO format.

Output
------------------------------------------------------------------------------------------------------------
1 | text | ISO formatted time

Parameters
------------------------------------------------------------------------------------------------------------
Time             | decimal [0..1] | Time of day as decimal fraction of a day.
[Options]        | text           | String with elements: [B][<][~][Significance]
             |                |  B : Display in basic format eg T0000
             |                |  < : Round by truncating components. Default is rounding to nearest.
             |                |  ~ : Floating display starting from Significance if provided
             |                |  Significance : least significant component where:
             |                |    Null : Defaults to seconds
             |                |       H : Hour
             |                |       M : Minute
             |                |       S : Second
             |                |       T : Millisecond (Ticks)
----------------------------------------------------------------------------------------------------------*/
/*
FORMAT_ISO_TIME = LAMBDA(Time, [Options],
IF(Time = "", "",
    IF(NOT(ISNUMBER(Time)), {#VALUE!},
        IF((Time < 0) + (Time > 1), {#NUM!},
            LET(
                _basic, IF(Options = "", FALSE,
                    IFERROR(SEARCH("B", Options), 0) > 0
                ),
                _fixed, IF(Options = "", TRUE,
                    IFERROR(FIND("~", Options), 0) = 0
                ),
                _truncate, IF(Options = "", FALSE,
                    IFERROR(FIND("<", Options), 0) > 0
                ),
                _precision, LET(
                    _trySigChar, SEARCH_NTH_CHAR("HMST", Options, 1, 1),
                    IFS(
                        INDEX(_trySigChar, 1, 1) = 0, IF(_fixed, 4, 0),
                        INDEX(_trySigChar, 1, 2) = "H", 2,
                        INDEX(_trySigChar, 1, 2) = "M", 3,
                        INDEX(_trySigChar, 1, 2) = "S", 4,
                        INDEX(_trySigChar, 1, 2) = "T", 5
                    )
                ),
                _usePrecision, IF(_fixed, _precision, 0),
                _rTime, RESOLVE_TIMESPAN(Time, _usePrecision, _truncate),
                _showPrecision, IF(_fixed, _precision, MAX(_precision, INDEX(_rTime, 1, 7))),
                _delim, IF(_basic, "", ":"),
                IFS(
                    _showPrecision = 5,
                        CONCAT(
                            "T", TEXT(INDEX(_rTime, 1, 3), "00"),
                            _delim, TEXT(INDEX(_rTime, 1, 4), "00"),
                            _delim, TEXT(INDEX(_rTime, 1, 5), "00"),
                            ".", TEXT(INDEX(_rTime, 1, 6), "000")
                        ),
                    _showPrecision = 4,
                        CONCAT(
                            "T", TEXT(INDEX(_rTime, 1, 3), "00"),
                            _delim, TEXT(INDEX(_rTime, 1, 4), "00"),
                            _delim, TEXT(INDEX(_rTime, 1, 5), "00")
                        ),
                    _showPrecision = 3,
                        CONCAT(
                            "T", TEXT(INDEX(_rTime, 1, 3), "00"),
                            _delim, TEXT(INDEX(_rTime, 1, 4), "00")
                        ),
                    _showPrecision = 2,
                        CONCAT(
                            "T", TEXT(INDEX(_rTime, 1, 3), "00")
                        )
                )
            )
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
FORMAT_ISO_TZO

Returns a time zone offset as text in ISO format.

Output
------------------------------------------------------------------------------------------------------------
1 | text | ISO formatted time zone offset

Parameters
------------------------------------------------------------------------------------------------------------
TimeZoneOffset | decimal         | Time zone offset from UTC as decimal fraction of a day.
           | [-0.625..0.625] | Assumed to be UTC if ommitted. [-15:00..+15:00]
[Options]      | text            | String with elements: [B][Z]
           |                 |  B : Display in basic format eg +0000
           |                 |  Z : Display 'Z' for Zulu time zone +00:00
----------------------------------------------------------------------------------------------------------*/
FORMAT_ISO_TZO = LAMBDA(TimeZoneOffset, [Options],
IF(TimeZoneOffset = "", "",
    IF(NOT(ISNUMBER(TimeZoneOffset)), {#VALUE!},
        LET(
            _basic,  IF(Options = "", FALSE,
                IFERROR(SEARCH("B", Options), 0) > 0
            ),
            _zulu,  IF(Options = "", FALSE,
                IFERROR(SEARCH("Z", Options), 0) > 0
            ),
            _tzo, ABS(TimeZoneOffset),
            IF((_tzo = 0) * _zulu, "Z",
                IF(_tzo > 0.625, {#NUM!},
                    LET(
                        _sign, IF(TimeZoneOffset >= 0, "+", UNICHAR(8722)), 
                        _delim, IF(_basic, "", ":"),
                        _hasSeconds, MOD(INT(_tzo * 86400), 60) > 0,
                        IF(_hasSeconds,
                            LET(
                                _rTZO, RESOLVE_TIMESPAN(_tzo, 4, 1),
                                CONCAT(
                                    _sign,
                                    TEXT(INDEX(_rTZO, 1, 3), "00"),
                                    _delim, TEXT(INDEX(_rTZO, 1, 4), "00"),
                                    _delim, TEXT(INDEX(_rTZO, 1, 5), "00")
                                )
                            ),
                            LET(
                                _rTZO, RESOLVE_TIMESPAN(_tzo, 3),
                                CONCAT(
                                    _sign,
                                    TEXT(INDEX(_rTZO, 1, 3), "00"),
                                    _delim, TEXT(INDEX(_rTZO, 1, 4), "00")
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
FORMAT_ISO_YEAR

Returns a year as text in ISO format.

Output
------------------------------------------------------------------------------------------------------------
1 | text | ISO formatted year

Parameters
------------------------------------------------------------------------------------------------------------
YearCE | integer | Note that 1 BC = 0 CE, 2 BC = -1 CE
----------------------------------------------------------------------------------------------------------*/
FORMAT_ISO_YEAR = LAMBDA(YearCE,
IF((YearCE = ""), "",
    IF(NOT(ISNUMBER(YearCE)), {#VALUE!},
        IF(NOT(IS_INTEGER(YearCE)), {#NUM!},
            LET(
                _yearFmt, IF((YearCE >= 1000) * (YearCE <= 9999),
                    "0000;" & UNICHAR(8722) & "0000",
                    "+0000;" & UNICHAR(8722) & "0000"
                ),
                TEXT(YearCE, _yearFmt)
            )
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
FORMAT_ISO_CALENDAR_DATE

Returns a calendar date as text in ISO format.

Output
------------------------------------------------------------------------------------------------------------
1 | text | ISO formatted date

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] |
Day              | integer [1..31] |
[Basic]          | switch          | Display in basic format eg yyyyMMdd
             |                 | Invalid when Day not provided and YearCE outside of range
             |                 | -9999..9999 due to collision with yyyyddd ISO format.
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
             |                 | proleptic calendar. 
----------------------------------------------------------------------------------------------------------*/
FORMAT_ISO_CALENDAR_DATE = LAMBDA(YearCE, Month, Day, [Basic], [JulianCalendar],
IF((YearCE = "") * (Month = "") * (Day = ""), "",
    IF(NOT(ISNUMBER(YearCE)), {#VALUE!},
        IF(((Month <> "") * NOT(ISNUMBER(Month))) + ((Day <> "") * NOT(ISNUMBER(Day))), {#VALUE!},
            IF((Month = "") * ISNUMBER(Day), {#VALUE!},
                IF(Month = "", FORMAT_ISO_Year(YearCE),
                    IF(NOT(IS_VALID_DATE(YearCE, Month, Day, JulianCalendar)), {#NUM!},
                        LET(
                            _basic, N(Basic) <> 0,
                            _delim, IF(_basic, "", "-"),
                            IF(Day = "",
                                IF(_basic * (ABS(YearCE) > 9999), {#VALUE!},
                                    CONCAT(
                                        FORMAT_ISO_Year(YearCE),
                                        _delim, TEXT(Month, "00")
                                    )
                                ),
                                CONCAT(
                                    FORMAT_ISO_Year(YearCE),
                                    _delim, TEXT(Month, "00"),
                                    _delim, TEXT(Day, "00")
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
FORMAT_ISO_ORDINAL_DATE

Returns an ordinal date as text in ISO format.

Output
------------------------------------------------------------------------------------------------------------
1 | text | ISO formatted ordinal date

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | integer          | Note that 1 BC = 0 CE, 2 BC = -1 CE
OrdinalDay       | integer [1..366] |
[Basic]          | switch           | Display in basic format eg yyyyddd.
             |                  | Invalid when YearCE outside of range -9999..9999 due to collision
             |                  | with yyyyMMdd ISO format.
[JulianCalendar] | switch           | Calculate for the Julian proleptic calendar. Default is Gregorian
             |                  | proleptic calendar. 
----------------------------------------------------------------------------------------------------------*/
FORMAT_ISO_ORDINAL_DATE = LAMBDA(YearCE, OrdinalDay, [Basic], [JulianCalendar],
IF((YearCE = "") * (OrdinalDay = ""), "",
    IF(NOT(ISNUMBER(YearCE)), {#VALUE!},
        IF((OrdinalDay <> "") * NOT(ISNUMBER(OrdinalDay)), {#VALUE!},
            IF(OrdinalDay = "", FORMAT_ISO_Year(YearCE),
                LET(
                    _basic, N(Basic) <> 0,
                    IF(_basic * (ABS(YearCE) > 9999), {#VALUE!},
                        LET(
                            _delim, IF(_basic, "", "-"),
                            IF(NOT(IS_VALID_ORDINAL_DATE(YearCE, OrdinalDay, JulianCalendar)), {#NUM!},
                                CONCAT(
                                    FORMAT_ISO_Year(YearCE),
                                    _delim, TEXT(OrdinalDay, "000")
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
FORMAT_ISO_WEEK_DATE

Returns a week date as text in ISO format.

Output
------------------------------------------------------------------------------------------------------------
1 | text | ISO formatted week date

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Note that 1 BC = 0 CE, 2 BC = -1 CE
ISOWeek          | integer [1..53] | Note most years have 52 ISO weeks
[ISOWeekDay]     | integer [1..7]  | ISO day of week Monday..Sunday
[Basic]          | switch          | Display in basic format eg yyyyWwwd
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
             |                 | proleptic calendar. 
----------------------------------------------------------------------------------------------------------*/
FORMAT_ISO_WEEK_DATE = LAMBDA(YearCE, ISOWeek, [ISOWeekDay], [Basic], [JulianCalendar],
IF((YearCE = "") * (ISOWeek = "") * (ISOWeekDay = ""), "",
    IF(NOT(ISNUMBER(YearCE)), {#VALUE!},
        IF(((ISOWeek <> "") * NOT(ISNUMBER(ISOWeek))) + ((ISOWeekDay <> "") * NOT(ISNUMBER(ISOWeekDay))), {#VALUE!},
            IF((ISOWeek = "") * ISNUMBER(ISOWeekDay), {#VALUE!},
                LET(
                    _delim, IF(N(Basic) = 0, "-", ""),
                    IF(ISOWeek = "", FORMAT_ISO_Year(YearCE),
                        IF(NOT(IS_VALID_WEEK_DATE(YearCE, ISOWeek, ISOWeekDay, JulianCalendar)), {#NUM!},
                            IF(ISOWeekDay = "",
                                CONCAT(
                                    FORMAT_ISO_Year(YearCE),
                                    _delim, "W", TEXT(ISOWeek, "00")
                                ),
                                CONCAT(
                                    FORMAT_ISO_Year(YearCE),
                                    _delim, "W", TEXT(ISOWeek, "00"),
                                    _delim, TEXT(ISOWeekDay, "0")
                                )
                            )
                        )
                    )
                )
            )
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
FORMAT_ISO_DATE

Returns a date as text in ISO format.

Output
------------------------------------------------------------------------------------------------------------
1 | text | ISO formatted date

Parameters
------------------------------------------------------------------------------------------------------------
Type             | text     | Type of date
             |          |  C - calendar date
             |          |  O - ordinal date
             |          |  W - week date
             |          |  Y - year only
YearCE           | integer  | Note that 1 BC = 0 CE, 2 BC = -1 CE
DatePart2        | integer  | [1..12] for calendar date, [1..53] for week date
DatePart3        | integer  | [1..31] for calendar date, [1..366] for ordinal date
[Basic]          | switch   | Display in basic format eg yyyyMMdd
[JulianCalendar] | switch   | Calculate for the Julian proleptic calendar. Default is Gregorian
             |          | proleptic calendar. 
----------------------------------------------------------------------------------------------------------*/
FORMAT_ISO_DATE = LAMBDA(Type, YearCE, DatePart2, DatePart3, [Basic], [JulianCalendar],
IF(NOT(ISERROR(Type)) * (YearCE = "") * (DatePart2 = "") * (DatePart3 = ""), "",
    IFS(
        Type = "C", FORMAT_ISO_CALENDAR_DATE(YearCE, DatePart2, DatePart3, Basic, JulianCalendar),
        Type = "O", FORMAT_ISO_ORDINAL_DATE(YearCE, DatePart3, Basic, JulianCalendar),
        Type = "W", FORMAT_ISO_WEEK_DATE(YearCE, DatePart2, DatePart3, Basic, JulianCalendar),
        Type = "Y", FORMAT_ISO_YEAR(YearCE),
        TRUE, {#VALUE!}
    )
)
);


/*----------------------------------------------------------------------------------------------------------
FORMAT_ISO_DATETIME

Returns a date, time and time zone offset as text in ISO format.

Output
------------------------------------------------------------------------------------------------------------
1 | text | ISO formatted date, time and time zone offset

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] |
Day              | integer [1..31] |
[Time]           | decimal [0..1]  | Time of day as decimal fraction of a day.
[TimeZoneOffset] | decimal         | Time zone offset from UTC as decimal fraction of a day.
             | [-0.625..0.625] | Assumed to be UTC if ommitted. [-15:00..+15:00]
[Options]        | text            | String with elements: [B][<][~][Significance][Z]
             |                 |  B : Display in basic format eg T0000
             |                 |  < : Round by truncating components. Default is rounding to nearest.
             |                 |  ~ : Floating display starting from Significance
             |                 |  Significance : least significant component where:
             |                 |    Null : Defaults to seconds if time present, otherwise day
             |                 |       D : Day
             |                 |       H : Hour
             |                 |       M : Minute
             |                 |       S : Second
             |                 |       T : Millisecond (Ticks)
             |                 |  Z : Display 'Z' for Zulu time zone +00:00
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
             |                 | proleptic calendar. 
----------------------------------------------------------------------------------------------------------*/
/*
FORMAT_ISO_DATETIME = LAMBDA(YearCE, Month, Day, [Time], [TimeZoneOffset], [Options], [JulianCalendar],
IF((YearCE = "") * (Month = "") * (Day = "") * (Time = ""), "",
    LET(
        _hasDate, ISNUMBER(YearCE) * ISNUMBER(Month) * ISNUMBER(Day),
        _hasTime, ISNUMBER(Time),
        IF(_hasDate + _hasTime = 0, {#VALUE!},
            LET(
                _basic, IFERROR(SEARCH("B", Options), 0) > 0,
                _fixed, IFERROR(FIND("~", Options), 0) = 0,
                _truncate, IFERROR(FIND("<", Options), 0) > 0,
                _trySigChar, SEARCH_NTH_CHAR("DHMST", Options, 1, 1),
                _precision, IFS(
                    INDEX(_trySigChar, 1, 1) = 0, IF(_fixed, 4, 0),
                    INDEX(_trySigChar, 1, 2) = "D", 1,
                    INDEX(_trySigChar, 1, 2) = "H", 2,
                    INDEX(_trySigChar, 1, 2) = "M", 3,
                    INDEX(_trySigChar, 1, 2) = "S", 4,
                    INDEX(_trySigChar, 1, 2) = "T", 5
                ),
                _usePrecision, IF(_fixed, _precision, 0),
                
                _timeOutOfRange, _hasTime * ((Time < 0) + (Time > 1) > 0),
                _time, IF(_timeOutOfRange, 0, Time),
                _resolve, IFS(
                    NOT(_hasDate),
                        HSTACK(
                            "",
                            ROUND_TIMESPAN(_time, _usePrecision, _truncate)
                        ),
                    NOT(IS_VALID_DATE(YearCE, Month, Day, JulianCalendar)),
                        HSTACK(
                            "#DATE!",
                            ROUND_TIMESPAN(_time, _usePrecision, _truncate)
                        ),
                    TRUE, 
                        LET(
                            _rDate, RESOLVE_DATE(YearCE, Month, Day, _time, _usePrecision, _truncate, JulianCalendar),
                            _sDate, FORMAT_ISO_CALENDAR_DATE(
                                INDEX(_rDate, 1, 1),
                                INDEX(_rDate, 1, 2),
                                INDEX(_rDate, 1, 3),
                                _basic,
                                JulianCalendar
                            ),
                            HSTACK(
                                IF(ISERROR(_sDate),"#DATE!", _sDate),
                                INDEX(_rDate, 1, 4)
                            )
                        )
                ),
                _sDate, INDEX(_resolve, 1, 1),
                _sTime, IF(NOT(_hasTime) * (_precision = 1) * _fixed, "",
                    IF(_timeOutOfRange, "#TIME!",
                        IFERROR(
                            FORMAT_ISO_TIME(
                                IF(INDEX(_resolve, 1, 2) = 1, 0, INDEX(_resolve, 1, 2)),
                                Options
                            ),
                            "#TIME!"
                        )
                    )
                ),
                _sTZO, IFERROR(FORMAT_ISO_TZO(TimeZoneOffset, Options), "#TZO!"),
                IF(_hasTime,
                    CONCAT(_sDate, _sTime, _sTZO),
                    IF(_sTZO = "", _sDate,
                        CONCAT(_sDate, "T", _sTZO)
                    )
                )
            )
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
FORMAT_LITERARY_YEAR

Returns a year formatted in literary style.

Output
------------------------------------------------------------------------------------------------------------
1 | text | Literary year

Parameters
------------------------------------------------------------------------------------------------------------
YearCE          | integer | Note that 1 BC = 0 CE, 2 BC = -1 CE
[AlwaysShowEra] | switch  | Always apply BCE/CE suffix. If not used, only years less than 1000 show an era.
----------------------------------------------------------------------------------------------------------*/
FORMAT_LITERARY_YEAR = LAMBDA(YearCE, [AlwaysShowEra],
IF(YearCE = "", "",
    LET(
        _yearCE, INT(YearCE),
        _isCE, _yearCE >= 1,
        _year, IF(_isCE, _yearCE, 1 - _yearCE),
        _suffix, IFS(NOT(_isCE), " BCE",
            _yearCE < 1000, " CE",
            N(AlwaysShowEra) <> 0, " CE",
            TRUE, ""
        ),
        _year & _suffix
    )
)
);


/*----------------------------------------------------------------------------------------------------------
FORMAT_LITERARY_DATE

Returns a date formatted in literary style.

Output
------------------------------------------------------------------------------------------------------------
1 | text | Literary date

Parameters
------------------------------------------------------------------------------------------------------------
YearCE                 | integer         | Note that 1 BC = 0 CE, 2 BC = -1 CE
Month                  | integer [1..12] |
Day                    | integer [1..31] |
[Time]                 | decimal [0..1]  | Time of day as decimal fraction of a day.
[Short]                | switch          | Return short format Jan..Dec
[InternationalEnglish] | switch          | Use the International English instead of local language set in Excel
[AlwaysShowEra]        | switch          | Always apply BCE/CE suffix. If not used, only years less than 1000
                   |                 | show an era.
[JulianCalendar]       | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                   |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
/*
FORMAT_LITERARY_DATE = LAMBDA(YearCE, Month, Day, [Time], [Short], [InternationalEnglish], [AlwaysShowEra], [JulianCalendar],
IF((YearCE = "") * (Month = "") * (Day = ""), "",
    IF(NOT(ISNUMBER(Month)) + (NOT(ISNUMBER(YearCE)) * NOT(ISNUMBER(Day))), {#VALUE!},
        LET(
            fnFormatDate, LAMBDA(_carryDay,
                LET(
                    _yearCE, IF(YearCE = "", 2000, YearCE),
                    _day, IF(Day = "", 1, INT(Day)),
                    IF(NOT(IS_VALID_DATE(_yearCE, Month, _day, JulianCalendar)), "#DATE!",
                        LET(
                            _rDate, IF(_carryDay,
                                RESOLVE_DATE(_yearCE, Month, _day + 1, 0, 0, 0, JulianCalendar),
                                HSTACK(_yearCE, Month, _day)
                            ),
                            _sMonth, MONTH_NAME(INDEX(_rDate, 1, 2), Short, InternationalEnglish),
                            _sDay, IF(ISNUMBER(Day), " " & INDEX(_rDate, 1, 3), ""),
                            _sYear, IF(ISNUMBER(YearCE), ", " & FORMAT_LITERARY_YEAR(INDEX(_rDate, 1, 1), AlwaysShowEra), ""),
                            CONCAT(_sMonth, _sDay, _sYear)
                        )
                    )
                )    
            ),

            fnFormatTime, LAMBDA(
                IF(Time = "", {"", 0},
                    IF(NOT(ISNUMBER(Time)), {" #TIME!", 0},
                        IF((Time < 0) + (Time > 1), {" #TIME!", 0},
                            LET(
                                _rTime, ROUND_TIMESPAN(Time, 3, 0),
                                _carryDay, N((_rTime = 1) * (Time < 1)),
                                _fmt, IF(Time = 1, "[H]:mm", "h:mm AM/PM"),
                                HSTACK(
                                    ", " & TEXT(_rTime, _fmt),
                                    _carryDay
                                )
                            )
                        )
                    )
                )
            ),
            
            _rTime, fnFormatTime(),
            _sDate, fnFormatDate(INDEX(_rTime, 1, 2)),
            CONCAT(_sDate, INDEX(_rTime, 1, 1))
        )
    )
)
);


/*----------------------------------------------------------------------------------------------------------
FORMAT_US_DATE

Returns a date formatted in the US style.

Output
------------------------------------------------------------------------------------------------------------
1 | text | US style date

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] |
Day              | integer [1..31] |
[Time]           | decimal [0..1)  | Time of day as decimal fraction of a day.
[Options]        | text            | String with elements: [Significance][DateSeparator][TimeSeparator][<]
             |                 |   Significance: least significant component where:
             |                 |    Null : Defaults to minutes if time present, otherwise day
             |                 |       D : Day
             |                 |       H : Hour
             |                 |       M : Minute
             |                 |       S : Second
             |                 |       T : Millisecond (Ticks)
             |                 |  DateSeparator: Character to separate date components. [,./-_]
             |                 |  TimeSeparator: Character to separate time components. [,.:-_]
             |                 |             < : Round by truncating components. Default is rounding to nearest.
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
             |                 | proleptic calendar. 
----------------------------------------------------------------------------------------------------------*/
/*
FORMAT_US_DATE = LAMBDA(YearCE, Month, Day, [Time], [Options], [JulianCalendar],
IF((YearCE = "") * (Month = "") * (Day = ""), "",
    IF(NOT(ISNUMBER(YearCE)) + NOT(ISNUMBER(Month)) + NOT(ISNUMBER(Day)) + ((Time <> "") * NOT(ISNUMBER(Time))), {#VALUE!},
        LET(
            fnFormatDate, LAMBDA(_separator, _carryDay,
                IF(NOT(IS_VALID_DATE(YearCE, Month, Day, JulianCalendar)), "#DATE!",
                    LET(
                        _rDay, INT(Day),
                        _rDate, IF(_carryDay,
                            RESOLVE_DATE(YearCE, Month, _rDay + 1, 0, 0, 0, JulianCalendar),
                            HSTACK(YearCE, Month, _rDay)
                        ),
                        _sYear, TEXT(INDEX(_rDate, 1, 1), "0000;" & UNICHAR(8722) & "0000;0000"),
                        _sMonth, TEXT(INDEX(_rDate, 1, 2), "0"),
                        _sDay, TEXT(INDEX(_rDate, 1, 3), "0"),
                        CONCAT(_sMonth, _separator, _sDay, _separator, _sYear)
                    )
                )
            ),
                                    
            fnFormatTime, LAMBDA(_precision, _truncate, _separator,
                IF(Time = "", {"", 0},
                    IF(NOT(ISNUMBER(Time)), {"#TIME!", 0},
                        IF((Time < 0) + (Time > 1), {" #TIME!", 0},
                            LET(
                                _rTime, ROUND_TIMESPAN(Time, _precision, _truncate),
                                _carryDay, N(_rTime = 1),
                                _fmt, IFS(
                                    _precision = 1, "",
                                    _precision = 2, "h AM/PM",
                                    _precision = 3, "h\" & _separator & "mm AM/PM",
                                    _precision = 4, "h\" & _separator & "mm\" & _separator & "ss AM/PM",
                                    TRUE, "h\" & _separator & "mm\" & _separator & "ss.000 AM/PM"
                                ),
                                _sTime, TEXT(_rTime, _fmt),
                                HSTACK(_sTime, _carryDay)
                            )
                        )
                    )
                )
            ),

            _hasTime, ISNUMBER(Time),
            _truncate, IF(Options = "", FALSE,
                IFERROR(FIND("<", Options), 0) > 0
            ),
            _usePrecision, IF(NOT(_hasTime), 1,
                LET(
                    _trySigChar, SEARCH_NTH_CHAR("DHMST", Options, 1, 1),
                    IFS(
                        INDEX(_trySigChar, 1, 1) = 0, 3,
                        INDEX(_trySigChar, 1, 2) = "D", 1,
                        INDEX(_trySigChar, 1, 2) = "H", 2,
                        INDEX(_trySigChar, 1, 2) = "M", 3,
                        INDEX(_trySigChar, 1, 2) = "S", 4,
                        INDEX(_trySigChar, 1, 2) = "T", 5
                    )
                )
            ),
            _tryDateSepChar, SEARCH_NTH_CHAR(",./-_", Options, 1, 1),
            _dateSeparator, IF(INDEX(_tryDateSepChar, 1, 1) = 0, "/",
                INDEX(_tryDateSepChar, 1, 2)
            ),
            _tryTimeSepChar, SEARCH_NTH_CHAR(",.:-_", Options, 1, 1, INDEX(_tryDateSepChar, 1, 1) + 1),
            _timeSeparator, IF(INDEX(_tryTimeSepChar, 1, 1) = 0, ":",
                INDEX(_tryTimeSepChar, 1, 2)
            ),
            
            _rTime, fnFormatTime(_usePrecision, _truncate, _timeSeparator),
            _sDate, fnFormatDate(_dateSeparator, INDEX(_rTime, 1, 2)),

            IF(_hasTime,
                CONCAT(_sDate, " ", INDEX(_rTime, 1 ,1)),
                _sDate
            )
        )
    )
)
);


/*--------------------------------------------------------------------------------------------------------
FORMAT_MIL_DTG

Returns a date formatted in US Military message traffic style.

Output
----------------------------------------------------------------------------------------------------------
1 | text | DTG formatted date

Parameters
----------------------------------------------------------------------------------------------------------
Year             | integer         |
             | [1951..2050]    |
Month            | integer [1..12] |
Day              | integer [1..31] |
Time             | decimal [0..1)  | Time of day as decimal fraction of a day.
[TimeZoneOffset] | decimal         | Time zone offset from UTC as decimal fraction of a day.
             | [-0.625..0.625] | Assumed to be UTC if ommitted. [-15:00..+15:00]
             |                 | Time will be converted if the offset does not align with military
             |                 | time zones.
[Short]          | switch          | Short time formt: hhmm, otherwise: hhmmss

Examples
----------------------------------------------------------------------------------------------------------
FORMAT_MIL_DTG(2023, 2, 12, 0.75, 600, 1)
Returns: 121800KFEB23

FORMAT_MIL_DTG( , , 12, 0.25)
Returns: 120600J
--------------------------------------------------------------------------------------------------------*/
/*
FORMAT_MIL_DTG = LAMBDA(Year, Month, Day, Time, [TimeZoneOffset], [Short],
IF((Year = "") * (Month = "") * (Day = "") * (Time = ""), "",
    IF((NOT(ISNUMBER(Year)) * (Year <> "")) + (NOT(ISNUMBER(Month)) * (Month <> "")) + (NOT(ISNUMBER(Day)) * (Day <> "")), {#VALUE!},
        IF((Month <> "") * NOT(IS_VALID_DATE(Year, Month, Day, 0)), "#DATE!",
            LET(
                _tzo, N(TimeZoneOffset),

                fnFmtTime, LAMBDA(_time,
                    LET(
                        _timeFmt, IF(N(Short), "HHmm", "HHmmss"),
                        TEXT(_time, _timeFmt)
                    )
                ),

                fnResolveMilitaryTZ, LAMBDA(
                    IFS(
                        TimeZoneOffset = "", HSTACK(N(Time), "J"),
                        _tzo > 0.5, LET(
                            _shiftTZO, _tzo - 0.5,
                            _time, N(Time) - _shiftTZO,  
                            HSTACK(_time, "M")
                        ),
                        _tzo < -0.5, LET(
                            _shiftTZO, _tzo + 0.5,
                            _time, N(Time) - _shiftTZO,  
                            HSTACK(_time, "Y")
                        ),
                        TRUE, LET(
                            _militaryTZO, SIGN(_tzo) * MROUND(ABS(_tzo * 1440), 60) / 1440,
                            _shiftTZO, _tzo - _militaryTZO,
                            _time, N(Time) - _shiftTZO,
                            _idx, INT(_militaryTZO * 24) + 13,
                            _militaryTZ, CHOOSE(_idx, "Y", "X", "W", "V", "U", "T", "S", "R", "Q", "P", "O", "N", "Z", "A", "B", "C", "D", "E", "F", "G", "H", "I", "K", "L", "M"),
                            HSTACK(_time, _militaryTZ)
                        )
                    )
                ),
        
                _day, INT(Day),
                _usePrecision, 4 - N(Short),
                _militaryTime, fnResolveMilitaryTZ(),
                _rDate, IF(Year = "",
                    RESOLVE_DATE(2000, 3, _day, INDEX(_militaryTime, 1, 1), _usePrecision),
                    RESOLVE_DATE(Year, Month, _day, INDEX(_militaryTime, 1, 1), _usePrecision)
                ),
                _sDay, TEXT(INDEX(_rDate, 3), "00"),
                IF(Year = "",
                    CONCAT(_sDay, fnFmtTime(INDEX(_rDate, 4)), INDEX(_militaryTime, 1, 2)),
                    IF((INDEX(_rDate, 1) < 1951) + (INDEX(_rDate, 1) > 2050), "#RANGE!",
                        LET(
                            _sTime, fnFmtTime(INDEX(_rDate, 4)),
                            _sMonth, UPPER(MONTH_NAME(INDEX(_rDate, 2), 1, 1)),
                            _sYY, RIGHT(TEXT(INDEX(_rDate, 1), "00"), 2),
                            CONCAT(_sDay, _sTime, INDEX(_militaryTime, 1, 2), _sMonth, _sYY)
                        )
                    )
                )
            )
        )
    )
)
);







/*########################################################################################################
# CONVERSION                                                                                             #
########################################################################################################*/


/*--------------------------------------------------------------------------------------------------------
MJDATE_TO_EDATE

Returns an Excel Date/Time for the provided Modified Julian Date.
Note Excel Date/Time uses the Gregorian calendar.

Output
----------------------------------------------------------------------------------------------------------
1 | decimal         | Excel Date/Time.
| [1..2958466)    | 1900-01-01..9999-12-31

Parameters
----------------------------------------------------------------------------------------------------------
MJDate  | decimal          | Modified Julian Date
    | [15019..2973484) |
--------------------------------------------------------------------------------------------------------*/
MJDATE_TO_EDATE = LAMBDA(MJDate,
IF(MJDate = "", "",
    IF(NOT(ISNUMBER(MJDate)), {#VALUE!},
        IF((MJDate < 15019) + (MJDate >= 2973484), {#NUM!}, 
            MJDate - 15018
        )
    )
)
);


/*--------------------------------------------------------------------------------------------------------
EDATE_TO_MJDATE

Returns the Modified Julian Date for the provided Excel Date/Time.
Note Excel Date/Time uses the Gregorian calendar.

Output
----------------------------------------------------------------------------------------------------------
1 | decimal          | Modified Julian Date.
| [15019..2973484) |

Parameters
----------------------------------------------------------------------------------------------------------
EDate | decimal      | Excel Date/Time
  | [1..2958466) | 1900-01-01..9999-12-31
--------------------------------------------------------------------------------------------------------*/
EDATE_TO_MJDATE = LAMBDA(EDate,
IF(EDate = "", "", 
    IF(NOT(ISNUMBER(EDate)), {#VALUE!},
        EDate + 15018
    )
)
);


/*--------------------------------------------------------------------------------------------------------
USDATE_TO_EDATE

Returns an Excel Date/Time for the provided US format date and time.

Output
----------------------------------------------------------------------------------------------------------
1 | decimal | Excel Date/Time.

Parameters
----------------------------------------------------------------------------------------------------------
USDate | text | Date in US format ie. MM/dd/yyyy hh:mm:ss
--------------------------------------------------------------------------------------------------------*/
/*
USDATE_TO_EDATE = LAMBDA(USDate,
IF(USDate = "", "",
    LET(
        _USDate, PARSE_US_DATE(USDate),
        _time, INDEX(_USDate, 1, 4),
        _year, INDEX(_USDate, 1, 1),
        _eDate, IF(_year = "", 0,
            DATE(_year, INDEX(_USDate, 1, 2), INDEX(_USDate, 1, 3))
        ),
        _eDate + _time
    )
)
);


/*--------------------------------------------------------------------------------------------------------
EDATE_TO_USDATE

Returns a US format date and time for the provided Excel Date/Time.

Output
----------------------------------------------------------------------------------------------------------
1 | text | US format date and time

Parameters
----------------------------------------------------------------------------------------------------------
EDate     | decimal | Excel Date/Time.
[Options] | text    | String with elements: [Significance][DateSeparator][TimeSeparator][<]
      |         |   Significance: least significant component where:
      |         |    Null : Defaults to minutes if time present, otherwise day
      |         |       D : Day
      |         |       H : Hour
      |         |       M : Minute
      |         |       S : Second
      |         |       T : Millisecond (Ticks)
      |         |  DateSeparator: Character to separate date components. [,./-_]
      |         |  TimeSeparator: Character to separate time components. [,.:-_]
      |         |             < : Round by truncating components. Default is rounding to nearest.
--------------------------------------------------------------------------------------------------------*/

/*EDATE_TO_USDATE = LAMBDA(EDate, [Options],
IF(EDate = "", "", 
    IF(NOT(ISNUMBER(EDate)), {#VALUE!},
        LET(
            _yearCE, YEAR(EDate),
            _month, MONTH(EDate),
            _day, DAY(EDate),
            _time, EDate - INT(EDate),
            FORMAT_US_DATE(_yearCE, _month, _day, _time, Options, 0)
        )
    )
)
);









/*--------------------------------------------------------------------------------------------------------
MJDATE_TO_ISODATETIME

Returns ISO format date, time and time zone offset from a Modified Julian Date.

Output
----------------------------------------------------------------------------------------------------------
1 | text | ISO date, time and time zone offset.

Parameters
----------------------------------------------------------------------------------------------------------
MJDate             | decimal         | Modified Julian Date
[TimeZoneOffset]   | decimal         | Time zone offset from UTC as decimal fraction of a day.
               | [-0.625..0.625] | -15:00..+15:00

[ToJulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
               |                | proleptic calendar. 
--------------------------------------------------------------------------------------------------------*/
MJDATE_TO_ISODATE = LAMBDA(MJDate, [TimeZoneOffset], [Options], [ToJulianCalendar],
LET(
    _rDate, MJDATE_TO_CALENDAR_DATE(MJDate, _precision, _truncate, ToJulianCalendar),
    FORMAT_ISO_DATETIME(
        INDEX(_rDate, 1, 1),
        INDEX(_rDate, 1, 2),
        INDEX(_rDate, 1, 3),
        INDEX(_rDate, 1, 4),
        TimeZoneOffset,
        Precision,
        NoZulu,
        ToJulianCalendar
    )
)
);























/*--------------------------------------------------------------------------------------------------------
ISODATETIME_TO_MJDATE

Returns the Modified Julian Date and time zone offset for a date and time provided in ISO format.

Output
----------------------------------------------------------------------------------------------------------
1 | decimal         | Modified Julian Date
2 | decimal         | Time zone offset from UTC as decimal fraction of a day.
| [-0.625..0.625] | -15:00..+15:00

Parameters
----------------------------------------------------------------------------------------------------------
ISODateTime          | text   | ISO formatted date, time and time zone offset.
[FromJulianCalendar] | switch | Calculate from the Julian proleptic calendar. Default is Gregorian
                 |        | proleptic calendar. 
--------------------------------------------------------------------------------------------------------*/
ISODATETIME_TO_MJDATE = LAMBDA(ISODateTime, [FromJulianCalendar],
IF(ISODateTime = "", {"", ""},
    LET(
        _isoDateTime, PARSE_ISO_DATETIME(ISODateTime, 0, FromJulianCalendar),
        IF(ISERROR(INDEX(_isoDateTime, 1, 1)), HSTACK(INDEX(_isoDateTime, 1, 1), ""),
            IF(INDEX(_isoDateTime, 1, 1) = "T", HSTACK({#N/A}, ""),
                LET(
                    _MJDate, IFS(
                        INDEX(_isoDateTime, 1, 1) = "D",
                            MODIFIED_JULIAN_DATE(
                                INDEX(_isoDateTime, 1, 2),
                                INDEX(_isoDateTime, 1, 3),
                                INDEX(_isoDateTime, 1, 4),
                                INDEX(_isoDateTime, 1, 5),
                                FromJulianCalendar
                            ),
                        INDEX(_isoDateTime, 1, 1) = "O",
                            ORDINAL_DATE_TO_MJDATE(
                                INDEX(_isoDateTime, 1, 2),
                                INDEX(_isoDateTime, 1, 4),
                                INDEX(_isoDateTime, 1, 5),
                                FromJulianCalendar
                            ),
                        INDEX(_isoDateTime, 1, 1) = "W",
                            WEEK_DATE_TO_MJDATE(
                                INDEX(_isoDateTime, 1, 2),
                                INDEX(_isoDateTime, 1, 3),
                                INDEX(_isoDateTime, 1, 4),
                                INDEX(_isoDateTime, 1, 5),
                                FromJulianCalendar
                            )
                    ),
                    HSTACK(
                        _MJDate,
                        INDEX(_isoDateTime, 1, 6)
                    )
                )
            )
        )
    )
)
);


/*--------------------------------------------------------------------------------------------------------
ISODATETIME_TO_EDATE

Returns an Excel Date/Time for a date and time provided in ISO format.
Note Excel Date/Time uses the Gregorian calendar.

Output
----------------------------------------------------------------------------------------------------------
1 | decimal         | Excel Date/Time.
| [1..2958466)    | 1900-01-01..9999-12-31
2 | decimal         | Time zone offset from UTC as decimal fraction of a day.
| [-0.625..0.625] | -15:00..+15:00

Parameters
----------------------------------------------------------------------------------------------------------
ISODateTime             | text   | ISO formatted date, time and time zone offset. If time is ommitted,
                    |        | assumed to be at 00:00.
[FromJulianCalendar]    | switch | Calculate from the Julian proleptic calendar. Default is Gregorian
                    |        | proleptic calendar.
--------------------------------------------------------------------------------------------------------*/
ISODATETIME_TO_EDATE = LAMBDA(ISODateTime, [FromJulianCalendar],
IF(ISODateTime = "", "",
    LET(
        _julianCalendar, N(FromJulianCalendar) <> 0,
        _isoDateTime, PARSE_ISO_DATETIME(ISODateTime, _julianCalendar),
        IF(ISERROR(INDEX(_isoDateTime, 1, 1)), HSTACK(INDEX(_isoDateTime, 1, 1), ""),
            LET(
                _gDate, IF(_julianCalendar,
                    JULIAN_TO_GREGORIAN(
                        INDEX(_isoDateTime, 1, 1),
                        INDEX(_isoDateTime, 1, 2),
                        INDEX(_isoDateTime, 1, 3)
                    ),
                    CHOOSECOLS(_isoDateTime, 2, 3, 4)
                ),
                _eDate, DATE(
                    INDEX(_gDate, 1, 1),
                    INDEX(_gDate, 1, 2),
                    INDEX(_gDate, 1, 3)
                ),
                _eDateTime, _eDate + INDEX(_isoDate, 1, 4),
                IF(_returnTZO,
                    HSTACK(
                        _eDateTime,
                        INDEX(_isoDate, 1, 5)
                    ),
                     _eDateTime
                )
            )
        )
    )
)
);



/*--------------------------------------------------------------------------------------------------------
EDATE_TO_ISODATE

Returns ISO format date, time and time zone offset from an Excel Date/Time.

Output
----------------------------------------------------------------------------------------------------------
1 | text | ISO date.

Parameters
----------------------------------------------------------------------------------------------------------
EDate              | decimal     | Excel Date/Time.
[TimeZoneOffset]   | decimal     | Time zone offset in minutes from UTC.
               | [-900..900] | Assumed to be UTC if ommitted.
[Precision]        | integer     | Select precision level, default is 3
               |             |   0 - Floats from minute to millisecond
               |             |   1 - Day
               |             |   2 - Hour
               |             |   3 - Minute
               |             |   4 - Second
               |             |   5 - Millisecond
[NoZulu]           | switch      | Use +00:00 instead of Z for UTC time zone.
[ToJulianCalendar] | switch      | Calculate in the Julian proleptic calendar. Default is Gregorian
               |             | proleptic calendar. 
--------------------------------------------------------------------------------------------------------*/
EDATE_TO_ISODATE = LAMBDA(EDate, [TimeZoneOffset], [Precision], [NoZulu], [ToJulianCalendar],
IF(EDate = "", "", 
    IF(NOT(ISNUMBER(EDate)), {#VALUE!},
        LET(
            _yearCE, YEAR(EDate),
            _month, MONTH(EDate),
            _day, DAY(EDate),
            _rDate, IF(N(ToJulianCalendar) = 0,
                HSTACK(_yearCE, _month, _day),
                GREGORIAN_TO_JULIAN(_yearCE, _month, _day)
            ),
            _time, EDate - INT(EDate),
            FORMAT_ISO_DATE(
                INDEX(_rDate, 1, 1),
                INDEX(_rDate, 1, 2),
                INDEX(_rDate, 1, 3),
                _time,
                TimeZoneOffset,
                Precision,
                NoZulu,
                ToJulianCalendar
            )
        )
    )
)
);





/*--------------------------------------------------------------------------------------------------------
JDN_LOCAL_TO_ISODATE

Returns ISO format date, time and time zone offset for the provided Julian Day Number and local time.

Output
----------------------------------------------------------------------------------------------------------
1 | text | ISO date.

Parameters
----------------------------------------------------------------------------------------------------------
LocalJDN           | integer     | Local Julian Day Number.
LocalTime          | decimal     | Local time of day as decimal fraction of a day or Excel Time data type.
[TimeZoneOffset]   | decimal     | Time zone offset in minutes from UTC.
               | [-900..900] | Assumed to be UTC if ommitted.
[Precision]        | integer     | Select precision level, default is 3
               |             |   0 - Floats from minute to millisecond
               |             |   1 - Day
               |             |   2 - Hour
               |             |   3 - Minute
               |             |   4 - Second
               |             |   5 - Millisecond
[NoZulu]           | switch      | Use +00:00 instead of Z for UTC time zone.
[ToJulianCalendar] | switch      | Calculate in the Julian proleptic calendar. Default is Gregorian
               |             | proleptic calendar. 
--------------------------------------------------------------------------------------------------------*/
JDN_LOCAL_TO_ISODATE = LAMBDA(LocalJDN, LocalTime, [TimeZoneOffset], [Precision], [NoZulu], [ToJulianCalendar],
LET(
    _jdate, JDN_LOCAL_TO_JDATE(LocalJDN, LocalTime, N(TimeZoneOffset)),
    JDATE_TO_ISODATE(_jdate, TimeZoneOffset, Precision, NoZulu, ToJulianCalendar)
)
);




/*--------------------------------------------------------------------------------------------------------
EDATE_TO_MJDATE

Returns the Modified Julian Date for the given Excel Date/Time.
Note Excel Date/Time is in the Gregorian calendar.

Output
----------------------------------------------------------------------------------------------------------
1 | decimal | Modified Julian Date.

Parameters
----------------------------------------------------------------------------------------------------------
EDate | decimal | Excel Date/Time.
--------------------------------------------------------------------------------------------------------*/
EDATE_TO_MJDATE = LAMBDA(EDate,
IF(EDate = "", "", 
    IF(NOT(ISNUMBER(EDate)), {#VALUE!},
        LET(
            _yearCE, YEAR(EDate),
            _month, MONTH(EDate),
            _day, DAY(EDate),
            _time, EDate - INT(EDate),
            MODIFIED_JULIAN_DATE(_yearCE, _month, _day, _time, 0)
        )
    )
)
);





/*--------------------------------------------------------------------------------------------------------
EDATE_TO_JDN_LOCAL

Returns the Julian Day Number and local time for the provided Excel Date/Time.

Output
----------------------------------------------------------------------------------------------------------
1 | integer        | Local Julian Day Number
2 | decimal [0..1) | Local time of day. Decimal fraction of a day, implicitly converts to Excel Date/Time type.

Parameters
----------------------------------------------------------------------------------------------------------
EDate | decimal | Excel Date/Time.
--------------------------------------------------------------------------------------------------------*/
EDATE_TO_JDN_LOCAL = LAMBDA(EDate,
IF(EDate = "", {"", ""}, 
    IF(NOT(ISNUMBER(EDate)), {#VALUE!, #VALUE!}, 
        LET(
            _yearCE, YEAR(EDate),
            _month, MONTH(EDate),
            _day, DAY(EDate),
            _time, EDate - INT(EDate),
            _jdn, JULIAN_DAY_NUMBER(_yearCE, _month, _day),
            HSTACK(_jdn, _time)
        )
    )
)
);





/*--------------------------------------------------------------------------------------------------------
JDATE_TO_EDATE

Returns an Excel Date/Time for the provided Julian Date.

Output
----------------------------------------------------------------------------------------------------------
1 | decimal | Excel Date/Time.

Parameters
----------------------------------------------------------------------------------------------------------
JDate          | decimal     | Julian Date
TimeZoneOffset | decimal     | Time zone offset in minutes from UTC.
           | [-900..900] | Assumed to be UTC if ommitted.
--------------------------------------------------------------------------------------------------------*/
JDATE_TO_EDATE = LAMBDA(JDate, TimeZoneOffset,
IF(JDate = "", "",
    IF(NOT(ISNUMBER(JDate)), {#VALUE!},
        LET(
            _jdnLocal, JDATE_TO_JDN_LOCAL(JDate, N(TimeZoneOffset)),
            JDN_LOCAL_TO_EDATE(INDEX(_jdnLocal, 1, 1), INDEX(_jdnLocal, 1, 2))
        )
    )
)
);









/*########################################################################################################
# END CALENDAR                                                                                           #
########################################################################################################*/


Examples
------------------------------------------------------------------------------------------------------------
PARSE_TIMESPAN("12:00")
Returns: 0.5

PARSE_TIMESPAN("24:00:01")
Returns: #NUM!  i.e. range is 0 to 24 hours 
----------------------------------------------------------------------------------------------------------*/
PARSE_TIMESPAN = LAMBDA(TimeSpanText, [AsComplication],
    LET(
        _asValue, N(AsComplication) = 0,
        IFS(
            TimeSpanText = "", IF(_asValue, "", {"", "", "", "", ""}),
            _asValue * ISNUMBER(TimeSpanText), TimeSpanText, 
            TRUE, LET(
                fnParseModernFmt, LAMBDA(_text,
                    LET(
                        _split, SPLIT_AROUND_CHARS("0123456789", _text),
                        _pattern, INDEX(_split, 1),
                        IFS(
                            // d.hh:mm:ss.000
                            _pattern = ".::.", HSTACK(
                                VALUE(INDEX(_split, 2)),
                                VALUE(INDEX(_split, 3)),
                                VALUE(INDEX(_split, 4)),
                                VALUE(INDEX(_split, 5) & "." & LEFT(INDEX(_split, 6), 9))
                            ),
                            // d.hh:mm:ss
                            _pattern = ".::", HSTACK(
                                VALUE(INDEX(_split, 2)),
                                VALUE(INDEX(_split, 3)),
                                VALUE(INDEX(_split, 4)),
                                VALUE(INDEX(_split, 5))
                            ),
                            // d.hh:mm
                            _pattern = ".:", HSTACK(
                                VALUE(INDEX(_split, 2)),
                                VALUE(INDEX(_split, 3)),
                                VALUE(INDEX(_split, 4)),
                                ""
                            ),
                            // h:mm:ss.000
                            _pattern = "::.", HSTACK(
                                "",
                                VALUE(INDEX(_split, 2)),
                                VALUE(INDEX(_split, 3)),
                                VALUE(INDEX(_split, 4) & "." & LEFT(INDEX(_split, 5), 9))
                            ),
                            // h:mm:ss
                            _pattern = "::", HSTACK(
                                "",
                                VALUE(INDEX(_split, 2)),
                                VALUE(INDEX(_split, 3)),
                                VALUE(INDEX(_split, 4))
                            ),
                            // m:ss.000
                            _pattern = ":.", HSTACK(
                                "",
                                "",
                                VALUE(INDEX(_split, 2)),
                                VALUE(INDEX(_split, 3) & "." & LEFT(INDEX(_split, 4), 9))
                            ),
                            // h:mm
                            _pattern = ":", HSTACK(
                                "",
                                VALUE(INDEX(_split, 2)),
                                VALUE(INDEX(_split, 3)),
                                ""
                            ),
                            // d.000
                            _pattern = ".", HSTACK(
                                VALUE(INDEX(_split, 2) & "." & INDEX(_split, 3)),
                                "",
                                "",
                                ""
                            ),
                            TRUE, {#VALUE!}
                        )
                    )
                ),

                fnParseTraditionalFmt, LAMBDA(_text,
                    LET(
                        _split, SPLIT_AROUND_CHARS(".0123456789", _text),
                        _pattern, INDEX(_split, 1),
                        IFS(
                            // 0d00h00'00.000"
                            _pattern = "dh'""", HSTACK(
                                VALUE(INDEX(_split, 2)),
                                VALUE(INDEX(_split, 3)),
                                VALUE(INDEX(_split, 4)),
                                ROUNDDOWN(VALUE(INDEX(_split, 5)), 9)
                            ),
                            // 0d00h00.000'
                            _pattern = "dh'", HSTACK(
                                VALUE(INDEX(_split, 2)),
                                VALUE(INDEX(_split, 3)),
                                ROUNDDOWN(VALUE(INDEX(_split, 4)), 9),
                                ""
                            ),
                            // 0d00.000h
                            _pattern = "dh", HSTACK(
                                VALUE(INDEX(_split, 2)),
                                ROUNDDOWN(VALUE(INDEX(_split, 3)), 9),
                                "",
                                ""
                            ),
                            // 0.000d
                            _pattern = "d", HSTACK(
                                ROUNDDOWN(VALUE(INDEX(_split, 2)), 9),
                                "",
                                "",
                                ""
                            ),
                            // 0h00'00.000"
                            _pattern = "h'""", HSTACK(
                                "",
                                VALUE(INDEX(_split, 2)),
                                VALUE(INDEX(_split, 3)),
                                ROUNDDOWN(VALUE(INDEX(_split, 4)), 9)
                            ),
                            // 0h00.000'
                            _pattern = "h'", HSTACK(
                                "",
                                VALUE(INDEX(_split, 2)),
                                ROUNDDOWN(VALUE(INDEX(_split, 3)), 9),
                                ""
                            ),
                            // 0.000h
                            _pattern = "h", HSTACK(
                                "",
                                ROUNDDOWN(VALUE(INDEX(_split, 2)), 9),
                                "",
                                ""
                            ),
                            // 0'00.000"
                            _pattern = "'""", HSTACK(
                                "",
                                "", 
                                VALUE(INDEX(_split, 2)),
                                ROUNDDOWN(VALUE(INDEX(_split, 3)), 9)
                            ),
                            // 0.000'
                            _pattern = "'", HSTACK(
                                "",
                                "",
                                ROUNDDOWN(VALUE(INDEX(_split, 2)), 9),
                                ""
                            ),
                            // 0.000"
                            _pattern = """", HSTACK(
                                "",
                                "",
                                "",
                                ROUNDDOWN(VALUE(INDEX(_split, 2)), 9)
                            ),
                            // 0.000
                            _pattern = "", HSTACK(
                                ROUNDDOWN(VALUE(INDEX(_split, 2)), 9),
                                "",
                                "",
                                ""
                            ),
                            TRUE, {#VALUE!}
                        )
                    )
                ),

                _complication, IF(ISNUMBER(TimeSpanText), RESOLVE_TIMESPAN(TimeSpanText),
                    LET(
                
                        _isModernFmt, IFERROR(FIND(":", TimeSpanText), 0) > 0,
                        _timeSpanText, IF(_isModernFmt, TimeSpanText, SUBSTITUTE(TimeSpanText, " ", "")),
                        _firstChar, LEFT(_timeSpanText, 1),
                        _hasSign, IFS(
                            _firstChar = "+", TRUE,
                            _firstChar = "-", TRUE,
                            _firstChar = UNICHAR(8722), TRUE,
                            TRUE, FALSE
                        ),
                        _nominalSign, IFS(
                            _firstChar = "-", -1,
                            _firstChar = UNICHAR(8722), -1,
                            TRUE, 1
                        ),
                        _uTimeSpan, IF(_hasSign, MID(_timeSpanText, 2, LEN(_timeSpanText) - 1), _timeSpanText),
                        
                        _tryParse, IF(_isModernFmt, fnParseModernFmt(_uTimeSpan), fnParseTraditionalFmt(_uTimeSpan)),
                        IF(ISERROR(INDEX(_tryParse, 1, 1)), {#VALUE!, "", "", "", ""},
                            LET(
                                _sign, IFS(
                                    INDEX(_tryParse, 1, 1) > 0, _nominalSign,
                                    INDEX(_tryParse, 1, 2) > 0, _nominalSign,
                                    INDEX(_tryParse, 1, 3) > 0, _nominalSign,
                                    INDEX(_tryParse, 1, 4) > 0, _nominalSign,
                                    TRUE, 0
                                ),
                                HSTACK(_sign, _tryParse)
                            )
                        )
                    )
                ),
                        
                IF(_asValue,
                    TIMESPAN(
                        INDEX(_complication, 1, 1),
                        INDEX(_complication, 1, 2),
                        INDEX(_complication, 1, 3),
                        INDEX(_complication, 1, 4),
                        INDEX(_complication, 1, 5)
                    ),
                    VALIDATE_TIMESPAN(
                        INDEX(_complication, 1, 1),
                        INDEX(_complication, 1, 2),
                        INDEX(_complication, 1, 3),
                        INDEX(_complication, 1, 4),
                        INDEX(_complication, 1, 5)
                    )
                )
            )
        )
    )
);















/*##########################################################################################################
# CALENDAR DATES                                                                                           #
##########################################################################################################*/


/*----------------------------------------------------------------------------------------------------------
YEAR_COMMON_ERA

Returns year value relative to the Common Era.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer | 1 CE = 1, 1 BCE = 0, 2 BCE = -1

Parameters
------------------------------------------------------------------------------------------------------------
Year  | integer [1..] | Positive non-zero integer.
BCE   | switch        | Before Common Era.
----------------------------------------------------------------------------------------------------------*/
YEAR_COMMON_ERA = LAMBDA(Year, BCE,
    IFS(
        Year = "", "",
        NOT(ISNUMBER(Year)), {#VALUE!},
        TRUE, LET(
            _year, INT(Year),
            IF(_year < 1, {#NUM!},
                IF(N(BCE), 1 - _year, _year)
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
IS_LEAP_YEAR

Tests if a year includes a leap day in the given calendar.

Output
------------------------------------------------------------------------------------------------------------
 1 | boolean | null if empty

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | decimal | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
IS_LEAP_YEAR = LAMBDA(YearCE, [JulianCalendar],
    IFS(
        YearCE = "", "",
        NOT(ISNUMBER(YearCE)), {#VALUE!},
        TRUE, LET(
            _yearCE, INT(YearCE),
            IF(
                N(JulianCalendar) = 0,
                IFS(MOD(_yearCE, 400) = 0, TRUE,
                    MOD(_yearCE, 100) = 0, FALSE,
                    TRUE, MOD(_yearCE, 4) = 0
                ),
                MOD(_yearCE, 4) = 0
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
IS_VALID_DATE

Tests if a date is valid for the given calendar.

Output
------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] | Month of year
[Day]            | decimal [1..32) | Day of month
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
IS_VALID_DATE = LAMBDA(YearCE, Month, [Day], [JulianCalendar],
    IFS(
        NOT(ISNUMBER(YearCE)) + NOT(ISNUMBER(Month)), FALSE, // cannot ommit year or month
        NOT(IS_INTEGER(YearCE) * IS_INTEGER(Month)), FALSE, // year and month cannot be fractional
        (Month < 1) + (Month > 12), FALSE, 
        Day = "", TRUE,
        TRUE, LET(
            _day, INT(Day),
            IF(_day < 1, FALSE,
                LET(
                    _daysInMonth, DAYS_IN_MONTH(Month, YearCE, JulianCalendar),
                    IF(ISERROR(_daysInMonth), FALSE,
                        _day <= _daysInMonth
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
DAYS_IN_YEAR

Returns number of days in the given year of the specified calendar.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer [365,366]

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | integer | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian proleptic
                 |         | calendar.
----------------------------------------------------------------------------------------------------------*/
DAYS_IN_YEAR = LAMBDA(YearCE, [JulianCalendar],
    IFS(
        YearCE = "", "",
        NOT(ISNUMBER(YearCE)), {#VALUE!},
        IS_LEAP_YEAR(YearCE, JulianCalendar), 366,
        TRUE, 365
    )
);


/*----------------------------------------------------------------------------------------------------------
DAYS_IN_MONTH

Returns number of days in the given month and year of the specified calendar.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer [1..31]

Parameters
------------------------------------------------------------------------------------------------------------
Month            | integer [1..12] | Month of year
[YearCE]         | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
DAYS_IN_MONTH = LAMBDA(Month, [YearCE], [JulianCalendar],
    IFS(
        Month = "", "",
        NOT(ISNUMBER(Month)), {#VALUE!},
        TRUE, LET(
            _month, INT(Month),
            IFS(
                _month < 1, {#NUM!},
                _month > 12, {#NUM!},

                // February
                _month = 2,
                    LET(
                        _leapDay, IF(ISNUMBER(YearCE),
                            N(IS_LEAP_YEAR(YearCE, JulianCalendar)),
                            0
                        ),
                        28 + _leapDay
                    ),

                // Jan, Mar, Apr, May, Jun, Jul
                _month <= 7, 30 + MOD(_month, 2),
                
                // Aug, Sep, Oct, Nov, Dec
                TRUE, 31 - MOD(_month, 2)
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
JULIAN_DAY_NUMBER

Returns the Julian Day Number (JDN) of the provided date in the specified calendar.
Note the Julian Day Number is an integer type and is an ordinal day number referenced from January 1,
4713 BC in the proleptic Julian calendar. It does not include any value for time of day.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer | Julian Day Number

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] | Month of year
Day              | integer [1..31] | Day of month
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
JULIAN_DAY_NUMBER = LAMBDA(YearCE, Month, Day, [JulianCalendar],
    IFS(
        (YearCE = "") * (Month = "") * (Day = ""), "",
        NOT(IS_VALID_DATE(YearCE, Month, Day, JulianCalendar)), {#NUM!},
        TRUE, LET(
            _day, INT(Day),
            _gregorian, N(JulianCalendar) = 0,
            _YEAR4801BCE, -4800,
            _G4801BCE_JD, -32045,
            _J4801BCE_JD, -32083,
            _DaysIn5MonthsFromMarch, 153,
            _MarchShiftYear, INT((14 - Month) / 12),
            _years, YearCE - _YEAR4801BCE - _MarchShiftYear,
            _MarchShiftMonth, Month + (12 * _MarchShiftYear) - 3,
            _days, 365 * _years + INT(_years / 4) + INT((_DaysIn5MonthsFromMarch * _MarchShiftMonth + 2) / 5) + _day,
            _days + IF(_gregorian,
                _G4801BCE_JD - INT(_years / 100) + INT(_years / 400),
                _J4801BCE_JD
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
MODIFIED_JULIAN_DAY_NUMBER

Returns the Modified Julian Day Number (MJDN) of the provided date in the specified calendar.
Note the Modified Julian Day Number is an integer type and is an ordinal day number referenced from November 17,
1858 in the proleptic Gregorian calendar. It does not include any value for time of day.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer | Modified Julian Day Number

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] | Month of year
Day              | integer [1..31] | Day of month
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
MODIFIED_JULIAN_DAY_NUMBER = LAMBDA(YearCE, Month, Day, [JulianCalendar],
    LET(
        _JDN, JULIAN_DAY_NUMBER(YearCE, Month, Day, JulianCalendar),
        IF(NOT(ISNUMBER(_JDN)), _JDN,
            JDN_TO_MODIFIED(_JDN)
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
JDN_TO_MODIFIED

Returns the Modified Julian Day Number (MJDN) of the provided Julian Day Number (JDN).

Output
------------------------------------------------------------------------------------------------------------
 1 | integer | Modified Julian Day Number

Parameters
------------------------------------------------------------------------------------------------------------
JDN | integer | Julian Day Number
----------------------------------------------------------------------------------------------------------*/
JDN_TO_MODIFIED = LAMBDA(JDN,
    IF(JDN = "", "",
        INT(JDN) - 2400001
    )
);


/*----------------------------------------------------------------------------------------------------------
MODIFIED_TO_JDN

Returns the Julian Day Number (JDN) of the provided Modified Julian Day Number (MJDN).

Output
------------------------------------------------------------------------------------------------------------
 1 | integer | Julian Day Number

Parameters
------------------------------------------------------------------------------------------------------------
MJDN | integer | Modified Julian Day Number
----------------------------------------------------------------------------------------------------------*/
MODIFIED_TO_JDN = LAMBDA(MJDN,
    IF(MJDN = "", "",
        INT(MJDN) + 2400001
    )
);


/*----------------------------------------------------------------------------------------------------------
JDN_TO_CALENDAR_DATE

Returns the date in the specified calendar from the given Julian Day Number.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day of month

Parameters
------------------------------------------------------------------------------------------------------------
JDN              | integer | Julian Day Number
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
JDN_TO_CALENDAR_DATE = LAMBDA(JDN, [JulianCalendar],
    IFS(
        JDN = "", {"", "", ""},
        NOT(ISNUMBER(JDN)), {#VALUE!, "", ""},
        TRUE, LET(
            _JDN, INT(JDN),
            _gregorian, N(JulianCalendar) = 0,
            _YEAR4801BCE, -4800,
            _DaysIn4Year, 1461,
            _DaysInYear, 365,
            _MonthCorrectionDays, 308,
            _DaysIn4Months, 122,
            _DaysIn5MonthsFromMarch, 153,
            IF(_gregorian,
                LET(
                    _G4801BCE_JD0, -32045,
                    _GregDaysIn400Year, 146097,
                    _GregDaysIn100Year, 36524,
                    _days0, _jdn - _G4801BCE_JD0 - 1,
                    _quadCent, INT(_days0 / _GregDaysIn400Year),
                    _days1, _days0 - _quadCent * _GregDaysIn400Year,
                    _remCent, INT((INT(_days1 / _GregDaysIn100Year) + 1) * 0.75),
                    _days2, _days1 - _remCent * _GregDaysIn100Year,
                    _quadYr, INT(_days2 / _DaysIn4Year),
                    _days3, _days2 - _quadYr * _DaysIn4Year,
                    _remYr, INT((INT(_days3 / _DaysInYear) + 1) * 0.75),
                    _days4, _days3 - _remYr * _DaysInYear,
                    _y, _quadCent * 400 + _remCent * 100 + _quadYr * 4 + _remYr,
                    _m, INT((_days4 * 5 + _MonthCorrectionDays) / _DaysIn5MonthsFromMarch) - 2,
                    _day, _days4 - INT((_m + 4) * _DaysIn5MonthsFromMarch / 5) +
                        _DaysIn4Months + 1,
                    _year, _YEAR4801BCE + _y + INT((_m + 2) / 12),
                    _month, MOD(_m + 2, 12) + 1,
                    HSTACK(_year, _month, _day)
                ),
                LET(
                    _J4801BCE_JD0, -32083,
                    _days0, _jdn - _J4801BCE_JD0 - 1,
                    _quadYr, INT(_days0 / _DaysIn4Year),
                    _days1, _days0 - _quadYr * _DaysIn4Year,
                    _remYr, INT((INT(_days1 / _DaysInYear) + 1) * 0.75),
                    _days2, _days1 - _remYr * _DaysInYear,
                    _y, _quadYr * 4 + _remYr,
                    _m, INT((_days2 * 5 + _MonthCorrectionDays) / _DaysIn5MonthsFromMarch) - 2,
                    _day, _days2 - INT((_m + 4) * _DaysIn5MonthsFromMarch / 5) +
                        _DaysIn4Months + 1,
                    _year, _YEAR4801BCE + _y + INT((_m + 2) / 12),
                    _month, MOD(_m + 2, 12) + 1,
                    HSTACK(_year, _month, _day)
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
MJDN_TO_CALENDAR_DATE

Returns the date in the specified calendar from the given Midified Julian Day Number.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day of month

Parameters
------------------------------------------------------------------------------------------------------------
MJDN             | integer | Modified Julian Day Number
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
MJDN_TO_CALENDAR_DATE = LAMBDA(MJDN, [JulianCalendar],
    LET(
        _JDN, MODIFIED_TO_JDN(MJDN),
        IF(NOT(ISNUMBER(_JDN)), _JDN,
            JDN_TO_CALENDAR_DATE(_JDN, JulianCalendar)
        )
    )
);

/*----------------------------------------------------------------------------------------------------------
GREGORIAN_TO_JULIAN

Translates a date in the Gregorian proleptic calendar to the Julian proleptic calendar.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day

Parameters
------------------------------------------------------------------------------------------------------------
YearCE | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month  | integer [1..12] | 
Day    | integer [1..31] |
----------------------------------------------------------------------------------------------------------*/
GREGORIAN_TO_JULIAN = LAMBDA(YearCE, Month, Day,
    LET(
        _JDN, JULIAN_DAY_NUMBER(YearCE, Month, Day, 0),
        IFS(ISERROR(_JDN), {#VALUE!, "", ""},
            _JDN = "", {"", "", ""},
            TRUE, JDN_TO_CALENDAR_DATE(_JDN, 1)
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
JULIAN_TO_GREGORIAN

Translates a date in the Julian proleptic calendar to the Gregorian proleptic calendar.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day

Parameters
------------------------------------------------------------------------------------------------------------
YearCE | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month  | integer [1..12] | 
Day    | integer [1..31] | 
----------------------------------------------------------------------------------------------------------*/
JULIAN_TO_GREGORIAN = LAMBDA(YearCE, Month, Day,
    LET(
        _JDN, JULIAN_DAY_NUMBER(YearCE, Month, Day, 1),
        IFS(ISERROR(_JDN), {#VALUE!, "", ""},
            _JDN = "", {"", "", ""},
            TRUE, JDN_TO_CALENDAR_DATE(_JDN, 0)
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
SECULAR_DIFFERENCE

Returns the number of days the Gregorian proleptic calendar is ahead of the Julian proleptic calendar for
a given date.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer | Days difference. Negative values are when the Julian proleptic calender is ahead.

Parameters
------------------------------------------------------------------------------------------------------------
YearCE               | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month                | integer [1..12] | 
Day                  | integer [1..31] | 
[FromJulianCalendar] | switch          | Provided date is in Julian calendar.
                     |                 | Default is the Gregorian calendar.
----------------------------------------------------------------------------------------------------------*/
SECULAR_DIFFERENCE = LAMBDA(YearCE, Month, Day, [FromJulianCalendar],
    IF(N(FromJulianCalendar) = 0,
        // From Gregorian calendar
        LET(
            _JDN_G, JULIAN_DAY_NUMBER(YearCE, Month, Day, 0),
            IF(ISERROR(_JDN_G), {#VALUE!},
                IF(_JDN_G = "", "",
                    LET(
                        _JDN_J, IF((Month = 2) * (Day = 29),
                            IF(IS_LEAP_YEAR(YearCE, 1),
                                JULIAN_DAY_NUMBER(YearCE, 2, 29, 1),
                                JULIAN_DAY_NUMBER(YearCE, 2, 28, 1)
                            ),
                            JULIAN_DAY_NUMBER(YearCE, Month, Day, 1)
                        ),
                        _JDN_J - _JDN_G
                    )
                )
            )
        ),
        
        // From Julian calendar
        LET(
            _date_G, JULIAN_TO_GREGORIAN(YearCE, Month, Day),
            IF(ISERROR(INDEX(_date_G, 1, 1)), {#VALUE!},
                IF(INDEX(_date_G, 1, 1) = "", "",
                    SECULAR_DIFFERENCE(
                        INDEX(_date_G, 1, 1),
                        INDEX(_date_G, 1, 2),
                        INDEX(_date_G, 1, 3),
                        0
                    )
                )
            )
        )
    )
);











/*##########################################################################################################
# DATE AND TIME                                                                                            #
##########################################################################################################*/


/*----------------------------------------------------------------------------------------------------------
IS_VALID_TIME_OF_DAY

Tests if sexagesimal representation of time is valid for a 24 hour day.

Output
------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
------------------------------------------------------------------------------------------------------------
Hour           | decimal [0..24) | Fractional allowed if minute and second empty.
Minute         | decimal [0..60) | Fractional allowed if second empty.
Second         | decimal [0..60) | Fractional allowed
[Accept24Hour] | switch          | Accept time of 24:00:00 to represent midnight next day.
----------------------------------------------------------------------------------------------------------*/
IS_VALID_TIME_OF_DAY = LAMBDA(Hour, Minute, Second, [Accept24Hour],
    LET(
        _accept24hour, N(Accept24Hour) <> 0,
        IFS(
            ISNUMBER(Hour) * ISNUMBER(Minute) * ISNUMBER(Second),
                IFS(
                    (_accept24hour * (Hour = 24) * (Minute = 0) * (Second = 0)) > 0, TRUE,
                    NOT(IS_INTEGER(Hour) * IS_INTEGER(Minute)), FALSE,
                    (Hour < 0) + (Hour > 23), FALSE,
                    (Minute < 0) + (Minute > 59), FALSE,
                    (Second < 0) + (Second >= 60), FALSE,
                    TRUE, TRUE
                ),
            ISNUMBER(Hour) * ISNUMBER(Minute) * (Second = ""),
                IFS(
                    (_accept24hour * (Hour = 24) * (Minute = 0)) > 0, TRUE,
                    NOT(IS_INTEGER(Hour)), FALSE,
                    (Hour < 0) + (Hour > 23), FALSE,
                    (Minute < 0) + (Minute >= 60), FALSE,
                    TRUE, TRUE
                ),
            ISNUMBER(Hour) * (Minute = "") * (Second = ""),
                IF((_accept24hour * (Hour = 24)) > 0, TRUE,
                    ((Hour >= 0) * (Hour < 24)) > 0
                ),
            (Hour = "") * ISNUMBER(Minute) * ISNUMBER(Second),
                IFS(
                    NOT(IS_INTEGER(Minute)), FALSE,
                    (Minute < 0) + (Minute > 59), FALSE,
                    (Second < 0) + (Second >= 60), FALSE,
                    TRUE, TRUE
                ),
            (Hour = "") * ISNUMBER(Minute) * (Second = ""),
                ((Minute >= 0) * (Minute < 60)) <> 0,
            (Hour = "") * (Minute = "") * ISNUMBER(Second),
                ((Second >= 0) * (Second < 60)) <> 0,
            TRUE, FALSE
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
JULIAN_DATE

Returns the Julian Date of the provided date and time of day in the specified calendar.
Note that the decimal time component of Julian Date is based from midday.

Output
------------------------------------------------------------------------------------------------------------
 1 | decimal | Julian Date

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] | Month of year
Day              | intger  [1..31] | Day of month
]Time]           | decimal [0..1)  | Time of day
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
JULIAN_DATE = LAMBDA(YearCE, Month, Day, [Time], [JulianCalendar],
    LET(
        _JDN, JULIAN_DAY_NUMBER(YearCE, Month, Day, JulianCalendar),
        IF(NOT(ISNUMBER(_JDN)), _JDN,
            LET(
                _timeAfterMidday, N(Time) - 0.5,
                _JDN + _timeAfterMidday
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
MODIFIED_JULIAN_DATE

Returns the Modified Julian Date of the provided date and time of day in the specified calendar.
Note that the time component of Modified Julian Date is based from midnight.

Output
------------------------------------------------------------------------------------------------------------
 1 | decimal | Modified Julian Date

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] | Month of year
Day              | intger  [1..31] | Day of month
[Time]           | decimal [0..1)  | Time of day
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
MODIFIED_JULIAN_DATE = LAMBDA(YearCE, Month, Day, [Time], [JulianCalendar],
    LET(
        _MJDN, MODIFIED_JULIAN_DAY_NUMBER(YearCE, Month, Day, JulianCalendar),
        IF(NOT(ISNUMBER(_MJDN)), _MJDN,
            _MJDN + N(Time)
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
JDATE_TO_MODIFIED

Returns the Modified Julian Date (MJDATE) of the provided Julian Date.
Note that the time component of MJDATE is based from midnight.

Output
------------------------------------------------------------------------------------------------------------
 1 | decimal | Modified Julian Date

Parameters
------------------------------------------------------------------------------------------------------------
JDate | decimal | Julian Date
----------------------------------------------------------------------------------------------------------*/
JDATE_TO_MODIFIED = LAMBDA(JDate,
    IF(JDate = "", "",
        JDate - 2400000.5
    )
);


/*----------------------------------------------------------------------------------------------------------
MODIFIED_TO_JDATE

Returns the Julian Date of the provided Modified Julian Date (MJDATE).
Note that the time component of JDATE is based from midday.

Output
------------------------------------------------------------------------------------------------------------
 1 | decimal | Julian Date

Parameters
------------------------------------------------------------------------------------------------------------
MJDate | decimal | Modified Julian Date
----------------------------------------------------------------------------------------------------------*/
MODIFIED_TO_JDATE = LAMBDA(MJDate,
    IF(MJDate = "", "",
        MJDate + 2400000.5
    )
);


/*----------------------------------------------------------------------------------------------------------
JDATE_TO_CALENDAR_DATE

Returns the date and time in the specified calendar from the given Julian Date.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day of month
 4 | decimal [0..1)  | Time of day

Parameters
------------------------------------------------------------------------------------------------------------
JDate            | decimal | Julian Date
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
JDATE_TO_CALENDAR_DATE = LAMBDA(JDate, [JulianCalendar],
    IFS(
        JDate = "", {"", "", "", ""},
        NOT(ISNUMBER(JDate)), {#VALUE!, "", "", ""},
        TRUE, LET(
            _JDN, INT(JDate + 0.5),
            _timeOfDay, JDate - _JDN + 0.5,
            _cDate, JDN_TO_CALENDAR_DATE(_JDN, JulianCalendar),
            HSTACK(_cDate, _timeOfDay)
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
MJDATE_TO_CALENDAR_DATE

Returns the date and time in the specified calendar from the given Modified Julian Date.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day of month
 4 | decimal [0..1)  | Time of day

Parameters
------------------------------------------------------------------------------------------------------------
MJDate           | decimal | Modified Julian Date
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
MJDATE_TO_CALENDAR_DATE = LAMBDA(MJDate, [JulianCalendar],
    IF(MJDate = "", {"", "", "", ""},
        IF(NOT(ISNUMBER(MJDate)), {#VALUE!, "", "", ""},
            LET(
                _JDate, MODIFIED_TO_JDATE(MJDate),
                JDATE_TO_CALENDAR_DATE(_JDate, JulianCalendar)
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
RESOLVE_MJDATE

Returns the date and sexagesimal representation of the time value with the given lowest order element rounded
to the specified precision.

Output - LowOrder = 6
------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day of month
 4 | integer [0..23] | Hour
 5 | integer [0..59] | Minute
 6 | decimal [0..60) | Second

Output - LowOrder = 5
------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day of month
 4 | integer [0..23] | Hour
 5 | decimal [0..60) | Minute

Output - LowOrder = 4
------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day of month
 4 | decimal [0..24) | Hour

Output - LowOrder = 3
------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | decimal [1..32) | Day of month

Output - LowOrder = 2
------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month

Output - LowOrder = 1
------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE

Parameters
------------------------------------------------------------------------------------------------------------
MJDate           | decimal        | Modified Julian Date
[LowOrder]       | integer [1..6] | Low-order element
                 |                |  1 - YearCE
                 |                |  2 - Month
                 |                |  3 - Day
                 |                |  4 - Hour
                 |                |  5 - Minute
                 |                |  6 - Second
[Precision]      | integer [0..9] | Select precision level. Not applicable when LowOrder = 1,2
                 |                | Null - Floating
[Truncate]       | switch         | Round to precision by truncating components. Default is rounding to nearest.
[JulianCalendar] | switch         | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
RESOLVE_MJDATE = LAMBDA(MJDate, [LowOrder], [Precision], [Truncate], [JulianCalendar],
    LET(
        _lowOrder, IFS(
            NOT(ISNUMBER(LowOrder)), 6,
            LowOrder < 1, 6,
            LowOrder > 6, 6,
            TRUE, INT(LowOrder)
        ),
        _precision, IFS(
            NOT(ISNUMBER(Precision)), "",
            Precision < 0, 0,
            Precision > 9, 9,
            TRUE, INT(Precision)
        ),
        _truncate, N(Truncate) <> 0,
        IFS(
            MJDate = "", TAKE({"", "", "", "", "", ""}, 1, _lowOrder),
            NOT(ISNUMBER(MJDate)), TAKE({#VALUE!, "", "", "", "", ""}, 1, _lowOrder),
            _lowOrder = 1, LET(
                _cDate, MJDN_TO_CALENDAR_DATE(MJDate, JulianCalendar),
                IF(_truncate,
                    INDEX(_cDate, 1, 1),
                    INDEX(_cDate, 1, 1) + N(INDEX(_cDate, 1, 2) > 6)
                )
            ),
            _lowOrder = 2, LET(
                _cDate, MJDATE_TO_CALENDAR_DATE(MJDate, JulianCalendar),
                IF(_truncate,
                    TAKE(_cDate, 1, 2),
                    LET(
                        _daysInMonth, DAYS_IN_MONTH(INDEX(_cDate, 1, 2), INDEX(_cDate, 1, 1)),
                        _carryMonth, ROUND(((INDEX(_cDate, 1, 3) - 1 + INDEX(_cDate, 1, 4)) / _daysInMonth), 0),
                        IFS(
                            _carryMonth = 0, TAKE(_cDate, 1, 2),
                            INDEX(_cDate, 1, 2) = 12, HSTACK(INDEX(_cDate, 1, 1) + 1, 1),
                            TRUE, HSTACK(INDEX(_cDate, 1, 1), INDEX(_cDate, 1, 2) + 1)
                        )
                    )
                )
            ),
            _lowOrder = 3, LET(
                _MJDN, INT(MJDate),
                _time, MJDate - _MJDN,
                _rTime, IFS(
                    _precision = "", _time,
                    _truncate, ROUNDDOWN(_time, _precision),
                    TRUE, ROUND(_time, _precision)
                ),
                IF(_rTime = 1,
                    MJDN_TO_CALENDAR_DATE(_MJDN + 1, JulianCalendar),
                    LET(
                        _cDate, MJDN_TO_CALENDAR_DATE(_MJDN, JulianCalendar),
                        HSTACK(
                            INDEX(_cDate, 1, 1),
                            INDEX(_cDate, 1, 2),
                            INDEX(_cDate, 1, 3) + _rTime
                        )
                    )
                )
            ),
            TRUE, LET(
                _MJDN, INT(MJDate),
                _time, MJDate - _MJDN,
                _rTime, RESOLVE_TIMESPAN(_time, _lowOrder - 2, _precision, _truncate),
                _carryDay, INDEX(_rTime, 2),
                _rDate, MJDN_TO_CALENDAR_DATE(_MJDN + _carryDay, JulianCalendar),
                HSTACK(_rDate, DROP(_rTime, , 2))
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
MJDATE_ADDITION

Returns the addition of a timespan complication to a given Modified Julian Date.
Note if date parts of years, quarters or months are added for a MJDate expressed in UTC rather than local
time, then inconsistent results can be produced due to the bounds of calendar days.

Output
------------------------------------------------------------------------------------------------------------
 1 | decimal | Modified Julian Date

Parameters
------------------------------------------------------------------------------------------------------------
LocalMJDate      | decimal     | Modifed Julian Date in local time zone
[AddTimeSpan]    | decimal     | Add timespan.
[AddWeeks]       | decimal     | Add weeks timespan. Fractional part carries to day.
[AddMonths]      | decimal     | Add months timespan. Fractional part carries to day.
[AddQuarters]    | decimal     | Add quarters timespan. Fractional part carries to month and day.
[AddYears]       | decimal     | Add years timespan. Fractional part carries to month and day.
[JulianCalendar] | switch      | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |             | proleptic calendar. Only needed if date parts of years, quarters or months
                 |             | are added.
----------------------------------------------------------------------------------------------------------*/
MJDATE_ADDITION = LAMBDA(LocalMJDate, [AddTimeSpan], [AddWeeks], [AddMonths], [AddQuarters], [AddYears], [JulianCalendar],
    IFS(
        LocalMJDate = "", "",
        NOT(ISNUMBER(LocalMJDate)), {#VALUE!},
        (N(AddTimeSpan) = 0) * (N(AddWeeks) = 0) * (N(AddMonths) = 0) * (N(AddQuarters) = 0) * (N(AddYears) = 0), LocalMJDate,
        TRUE, LET(
            _hasDatePartsAdded, ((N(AddMonths) <> 0) + (N(AddQuarters) <> 0) + (N(AddYears) <> 0)) <> 0,
            _baseMJDate, IF(NOT(_hasDatePartsAdded), LocalMJDate,
                LET(
                    _decMonths, (N(AddYears) * 12) + (N(AddQuarters) * 3) + N(AddMonths),
                    _addTotalMonths, INT(_decMonths),
                    _partialMonths, _decMonths - _addTotalMonths,
                    _startDate, MJDATE_TO_CALENDAR_DATE(LocalMJDate, JulianCalendar),
                    _shiftMonths, INDEX(_startDate, 1, 2) - 1 + _addTotalMonths,
                    _resultYear, INDEX(_startDate, 1, 1) + INT(_shiftMonths / 12),
                    _resultMonth, MOD(_shiftMonths, 12) + 1,
                    _MJDateMonth, MODIFIED_JULIAN_DATE(_resultYear, _resultMonth, 1, 0, JulianCalendar) - 1,
                    _avgDaysMonth, IF(N(JulianCalendar), 30.4375, 30.436875),
                    _MJDateMonth + INDEX(_startDate, 1, 3) + ROUND(_partialMonths * _avgDaysMonth, 0) + INDEX(_startDate, 1, 4)
                )
            ),
            _baseMJDate + N(AddTimeSpan) + ROUND(N(AddWeeks) * 7, 0)
        )
    )
);









/*##########################################################################################################
# ORDINAL DATES                                                                                            #
##########################################################################################################*/


/*----------------------------------------------------------------------------------------------------------
IS_VALID_ORDINAL_DATE

Tests if an ordinal date is valid for the given calendar.

Output
------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
OrdinalDay       | decimal [1..367) | Day of year
[JulianCalendar] | switch           | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                  | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
IS_VALID_ORDINAL_DATE = LAMBDA(YearCE, OrdinalDay, [JulianCalendar],
    IFS(
        NOT(ISNUMBER(YearCE)) + NOT(ISNUMBER(OrdinalDay)), FALSE, // cannot ommit year or ordinal day
        NOT(IS_INTEGER(YearCE)), FALSE, // year cannot be fractional
        TRUE, LET(
            _ordinalDay, INT(OrdinalDay),
            IF(_ordinalDay < 1, FALSE,
                LET(
                    _daysInYear, DAYS_IN_YEAR(YearCE, JulianCalendar),
                    _ordinalDay <= _daysInYear
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
ORDINAL_DATE_TO_MJDATE

Returns the Modified Julian Date from the given ordinal date and time in the specified calendar.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer | Modified Julian Date

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
OrdinalDay       | integer [1..366] | Day of year, carries if range exceeded
[Time]           | decimal [0..1)   | Time of day
[JulianCalendar] | switch           | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                  | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
ORDINAL_DATE_TO_MJDATE = LAMBDA(YearCE, OrdinalDay, [Time], [JulianCalendar],
    IFS(
        (YearCE = "") * (OrdinalDay = "") * (Time = ""), "",
        NOT(ISNUMBER(YearCE)) + NOT(ISNUMBER(OrdinalDay)), {#VALUE!},
        TRUE, LET(
            _ordinalDay, INT(OrdinalDay),
            _MJDNYear, MODIFIED_JULIAN_DAY_NUMBER(YearCE, 1, 1, JulianCalendar) - 1,
            _MJDNYear + _ordinalDay + N(Time)
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
MJDATE_TO_ORDINAL_DATE

Returns the year, ordinal day of year, time of day and days in the year in the specified calendar.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer           | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..366]  | Ordinal day
 3 | decimal [0..1)    | Time of day
 4 | integer [365,366] | Days in year

Parameters
------------------------------------------------------------------------------------------------------------
MJDate           | decimal | Modified Julian Date
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
MJDATE_TO_ORDINAL_DATE = LAMBDA(MJDate, [JulianCalendar],
    IFS(
        MJDate = "", {"", "", "", ""},
        NOT(ISNUMBER(MJDate)), {#VALUE!, "", "", ""},
        TRUE, LET(
            _cDate, MJDATE_TO_CALENDAR_DATE(MJDate, JulianCalendar),
            _yearCE, INDEX(_cDate, 1, 1),
            _MJDNYear, MODIFIED_JULIAN_DAY_NUMBER(_yearCE, 1, 1, JulianCalendar) - 1,
            _ordinalDay, INT(MJDate - _MJDNYear),
            _daysInYear, DAYS_IN_YEAR(_yearCE, JulianCalendar),
            HSTACK(
                _yearCE,
                _ordinalDay,
                INDEX(_cDate, 1, 4),
                _daysInYear
            )
        )
    )
);








/*##########################################################################################################
# WEEKS                                                                                                    #
##########################################################################################################*/


/*----------------------------------------------------------------------------------------------------------
DAY_OF_WEEK

Returns an integer for the day of the week for a given Modified Julian Date.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer [1..7] | ISO day of week number
   |                | Monday..Sunday

Parameters
------------------------------------------------------------------------------------------------------------
MJDate | decimal | Modified Julian Date
----------------------------------------------------------------------------------------------------------*/
DAY_OF_WEEK = LAMBDA(MJDate,
    IFS(
        MJDate = "", "",
        NOT(ISNUMBER(MJDate)), {#VALUE!},
        TRUE, LET(
            _MJDN, INT(MJDate),
            MOD(_MJDN + 2, 7) + 1
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
CONVERT_WEEKDAY_NUMBER

Returns an integer for the day of the week from the traditonal numbering scheme to the ISO definition, or
vice versa.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer | Weekday number
   | [1..7]  |    | ISO       | Traditioal
   |         | ---------------------------
   |         |  1 | Monday    | Sunday 
   |         |  2 | Tuesday   | Monday 
   |         |  3 | Wednesday | Tuesday
   |         |  4 | Thursday  | Wednesday
   |         |  5 | Friday    | Thursday
   |         |  6 | Saturday  | Friday
   |         |  7 | Sunday    | Saturday

Parameters
------------------------------------------------------------------------------------------------------------
DayOfWeek          | integer [1..7] | Day of week number
[ISOtoTraditional] | switch         | Return day of week using traditional numbering scheme, assuming 
                   |                | DayOfWeek was provided according to ISO definition.
                   |                | Default is to return in ISO definition, assuming DayOfWeek was
                   |                | provided according to the traditional numbering scheme.
----------------------------------------------------------------------------------------------------------*/
CONVERT_WEEKDAY_NUMBER = LAMBDA(DayOfWeek, [ISOtoTraditional],
    IFS(
        DayOfWeek = "", "",
        NOT(ISNUMBER(DayOfWeek)), {#VALUE!},
        TRUE, LET(
            _givenDoW, INT(N(DayOfWeek)),
            _fromISO, N(ISOtoTraditional) <> 0, 
            _shiftDoW, _givenDow + IF(_fromISO, 0, -2),
            MOD(_shiftDow, 7) + 1
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
WEEKDAY_OF_MONTH

Returns a Modified Julian Date for a given day of week, relative week for the month, year and time of day
of the specified calendar.

Output
------------------------------------------------------------------------------------------------------------
 1 | decimal | Modified Julian Date

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] | Month of the year
WeekOfMonth      | integer [-4..5] | Week in the month.
                 |                 | Note if the reference exceeds the bounds of the month, another month
                 |                 | will be returned.
                 |                 |  0 - last week of previous month
                 |                 |  1 - first week
                 |                 |  2 - second week
                 |                 |  3 - third week
                 |                 |  4 - fourth week
                 |                 |  5 - fifth week
                 |                 | -1 - last week
                 |                 | -2 - second to last week
                 |                 | -3 - third to last week
                 |                 | -4 - fourth to last week
ISOWeekDay       | integer [1..7]  | ISO day of week number Monday..Sunday
[Time]           | decimal [0..1)  | Time of day
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
    
Examples
------------------------------------------------------------------------------------------------------------
WEEKDAY_OF_MONTH(2023, 6, 0, 7)
Returns: MJDate 60120.0 (25/06/2023) ie. the last Sunday of June 2023

WEEKDAY_OF_MONTH(2023, 1, 2, 2, 0.5)
Returns: MJDate 59954.5 (10/01/2023 12pm) ie. midday of the second Tuesday of January 2023
----------------------------------------------------------------------------------------------------------*/
WEEKDAY_OF_MONTH = LAMBDA(YearCE, Month, WeekOfMonth, ISOWeekDay, [Time], [JulianCalendar],
    IFS(
        (YearCE = "") * (Month = "") * (WeekOfMonth = "") * (ISOWeekDay = ""), "",
        NOT(ISNUMBER(YearCE)) + NOT(ISNUMBER(Month)) + NOT(ISNUMBER(WeekOfMonth)) + NOT(ISNUMBER(ISOWeekDay)), {#VALUE!},
        NOT(IS_INTEGER(YearCE) * IS_INTEGER(Month) * IS_INTEGER(WeekOfMonth) * IS_INTEGER(ISOWeekDay)), {#NUM!},
        (WeekOfMonth < -4) + (WeekOfMonth > 5), {#NUM!},
        TRUE, LET(
            _month, Month + N(WeekOfMonth < 0),
            _weekOffset, WeekOfMonth - N(WeekOfMonth >= 0),
            _isoDoW, MOD(ISOWeekDay - 1, 7) + 1,
            _firstOfMonth, MODIFIED_JULIAN_DATE(YearCE, _month, 1, 0, JulianCalendar),
            _firstDoW, DAY_OF_WEEK(_firstOfMonth),
            _firstOfMonth + (_weekOffset * 7) + MOD(_isoDow - _firstDoW, 7) + N(Time)
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
IS_VALID_WEEK_DATE

Tests if a week date is valid for the given calendar.

Output
------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
ISOWeek          | integer [1..53] | ISO defined week number of the year
[ISOWeekDay]     | integer [1..7]  | ISO defined day of week Monday..Sunday
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
IS_VALID_WEEK_DATE = LAMBDA(YearCE, ISOWeek, [ISOWeekDay], [JulianCalendar],
    IFS(
        NOT(ISNUMBER(YearCE)) + NOT(ISNUMBER(ISOWeek)), FALSE, // cannot ommit year or week
        NOT(IS_INTEGER(YearCE) * IS_INTEGER(ISOWeek)), FALSE, // year and week cannot be fractional
        TRUE, LET(
            _validWeek, IFS(
                ISOWeek < 1, FALSE,
                ISOWeek <= 52, TRUE,
                ISOWeek = 53, (WEEKS_IN_YEAR(YearCE, JulianCalendar) = 53),
                TRUE, FALSE
            ),
            IF(NOT(_validWeek), FALSE,
                IF(NOT(ISNUMBER(ISOWeekDay)), TRUE,
                    LET(
                        _weekDay, INT(ISOWeekDay),
                        (_weekDay >= 1) * (_weekDay <= 7) <> 0
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
WEEKS_IN_YEAR

Returns the count of ISO defined weeks in a given year of the specified calendar.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer [52,53]

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | integer | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
WEEKS_IN_YEAR = LAMBDA(YearCE, [JulianCalendar],
    IFS(
        YearCE = "", "",
        NOT(ISNUMBER(YearCE)), {#VALUE!},
        TRUE, LET(
            _gregorian, N(JulianCalendar) = 0,
            fnLastWeekDayOfYear, LAMBDA(_yearCE,
                LET(
                    _dayPrecession, IF(_gregorian,
                        _yearCE + INT(_yearCE / 4) - INT(_yearCE / 100) + INT(_yearCE / 400) + 6,
                        _yearCE + INT(_yearCE / 4) + 4
                    ),
                    MOD(_dayPrecession, 7) + 1
                )
            ),

            _yearCE, INT(YearCE),
            _dowLastDay, fnLastWeekDayOfYear(_yearCE),
            IF(
                _dowLastDay = 4,
                // if last day of year is a Thursday, then has an extra week
                53,
                LET(
                    _dowLastDayPrev, fnLastWeekDayOfYear(_yearCE - 1) ,
                    IF(
                        _dowLastDayPrev = 3,
                        // if last day of previous year is a Wednesday, then has an extra week
                        53,
                        // otherwise
                        52
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
WEEK_DATE_TO_MJDATE

Returns the Modified Julian Date of the provided week date and time in the specified calendar.

Output
------------------------------------------------------------------------------------------------------------
 1 | decimal | Modified Julian Date

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
ISOWeek          | integer [1..53] | ISO defined week number of the year
ISOWeekDay       | integer [1..7]  | ISO defined day of week Monday..Sunday
[Time]           | decimal [0..1)  | Time of day
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
WEEK_DATE_TO_MJDATE = LAMBDA(YearCE, ISOWeek, ISOWeekDay, [Time], [JulianCalendar],
    IFS(
        (YearCE = "") * (ISOWeek = "") * (ISOWeekDay = ""), "",
        NOT(ISNUMBER(YearCE)) + NOT(ISNUMBER(ISOWeek)) + NOT(ISNUMBER(ISOWeekDay)), {#VALUE!},
        TRUE, LET(
            _invalid, IFS(
                NOT(IS_INTEGER(YearCE)), TRUE,
                NOT(IS_INTEGER(ISOWeek)), TRUE,
                ISOWeek < 1, TRUE,
                ISOWeek > 53, TRUE,
                ISOWeek = 53, (WEEKS_IN_YEAR(YearCE, JulianCalendar) < 53),
                TRUE, FALSE
            ),
            IF(_invalid, {#NUM!},
                LET(
                    _shiftByWeeks, (ISOWeek - 1) * 7,
                    _shiftDayOfWeek, MOD(INT(ISOWeekDay) - 1, 7),
                    _firstDayYear, MODIFIED_JULIAN_DAY_NUMBER(YearCE, 1, 1, JulianCalendar),
                    _firstWeekDay, DAY_OF_WEEK(_firstDayYear),
                    _yearCorrection, MOD(4 - _firstWeekDay, 7) - 3,
                    _firstDayYear + _yearCorrection + _shiftByWeeks + _shiftDayOfWeek + N(Time) 
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
MJDATE_TO_WEEK_DATE

Returns the year, ISO defined week number, ISO weekday, time, and weeks in the year for the given Modified
Julian Date in the specified calendar.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer         | YearCE
 2 | integer [1..53] | ISO week number
 3 | integer [1..7]  | ISO day of week Monday..Sunday
 4 | decimal [0..1)  | Time of day
 5 | integer [52,53] | ISO weeks in year

Parameters
------------------------------------------------------------------------------------------------------------
MJDate           | decimal | Modified Julian Date
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
MJDATE_TO_WEEK_DATE = LAMBDA(MJDate, [JulianCalendar],
    IFS(
        MJDate = "", {"", "", "", "", ""},
        NOT(ISNUMBER(MJDate)), {#VALUE!, "", "", "", ""},
        TRUE, LET(
            _cDate, MJDATE_TO_CALENDAR_DATE(MJDate, JulianCalendar),
            _yearCE, INDEX(_cDate, 1, 1),
            _dayOfWeek, DAY_OF_WEEK(MJDate),
            _MJDNYear, MODIFIED_JULIAN_DAY_NUMBER(_yearCE, 1, 1, JulianCalendar) - 1,
            _dayOfYear, INT(MJDate - _MJDNYear),
            _nominalWeek, INT((_dayOfYear - _dayOfWeek + 10) / 7),
            IFS(
                // last week of previous year
                _nominalWeek = 0, LET(
                    _weeksInYear, WEEKS_IN_YEAR(_yearCE - 1, JulianCalendar), 
                    HSTACK(
                        _yearCE - 1,
                        _weeksInYear,
                        _dayOfWeek,
                        INDEX(_cDate, 1, 4),
                        _weeksInYear
                    )
                ),
                
                // auxiliary week
                _nominalWeek = 53, IF(WEEKS_IN_YEAR(_yearCE, JulianCalendar) = 53,
                    HSTACK(
                        _yearCE,
                        53,
                        _dayOfWeek,
                        INDEX(_cDate, 1, 4),
                        53
                    ),
                    // if this year does not have 53 weeks, then is the first week of following year
                    LET(
                        _weeksInYear, WEEKS_IN_YEAR(_yearCE + 1, JulianCalendar),
                        HSTACK(
                            _yearCE + 1,
                            1,
                            _dayOfWeek,
                            INDEX(_cDate, 1, 4),
                            _weeksInYear
                        )
                    )
                ),
                
                // any other week in the year
                TRUE, LET(
                    _weeksInYear, WEEKS_IN_YEAR(_yearCE, JulianCalendar),
                    HSTACK(
                        _yearCE,
                        _nominalWeek,
                        _dayOfWeek,
                        INDEX(_cDate, 1, 4),
                        _weeksInYear
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
WEEK_NUMBER

Returns the ISO defined week number for a given Modified Julian Date in the specified calendar.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer [1..53] | ISO week number

Parameters
------------------------------------------------------------------------------------------------------------
MJDate           | decimal | Modifed Julian Date
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
WEEK_NUMBER = LAMBDA(MJDate, [JulianCalendar],
    IFS(
        MJDate = "", "",
        NOT(ISNUMBER(MJDate)), {#VALUE!},
        TRUE, LET(
            _weekDate, MJDATE_TO_WEEK_DATE(MJDate, JulianCalendar),
            CHOOSECOLS(_weekDate, 2)
        )
    )
);










/*##########################################################################################################
# QUARTERS                                                                                                 #
##########################################################################################################*/


/*----------------------------------------------------------------------------------------------------------
DAYS_IN_QUARTER

Returns the count of days in a quarter of a given year of the specified calendar.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer [89..92]

Parameters
------------------------------------------------------------------------------------------------------------
Quarter          | integer [1..4]  | Quarter of the year 1..4, transitive, exceeding range will carry to year.
[FiscalYearCE]   | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
                 |                 | When month offset is non-zero the fiscal year spans calendar years and
                 |                 | is defined as the year where June falls.
[MonthOffset]    | integer [-6..3] | Quarter month offset from Januaray
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.

Examples
------------------------------------------------------------------------------------------------------------
DAYS_IN_QUARTER(3, 2020, -6)
Returns: 91
i.e. 3rd quarter starting from July 2019, namely Jan, Feb, Mar 2020 with 31, 29, 31 days respectively
----------------------------------------------------------------------------------------------------------*/
DAYS_IN_QUARTER = LAMBDA(Quarter, [FiscalYearCE], [MonthOffset], [JulianCalendar],
    IFS(
        Quarter = "", "",
        NOT(ISNUMBER(Quarter)), {#VALUE!},
        NOT(IS_INTEGER(Quarter)), {#NUM!},
        TRUE, LET(
            _monthOffset, ROUND(N(MonthOffset), 0),
            IF((_monthOffset < -6) + (_monthOffset > 3), {#NUM!},
                LET(
                    _quarter, MOD(INT(Quarter) - 1, 4), // 0..3
                    _daysInQuarterCyclical, {90,89,92,91,92,92,92,92,91,92,92,90},
                    _quarterWithFeb, INT(MOD(1 - _monthOffset, 12) / 3),  // 0..3
                    _quarterPrecession, MOD(_monthOffset + (_quarter * 3), 12) + 1,
                    _nominalDaysInQuarter, INDEX(_daysInQuarterCyclical, 1, _quarterPrecession),
                    _leapDay, IF(ISNUMBER(FiscalYearCE) * (_quarterWithFeb = _quarter),
                        LET(
                            _yearOfFeb, INT(FiscalYearCE) + N(_quarter = 3),
                            N(IS_LEAP_YEAR(_yearOfFeb, JulianCalendar))
                        ),
                        0
                    ),
                    _nominalDaysInQuarter + _leapDay
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
QUARTER_DATE_TO_MJDATE

Returns the Modified Julian Date from the given quarter date in the specified calendar.

Output
------------------------------------------------------------------------------------------------------------
 1 | decimal | Modified Julian Date

Parameters
------------------------------------------------------------------------------------------------------------
FiscalYearCE     | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
                 |                 | When month offset is non-zero the fiscal year spans calendar years and
                 |                 | is defined as the year where June falls.
Quarter          | integer [1..4]  | Quarter of the year 1..4, transitive, exceeding range will carry to year.
DayOfQuarter     | integer [1..92] | Ordinal day of the quarter, exceeding range will carry
[Time]           | decimal [0..1)  | Time of day
[MonthOffset]    | integer [-6..3] | Quarter month offset from January
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
QUARTER_DATE_TO_MJDATE = LAMBDA(FiscalYearCE, Quarter, DayOfQuarter, [Time], [MonthOffset], [JulianCalendar],
    IFS(
        (FiscalYearCE = "") * (Quarter = "") * (DayOfQuarter = ""), "",
        NOT(ISNUMBER(FiscalYearCE)), {#VALUE!},
        NOT(ISNUMBER(Quarter)), {#VALUE!},
        NOT(ISNUMBER(DayOfQuarter)), {#VALUE!},
        NOT(IS_INTEGER(Quarter)), {#NUM!},
        TRUE, LET(
            _monthOffset, ROUND(N(MonthOffset), 0),
            IF((_monthOffset < -6) + (_monthOffset > 3), {#NUM!},
                LET(
                    _fiscalYearCE, INT(FiscalYearCE),
                    _quarter, INT(Quarter),
                    _shiftMonth, (_quarter - 1) * 3 + _monthOffset,
                    _yearCE, _fiscalYearCE + INT(_shiftMonth / 12),
                    _month, MOD(_shiftMonth, 12) + 1,
                    _MJDNQuarter, MODIFIED_JULIAN_DAY_NUMBER(_yearCE, _month, 1, JulianCalendar) - 1,
                    _MJDNQuarter + INT(DayOfQuarter) + N(Time)
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
MJDATE_TO_QUARTER_DATE

Returns the fiscal year, quarter, day of quarter, time and days in the quarter for the given Modifed Julian
Date in the specified calendar.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer          | FiscalYearCE
   |                  | When month offset is non-zero the fiscal year spans calendar years and
   |                  | is defined as the year where June falls.
 2 | integer [1..4]   | Quarter
 3 | integer [1..92]  | Day of quarter
 4 | decimal [0..1)   | Time of day
 5 | integer [89..92] | Days in quarter

Parameters
------------------------------------------------------------------------------------------------------------
MJDate           | decimal         | Modifed Julian Date
[MonthOffset]    | integer [-6..3] | Quarter month offset from January
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
MJDATE_TO_QUARTER_DATE = LAMBDA(MJDate, [MonthOffset], [JulianCalendar],
    IFS(
        MJDate = "", {"", "", "", "", ""},
        NOT(ISNUMBER(MJDate)), {#VALUE!, "", "", "", ""},
        TRUE, LET(
            _monthOffset, ROUND(N(MonthOffset), 0),
            IFS(
                _monthOffset < -6, {#NUM!, "", "", "", ""},
                _monthOffset > 3, {#NUM!, "", "", "", ""},
                TRUE, LET(
                    _cDate, MJDATE_TO_CALENDAR_DATE(MJDate, JulianCalendar),
                    _shiftMonth, INDEX(_cDate, 1, 2) - 1 - _monthOffset,
                    _fiscalYear, INDEX(_cDate, 1, 1) + INT(_shiftMonth / 12),
                    _zeroBasedFiscalMonth, MOD(_shiftMonth, 12),
                    _quarter, INT(_zeroBasedFiscalMonth / 3) + 1,
                    _MJDNQuarter, QUARTER_DATE_TO_MJDATE(_fiscalYear, _quarter, 1, 0, _monthOffset, JulianCalendar) - 1,
                    _dayOfQuarter, INT(MJDate - _MJDNQuarter),
                    _daysInQuarter, DAYS_IN_QUARTER(_quarter, _fiscalYear, _monthOffset, JulianCalendar),
                    HSTACK(
                        _fiscalYear,
                        _quarter,
                        _dayOfQuarter,
                        INDEX(_cDate, 1, 4),
                        _daysInQuarter
                    )
                )
            )
        )
    )
);











/*##########################################################################################################
# DELTAS                                                                                                   #
##########################################################################################################*/


/*----------------------------------------------------------------------------------------------------------
DELTA_HOURS

Returns the timespan difference between Modified Julian Dates in hours.
Can also accept standard Julian Dates, provided types are not mixed.

Output
------------------------------------------------------------------------------------------------------------
 1 | decimal | Difference in hours

Parameters
------------------------------------------------------------------------------------------------------------
MJDateStart | decimal | Starting Modified Julian Date 
MJDateEnd   | decimal | Ending Modified Julian Date
----------------------------------------------------------------------------------------------------------*/
DELTA_HOURS = LAMBDA(MJDateStart, MJDateEnd,
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), "",
        NOT(ISNUMBER(MJDateStart)), {#VALUE!},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
        TRUE, (MJDateEnd - MJDateStart) * 24
    )
);


/*----------------------------------------------------------------------------------------------------------
DELTA_MINUTES

Returns the timespan difference between Modified Julian Dates in minutes.
Can also accept standard Julian Dates, provided types are not mixed.

Output
------------------------------------------------------------------------------------------------------------
 1 | decimal | Difference in minutes

Parameters
------------------------------------------------------------------------------------------------------------
MJDateStart | decimal | Starting Modified Julian Date 
MJDateEnd   | decimal | Ending Modified Julian Date
----------------------------------------------------------------------------------------------------------*/
DELTA_MINUTES = LAMBDA(MJDateStart, MJDateEnd,
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), "",
        NOT(ISNUMBER(MJDateStart)), {#VALUE!},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
        TRUE, (MJDateEnd - MJDateStart) * 1440
    )
);


/*----------------------------------------------------------------------------------------------------------
DELTA_SECONDS

Returns the timespan difference between Modified Julian Dates in seconds.
Can also accept standard Julian Dates, provided types are not mixed.

Output
------------------------------------------------------------------------------------------------------------
 1 | decimal | Difference in seconds

Parameters
------------------------------------------------------------------------------------------------------------
MJDateStart | decimal | Starting Modified Julian Date 
MJDateEnd   | decimal | Ending Modified Julian Date
----------------------------------------------------------------------------------------------------------*/
DELTA_SECONDS = LAMBDA(MJDateStart, MJDateEnd,
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), "",
        NOT(ISNUMBER(MJDateStart)), {#VALUE!},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
        TRUE, (MJDateEnd - MJDateStart) * 86400
    )
);


/*----------------------------------------------------------------------------------------------------------
DELTA_DHMS

Returns the sexagesimal difference between Modified Julian Dates with the given lowest order element rounded
to the specified precision.
Can also accept standard Julian Dates, provided types are not mixed.

Output - LowOrder = 4 (default)
------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Days
 3 | integer [0..23]  | Hours
 4 | integer [0..59]  | Minutes
 5 | decimal [0..60)  | Seconds

Output - LowOrder = 3
------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Days
 3 | integer [0..23]  | Hours
 4 | decimal [0..60)  | Minutes

Output - LowOrder = 2
------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Days
 3 | decimal [0..24)  | Hours

Output - LowOrder = 1
------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | decimal [0..]    | Days

Parameters
------------------------------------------------------------------------------------------------------------
MJDateStart   | decimal | Starting Modified Julian Date 
MJDateEnd     | decimal | Ending Modified Julian Date
[LowOrder]    | integer | Lowest-order element. Defaults to Second.
              | [1..4]  |  1 - Day
              |         |  2 - Hour
              |         |  3 - Minute
              |         |  4 - Second
[Precision]   | integer | Select precision level
              | [0..9]  | Null - Floating
[Truncate]    | switch  | Round to precision by truncating components. Default is rounding to nearest.
----------------------------------------------------------------------------------------------------------*/
DELTA_DHMS = LAMBDA(MJDateStart, MJDateEnd, [LowOrder], [Precision], [Truncate],
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), {"","","",""},
        NOT(ISNUMBER(MJDateStart)), {#VALUE!, "", "", ""},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!, "", "", ""},
        TRUE, RESOLVE_TIMESPAN(MJDateEnd - MJDateStart, LowOrder, Precision, Truncate)
    )
);


/*----------------------------------------------------------------------------------------------------------
DELTA_TIMESPAN

Returns the timespan difference between Modified Julian Dates.
Can also accept standard Julian Dates, provided types are not mixed.

Output
------------------------------------------------------------------------------------------------------------
 1 | decimal | Timespan difference, day = 1

Parameters
------------------------------------------------------------------------------------------------------------
MJDateStart | decimal | Starting Modified Julian Date 
MJDateEnd   | decimal | Ending Modified Julian Date
----------------------------------------------------------------------------------------------------------*/
DELTA_TIMESPAN = LAMBDA(MJDateStart, MJDateEnd,
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), "",
        NOT(ISNUMBER(MJDateStart)), {#VALUE!},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
        TRUE, (MJDateEnd - MJDateStart)
    )
);


/*----------------------------------------------------------------------------------------------------------
DELTA_WEEKS

Returns the timespan difference between Modified Julian Dates in weeks.
Can also accept standard Julian Dates, provided types are not mixed.

Output
------------------------------------------------------------------------------------------------------------
 1 | decimal | Difference in weeks

Parameters
------------------------------------------------------------------------------------------------------------
MJDateStart | decimal | Starting Modified Julian Date 
MJDateEnd   | decimal | Ending Modified Julian Date
----------------------------------------------------------------------------------------------------------*/
DELTA_WEEKS = LAMBDA(MJDateStart, MJDateEnd,
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), "",
        NOT(ISNUMBER(MJDateStart)), {#VALUE!},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
        TRUE, (MJDateEnd - MJDateStart) / 7
    )
);


/*----------------------------------------------------------------------------------------------------------
DELTA_MONTHS

Returns the timespan difference between Modified Julian Dates in months.
Where the difference includes partial months, the fraction is calculated on the basis of days in the month
of the calendar. If the Modifed Julian Dates are expressed in UTC rather than local time then a small margin
of error will be introduced due to the bounds of calendar days.

Output
------------------------------------------------------------------------------------------------------------
 1 | decimal | Difference in months

Parameters
------------------------------------------------------------------------------------------------------------
MJDateStart      | decimal | Starting Modified Julian Date 
MJDateEnd        | decimal | Ending Modified Julian Date
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
DELTA_MONTHS = LAMBDA(MJDateStart, MJDateEnd, [JulianCalendar],
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), "",
        NOT(ISNUMBER(MJDateStart)), {#VALUE!},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
        TRUE, IF(MJDateStart = MJDateEnd, 0,
            LET(
                _sign, IF(MJDateEnd >= MJDateStart, 1, -1),
                _date_A, MJDATE_TO_CALENDAR_DATE(
                    IF(_sign = 1, MJDateStart, MJDateEnd),
                    JulianCalendar
                ),
                _date_B, MJDATE_TO_CALENDAR_DATE(
                    IF(_sign = 1, MJDateEnd, MJDateStart),
                    JulianCalendar
                ),
                _deltaYear, INDEX(_date_B, 1, 1) - INDEX(_date_A, 1, 1),
                _deltaMonth, INDEX(_date_B, 1, 2) - INDEX(_date_A, 1, 2),
                _diffMonths, (_deltaYear * 12) + _deltaMonth,
                _daysMonth_A, DAYS_IN_MONTH(INDEX(_date_A, 1, 2), INDEX(_date_A, 1, 1), JulianCalendar),
                _daysMonth_B, DAYS_IN_MONTH(INDEX(_date_B, 1, 2), INDEX(_date_B, 1, 1), JulianCalendar),
                _partialMonth_A, (INDEX(_date_A, 1, 3) - 1 + INDEX(_date_A, 1, 4)) / _daysMonth_A,
                _partialMonth_B, (INDEX(_date_B, 1, 3) - 1 + INDEX(_date_B, 1, 4)) / _daysMonth_B,
                _sign * (_diffMonths - _partialMonth_A + _partialMonth_B)
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
DELTA_QUARTERS

Returns the timespan difference between Modified Julian Dates in quarters.
Where the difference includes partial quarters, the fraction is calculated on the basis of days in the
quarter of the calendar. If the Modifed Julian Dates are expressed in UTC rather than local time then a
small margin of error will be introduced due to the bounds of calendar days.

Output
------------------------------------------------------------------------------------------------------------
 1 | decimal | Difference in quarters

Parameters
------------------------------------------------------------------------------------------------------------
MJDateStart      | decimal         | Starting Modified Julian Date 
MJDateEnd        | decimal         | Ending Modified Julian Date
[MonthOffset]    | integer [-6..3] | Quarter month offset from January.
[JulianCalendar] | switch          | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
DELTA_QUARTERS = LAMBDA(MJDateStart, MJDateEnd, [MonthOffset], [JulianCalendar],
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), "",
        NOT(ISNUMBER(MJDateStart)), {#VALUE!},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
        TRUE, LET(
            _monthOffset, ROUND(N(MonthOffset), 0),
            IFS(
                _monthOffset < -6, {#NUM!},
                _monthOffset > 3, {#NUM!},
                MJDateStart = MJDateEnd, 0,
                TRUE, LET(
                    _sign, IF(MJDateEnd >= MJDateStart, 1, -1),
                    _quarterDate_A, MJDATE_TO_QUARTER_DATE(
                        IF(_sign = 1, MJDateStart, MJDateEnd),
                        _monthOffset, JulianCalendar
                    ),
                    _quarterDate_B, MJDATE_TO_QUARTER_DATE(
                        IF(_sign = 1, MJDateEnd, MJDateStart),
                        _monthOffset, JulianCalendar
                    ),
                    _deltaYear, INDEX(_quarterDate_B, 1, 1) - INDEX(_quarterDate_A, 1, 1),
                    _deltaQuarter, INDEX(_quarterDate_B, 1, 2) - INDEX(_quarterDate_A, 1, 2),
                    _diffQuarters, (_deltaYear * 4) + _deltaQuarter,
                    _partialQuarter_A, (INDEX(_quarterDate_A, 1, 3) - 1 + INDEX(_quarterDate_A, 1, 4)) / INDEX(_quarterDate_A, 1, 5),
                    _partialQuarter_B, (INDEX(_quarterDate_B, 1, 3) - 1 + INDEX(_quarterDate_B, 1, 4)) / INDEX(_quarterDate_B, 1, 5),
                    _sign * (_diffQuarters - _partialQuarter_A + _partialQuarter_B)
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
DELTA_YEARS

Returns the timespan difference between Modified Julian Dates in years.
Where the difference includes partial years, the fraction is calculated on the basis of days in the
year of the calendar. If the Modifed Julian Dates are expressed in UTC rather than local time then a
small margin of error will be introduced due to the bounds of calendar days.

Output
------------------------------------------------------------------------------------------------------------
 1 | decimal | Difference in years

Parameters
------------------------------------------------------------------------------------------------------------
MJDateStart      | decimal | Starting Modified Julian Date 
MJDateEnd        | decimal | Ending Modified Julian Date
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
DELTA_YEARS = LAMBDA(MJDateStart, MJDateEnd, [JulianCalendar],
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), "",
        NOT(ISNUMBER(MJDateStart)), {#VALUE!},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
        MJDateStart = MJDateEnd, 0,
        TRUE, LET(
            _sign, IF(MJDateEnd >= MJDateStart, 1, -1),
            _ordinalDate_A, MJDATE_TO_ORDINAL_DATE(
                IF(_sign = 1, MJDateStart, MJDateEnd),
                JulianCalendar
            ),
            _ordinalDate_B, MJDATE_TO_ORDINAL_DATE(
                IF(_sign = 1, MJDateEnd, MJDateStart),
                JulianCalendar
            ),
            _deltaYear, INDEX(_ordinalDate_B, 1, 1) - INDEX(_ordinalDate_A, 1, 1),
            _partialYear_A, (INDEX(_ordinalDate_A, 1, 2) - 1 + INDEX(_ordinalDate_A, 1, 3)) / INDEX(_ordinalDate_A, 1, 4),
            _partialYear_B, (INDEX(_ordinalDate_B, 1, 2) - 1 + INDEX(_ordinalDate_B, 1, 3)) / INDEX(_ordinalDate_B, 1, 4),
            _sign * (_deltaYear - _partialYear_A + _partialYear_B)
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
DELTA_WEEK_DAYS

Returns the timespan difference between Modified Julian Dates in weeks and days.
Can also accept standard Julian Dates, provided types are not mixed.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Delta weeks 
 3 | integer [0..6]   | Delta days
 4 | decimal [0..1)   | Delta time

Parameters
------------------------------------------------------------------------------------------------------------
MJDateStart | decimal | Starting Modified Julian Date 
MJDateEnd   | decimal | Ending Modified Julian Date
----------------------------------------------------------------------------------------------------------*/
DELTA_WEEK_DAYS = LAMBDA(MJDateStart, MJDateEnd,
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), {"", "", "", ""},
        NOT(ISNUMBER(MJDateStart)), {#VALUE!, "", "", ""},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!, "", "", ""},
        TRUE, LET(
            _diffDays, (MJDateEnd - MJDateStart),
            IF(_diffDays = 0, {0, 0, 0, 0},
                LET(
                    _sign, IF(_diffDays >= 0, 1, -1),
                    _absDiffDays, _sign * _diffDays,
                    _deltaWeek, INT(_absDiffDays / 7),
                    _remDays, _absDiffDays - _deltaWeek * 7,
                    _deltaDay, INT(_remDays),
                    _deltaTime, _remDays - _deltaDay,
                    HSTACK(
                        _sign,
                        _deltaWeek,
                        _deltaDay,
                        _deltaTime
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
DELTA_YEAR_WEEK_DAYS

Returns the timespan difference between Modified Julian Dates in years, weeks, and days.
Note the number of weeks per year can vary between 52 and 53. If an absolute number of weeks is being sought
then use either DELTA_WEEK_DAYS or DELTA_WEEKS functions. If the Modifed Julian Dates are expressed in UTC
rather than local time then a small margin of error will be introduced due to the bounds of calendar days.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Delta years
 3 | integer [0..52]  | Delta weeks 
 4 | decimal [0..6]   | Delta days
 5 | decimal [0..1)   | Delta time

Parameters
------------------------------------------------------------------------------------------------------------
MJDateStart      | decimal | Starting Modified Julian Date 
MJDateEnd        | decimal | Ending Modified Julian Date
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
DELTA_YEAR_WEEK_DAYS = LAMBDA(MJDateStart, MJDateEnd, [JulianCalendar],
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), {"", "", "", "", ""},
        NOT(ISNUMBER(MJDateStart)), {#VALUE!, "", "", "", ""},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!, "", "", "", ""},
        MJDateStart = MJDateEnd, {0, 0, 0, 0, 0},
        TRUE, LET(
            _sign, IF(MJDateEnd >= MJDateStart, 1, -1),
            _weekDate_A, MJDATE_TO_WEEK_DATE(
                IF(_sign = 1, MJDateStart, MJDateEnd),
                JulianCalendar
            ),
            _weekDate_B, MJDATE_TO_WEEK_DATE(
                IF(_sign = 1, MJDateEnd, MJDateStart),
                JulianCalendar
            ),
            _deltaYear, INDEX(_weekDate_B, 1, 1) - INDEX(_weekDate_A, 1, 1),
            _deltaWeek, INDEX(_weekDate_B, 1, 2) - INDEX(_weekDate_A, 1, 2),
            _diffDays, INDEX(_weekDate_B, 1, 3) - INDEX(_weekDate_A, 1, 3)
                + INDEX(_weekDate_B, 1, 4) - INDEX(_weekDate_A, 1, 4),
            _carryWeek, INT(_diffDays / 7),
            _remDays, _diffDays - _carryWeek * 7,
            _deltaWeek2, _deltaWeek + _carryWeek,
            _deltaDay, INT(_remDays),
            _deltaTime, _remDays - _deltaDay,
            IF(_deltaWeek2 >= 0,
                HSTACK(
                    _sign,
                    _deltaYear,
                    _deltaWeek2,
                    _deltaDay,
                    _deltaTime
                ),
                HSTACK(
                    _sign,
                    _deltaYear - 1,
                    _deltaWeek2 + INDEX(_weekDate_A, 1, 5),
                    _deltaDay,
                    _deltaTime
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
DELTA_MONTH_DAYS

Returns the timespan difference between Modified Julian Dates in months and days.
If the Modifed Julian Dates are expressed in UTC rather than local time then a small margin of error will
be introduced due to the bounds of calendar days.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Delta months
 3 | integer [0..30]  | Delta days
 4 | decimal [0..1)   | Delta time

Parameters
------------------------------------------------------------------------------------------------------------
MJDateStart      | decimal | Starting Modified Julian Date 
MJDateEnd        | decimal | Ending Modified Julian Date
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
DELTA_MONTH_DAYS = LAMBDA(MJDateStart, MJDateEnd, [JulianCalendar],
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), {"", "", "", ""},
        NOT(ISNUMBER(MJDateStart)), {#VALUE!, "", "", ""},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!, "", "", ""},
        MJDateStart = MJDateEnd, {0, 0, 0, 0},
        TRUE, LET(
            _sign, IF(MJDateEnd >= MJDateStart, 1, -1),
            _date_A, MJDATE_TO_CALENDAR_DATE(
                IF(_sign = 1, MJDateStart, MJDateEnd),
                JulianCalendar
            ),
            _date_B, MJDATE_TO_CALENDAR_DATE(
                IF(_sign = 1, MJDateEnd, MJDateStart),
                JulianCalendar
            ),
            _deltaYear, INDEX(_date_B, 1, 1) - INDEX(_date_A, 1, 1),
            _deltaMonth, INDEX(_date_B, 1, 2) - INDEX(_date_A, 1, 2),
            _diffMonths, (_deltaYear * 12) + _deltaMonth,
            _diffDays, INDEX(_date_B, 1, 3) - INDEX(_date_A, 1, 3)
                + INDEX(_date_B, 1, 4) - INDEX(_date_A, 1, 4),
            IF(_diffDays >= 0,
                LET(
                    _deltaDay, INT(_diffDays),
                    _deltaTime, _diffDays - _deltaDay,
                    HSTACK(
                        _sign,
                        _diffMonths,
                        _deltaDay,
                        _deltaTime
                    )
                ),
                LET(
                    _daysMonth_A, DAYS_IN_MONTH(INDEX(_date_A, 1, 2), INDEX(_date_A, 1, 1), JulianCalendar),
                    _diffDays2, _diffDays + _daysMonth_A,  
                    _deltaDay, INT(_diffDays2),
                    _deltaTime, _diffDays2 - _deltaDay,
                    HSTACK(
                        _sign,
                        _diffMonths - 1,
                        _deltaDay,
                        _deltaTime
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
DELTA_QUARTER_DAYS

Returns the timespan difference between Modified Julian Dates in quarters and days.
If the Modifed Julian Dates are expressed in UTC rather than local time then a small margin of error will
be introduced due to the bounds of calendar days.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Delta quarters
 3 | decimal [0..92)  | Delta days

Parameters
------------------------------------------------------------------------------------------------------------
MJDateStart      | decimal         | Starting Modified Julian Date 
MJDateEnd        | decimal         | Ending Modified Julian Date
[MonthOffset]    | integer [-6..3] | Quarter month offset from January.
[JulianCalendar] | switch          | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
DELTA_QUARTER_DAYS = LAMBDA(MJDateStart, MJDateEnd, [MonthOffset], [JulianCalendar],
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), {"", "", "", ""},
        NOT(ISNUMBER(MJDateStart)), {#VALUE!, "", "", ""},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!, "", "", ""},
        TRUE, LET(
            _monthOffset, ROUND(N(MonthOffset), 0),
            IFS(
                _monthOffset < -6, {#NUM!, "", "", ""},
                _monthOffset > 3, {#NUM!, "", "", ""},
                MJDateStart = MJDateEnd, {0, 0, 0, 0},
                TRUE, LET(
                    _sign, IF(MJDateEnd >= MJDateStart, 1, -1),
                    _quarterDate_A, MJDATE_TO_QUARTER_DATE(
                        IF(_sign = 1, MJDateStart, MJDateEnd),
                        _monthOffset, JulianCalendar
                    ),
                    _quarterDate_B, MJDATE_TO_QUARTER_DATE(
                        IF(_sign = 1, MJDateEnd, MJDateStart),
                        _monthOffset, JulianCalendar
                    ),
                    _deltaYear, INDEX(_quarterDate_B, 1, 1) - INDEX(_quarterDate_A, 1, 1),
                    _deltaQuarter, INDEX(_quarterDate_B, 1, 2) - INDEX(_quarterDate_A, 1, 2),
                    _diffQuarters, (_deltaYear * 4) + _deltaQuarter,
                    _diffDays, INDEX(_quarterDate_B, 1, 3) - INDEX(_quarterDate_A, 1, 3)
                        + INDEX(_quarterDate_B, 1, 4) - INDEX(_quarterDate_A, 1, 4),
                    IF(_diffDays >= 0,
                        LET(
                            _deltaDay, INT(_diffDays),
                            _deltaTime, _diffDays - _deltaDay,
                            HSTACK(
                                _sign,
                                _diffQuarters,
                                _deltaDay,
                                _deltaTime
                            )
                        ),
                        LET(
                            _diffDays2, _diffDays + INDEX(_quarterDate_A, 1, 5),
                            _deltaDay, INT(_diffDays2),
                            _deltaTime, _diffDays2 - _deltaDay,
                            HSTACK(
                                _sign,
                                _diffQuarters - 1,
                                _deltaDay,
                                _deltaTime
                            )
                        )
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
DELTA_INTERVAL

Returns the timespan difference between Modified Julian Dates in the specified units.

Output where Units = H, N, S, D, W, M, Q, Y
------------------------------------------------------------------------------------------------------------
 1 | decimal | Delta units decimal

Output where Units = HMS
------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Delta hours
 3 | integer [0..59]  | Delta minutes
 4 | decimal [0..60)  | Delta seconds

Output where Units = DHMS
------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Delta days
 3 | integer [0..23]  | Delta hours
 4 | integer [0..59]  | Delta minutes
 5 | decimal [0..60)  | Delta seconds

Output where Units = WD, MD, QD
------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1]     | Sign
 2 | integer [0..]        | Delta weeks/months/quarters
 3 | integer [0..6/30/91] | Delta days
 4 | decimal [0..1)       | Delta time

Output where Units = YWD, YMD, YQD
------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1]     | Sign
 2 | integer [0..]        | Delta years
 3 | integer [0..52/12/4] | Delta weeks/months/quarters
 4 | integer [0..6/30/91] | Delta days
 5 | decimal [0..1)       | Delta time

Output where Units = YMDHMS
------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Delta years
 3 | integer [0..12]  | Delta months
 4 | integer [0..30]  | Delta days
 5 | integer [0..23]  | Delta hours
 6 | integer [0..59]  | Delta minutes
 7 | decimal [0..60)  | Delta seconds

Parameters
------------------------------------------------------------------------------------------------------------
Units            | text            |      H - hours decimal
                 |                 |      N - minutes decimal
                 |                 |      S - seconds decimal
                 |                 |      T - timespan decimal
                 |                 |      W - weeks decimal
                 |                 |      M - months decimal
                 |                 |      Q - quarters decimal
                 |                 |      Y - years decimal
                 |                 |    HMS - hours, minutes, seconds
                 |                 |   DHMS - days, hours, minutes, seconds
                 |                 |     WD - weeks and days
                 |                 |     MD - months and days
                 |                 |     QD - quarters and days
                 |                 |    YWD - years, weeks, days
                 |                 |    YMD - years, months, days
                 |                 |    YQD - years, quarters, days
                 |                 | YMDHMS - years, months, days, hours, minutes, seconds
MJDateStart      | decimal         | Starting Modified Julian Date 
MJDateEnd        | decimal         | Ending Modified Julian Date
[MonthOffset]    | integer [-6..3] | Quarter month offset from January.
[JulianCalendar] | switch          | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
DELTA_INTERVAL = LAMBDA(Units, MJDateStart, MJDateEnd, [MonthOffset], [JulianCalendar],
    IFS(
        Units = "", {#VALUE!},
        Units = "H", DELTA_HOURS(MJDateStart, MJDateEnd),
        Units = "N", DELTA_MINUTES(MJDateStart, MJDateEnd),
        Units = "S", DELTA_SECONDS(MJDateStart, MJDateEnd),
        Units = "DHMS", DELTA_DHMS(MJDateStart, MJDateEnd, 4),
        Units = "T", DELTA_TIMESPAN(MJDateStart, MJDateEnd),
        Units = "W", DELTA_WEEKS(MJDateStart, MJDateEnd),
        Units = "M", DELTA_MONTHS(MJDateStart, MJDateEnd, JulianCalendar),
        Units = "Q", DELTA_QUARTERS(MJDateStart, MJDateEnd, MonthOffset, JulianCalendar),
        Units = "Y", DELTA_YEARS(MJDateStart, MJDateEnd, JulianCalendar),
        Units = "WD", DELTA_WEEK_DAYS(MJDateStart, MJDateEnd),
        Units = "YWD", DELTA_YEAR_WEEK_DAYS(MJDateStart, MJDateEnd, JulianCalendar),
        Units = "MD", DELTA_MONTH_DAYS(MJDateStart, MJDateEnd, JulianCalendar),
        Units = "QD", DELTA_QUARTER_DAYS(MJDateStart, MJDateEnd, MonthOffset, JulianCalendar),
        Units = "HMS", LET(
                _dhms, DELTA_DHMS(MJDateStart, MJDateEnd, 4),
                _hours, INDEX(_dhms, 1, 3) + (24 * INDEX(_dhms, 1, 2)),
                HSTACK(
                    INDEX(_dhms, 1, 1),
                    _hours,
                    INDEX(_dhms, 1, 4),
                    INDEX(_dhms, 1, 5)
                )
            ),
        Units = "YMD", LET(
                _monthDays, DELTA_MONTH_DAYS(MJDateStart, MJDateEnd, JulianCalendar),
                _years, INT(INDEX(_monthDays, 1, 2) / 12),
                _months, INDEX(_monthDays, 1, 2) - _years * 12,
                HSTACK(
                    INDEX(_monthDays, 1, 1),
                    _years,
                    _months,
                    INDEX(_monthDays, 1, 3),
                    INDEX(_monthDays, 1, 4)
                )
            ),
        Units = "YQD", LET(
                _quarterDays, DELTA_QUARTER_DAYS(MJDateStart, MJDateEnd, MonthOffset, JulianCalendar),
                _years, INT(INDEX(_quarterDays, 1, 2) / 4),
                _quarters, INDEX(_quarterDays, 1, 2) - _years * 4,
                HSTACK(
                    INDEX(_quarterDays, 1, 1),
                    _years,
                    _quarters,
                    INDEX(_quarterDays, 1, 3),
                    INDEX(_quarterDays, 1, 4)
                )
            ),
        Units = "YMDHMS", LET(
                _monthDays, DELTA_MONTH_DAYS(MJDateStart, MJDateEnd, JulianCalendar),
                _years, INT(INDEX(_monthDays, 1, 2) / 12),
                _months, INDEX(_monthDays, 1, 2) - _years * 12,
                _hms, RESOLVE_TIMESPAN(INDEX(_monthDays, 1, 4), 4),
                HSTACK(
                    INDEX(_monthDays, 1, 1),
                    _years,
                    _months,
                    INDEX(_monthDays, 1, 3),
                    DROP(_hms,, 2)
                )
            ),
        TRUE, {#VALUE!}
    )
);












/*##########################################################################################################
# EXTENTS                                                                                                  #
##########################################################################################################*/


/*----------------------------------------------------------------------------------------------------------
EXTENT_OF_DAYS

Returns the inclusive extent of days spanned by two Modified Julian Dates expressed in local time.
If the Modifed Julian Dates are expressed in UTC rather than local time then inconsistent results may be
produced due to the bounds of calendar days.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer | Extent of days

Parameters
------------------------------------------------------------------------------------------------------------
LocalMJDateStart | decimal | Starting Modified Julian Date in local time 
LocalMJDateEnd   | decimal | Ending Modified Julian Date in local time

Examples
------------------------------------------------------------------------------------------------------------
EXTENT_DAYS(MODIFIED_JULIAN_DATE(2023,1,1,TIME(23,59,55)), MODIFIED_JULIAN_DATE(2023,1,2,TIME(0,0,5)))
= 2  i.e. 2 days because the 10 second timespan crosses the day boundary
----------------------------------------------------------------------------------------------------------*/
EXTENT_OF_DAYS = LAMBDA(LocalMJDateStart, LocalMJDateEnd,
    IFS(
        (LocalMJDateStart = "") * (LocalMJDateEnd = ""), "",
        NOT(ISNUMBER(LocalMJDateStart)), {#VALUE!},
        NOT(ISNUMBER(LocalMJDateEnd)), {#VALUE!},
        TRUE, LET(
            _sign, IF(LocalMJDateEnd >= LocalMJDateStart, 1, -1),
            _deltaDay, INT(LocalMJDateEnd) - INT(LocalMJDateStart),
            _sign * (ABS(_deltaDay) + 1)
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
EXTENT_OF_WEEKS

Returns the inclusive extent of weeks spanned by two Modified Julian Dates expressed in local time.
If the Modifed Julian Dates are expressed in UTC rather than local time then inconsistent results may be
produced due to the bounds of calendar days.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer | Extent of weeks

Parameters
------------------------------------------------------------------------------------------------------------
LocalMJDateStart | decimal | Starting Modified Julian Date in local time 
LocalMJDateEnd   | decimal | Ending Modified Julian Date in local time

Examples
------------------------------------------------------------------------------------------------------------
EXTENT_WEEKS(MODIFIED_JULIAN_DATE(2023,6,4,TIME(23,59,55)), MODIFIED_JULIAN_DATE(2023,6,5,TIME(0,0,5)))
= 2  i.e. 2 weeks because the 10 second timespan crosses the week boundary
----------------------------------------------------------------------------------------------------------*/
EXTENT_OF_WEEKS = LAMBDA(LocalMJDateStart, LocalMJDateEnd,
    IFS(
        (LocalMJDateStart = "") * (LocalMJDateEnd = ""), "",
        NOT(ISNUMBER(LocalMJDateStart)), {#VALUE!},
        NOT(ISNUMBER(LocalMJDateEnd)), {#VALUE!},
        TRUE, LET(
            _sign, IF(LocalMJDateEnd >= LocalMJDateStart, 1, -1),
            _startMonday, INT(LocalMJDateStart) + 1 - DAY_OF_WEEK(LocalMJDateStart),
            _endMonday, INT(LocalMJDateEnd) + 1 - DAY_OF_WEEK(LocalMJDateEnd),
            _sign * (INT(ABS(_endMonday - _startMonday) / 7) + 1)
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
EXTENT_OF_MONTHS

Returns the inclusive extent of months spanned by two Modified Julian Dates expressed in local time.
If the Modifed Julian Dates are expressed in UTC rather than local time then inconsistent results may be
produced due to the bounds of calendar days.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer | Extent of months

Parameters
------------------------------------------------------------------------------------------------------------
LocalMJDateStart | decimal | Starting Modified Julian Date in local time 
LocalMJDateEnd   | decimal | Ending Modified Julian Date in local time
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
EXTENT_OF_MONTHS = LAMBDA(LocalMJDateStart, LocalMJDateEnd, [JulianCalendar],
    IFS(
        (LocalMJDateStart = "") * (LocalMJDateEnd = ""), "",
        NOT(ISNUMBER(LocalMJDateStart)), {#VALUE!},
        NOT(ISNUMBER(LocalMJDateEnd)), {#VALUE!},
        TRUE, LET(
            _sign, IF(LocalMJDateEnd >= LocalMJDateStart, 1, -1),
            _date_A, MJDATE_TO_CALENDAR_DATE(
                IF(_sign = 1, LocalMJDateStart, LocalMJDateEnd),
                JulianCalendar
            ),
            _date_B, MJDATE_TO_CALENDAR_DATE(
                IF(_sign = 1, LocalMJDateEnd, LocalMJDateStart),
                JulianCalendar
            ),
            _deltaYear, INDEX(_date_B, 1, 1) - INDEX(_date_A, 1, 1),
            _deltaMonth, INDEX(_date_B, 1, 2) - INDEX(_date_A, 1, 2),
            _diffMonths, (_deltaYear * 12) + _deltaMonth,
            _sign * (_diffMonths + 1)
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
EXTENT_OF_QUARTERS

Returns the inclusive extent of quarters spanned by two Modified Julian Dates expressed in local time.
If the Modifed Julian Dates are expressed in UTC rather than local time then inconsistent results may be
produced due to the bounds of calendar days.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer | Extent of quarters

Parameters
------------------------------------------------------------------------------------------------------------
LocalMJDateStart | decimal         | Starting Modified Julian Date in local time 
LocalMJDateEnd   | decimal         | Ending Modified Julian Date in local time
[MonthOffset]    | integer [-6..3] | Quarter month offset from January.
[JulianCalendar] | switch          | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
EXTENT_OF_QUARTERS = LAMBDA(LocalMJDateStart, LocalMJDateEnd, [MonthOffset], [JulianCalendar],
    IFS(
        (LocalMJDateStart = "") * (LocalMJDateEnd = ""), "",
        NOT(ISNUMBER(LocalMJDateStart)), {#VALUE!},
        NOT(ISNUMBER(LocalMJDateEnd)), {#VALUE!},
        TRUE, LET(
            _monthOffset, ROUND(N(MonthOffset), 0),
            IFS(
                _monthOffset < -6, {#NUM!},
                _monthOffset > 3, {#NUM!},
                TRUE, LET(
                    _sign, IF(LocalMJDateEnd >= LocalMJDateStart, 1, -1),
                    _quarterDate_A, MJDATE_TO_QUARTER_DATE(
                        IF(_sign = 1, LocalMJDateStart, LocalMJDateEnd),
                        _monthOffset, JulianCalendar
                    ),
                    _quarterDate_B, MJDATE_TO_QUARTER_DATE(
                        IF(_sign = 1, LocalMJDateEnd, LocalMJDateStart),
                        _monthOffset, JulianCalendar
                    ),
                    _deltaYear, INDEX(_quarterDate_B, 1, 1) - INDEX(_quarterDate_A, 1, 1),
                    _deltaQuarter, INDEX(_quarterDate_B, 1, 2) - INDEX(_quarterDate_A, 1, 2),
                    _diffQuarters, (_deltaYear * 4) + _deltaQuarter,
                    _sign * (_diffQuarters + 1)
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
EXTENT_OF_YEARS

Returns the inclusive extent of years spanned by two Modified Julian Dates expressed in local time.
If the Modifed Julian Dates are expressed in UTC rather than local time then inconsistent results may be
produced due to the bounds of calendar days.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer | Extent of quarters

Parameters
------------------------------------------------------------------------------------------------------------
LocalMJDateStart | decimal | Starting Modified Julian Date in local time 
LocalMJDateEnd   | decimal | Ending Modified Julian Date in local time
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
EXTENT_OF_YEARS = LAMBDA(LocalMJDateStart, LocalMJDateEnd, [JulianCalendar],
    IFS(
        (LocalMJDateStart = "") * (LocalMJDateEnd = ""), "",
        NOT(ISNUMBER(LocalMJDateStart)), {#VALUE!},
        NOT(ISNUMBER(LocalMJDateEnd)), {#VALUE!},
        TRUE, LET(
            _sign, IF(LocalMJDateEnd >= LocalMJDateStart, 1, -1),
            _date_A, MJDATE_TO_CALENDAR_DATE(
                IF(_sign = 1, LocalMJDateStart, LocalMJDateEnd),
                JulianCalendar
            ),
            _date_B, MJDATE_TO_CALENDAR_DATE(
                IF(_sign = 1, LocalMJDateEnd, LocalMJDateStart),
                JulianCalendar
            ),
            _deltaYear, INDEX(_date_B, 1, 1) - INDEX(_date_A, 1, 1),
            _sign * (_deltaYear + 1)
        )
    )
);








/*##########################################################################################################
# PARSING                                                                                                  #
##########################################################################################################*/


/*----------------------------------------------------------------------------------------------------------
PARSE_WEEKDAY

Returns a number representing the day of the week from a given text weekday name.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer | Weekday number
   | [1..7]  |    | ISO       | Traditioal
   |         | ---------------------------
   |         |  1 | Monday    | Sunday 
   |         |  2 | Tuesday   | Monday 
   |         |  3 | Wednesday | Tuesday
   |         |  4 | Thursday  | Wednesday
   |         |  5 | Friday    | Thursday
   |         |  6 | Saturday  | Friday
   |         |  7 | Sunday    | Saturday

Parameters
------------------------------------------------------------------------------------------------------------
DayOfWeekText | text   | Day of week name
[Traditional] | switch | Return day of week using traditional numbering scheme.

Examples
------------------------------------------------------------------------------------------------------------
PARSE_WEEKDAY("Saturday")
Returns: 6

PARSE_WEEKDAY("Mon", 1)
Returns: 2

PARSE_WEEKDAY("Thurs")
Returns: #VALUE!

PARSE_WEEKDAY("Ven")
Returns: 5 (Friday, if local language is set to Italian)
----------------------------------------------------------------------------------------------------------*/
PARSE_WEEKDAY = LAMBDA(DayOfWeekText, [Traditional],
    IF(DayOfWeekText = "", "",
        LET(
            fnMatchIntEng, LAMBDA(DoW,
                LET(
                    _dow, IF(LEN(DayOfWeekText) = 3,
                        XMATCH(
                            DayOfWeekText,
                            {
                                "Mon";
                                "Tue";
                                "Wed";
                                "Thu";
                                "Fri";
                                "Sat";
                                "Sun"
                            }
                        ),
                        XMATCH(
                            DayOfWeekText,
                            {
                                "Monday";
                                "Tuesday";
                                "Wednesday";
                                "Thursday";
                                "Friday";
                                "Saturday";
                                "Sunday"
                            }
                        )
                    ),
                    IFNA(_dow, 0)
                )
            ),
            fnMatchLocalLang, LAMBDA(DoW,
                LET(
                    _days, SEQUENCE(7, 1, 36528),
                    _dow, IF(LEN(DayOfWeekText) = 3,
                        XMATCH(DayOfWeekText, TEXT(_days, "ddd")),
                        XMATCH(DayOfWeekText, TEXT(_days, "dddd"))
                    ),
                    IFNA(_dow, 0)
                )
            ),
            _ISOWeekday, LET(
                _idx, fnMatchIntEng(DayOfWeekText),
                IF(_idx > 0, _idx, fnMatchLocalLang(DayOfWeekText))
            ),
            IFS(_ISOWeekday = 0, {#VALUE!},
                N(Traditional) = 0, _ISOWeekday,
                TRUE, MOD(_ISOWeekday, 7) + 1
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
PARSE_MONTH

Returns a number representing the month of year from a given text month name.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer [1..12] | Month

Parameters
------------------------------------------------------------------------------------------------------------
MonthText | text | Month name

Examples
------------------------------------------------------------------------------------------------------------
PARSE_MONTH("Feb")
Returns: 2

PARSE_MONTH("January")
Returns: 1

PARSE_MONTH("J")
Returns: #VALUE!

PARSE_MONTH("Marzo")
Returns: 3 (if local language is set to Italian)
----------------------------------------------------------------------------------------------------------*/
PARSE_MONTH = LAMBDA(MonthText,
    IF(MonthText = "", "",
        MONTH(DATEVALUE(MonthText & " 2000"))
    )
);





/*----------------------------------------------------------------------------------------------------------
PARSE_ISO_TIME

Parses an ISO formatted time of day into decimal time of day.

Output
------------------------------------------------------------------------------------------------------------
 1 | decimal [0..1] | Time of day as decimal fraction of a day.

Parameters
------------------------------------------------------------------------------------------------------------
ISOTime | text   | Time in ISO format ie. hh:mm:ss.000

Examples
------------------------------------------------------------------------------------------------------------
PARSE_ISO_TIME("12:00")
Returns: 0.5

PARSE_ISO_TIME("24:00:01")
Returns: #NUM!  i.e. range is 0 to 24 hours 
----------------------------------------------------------------------------------------------------------*/
PARSE_ISO_TIME = LAMBDA(ISOTime,
    IFS(
        ISOTime = "", "",
        CODE(ISOTime) <> 84, {#VALUE!},
        TRUE, LET(
            _len, LEN(ISOTime) - 1,
            _timePart, RIGHT(ISOTime, _len),
            _pattern, REPLACE_CHARS(_timePart, "0123456789", "_"),
            _tryParse, IFS(
                LEFT(_pattern, 10) = "__:__:__._",
                    HSTACK(
                        VALUE(LEFT(_timePart, 2)),
                        VALUE(MID(_timePart, 4, 2)),
                        VALUE(MID(_timePart, 7, 2)),
                        VALUE(RIGHT(_timePart, _len - 9)) * 10 ^ (12 - _len)
                    ),
                _pattern = "__:__:__",
                    HSTACK(
                        VALUE(LEFT(_timePart, 2)),
                        VALUE(MID(_timePart, 4, 2)),
                        VALUE(RIGHT(_timePart, 2)),
                        0
                    ),
                _pattern = "__:__",
                    HSTACK(
                        VALUE(LEFT(_timePart, 2)),
                        VALUE(RIGHT(_timePart, 2)),
                        0, 0
                    ),
                LEFT(_pattern, 8) = "______._",
                    HSTACK(
                        VALUE(LEFT(_timePart, 2)),
                        VALUE(MID(_timePart, 3, 2)),
                        VALUE(MID(_timePart, 5, 2)),
                        VALUE(RIGHT(_timePart, _len - 7)) * 10 ^ (10 - _len)
                    ),
                _pattern = "______",
                    HSTACK(
                        VALUE(LEFT(_timePart, 2)),
                        VALUE(MID(_timePart, 3, 2)),
                        VALUE(RIGHT(_timePart, 2)),
                        0
                    ),
                _pattern = "____",
                    HSTACK(
                        VALUE(LEFT(_timePart, 2)),
                        VALUE(RIGHT(_timePart, 2)),
                        0, 0
                    ),
                _pattern = "__",
                    HSTACK(
                        VALUE(_timePart), 0, 0, 0
                    ),
                TRUE, ""
            ),
            IF(INDEX(_tryParse, 1, 1) = "", {#VALUE!},
                LET(
                    _hour, INDEX(_tryParse, 1, 1),
                    _minute, INDEX(_tryParse, 1, 2),
                    _second, INDEX(_tryParse, 1, 3) + INDEX(_tryParse, 1, 4) / 1000,
                    IF(NOT(IS_VALID_TIME_OF_DAY(_hour, _minute, _second, 1)), {#NUM!},
                        TIMESPAN(1, 0, _hour, _minute, _second)
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
PARSE_ISO_TZO

Parses an ISO formatted time zone offset into a decimal timespan.

Output
------------------------------------------------------------------------------------------------------------
 1 | decimal [-0.625..0.625] | Time zone offset as decimal fraction of a day

Parameters
------------------------------------------------------------------------------------------------------------
ISOTimeZoneOffset | text   | Time zone offset in ISO format ie. hh:mm

Examples
------------------------------------------------------------------------------------------------------------
PARSE_ISO_TZO("Z")
Returns: 0 i.e. UTC time zone (Zulu)

PARSE_ISO_TIME("06:00")
Returns: -0.25

PARSE_ISO_TIME("+16:00")
Returns: #NUM! i.e. range is 15:00 to +15:00
----------------------------------------------------------------------------------------------------------*/
PARSE_ISO_TZO = LAMBDA(ISOTimeZoneOffset,
    IF(ISOTimeZoneOffset = "", "",
        LET(
            _len, LEN(ISOTimeZoneOffset),
            IF((_len = 1) * (CODE(ISOTimeZoneOffset) = 90), 0,
                LET(
                    _sChar, LEFT(ISOTimeZoneOffset, 1),
                    _sign, IFS(
                        _sChar = "+", 1,
                        _sChar = "-", -1,
                        UNICODE(_sChar) = 8722, -1,
                        TRUE, 0
                    ),
                    IF(_sign = 0, {#VALUE!},
                        LET(
                            _tz, MID(ISOTimeZoneOffset, 2, _len - 1),
                            _pattern, REPLACE_CHARS(_tz, "0123456789", "_"),
                            _tryParse, IFS(
                                _pattern = "__:__:__",
                                    HSTACK(
                                        VALUE(LEFT(_tz, 2)),
                                        VALUE(MID(_tz, 4, 2)),
                                        VALUE(RIGHT(_tz, 2))
                                    ),
                                _pattern = "__:__",
                                    HSTACK(
                                        VALUE(LEFT(_tz, 2)),
                                        VALUE(RIGHT(_tz, 2)),
                                        0
                                    ),
                                _pattern = "______",
                                    HSTACK(
                                        VALUE(LEFT(_tz, 2)),
                                        VALUE(MID(_tz, 3, 2)),
                                        VALUE(RIGHT(_tz, 2))
                                    ),
                                _pattern = "____",
                                    HSTACK(
                                        VALUE(LEFT(_tz, 2)),
                                        VALUE(RIGHT(_tz, 2)),
                                        0
                                    ),
                                _pattern = "__",
                                    HSTACK(VALUE(_tz), 0, 0),
                                TRUE, ""
                            ),
                            
                            IF(INDEX(_tryParse, 1, 1) = "", {#VALUE!},
                                LET(
                                    _hour, INDEX(_tryParse, 1, 1),
                                    _minute, INDEX(_tryParse, 1, 2),
                                    _second, INDEX(_tryParse, 1, 3),
                                    IF(NOT(IS_VALID_TIME_OF_DAY(_hour, _minute, _second)), {#NUM!},
                                        LET(
                                            _absTZO, TIMESPAN(1, 0, _hour, _minute, _second),
                                            IF(_absTZO > 0.625, {#NUM!},
                                                _sign * _absTZO
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
PARSE_ISO_CALENDAR_DATE

Parses an ISO formatted calendar date into respective parts of year, month and day.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer | YearCE
 2 | integer | Month
 3 | integer | Day

Parameters
------------------------------------------------------------------------------------------------------------
ISOCalendarDate  | text   | Date in ISO format ie. yyyy-MM-dd
[JulianCalendar] | switch | Validate in the Julian proleptic calendar. Default is Gregorian
                 |        | proleptic calendar.

Examples
------------------------------------------------------------------------------------------------------------
PARSE_ISO_CALENDAR_DATE("2023-05-23")
Returns: {2023, 5, 23}

PARSE_ISO_CALENDAR_DATE("1900-02-29", 1)
Returns: {2023, 2, 29} i.e. Feb 29, 1900 is valid in the Julian calendar
----------------------------------------------------------------------------------------------------------*/
PARSE_ISO_CALENDAR_DATE = LAMBDA(ISOCalendarDate, [JulianCalendar],
    IFS(
        ISOCalendarDate = "", {"", "", ""},
        NOT(VALIDATE_CHARSET("+-0123456789" & UNICHAR(8722), ISOCalendarDate)), {#VALUE!, "", ""},
        TRUE, LET(
            _firstChar, LEFT(ISOCalendarDate, 1),
            _isSigned, IFS(
                _firstChar = "+", TRUE,
                _firstChar = "-", TRUE,
                _firstChar = UNICHAR(8722), TRUE,
                TRUE, FALSE
            ),
            _sign, IFS(
                NOT(_isSigned), 1,
                _firstChar = "-", -1,
                _firstChar = UNICHAR(8722), -1,
                TRUE, 1
            ),
            _unSigned, IF(_isSigned,
                RIGHT(ISOCalendarDate, LEN(ISOCalendarDate) - 1),
                ISOCalendarDate
            ),
            _len, LEN(_unSigned),
            _pattern, REPLACE_CHARS(_unSigned, "0123456789", "_"),
            _tryParse, IFS(
                _len >= 10, IFS(
                    _pattern = RIGHT("_______________-__-__", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 6)),
                        VALUE(MID(_unSigned, _len - 4, 2)),
                        VALUE(RIGHT(_unSigned, 2))
                    ),
                    _pattern = RIGHT("_______________-__", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 3)),
                        VALUE(RIGHT(_unSigned, 2)),
                        ""
                    ),
                    _pattern = RIGHT("___________________", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 4)),
                        VALUE(MID(_unSigned, _len - 3, 2)),
                        VALUE(RIGHT(_unSigned, 2))
                    ),
                    TRUE, ""
                ),
                _len >= 8, IFS(
                    _pattern = RIGHT("______-__", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 3)),
                        VALUE(RIGHT(_unSigned, 2)),
                        ""
                    ),
                    _pattern = RIGHT("_________", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 4)),
                        VALUE(MID(_unSigned, _len - 3, 2)),
                        VALUE(RIGHT(_unSigned, 2))
                    ),
                    TRUE, ""
                ),
                _len = 7, IF(
                    _pattern = "____-__",
                    HSTACK(
                        VALUE(LEFT(_unSigned, 4)),
                        VALUE(RIGHT(_unSigned, 2)),
                        ""
                    ),
                    ""
                ),
                (_len >= 4) * (_len <= 5),  IF(
                    _pattern = RIGHT("_____", _len),
                    HSTACK(
                        VALUE(_unSigned),
                        "",
                        ""
                    ),
                    ""
                ),
                TRUE, ""
            ),

            IF(INDEX(_tryParse, 1, 1) = "", {#VALUE!, "", ""},
                LET(
                    _year, _sign * INDEX(_tryParse, 1, 1),
                    _month, INDEX(_tryParse, 1, 2),
                    IFS(
                        _month = "", HSTACK(_year, "", ""),
                        (_month < 1) + (_month > 12), HSTACK(_year, {#NUM!}, ""),
                        TRUE, LET(
                            _day, INDEX(_tryParse, 1, 3),
                            IF(_day = "",
                                HSTACK(_year, _month, ""),    
                                IF(IS_VALID_DATE(_year, _month, _day, JulianCalendar),
                                    HSTACK(_year, _month, _day),
                                    HSTACK(_year, _month, {#NUM!})
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
PARSE_ISO_ORDINAL_DATE

Parses an ISO formatted ordinal date into respective parts of year, and ordinal day.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer          | YearCE
 2 | integer [1..366] | Ordinal day

Parameters
------------------------------------------------------------------------------------------------------------
ISOOrdinalDate   | text   | Date in ISO format ie. yyyy-ddd
[JulianCalendar] | switch | Validate in the Julian proleptic calendar. Default is Gregorian
                 |        | proleptic calendar.

Examples
------------------------------------------------------------------------------------------------------------
PARSE_ISO_ORDINAL_DATE("2023-223")
Returns: {2023, 223}

PARSE_ISO_ORDINAL_DATE("1900-366", 1)
Returns: {2023, 366} i.e. 1900 was a leap year in the Julian calendar
----------------------------------------------------------------------------------------------------------*/
PARSE_ISO_ORDINAL_DATE = LAMBDA(ISOOrdinalDate, [JulianCalendar],
    IFS(
        ISOOrdinalDate = "", {"", ""},
        NOT(VALIDATE_CHARSET("+-0123456789" & UNICHAR(8722), ISOOrdinalDate)), {#VALUE!, ""},
        TRUE, LET(
            _firstChar, LEFT(ISOOrdinalDate, 1),
            _isSigned, IFS(
                _firstChar = "+", TRUE,
                _firstChar = "-", TRUE,
                _firstChar = UNICHAR(8722), TRUE,
                TRUE, FALSE
            ),
            _sign, IFS(
                NOT(_isSigned), 1,
                _firstChar = "-", -1,
                _firstChar = UNICHAR(8722), -1,
                TRUE, 1
            ),
            _unSigned, IF(_isSigned,
                RIGHT(ISOOrdinalDate, LEN(ISOOrdinalDate) - 1),
                ISOOrdinalDate
            ),
            _len, LEN(_unSigned),
            _pattern, REPLACE_CHARS(_unSigned, "0123456789", "_"),
            _tryParse, IFS(
                _len >= 8, IF(
                    _pattern = RIGHT("_______________-___", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 4)),
                        VALUE(RIGHT(_unSigned, 3))
                    ),
                    ""
                ),
                _len = 7, IF(
                    _pattern = "_______",
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 3)),
                        VALUE(RIGHT(_unSigned, 3))
                    ),
                    ""
                ),
                (_len >= 4) * (_len <= 5), IF(
                    _pattern = RIGHT("_____", _len),
                    HSTACK(
                        VALUE(_unSigned),
                        ""
                    ),
                    ""
                ),
                TRUE, ""
            ),

            IF(INDEX(_tryParse, 1, 1) = "", {#VALUE!, ""},
                LET(
                    _year, _sign * INDEX(_tryParse, 1, 1),
                    _ordinalDay, INDEX(_tryParse, 1, 2),
                    IFS(
                        _ordinalDay = "", HSTACK(_year, ""),
                        IS_VALID_ORDINAL_DATE(_year, _ordinalDay, JulianCalendar),
                            HSTACK(_year, _ordinalDay),
                        TRUE,
                            HSTACK(_year, {#NUM!})
                    )
                )
            )
        )
    )
);
           

/*----------------------------------------------------------------------------------------------------------
PARSE_ISO_WEEK_DATE

Parses an ISO formatted week date into respective parts of year, week and weekday.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer | YearCE
 2 | integer | ISO week
 3 | integer | ISO week day

Parameters
------------------------------------------------------------------------------------------------------------
ISOWeekDate      | text   | Week date in ISO format ie. yyyy-Www-d
[JulianCalendar] | switch | Validate in the Julian proleptic calendar. Default is Gregorian
                 |        | proleptic calendar.

Examples
------------------------------------------------------------------------------------------------------------
PARSE_ISO_WEEK_DATE("2023-W05-1")
Returns: {2023, 5, 1}
----------------------------------------------------------------------------------------------------------*/
PARSE_ISO_WEEK_DATE = LAMBDA(ISOWeekDate, [JulianCalendar],
    IFS(
        ISOWeekDate = "", {"", "", ""},
        NOT(VALIDATE_CHARSET("+-0123456789W" & UNICHAR(8722), ISOWeekDate)), {#VALUE!, "", ""},
        TRUE, LET(
            _firstChar, LEFT(ISOWeekDate, 1),
            _isSigned, IFS(
                _firstChar = "+", TRUE,
                _firstChar = "-", TRUE,
                _firstChar = UNICHAR(8722), TRUE,
                TRUE, FALSE
            ),
            _sign, IFS(
                NOT(_isSigned), 1,
                _firstChar = "-", -1,
                _firstChar = UNICHAR(8722), -1,
                TRUE, 1
            ),
            _unSigned, IF(_isSigned,
                RIGHT(ISOWeekDate, LEN(ISOWeekDate) - 1),
                ISOWeekDate
            ),
            _len, LEN(_unSigned),
            _pattern, REPLACE_CHARS(_unSigned, "0123456789", "_"),
            _tryParse, IFS(
                _len >= 10, IFS(
                    _pattern = RIGHT("_______________-W__-_", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 6)),
                        VALUE(MID(_unSigned, _len - 3, 2)),
                        VALUE(RIGHT(_unSigned, 1))
                    ),
                    _pattern = RIGHT("_______________-W__", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 4)),
                        VALUE(RIGHT(_unSigned, 2)),
                        ""
                    ),
                    _pattern = RIGHT("_______________W___", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 4)),
                        VALUE(MID(_unSigned, _len - 2, 2)),
                        VALUE(RIGHT(_unSigned, 1))
                    ),
                    _pattern = RIGHT("_______________W__", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 3)),
                        VALUE(RIGHT(_unSigned, 2)),
                        ""
                    ),
                    TRUE, ""
                ),
                _len >= 8, IFS(
                    _pattern = RIGHT("_____-W__", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 4)),
                        VALUE(RIGHT(_unSigned, 2)),
                        ""
                    ),
                    _pattern = RIGHT("_____W___", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 4)),
                        VALUE(MID(_unSigned, _len - 2, 2)),
                        VALUE(RIGHT(_unSigned, 1))
                    ),
                    _pattern = RIGHT("______W__", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 3)),
                        VALUE(RIGHT(_unSigned, 2)),
                        ""
                    ),
                    TRUE, ""
                ),
                _len = 7, IF(
                    _pattern = "____W__",
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 3)),
                        VALUE(RIGHT(_unSigned, 2)),
                        ""
                    ),
                    ""
                ),
                (_len >= 4) * (_len <= 5), IF(
                    _pattern = RIGHT("_____", _len),
                    HSTACK(
                        VALUE(_unSigned),
                        "",
                        ""
                    ),
                    ""
                ),
                TRUE, ""
            ),

            IF(INDEX(_tryParse, 1, 1) = "", {#VALUE!, "", ""},
                LET(
                    _year, _sign * INDEX(_tryParse, 1, 1),
                    _week, INDEX(_tryParse, 1, 2),
                    IF(_week = "", HSTACK(_year, "", ""),
                        LET(
                            _invalidWeek, IFS(
                                _week < 1, TRUE,
                                _week <= 52, FALSE,
                                _week > 53, TRUE,
                                TRUE, WEEKS_IN_YEAR(_year, JulianCalendar) < 53
                            ),
                            IF(_invalidWeek, HSTACK(_year, {#NUM!}, ""),
                                LET(
                                    _day, INDEX(_tryParse, 1, 3),
                                    IF(_day = "", HSTACK(_year, _week, ""),
                                        IF((_day >= 1) * (_day <= 7),
                                            HSTACK(_year, _week, _day),
                                            HSTACK(_year, _week, {#NUM!})
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
PARSE_ISO_DATE

Parses an ISO formatted date into its respective parts.

Output
------------------------------------------------------------------------------------------------------------
 1 | text    | Type of date:
   |         |  C - calendar date
   |         |  O - ordinal date
   |         |  W - week date
   |         |  Y - year only
 2 | integer | Year
 3 | integer | Month / Week
 4 | integer | Day / Ordinal day / Week day

Parameters
------------------------------------------------------------------------------------------------------------
ISODate          | text   | Date in ISO format ie. yyyy-MM-dd
[JulianCalendar] | switch | Validate in the Julian proleptic calendar. Default is Gregorian
                 |        | proleptic calendar.

Examples
------------------------------------------------------------------------------------------------------------
PARSE_ISO_DATE("2023-05-23")
Returns: {"C", 2023, 5, 23}

PARSE_ISO_DATE("1900-02-29", 1)
Returns: {"C", 2023, 2, 29} i.e. Feb 29, 1900 is valid in the Julian calendar

PARSE_ISO_DATE("2023-W12-2")
Returns: {"W", 2023, 12, 2}
----------------------------------------------------------------------------------------------------------*/
PARSE_ISO_DATE = LAMBDA(ISODate, [JulianCalendar],
    IFS(
        ISODate = "", {"", "", "", ""},
        NOT(VALIDATE_CHARSET("+-0123456789W" & UNICHAR(8722), ISODate)), {#VALUE!, "", "", ""},
        IFERROR(FIND("W", ISODate), 0) > 0, HSTACK("W", PARSE_ISO_WEEK_DATE(ISODate, JulianCalendar)),
        TRUE, LET(
            _len, LEN(ISODate),
            _lastHyphen, FIND_NTH_CHAR("-", ISODate, -1),
            IFS(
                _len - _lastHyphen = 3, LET(
                    _Odate, PARSE_ISO_ORDINAL_DATE(ISODate, JulianCalendar),
                    HSTACK(
                        "O",
                        INDEX(_Odate, 1, 1),
                        "",
                        INDEX(_Odate, 1, 2)
                    )
                ),
                _len - _lastHyphen = 2,
                HSTACK("C", PARSE_ISO_CALENDAR_DATE(ISODate, JulianCalendar)),
                TRUE, LET(
                    _firstChar, LEFT(ISODate, 1),
                    _isSigned, IFS(
                        _firstChar = "+", TRUE,
                        _firstChar = "-", TRUE,
                        _firstChar = UNICHAR(8722), TRUE,
                        TRUE, FALSE
                    ),
                    _sign, IFS(
                        NOT(_isSigned), 1,
                        _firstChar = "-", -1,
                        _firstChar = UNICHAR(8722), -1,
                        TRUE, 1
                    ),
                    _unSigned, IF(_isSigned,
                        RIGHT(ISODate, LEN(ISODate) - 1),
                        ISODate
                    ),
                    _len, LEN(_unSigned),
                    _type, IFS(
                        _len >= 8, "C",
                        _len = 7, "O",
                        (_len >= 4) * (_len <= 5), "Y",
                        TRUE, ""
                    ),
                    IFS(
                        _type = "", {#VALUE!, "", "", ""},
                        _type = "O", LET(
                            _Odate, PARSE_ISO_ORDINAL_DATE(ISODate, JulianCalendar),
                            IF(ISERROR(INDEX(_Odate, 1, 1)), {#VALUE!, "", "", ""},
                                HSTACK("O",
                                    INDEX(_Odate, 1, 1),
                                    "",
                                    INDEX(_Odate, 1, 2)
                                )
                            )
                        ),
                        TRUE, LET(
                            _Cdate, PARSE_ISO_CALENDAR_DATE(ISODate, JulianCalendar),
                            IF(ISERROR(INDEX(_Cdate, 1, 1)), {#VALUE!, "", "", ""},
                                HSTACK(_type, _Cdate)
                            )
                        )
                    )
                )
            )
        )
    )
);



/*----------------------------------------------------------------------------------------------------------
PARSE_ISO_DATETIME

Parses an ISO formatted date and time into respective date parts, time, and time zone offset from UTC.
Providing a time zone offset on its own is invalid for this function.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer         | Year
 2 | integer         | Month
 3 | integer         | Day
 4 | decimal [0..1]  | Time
 5 | decimal         | Time zone offset from UTC
   | [-0.625..0.625] | 

Parameters
------------------------------------------------------------------------------------------------------------
ISODateTime      | text   | Date time in ISO format ie. yyyy-MM-ddThh:mm:ss+hh:mm
[NoMixedFormat]  | switch | Validate no mix of basic and extended formats. eg. yyyyMMddThh:mm 
[JulianCalendar] | switch | Validate in the Julian proleptic calendar. Default is Gregorian
                 |        | proleptic calendar.

Examples
------------------------------------------------------------------------------------------------------------
PARSE_ISO_DATETIME("2023-05-23")
Returns: {2023, 5, 23, "", ""}

PARSE_ISO_DATETIME("2023-05-23T06:00")
Returns: {2023, 5, 23, 0.25, ""}

PARSE_ISO_DATETIME("T12:00")
Returns: {"", "", "", 0.5, ""}

PARSE_ISO_DATETIME("T12:0006:00")
Returns: {"", "", "", 0.5, -0.25}

PARSE_ISO_DATETIME("2023-05-23T+09:00")
Returns: {2023, 5, 23, "", 0.375}
----------------------------------------------------------------------------------------------------------*/
PARSE_ISO_DATETIME = LAMBDA(ISODateTime, [AllowMixedStyles], [JulianCalendar],
    IFS(
        ISODateTime = "", {"", "", "", "", ""},
        NOT(VALIDATE_CHARSET("+,-.0123456789:TWZ" & UNICHAR(8722), ISODateTime)), {#VALUE!, "", "", "", ""},
        TRUE, LET(
            _Tpos, IFERROR(FIND("T", ISODateTime), 0),
            _parts, IF(_Tpos = 0, 
                HSTACK(ISODateTime, "", ""),
                LET(
                    _len, LEN(ISODateTime),
                    _datePart, LEFT(ISODateTime, _Tpos - 1),
                    _TZpos, FIND_NTH_CHAR("Z+-" & UNICHAR(8722), ISODateTime, 1, 0, _Tpos + 1),
                    IFS(
                        _TZpos = 0,
                        HSTACK(
                            _datePart,
                            RIGHT(ISODateTime, _len - _Tpos + 1),
                            ""
                        ),
                        _TZpos = _Tpos + 1,
                        HSTACK(
                            _datePart,
                            "",
                            RIGHT(ISODateTime, _len - _TZpos + 1)
                        ),
                        TRUE,
                        HSTACK(
                            _datePart,
                            MID(ISODateTime, _Tpos, _TZPos - _Tpos),
                            RIGHT(ISODateTime, _len - _TZpos + 1)
                        )
                    )
                )
            ),
            _failStyleCheck, IF(N(AllowMixedStyles) <> 0, FALSE,
                LET(
                    _fmtDate, IFS(
                        INDEX(_parts, 1, 1) = "", 3,
                        IFERROR(FIND("-", INDEX(_parts, 1, 1), 5), 0) > 0, 2,
                        TRUE, 1
                    ),
                    _fmtTime, IFS(
                        INDEX(_parts, 1, 2) = "", 3,
                        LEN(INDEX(_parts, 1, 2)) = 3, 3,
                        IFERROR(FIND(":", INDEX(_parts, 1, 2), 4), 0) > 0, 2,
                        TRUE, 1
                    ),
                    _fmtTZO, IFS(
                        INDEX(_parts, 1, 3) = "", 3,
                        CODE(INDEX(_parts, 1, 3)) = 90, 3,
                        LEN(INDEX(_parts, 1, 3)) = 3, 3,
                        IFERROR(FIND(":", INDEX(_parts, 1, 3), 4), 0) > 0, 2,
                        TRUE, 1
                    ),
                    IFS(
                        BITAND(_fmtDate, _fmtTime) = 0, TRUE,
                        BITAND(_fmtDate, _fmtTZO) = 0, TRUE,
                        BITAND(_fmtTime, _fmtTZO) = 0, TRUE,
                        TRUE, FALSE
                    )
                )
            ),
            IF(_failStyleCheck, {#N/A, "", "", "", ""},
                LET(
                    _time, PARSE_ISO_TIME(INDEX(_parts, 1, 2)),
                    _tzo, PARSE_ISO_TZO(INDEX(_parts, 1, 3)),
                    IF(INDEX(_parts, 1, 1) = "",
                        IF((_time = "") * (_tzo <> ""), {#VALUE!, "", "", "", ""},
                            HSTACK("", "", "", _time, _tzo)
                        ),
                        LET(
                            _date, PARSE_ISO_CALENDAR_DATE(INDEX(_parts, 1, 1), JulianCalendar),
                            HSTACK(_date, _time, _tzo)
                        )
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
PARSE_LITERARY_YEAR

Returns a number representing the year relative to the common era from a given literary year.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer | YearCE. Note that 1 BC = 0 CE, 2 BC = -1 CE

Parameters
------------------------------------------------------------------------------------------------------------
LiteraryYear | text | Literary year
----------------------------------------------------------------------------------------------------------*/
PARSE_LITERARY_YEAR = LAMBDA(LiteraryYear,
    IF(LiteraryYear = "", "",
        IF(NOT(VALIDATE_CHARSET(" -+0123456789BCE" & UNICHAR(8722), LiteraryYear)), {#VALUE!},
            LET(
                fnYearValue, LAMBDA(_text,
                    LET(
                        _char1, LEFT(_text, 1),
                        _sign, IFS(
                            _char1 = "+", 1,
                            _char1 = "-", -1,
                            UNICODE(_char1) = 8722, -1,
                            TRUE, ""
                        ),
                        IF(_sign = "",
                            INT(VALUE(_text)),
                            _sign * INT(VALUE(RIGHT(_text, LEN(_text) -1)))
                        )
                    )
                ),

                _litYear, SUBSTITUTE(SUBSTITUTE(LiteraryYear, ",", ""), " ", ""),
                _yearCE, IFS(
                    RIGHT(_litYear, 3) = "BCE",
                        LET(
                            _sYear, LEFT(_litYear, LEN(_litYear) - 3),
                            1 - fnYearValue(_sYear)
                        ),
                    RIGHT(_litYear, 2) = "CE",
                        LET(
                            _sYear, LEFT(_litYear, LEN(_litYear) - 2),
                            fnYearValue(_sYear)
                        ),
                    TRUE, fnYearValue(_litYear)
                ),
                
                IFERROR(_yearCE, {#VALUE!})
            )
        )
    )
);

/*----------------------------------------------------------------------------------------------------------
PARSE_LITERARY_DATE

Parses a literary date into respective parts of year, month, day and time of day.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer         | Year
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day
 4 | decimal [0..1]  | Time

Parameters
------------------------------------------------------------------------------------------------------------
LiteraryDate | text | Literary date and time

Examples
------------------------------------------------------------------------------------------------------------
PARSE_LITERARY_DATE("Feb 25, 2014, 6:00")
Returns: {2014, 2, 25, 0.25}

PARSE_LITERARY_DATE("Dec 31, 2023, 24:00")
Returns: {2023, 12, 31, 1}

PARSE_LITERARY_DATE("Feb 25")
Returns: {"" , 2, 25, ""}
----------------------------------------------------------------------------------------------------------*/
PARSE_LITERARY_DATE = LAMBDA(LiteraryDate,
    IF(LiteraryDate = "", {"", "", "", ""},
        LET(
            fnParseTime, LAMBDA(_timePart,
                LET(
                    _tryTime, DATEVALUE(_timePart) + TIMEVALUE(_timePart),
                    IFS(
                        ISERROR(_tryTime), "",
                        _tryTime > 1, {#NUM!},
                        TRUE, _tryTime
                    )
                )
            ),

            fnParseDay, LAMBDA(_dayPart, _year, _month,
                LET(
                    _day, INT(VALUE(_dayPart)),
                    IFS(
                        _day <= 0, {#NUM!},
                        _day <= DAYS_IN_MONTH(_month, _year, _year <= 1582), _day,
                        TRUE, {#NUM!}
                    )
                )
            ),

            _parts, TRIM(TEXTSPLIT(LiteraryDate, ",")),
            _cols, COLUMNS(_parts),
            IFS(_cols = 1,
                LET(
                    _part1, INDEX(_parts, 1, 1),
                    _spacePos, IFERROR(FIND(" ", _part1), 0),
                    IF(_spacePos = 0, {#VALUE!, "", "", ""},
                        LET(
                            _month, PARSE_MONTH(LEFT(_part1, _spacePos - 1)),
                            _daysInMonth, DAYS_IN_MONTH(_month, 2000),
                            _remain, MID(_part1, _spacePos + 1, LEN(_part1) - _spacePos),
                            _denotedYear, IFERROR(FIND("C", _remain), 0) > 0,
                            _val, IF(_denotedYear, PARSE_LITERARY_YEAR(_remain),
                                INT(VALUE(_remain))
                            ), 
                            _day, IFS(_denotedYear, "",
                                _val <= 0, "",
                                _val <= _daysInMonth, _val,
                                TRUE, ""
                            ),
                            _year, IFS(_denotedYear, _val,
                                _val <= 0, _val,
                                _val <= _daysInMonth, "",
                                TRUE, _val
                            ),
                            HSTACK(_year, _month, _day, "")
                        )
                    )
                ),
                _cols = 2,
                LET(
                    _p1, INDEX(_parts, 1, 1),
                    _spacePos, IFERROR(FIND(" ", _p1), 0),
                    IF(_spacePos = 0, {#VALUE!, "", "", ""},
                        LET(
                            _month, PARSE_MONTH(LEFT(_p1, _spacePos - 1)),
                            _p2, INDEX(_parts, 1, 2),
                            _time, fnParseTime(_p2),
                            _year, IF(NOT(ISNUMBER(_time)), PARSE_LITERARY_YEAR(_p2), ""),
                            _dayPart, MID(_p1, _spacePos + 1, LEN(_p1) - _spacePos),
                            _day, fnParseDay(_dayPart, _year, _month),
                            HSTACK(_year, _month, _day, _time)
                        )
                    )
                ),
                _cols = 3,
                LET(
                    _year, PARSE_LITERARY_YEAR(INDEX(_parts, 1, 2)),
                    _time, fnParseTime(INDEX(_parts, 1, 3)),
                    _p1, INDEX(_parts, 1, 1),
                    _spacePos, IFERROR(FIND(" ", _p1), 0),
                    IF(_spacePos = 0, {#VALUE!, "", "", ""},
                        LET(
                            _month, PARSE_MONTH(LEFT(_p1, _spacePos - 1)),
                            _dayPart, MID(_p1, _spacePos + 1, LEN(_p1) - _spacePos),
                            _day, fnParseDay(_dayPart, 2000, _month),
                            HSTACK(_year, _month, _day, _time)
                        )
                    )
                ),
                TRUE, {#VALUE!, "", "", ""}
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
PARSE_US_DATE

Parses a US formated date into respective parts of year, month, day and time of day.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer         | Year
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day
 4 | decimal [0..1)  | Time

Parameters
------------------------------------------------------------------------------------------------------------
USDate | text | Date in US format ie. MM/dd/yyyy hh:mm:ss

Examples
------------------------------------------------------------------------------------------------------------
PARSE_US_DATE("1/25/2014 6:00")
Returns: {2014, 1, 25, 0.25}

PARSE_US_DATE("12/31/2023 24:00")
Returns: {2023, 12, 31, 1}
----------------------------------------------------------------------------------------------------------*/
PARSE_US_DATE = LAMBDA(USDate,
    IFS(
        USDate = "", {"", "", "", ""},
        NOT(VALIDATE_CHARSET(" ,-./0123456789:AMPTamp_" & UNICHAR(8722), USDate)), {#VALUE!},
        TRUE, LET(
            fnYearValue, LAMBDA(_text,
                LET(
                    _char1, LEFT(_text, 1),
                    _sign, IFS(
                        _char1 = "+", 1,
                        _char1 = "-", -1,
                        UNICODE(_char1) = 8722, -1,
                        TRUE, ""
                    ),
                    IF(_sign = "",
                        INT(VALUE(_text)),
                        _sign * INT(VALUE(RIGHT(_text, LEN(_text) -1)))
                    )
                )
            ),

            _pos1, FIND_NTH_CHAR(",./-_", USDate, 1),
            _pos2, FIND_NTH_CHAR(",./-_", USDate, 2),
            _pos3, IF(_pos2 = 0, 0, FIND_NTH_CHAR(",./-_T ", USDate, 1, 0, _pos2 + 2)),
            _pos4, IF(_pos3 = 0, 0, FIND_NTH_CHAR("0123456789", USDate, 1, 0, MAX(_pos2, _pos3) + 1)),
            _month, IF(_pos1 = 0, {#VALUE!},
                INT(VALUE(LEFT(USDate, _pos1 - 1)))
            ),
            _day, IF(_pos2 = 0, {#VALUE!},
                INT(VALUE(MID(USDate, _pos1 + 1, _pos2 - _pos1 - 1)))
            ),
            _year, fnYearValue(
                IF(_pos3 = 0,
                    RIGHT(USDate, LEN(USDate) - _pos2),
                    MID(USDate, _pos2 + 1, _pos3 - _pos2 - 1)
                )
            ),
            _time, IF(_pos4 = 0, "",
                LET(
                    _timePart, RIGHT(USDate, LEN(USDate) - _pos4 + 1),
                    _timeVal, DATEVALUE(_timePart) + TIMEVALUE(_timePart),
                    IF(_timeVal >= 1, {#NUM!}, _timeVal)
                )
            ),
            HSTACK(_year, _month, _day, _time)
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
PARSE_MIL_DTG

Parses a date-time group in the format used by US Military message traffic, into respective parts of year,
month, day, time of day and time zone offset in minutes.

Output
------------------------------------------------------------------------------------------------------------
 1 | integer [1951..2050] | Year
 2 | integer [1..12]      | Month
 3 | integer [1..31]      | Day
 4 | decimal [0..1)       | Time
 5 | decimal [-900..900]  | Time zone offset minutes

Parameters
------------------------------------------------------------------------------------------------------------
DTG | text | Date-time group in US Military format ie. ddHHmmssZmmmYY

Examples
------------------------------------------------------------------------------------------------------------
PARSE_MIL_DTG("12 15 30 45 B MAY 23")
Returns: {2023, 5, 12, 0.77118055, 120}

PARSE_MIL_DTG("05064515KJUN00")
Returns: {2000, 6, 5, 0.281423611, 600}

PARSE_MIL_DTG("150600Z")
Returns: {"", "", 15, 0.25, 0}
----------------------------------------------------------------------------------------------------------*/
PARSE_MIL_DTG = LAMBDA(DTG,
    IF(DTG = "", {"", "", "", "", ""},
        LET(
            _DTG, SUBSTITUTE(DTG, " ", ""),
            IF(NOT(VALIDATE_CHARSET("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ", _DTG)), {#VALUE!, "", "", "", ""},
                LET(
                    fnYear, LAMBDA(_sYear,
                        LET(
                            _yy, VALUE(_sYear),
                            IF(_yy < 51, 2000 + _yy, 1900 + _yy)
                        )
                    ),

                    fnTime, LAMBDA(_hour, _minute, _second,
                        IF(NOT(IS_VALID_TIME_OF_DAY(_hour, _minute, _second, 0)), {#NUM!},
                            TIMESPAN(1, 0, _hour, _minute, _second)
                        )
                    ),

                    fnParseTZ, LAMBDA(_tzChar,
                        LET(
                            _code, CODE(_tzChar) - 64,
                            IFS(
                                _code = 26, 0, // Z = UTC
                                _code = 10, "", // J = Local Time
                                _code <= 0, {#VALUE!},
                                _code <= 9, _code / 24, // ABCDEFGHI -> +1..+9
                                _code <= 13, (_code - 1) / 24,  // KLM -> +10..+12
                                _code <= 25, (13 - _code) / 24, // NOPQRSTUVWXY -> -1..-12
                                TRUE, {#VALUE!}
                            )
                        )
                    ),

                    fnParseFull, LAMBDA(_DTG,
                        LET(
                            _day, VALUE(LEFT(_DTG, 2)),
                            _month, PARSE_MONTH(MID(_DTG, 10, 3)),
                            _year, fnYear(RIGHT(_DTG, 2)),
                            IF(NOT(IS_VALID_DATE(_year, _month, _day, 0)), {#VALUE!, "", "", "", ""},
                                LET(
                                    _hour, VALUE(MID(_DTG, 3, 2)),
                                    _minute, VALUE(MID(_DTG, 5, 2)),
                                    _second, VALUE(MID(_DTG, 7, 2)),
                                    _time, fnTime(_hour, _minute, _second),
                                    _tz, fnParseTZ(MID(_DTG, 9, 1)),
                                    HSTACK(
                                        _year,
                                        _month,
                                        _day,
                                        _time,
                                        _tz
                                    )
                                )
                            )
                        )
                    ),

                    fnParseShort, LAMBDA(_DTG,
                        LET(
                            _day, VALUE(LEFT(_DTG, 2)),
                            _month, PARSE_MONTH(MID(_DTG, 8, 3)),
                            _year, fnYear(RIGHT(_DTG, 2)),
                            IF(NOT(IS_VALID_DATE(_year, _month, _day, 0)), {#VALUE!, "", "", "", ""},
                                LET(
                                    _hour, VALUE(MID(_DTG, 3, 2)),
                                    _minute, VALUE(MID(_DTG, 5, 2)),
                                    _time, fnTime(_hour, _minute, 0),
                                    _tz, fnParseTZ(MID(_DTG, 7, 1)),
                                    HSTACK(
                                        _year,
                                        _month,
                                        _day,
                                        _time,
                                        _tz
                                    )
                                )
                            )
                        )
                    ),

                    fnParsePlan, LAMBDA(_DTG,
                        LET(
                            _day, VALUE(LEFT(_DTG, 2)),
                            _hour, VALUE(MID(_DTG, 3, 2)),
                            _minute, VALUE(MID(_DTG, 5, 2)),
                            _time, fnTime(_hour, _minute, 0),
                            _tz, fnParseTZ(MID(_DTG, 7, 1)),
                            HSTACK(
                                "",
                                "",
                                _day,
                                _time,
                                _tz
                            )
                        )
                    ),

                    _len, LEN(_DTG),
                    _fmt, IFS(_len = 14, 1, 
                        _len = 12, 2,
                        _len = 7, 3,
                        TRUE, 0
                    ),
                    IF(_fmt = 0, {#VALUE!, "", "", "", ""},
                        IFS(
                            _fmt = 1, fnParseFull(_DTG),
                            _fmt = 2, fnParseShort(_DTG),
                            _fmt = 3, fnParsePlan(_DTG)
                        )
                    )
                )
            )
        )
    )
);













/*##########################################################################################################
# TEXT                                                                                                     #
##########################################################################################################*/


/*----------------------------------------------------------------------------------------------------------
WEEKDAY_NAME

Returns name of an ISO day of week number as text.

Output
------------------------------------------------------------------------------------------------------------
 1 | text | Weekday

Parameters
------------------------------------------------------------------------------------------------------------
ISOWeekDay             | integer [1..7] | ISO day of week number
[Short]                | switch         | Return short format Mon..Sun
[InternationalEnglish] | switch         | International English instead of local language set in Excel
----------------------------------------------------------------------------------------------------------*/
WEEKDAY_NAME = LAMBDA(ISOWeekDay, [Short], [InternationalEnglish],
    IFS(
        ISOWeekDay = "", "",
        NOT(ISNUMBER(ISOWeekDay)), {#VALUE!},
        TRUE, LET(
            _useShort, N(Short) <> 0,
            _useLocalLang, N(InternationalEnglish) = 0,
            _isoDoW, MOD(INT(ISOWeekDay) - 1, 7) + 1, 
            IF(_useLocalLang,
                LET(
                    _y2krefDay, 36527 + _isoDoW,
                    _fmt, IF(_useShort, "ddd", "dddd"),
                    TEXT(_y2krefDay, _fmt)
                ),
                IF(
                    _useShort,
                    CHOOSE(_isoDoW,
                        "Mon",
                        "Tue",
                        "Wed",
                        "Thu",
                        "Fri",
                        "Sat",
                        "Sun"
                    ),
                    CHOOSE(_isoDoW,
                        "Monday",
                        "Tuesday",
                        "Wednesday",
                        "Thursday",
                        "Friday",
                        "Saturday",
                        "Sunday"
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
MONTH_NAME

Returns a month as text.

Output
------------------------------------------------------------------------------------------------------------
 1 | text | Month name

Parameters
------------------------------------------------------------------------------------------------------------
Month                  | integer [1..12] | Month
[Short]                | switch          | Return short format Jan..Dec
[InternationalEnglish] | switch          | International English instead of local language set in Excel
----------------------------------------------------------------------------------------------------------*/
MONTH_NAME = LAMBDA(Month, [Short], [InternationalEnglish],
    IFS(
        Month = "", "",
        NOT(ISNUMBER(Month)), #VALUE!,
        TRUE, LET(
            _useShort, N(Short) <> 0,
            _useLocalLang, N(InternationalEnglish) = 0,
            _month, INT(Month),
            IF(_useLocalLang,
                LET(
                    _dayOfMonth, DATE(2000, _month, 1),
                    _fmt, IF(_useShort, "MMM", "MMMM"),
                    TEXT(_dayOfMonth, _fmt)
                ),
                IF(
                    _useShort,
                    INDEX(
                        {
                            "Jan";
                            "Feb";
                            "Mar";
                            "Apr";
                            "May";
                            "Jun";
                            "Jul";
                            "Aug";
                            "Sep";
                            "Oct";
                            "Nov";
                            "Dec"
                        },
                        _month
                    ),
                    INDEX(
                        {
                            "January";
                            "February";
                            "March";
                            "April";
                            "May";
                            "June";
                            "July";
                            "August";
                            "September";
                            "October";
                            "November";
                            "December"
                        },
                        _month
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
FORMAT_TIMESPAN

Returns a timespan as text in the specified format from a given decimal timespan.

Output
------------------------------------------------------------------------------------------------------------
 1 | text    | Formatted timespan d.HH:mm:ss.000

Parameters
------------------------------------------------------------------------------------------------------------
TimeSpan       | decimal | Decimal timespan where a day = 1
[Options]      | text    | String with elements: [Style][+][P][<][~][MostSig][LeastSig]
               |         |    Style : null = Standard, I = ISO, E = European, L = Literary
               |         |        + : Display positive sign for non-negative values
               |         |        P : Pad leading values < 10 with zero. For example 1 hour -> 01
               |         |          : Note inapplicable to Literary style.
               |         |        < : Round by truncating components. Default is rounding to nearest.
               |         |        ~ : Floating display starting from MostSig, to no futher than LeastSig
               |         |          : If ommitted, default behaviour is fully expressed display from MostSig to LeastSig
               |         |  MostSig : most significant component
               |         | LeastSig : least significant component 
               |         | MostSig and LeastSig elements take the following:
               |         |        D : Day
               |         |        H : Hour
               |         |        M : Minute
               |         |        S : Second
               |         |        1 : Decisecond
               |         |        2 : Centisecond
               |         |        3 : Millisecond

Examples
------------------------------------------------------------------------------------------------------------
FORMAT_TIMESPAN(1.7865, "")
Returns: 1.18:52:33.600

FORMAT_TIMESPAN(1.7865, "H:S")
Returns: 42:52:34

FORMAT_TIMESPAN(1.7865, "IH:S<")
Returns: 42h52m33s

FORMAT_TIMESPAN(1.7865, "E+H:S")
Returns: +42h52'34"

FORMAT_TIMESPAN(1.7865, "H~S")
Returns: +42h52'34"
----------------------------------------------------------------------------------------------------------*/
/*
FORMAT_TIMESPAN = LAMBDA(TimeSpan, [Options],
    IFS(
        TimeSpan = "", "",
        NOT(ISNUMBER(TimeSpan)), {#VALUE!},
        TRUE, LET(
            _style, LET(
                _pos, SEARCH_NTH_CHAR("IEL", Options, 1, 1),
                IF(INDEX(_pos, 1, 1) = 0, "A", INDEX(_pos, 1, 2))
            ),

            _tryMostSigChar, SEARCH_NTH_CHAR("DHMS", Options, 1, 1),
            
            // Express from most significant element
            // day, hour, minute, second, null if not provided
            _mostSig, IFS(
                INDEX(_tryMostSigChar, 1, 1) = 0, "",
                INDEX(_tryMostSigChar, 1, 2) = "D", -3,
                INDEX(_tryMostSigChar, 1, 2) = "H", -2,
                INDEX(_tryMostSigChar, 1, 2) = "M", -1,
                INDEX(_tryMostSigChar, 1, 2) = "S", 0
            ),

            // Express to a desired precision (max 9 decimals for nanoseconds)
            // day, hour, minute, second, decimals, null if not provided
            // auto adjusted to no lower than _mostSig
            _leastSig, LET(
                _tryLeastSigChar, SEARCH_NTH_CHAR("DHMS123456789", Options, 1, 1, INDEX(_tryMostSigChar, 1, 1) + 1),
                _decimals, IFERROR(VALUE(INDEX(_tryLeastSigChar, 1, 2)), 0),
                IF(INDEX(_tryLeastSigChar, 1, 1) = 0, "",
                    LET(
                        _least, IFS(
                            _decimals > 0, _decimals,
                            INDEX(_tryLeastSigChar, 1, 2) = "D", -3,
                            INDEX(_tryLeastSigChar, 1, 2) = "H", -2,
                            INDEX(_tryLeastSigChar, 1, 2) = "M", -1,
                            INDEX(_tryLeastSigChar, 1, 2) = "S", 0
                        ),
                        IF(_mostSig = "", _least, MAX(_least, _mostSig))
                    )
                )
            ),
            
            IFS(
                _style = "A" , FORMAT_TIMESPAN_STANDARD(TimeSpan, _mostSig, _leastSig, Options),
                _style = "I" , FORMAT_TIMESPAN_ISO(TimeSpan, _mostSig, _leastSig, Options),
                _style = "E" , FORMAT_TIMESPAN_EURO(TimeSpan, _mostSig, _leastSig, Options),
                _style = "L" , fnFmtProvider_L(_rTimeSpan, _fixed, _mostSig, _showPrecision, Options)
                
            )
        )
    )
);

/*
FORMAT_TIMESPAN_STANDARD = LAMBDA(TimeSpan, MostSig, LeastSig, Options,
    LET(
        _maxPrecision, 9,
        _defaultPrecision, 0,
        _lowestSig, -2,
        _fixed, IFERROR(FIND("~", Options), 0) = 0,
        _truncate, IFERROR(FIND("<", Options), 0) > 0,
        _signPositive, IFERROR(FIND("+", Options), 0) > 0,
        _padLeading, IFERROR(FIND("P", Options), 0) > 0,
        
        // Precision at which to resolve the TimeSpan
        // If fixed style and not provided then set to default precision
        _rPrecision, IF(_fixed * (LeastSig = ""), _defaultPrecision, LeastSig),
        _rTimeSpan, RESOLVE_TIMESPAN(TimeSpan, _rPrecision, _truncate),
            
        // Display at precision, fixed style remains the same
        // if floating style allow to fall back to MostSig
        _showPrecision, IF(_fixed, _rPrecision,
            LET(
                _hasPrecision, TIME_SIGNIFICANCE(
                    INDEX(_rTimeSpan, 1, 1),
                    INDEX(_rTimeSpan, 1, 3),
                    INDEX(_rTimeSpan, 1, 4),
                    INDEX(_rTimeSpan, 1, 5)
                ),
                MAX(IF(MostSig = "", -3, MostSig), MIN(IF(_rPrecision = "", _maxPrecision, _rPrecision), _hasPrecision, _maxPrecision))
            )
        ),

        // Resolve sign
        _sign, IF(INDEX(_rTimeSpan, 1, 1) < 0,
            UNICHAR(8722),
            IF(_signPositive, "+", "")
        ),

        // If floating style, allow high end to float if MostSig not provided
        _high, IFS(
            _fixed, IF(MostSig = "", -3, MostSig),
            MostSig <> "", MostSig,
            TRUE, LET(
                _float, IFS(
                    INDEX(_rTimeSpan, 1, 2) > 0, -3,
                    INDEX(_rTimeSpan, 1, 3) > 0, -2,
                    INDEX(_rTimeSpan, 1, 4) > 0, -1,
                    TRUE, 0
                ),
                MIN(_float, _showPrecision, _lowestSig)
            )
        ),

        // Translate high significance to resolved timespan column [2..5]
        _leadCol, _high + 5,
        // Number of columns to display from resolved timespan [1..4]
        _n, MIN(_showPrecision, 0) - _high + 1,
        
        // Corresponding delims
        _prefix, TAKE({"", "", "", ""}, 1, _n), 
        // Last suffix is dropped
        _suffix, CHOOSECOLS(
            HSTACK(
                TAKE({".", ":", ":", ""}, 1, _n),
                {"", "", ""}
            ),
            SEQUENCE(1, _n, _leadCol - 1)
        ),
        
        _leadFmt, IF(_padLeading, "00", "0"),
        _midFmt, "00",
        _lastFmt, IF(_showPrecision < 0, "00",
            LET(
                _useSecFmt, IF(_leadCol = 5, _leadFmt, _midFmt),
                IF(_showPrecision = 0, _useSecFmt,
                    _useSecFmt & LEFT(".000000000", _showPrecision + 1)
                )
            )
        ),
        
        // General formatter
        fnFormat1(_rTimeSpan,
            HSTACK(
                _leadCol,
                _n,
                _sign,
                _leadFmt,
                _midFmt,
                _lastFmt,
                _prefix,
                _suffix
            )
        )
    )
);


FORMAT_TIMESPAN_ISO = LAMBDA(TimeSpan, MostSig, LeastSig, Options,
    LET(
        _maxPrecision, 9,
        _defaultPrecision, 0,
        _lowestSig, 0,
        _fixed, IFERROR(FIND("~", Options), 0) = 0,
        _truncate, IFERROR(FIND("<", Options), 0) > 0,
        _padLeading, IFERROR(FIND("P", Options), 0) > 0,
        
        // Precision at which to resolve the TimeSpan
        // If fixed style and not provided then set to default precision
        _rPrecision, IF(_fixed * (LeastSig = ""), _defaultPrecision, LeastSig),
        _rTimeSpan, RESOLVE_TIMESPAN(TimeSpan, _rPrecision, _truncate),
            
        // Display at precision, fixed style remains the same
        // if floating style allow to fall back to MostSig
        _showPrecision, IF(_fixed, _rPrecision,
            LET(
                _hasPrecision, TIME_SIGNIFICANCE(
                    INDEX(_rTimeSpan, 1, 1),
                    INDEX(_rTimeSpan, 1, 3),
                    INDEX(_rTimeSpan, 1, 4),
                    INDEX(_rTimeSpan, 1, 5)
                ),
                MAX(IF(MostSig = "", -3, MostSig), MIN(IF(_rPrecision = "", _maxPrecision, _rPrecision), _hasPrecision, _maxPrecision))
            )
        ),

        // If floating style, allow high end to float if MostSig not provided
        _high, IFS(
            _fixed, IF(MostSig = "", -3, MostSig),
            MostSig <> "", MostSig,
            TRUE, LET(
                _float, IFS(
                    INDEX(_rTimeSpan, 1, 2) > 0, -3,
                    INDEX(_rTimeSpan, 1, 3) > 0, -2,
                    INDEX(_rTimeSpan, 1, 4) > 0, -1,
                    TRUE, 0
                ),
                MIN(_float, _showPrecision, _lowestSig)
            )
        ),

        // Translate high significance to resolved timespan column [2..5]
        _leadCol, _high + 5,
        // Number of columns to display from resolved timespan [1..4]
        _n, MIN(_showPrecision, 0) - _high + 1,
        
        // Corresponding delims
        _prefix, CHOOSECOLS(
            {"", "T", "", ""},
            SEQUENCE(1, _n, 2 - N(_leadCol = 2))
        ),
        _suffix, CHOOSECOLS(
            {"D", "H", "M", "S"},
            SEQUENCE(1, _n, _leadCol - 1)
        ),
        
        _numFmt, IF(_padLeading, "00", "0"),
        _lastFmt, IF(_showPrecision <= 0, _numFmt,
            _numFmt & LEFT(".000000000", _showPrecision + 1)
        ),
        
        // General formatter
        fnFormat1(_rTimeSpan,
            HSTACK(
                _leadCol,
                _n,
                "P",
                _numFmt,
                _numFmt,
                _lastFmt,
                _prefix,
                _suffix
            )
        )
    )
);


FORMAT_TIMESPAN_EURO = LAMBDA(TimeSpan, MostSig, LeastSig, Options,
    LET(
        _maxPrecision, 9,
        _defaultPrecision, 0,
        _lowestSig, -2,
        _fixed, IFERROR(FIND("~", Options), 0) = 0,
        _truncate, IFERROR(FIND("<", Options), 0) > 0,
        _signPositive, IFERROR(FIND("+", Options), 0) > 0,
        _padLeading, IFERROR(FIND("P", Options), 0) > 0,
        
        // Precision at which to resolve the TimeSpan
        // If fixed style and not provided then set to default precision
        _rPrecision, IF(_fixed * (LeastSig = ""), _defaultPrecision, LeastSig),
        _rTimeSpan, RESOLVE_TIMESPAN(TimeSpan, _rPrecision, _truncate),
            
        // Display at precision, fixed style remains the same
        // if floating style allow to fall back to MostSig
        _showPrecision, IF(_fixed, _rPrecision,
            LET(
                _hasPrecision, TIME_SIGNIFICANCE(
                    INDEX(_rTimeSpan, 1, 1),
                    INDEX(_rTimeSpan, 1, 3),
                    INDEX(_rTimeSpan, 1, 4),
                    INDEX(_rTimeSpan, 1, 5)
                ),
                MAX(IF(MostSig = "", -3, MostSig), MIN(IF(_rPrecision = "", _maxPrecision, _rPrecision), _hasPrecision, _maxPrecision))
            )
        ),

        // Resolve sign
        _sign, IF(INDEX(_rTimeSpan, 1, 1) < 0,
            UNICHAR(8722),
            IF(_signPositive, "+", "")
        ),

        // If floating style, allow high end to float if MostSig not provided
        _high, IFS(
            _fixed, IF(MostSig = "", -3, MostSig),
            MostSig <> "", MostSig,
            TRUE, LET(
                _float, IFS(
                    INDEX(_rTimeSpan, 1, 2) > 0, -3,
                    INDEX(_rTimeSpan, 1, 3) > 0, -2,
                    INDEX(_rTimeSpan, 1, 4) > 0, -1,
                    TRUE, 0
                ),
                MIN(_float, _showPrecision, _lowestSig)
            )
        ),

        // Translate high significance to resolved timespan column [2..5]
        _leadCol, _high + 5,
        // Number of columns to display from resolved timespan [1..4]
        _n, MIN(_showPrecision, 0) - _high + 1,
        
        // Corresponding delims
        _prefix, TAKE({"", "", "", ""}, 1, _n), 
        _suffix, CHOOSECOLS(
            {"d", "h", "'", """"},
            SEQUENCE(1, _n, _leadCol - 1)
        ),
        
        _leadFmt, IF(_padLeading, "00", "0"),
        _midFmt, "00",
        _lastFmt, IF(_showPrecision < 0, "00",
            LET(
                _useSecFmt, IF(_leadCol = 5, _leadFmt, _midFmt),
                IF(_showPrecision = 0, _useSecFmt,
                    _useSecFmt & LEFT(".000000000", _showPrecision + 1)
                )
            )
        ),
        
        // General formatter
        fnFormat1(_rTimeSpan,
            HSTACK(
                _leadCol,
                _n,
                _sign,
                _leadFmt,
                _midFmt,
                _lastFmt,
                _prefix,
                _suffix
            )
        )
    )
);


FORMAT_TIMESPAN_LITERARY = LAMBDA(TimeSpan, MostSig, LeastSig, Options,
    LET(
        _maxPrecision, 9,
        _defaultPrecision, 0,
        _lowestSig, 0,
        _fixed, 0,
        _truncate, 1,
        _padLeading, 0,
        
        // Precision at which to resolve the TimeSpan
        // If fixed style and not provided then set to default precision
        _rPrecision, IF(_fixed * (LeastSig = ""), _defaultPrecision, LeastSig),
        _rTimeSpan, RESOLVE_TIMESPAN(TimeSpan, _rPrecision, _truncate),
            
        // Display at precision, fixed style remains the same
        // if floating style allow to fall back to MostSig
        _showPrecision, IF(_fixed, _rPrecision,
            LET(
                _hasPrecision, TIME_SIGNIFICANCE(
                    INDEX(_rTimeSpan, 1, 1),
                    INDEX(_rTimeSpan, 1, 3),
                    INDEX(_rTimeSpan, 1, 4),
                    INDEX(_rTimeSpan, 1, 5)
                ),
                MAX(IF(MostSig = "", -3, MostSig), MIN(IF(_rPrecision = "", _maxPrecision, _rPrecision), _hasPrecision, _maxPrecision))
            )
        ),

        // If floating style, allow high end to float if MostSig not provided
        _high, IFS(
            _fixed, IF(MostSig = "", -3, MostSig),
            MostSig <> "", MostSig,
            TRUE, LET(
                _float, IFS(
                    INDEX(_rTimeSpan, 1, 2) > 0, -3,
                    INDEX(_rTimeSpan, 1, 3) > 0, -2,
                    INDEX(_rTimeSpan, 1, 4) > 0, -1,
                    TRUE, 0
                ),
                MIN(_float, _showPrecision, _lowestSig)
            )
        ),

        // Translate high significance to resolved timespan column [2..5]
        _leadCol, _high + 5,
        // Number of columns to display from resolved timespan [1..4]
        _n, MIN(_showPrecision, 0) - _high + 1,
        
        // Corresponding delims
        _prefix, CHOOSECOLS(
            {"", "T", "", ""},
            SEQUENCE(1, _n, 2 - N(_leadCol = 2))
        ),
        _suffix, CHOOSECOLS(
            {" days", " hours", " minutes", "seconds"},
            SEQUENCE(1, _n, _leadCol - 1)
        ),
        
        _numFmt, IF(_padLeading, "00", "0"),
        _lastFmt, IF(_showPrecision <= 0, _numFmt,
            _numFmt & LEFT(".000000000", _showPrecision + 1)
        ),
        
        // General formatter
        fnFormat1(_rTimeSpan,
            HSTACK(
                _leadCol,
                _n,
                "P",
                _numFmt,
                _numFmt,
                _lastFmt,
                _prefix,
                _suffix
            )
        )
    )
);


fnFmtProvider_E = LAMBDA(_rTimeSpan, _fixed, _mostSig, _precision, _options,
    LET(
        _signPositive, IFERROR(FIND("+", _options), 0) > 0,
        _padLeading, IFERROR(FIND("P", _options), 0) > 0,

        _sign, IF(INDEX(_rTimeSpan, 1, 1) < 0,
            UNICHAR(8722),
            IF(_signPositive, "+", "")
        ),

        _high, IFS(
            _fixed, IF(_mostSig = "", -3, _mostSig),
            _mostSig <> "", _mostSig,
            TRUE, LET(
                _float, IFS(
                    INDEX(_rTimeSpan, 1, 2) > 0, -3,
                    INDEX(_rTimeSpan, 1, 3) > 0, -2,
                    INDEX(_rTimeSpan, 1, 4) > 0, -1,
                    TRUE, 0
                ),
                MIN(_float, _precision, 0)
            )
        ),

        _leadCol, _high + 5,
        _n, MIN(_precision, 0) - _high + 1,
        
        _delims, CHOOSECOLS(
            {"d", "h", "'", """"},
            SEQUENCE(1, _n, _leadCol - 1)
        ),
        
        _leadFmt, IF(_padLeading, "00", "0"),
        _midFmt, "00",
        _lastFmt, IF(_precision < 0, "00",
            LET(
                _useSecFmt, IF(_leadCol = 5, _leadFmt, _midFmt),
                IF(_precision = 0, _useSecFmt,
                    _useSecFmt & LEFT(".000000000", _precision + 1)
                )
            )
        ),
        
        HSTACK(
            _leadCol,
            _n,
            _sign,
            _leadFmt,
            _midFmt,
            _lastFmt,
            _delims
        )
    )
);


fnFmtProvider_L = LAMBDA(_rTimeSpan, _fixed, _mostSig, _precision, _options,
    LET(
        _signPositive, IFERROR(FIND("+", _options), 0) > 0,
        
        _sign, IF(INDEX(_rTimeSpan, 1, 1) < 0,
            UNICHAR(8722) & " ",
            IF(_signPositive, "+ ", "")
        ),

        _high, IF(_mostSig <> "", _mostSig,
            LET(
                _float, IFS(
                    INDEX(_rTimeSpan, 1, 2) > 0, -3,
                    INDEX(_rTimeSpan, 1, 3) > 0, -2,
                    INDEX(_rTimeSpan, 1, 4) > 0, -1,
                    TRUE, 0
                ),
                MIN(_float, _precision, 0)
            )
        ),

        _leadCol, _high + 5,
        _n, MIN(_precision, 0) - _high + 1,
        
        _delims, CHOOSECOLS(
            {" days ", " hours ", " minutes ", " seconds "},
            SEQUENCE(1, _n, _leadCol - 1)
        ),
        
        _numFmt, "0",
        _lastFmt, IF(_precision <= 0, _numFmt,
            _numFmt & LEFT(".000000000", _precision + 1)
        ),
        
        HSTACK(
            _leadCol,
            _n,
            _sign,
            _numFmt,
            _numFmt,
            _lastFmt,
            _delims
        )
    )
);


fnFormat1 = LAMBDA(_rTimeSpan, _fmtProvider,
    LET(
        _leadCol, INDEX(_fmtProvider, 1, 1),
        _n, INDEX(_fmtProvider, 1, 2),
        _designator, INDEX(_fmtProvider, 1, 3),
        _leadFmt, INDEX(_fmtProvider, 1, 4),
        _midFmt, INDEX(_fmtProvider, 1, 5),
        _lastFmt, INDEX(_fmtProvider, 1, 6),
        _prefix, CHOOSECOLS(_fmtProvider, SEQUENCE(1, _n, 7)),
        _suffix, CHOOSECOLS(_fmtProvider, SEQUENCE(1, _n, 7 + _n)),
        
        _leadElement, IFS(
            _leadCol = 2, INDEX(_rTimeSpan, 1, 2),
            _leadCol = 3, (INDEX(_rTimeSpan, 1, 2) * 24) + INDEX(_rTimeSpan, 1, 3),
            _leadCol = 4, (INDEX(_rTimeSpan, 1, 2) * 1440) + (INDEX(_rTimeSpan, 1, 3) * 60) + INDEX(_rTimeSpan, 1, 4),
            _leadCol = 5, (INDEX(_rTimeSpan, 1, 2) * 86400) + (INDEX(_rTimeSpan, 1, 3) * 3600) + (INDEX(_rTimeSpan, 1, 4) * 60) + INDEX(_rTimeSpan, 1, 5)
        ),
            
        _elements, IF(_n = 1, _leadElement,
            LET(
                _cols, SEQUENCE(1, _n - 1, _leadCol + 1),
                HSTACK(_leadElement, CHOOSECOLS(_rTimeSpan, _cols))
            )
        ),

        _fmts, IFS(
            _n = 1, HSTACK(_lastFmt),
            _n = 2, HSTACK(_leadFmt, _lastFmt),
            _n = 3, HSTACK(_leadFmt, _midFmt, _lastFmt),
            _n = 4, HSTACK(_leadFmt, _midFmt, _midFmt, _lastFmt),
            _n = 5, HSTACK(_leadFmt, _midFmt, _midFmt, _midFmt, _lastFmt)
        ),
        
        CONCAT(_designator, _prefix & TEXT(_elements, _fmts) & _suffix)
    )
);



fnFormat = LAMBDA(_rTimeSpan, _fmtProvider,
    LET(
        _day, INDEX(_rTimeSpan, 1, 2),
        _hour, INDEX(_rTimeSpan, 1, 3),
        _minute, INDEX(_rTimeSpan, 1, 4),
        _second, INDEX(_rTimeSpan, 1, 5),
        _high, INDEX(_fmtProvider, 1, 1),
        _low, INDEX(_fmtProvider, 1, 2),
        _sign, INDEX(_fmtProvider, 1, 3),
        _leadFmt, INDEX(_fmtProvider, 1, 4),
        _midFmt, INDEX(_fmtProvider, 1, 5),
        _secFmt, INDEX(_fmtProvider, 1, 6),
        _dMark, INDEX(_fmtProvider, 1, 7),
        _hMark, INDEX(_fmtProvider, 1, 8),
        _mMark, INDEX(_fmtProvider, 1, 9),
        _sMark, INDEX(_fmtProvider, 1, 10),
        IFS(
            _high = -3, IFS(
                _low >= 0,
                    CONCAT(
                        _sign,
                        TEXT(_day, _leadFmt),
                        _dMark,
                        TEXT(_hour, _midFmt),
                        _hMark,
                        TEXT(_minute, _midFmt),
                        _mMark,
                        TEXT(_second, _secFmt),
                        _sMark
                    ),
                _low = -1,
                    CONCAT(
                        _sign,
                        TEXT(_day, _leadFmt),
                        _dMark,
                        TEXT(_hour, _midFmt),
                        _hMark,
                        TEXT(_minute, _midFmt),
                        _mMark
                    ),
                _low = -2,
                    CONCAT(
                        _sign,
                        TEXT(_day, _leadFmt),
                        _dMark,
                        TEXT(_hour, _midFmt),
                        _hMark
                    ),
                _low = -3,
                    CONCAT(
                        _sign,
                        TEXT(_day, _leadFmt),
                        _dMark
                    ),
                TRUE, "#TIMESPAN!"
            ),
            _high = -2, LET(
                _hours, (_day * 24) + _hour,
                IFS(
                    _low >= 0,
                        CONCAT(
                            _sign,
                            TEXT(_hour, _leadFmt),
                            _hMark,
                            TEXT(_minute, _midFmt),
                            _mMark,
                            TEXT(_second, _secFmt),
                            _sMark
                        ),
                    _low = -1,
                        CONCAT(
                            _sign,
                            TEXT(_hour, _leadFmt),
                            _hMark,
                            TEXT(_minute, _midFmt),
                            _mMark
                        ),
                    _low = -2,
                        CONCAT(
                            _sign,
                            TEXT(_hour, _leadFmt),
                            _hMark
                        ),
                    TRUE, "#TIMESPAN!"
                )
            ),
            _high = -1, LET(
                _minutes, (_day * 1440) + (_hour * 60) + _minute,
                IFS(
                    _low >= 0,
                        CONCAT(
                            _sign,
                            TEXT(_minutes, _leadFmt),
                            _mMark,
                            TEXT(_second, _secFmt),
                            _sMark
                        ),
                    _low = -1,
                        CONCAT(
                            _sign,
                            TEXT(_minutes, _leadFmt),
                            _mMark
                        ),
                    TRUE, "#TIMESPAN!"
                )
            ),
            _high = 0, LET(
                _seconds, (_day * 86400) + (_hour * 3600) + (_minute * 60) + _second,
                IF(_low >= 0,
                    CONCAT(
                        _sign,
                        TEXT(_seconds , _secFmt),
                        _sMark
                    ),
                    "#TIMESPAN!"
                )
            ),
            TRUE, "#TIMESPAN!"
        )
    )
);




/*----------------------------------------------------------------------------------------------------------
FORMAT_ISO_TIME

Returns a time as text in ISO format.

Output
------------------------------------------------------------------------------------------------------------
 1 | text | ISO formatted time

Parameters
------------------------------------------------------------------------------------------------------------
Time             | decimal [0..1] | Time of day as decimal fraction of a day.
[Options]        | text           | String with elements: [B][<][~][Significance]
                 |                |  B : Display in basic format eg T0000
                 |                |  < : Round by truncating components. Default is rounding to nearest.
                 |                |  ~ : Floating display starting from Significance if provided
                 |                |  Significance : least significant component where:
                 |                |    Null : Defaults to seconds
                 |                |       H : Hour
                 |                |       M : Minute
                 |                |       S : Second
                 |                |       T : Millisecond (Ticks)
----------------------------------------------------------------------------------------------------------*/
/*
FORMAT_ISO_TIME = LAMBDA(Time, [Options],
    IF(Time = "", "",
        IF(NOT(ISNUMBER(Time)), {#VALUE!},
            IF((Time < 0) + (Time > 1), {#NUM!},
                LET(
                    _basic, IF(Options = "", FALSE,
                        IFERROR(SEARCH("B", Options), 0) > 0
                    ),
                    _fixed, IF(Options = "", TRUE,
                        IFERROR(FIND("~", Options), 0) = 0
                    ),
                    _truncate, IF(Options = "", FALSE,
                        IFERROR(FIND("<", Options), 0) > 0
                    ),
                    _precision, LET(
                        _trySigChar, SEARCH_NTH_CHAR("HMST", Options, 1, 1),
                        IFS(
                            INDEX(_trySigChar, 1, 1) = 0, IF(_fixed, 4, 0),
                            INDEX(_trySigChar, 1, 2) = "H", 2,
                            INDEX(_trySigChar, 1, 2) = "M", 3,
                            INDEX(_trySigChar, 1, 2) = "S", 4,
                            INDEX(_trySigChar, 1, 2) = "T", 5
                        )
                    ),
                    _usePrecision, IF(_fixed, _precision, 0),
                    _rTime, RESOLVE_TIMESPAN(Time, _usePrecision, _truncate),
                    _showPrecision, IF(_fixed, _precision, MAX(_precision, INDEX(_rTime, 1, 7))),
                    _delim, IF(_basic, "", ":"),
                    IFS(
                        _showPrecision = 5,
                            CONCAT(
                                "T", TEXT(INDEX(_rTime, 1, 3), "00"),
                                _delim, TEXT(INDEX(_rTime, 1, 4), "00"),
                                _delim, TEXT(INDEX(_rTime, 1, 5), "00"),
                                ".", TEXT(INDEX(_rTime, 1, 6), "000")
                            ),
                        _showPrecision = 4,
                            CONCAT(
                                "T", TEXT(INDEX(_rTime, 1, 3), "00"),
                                _delim, TEXT(INDEX(_rTime, 1, 4), "00"),
                                _delim, TEXT(INDEX(_rTime, 1, 5), "00")
                            ),
                        _showPrecision = 3,
                            CONCAT(
                                "T", TEXT(INDEX(_rTime, 1, 3), "00"),
                                _delim, TEXT(INDEX(_rTime, 1, 4), "00")
                            ),
                        _showPrecision = 2,
                            CONCAT(
                                "T", TEXT(INDEX(_rTime, 1, 3), "00")
                            )
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
FORMAT_ISO_TZO

Returns a time zone offset as text in ISO format.

Output
------------------------------------------------------------------------------------------------------------
 1 | text | ISO formatted time zone offset

Parameters
------------------------------------------------------------------------------------------------------------
TimeZoneOffset | decimal         | Time zone offset from UTC as decimal fraction of a day.
               | [-0.625..0.625] | Assumed to be UTC if ommitted. [-15:00..+15:00]
[Options]      | text            | String with elements: [B][Z]
               |                 |  B : Display in basic format eg +0000
               |                 |  Z : Display 'Z' for Zulu time zone +00:00
----------------------------------------------------------------------------------------------------------*/
FORMAT_ISO_TZO = LAMBDA(TimeZoneOffset, [Options],
    IF(TimeZoneOffset = "", "",
        IF(NOT(ISNUMBER(TimeZoneOffset)), {#VALUE!},
            LET(
                _basic,  IF(Options = "", FALSE,
                    IFERROR(SEARCH("B", Options), 0) > 0
                ),
                _zulu,  IF(Options = "", FALSE,
                    IFERROR(SEARCH("Z", Options), 0) > 0
                ),
                _tzo, ABS(TimeZoneOffset),
                IF((_tzo = 0) * _zulu, "Z",
                    IF(_tzo > 0.625, {#NUM!},
                        LET(
                            _sign, IF(TimeZoneOffset >= 0, "+", UNICHAR(8722)), 
                            _delim, IF(_basic, "", ":"),
                            _hasSeconds, MOD(INT(_tzo * 86400), 60) > 0,
                            IF(_hasSeconds,
                                LET(
                                    _rTZO, RESOLVE_TIMESPAN(_tzo, 4, 1),
                                    CONCAT(
                                        _sign,
                                        TEXT(INDEX(_rTZO, 1, 3), "00"),
                                        _delim, TEXT(INDEX(_rTZO, 1, 4), "00"),
                                        _delim, TEXT(INDEX(_rTZO, 1, 5), "00")
                                    )
                                ),
                                LET(
                                    _rTZO, RESOLVE_TIMESPAN(_tzo, 3),
                                    CONCAT(
                                        _sign,
                                        TEXT(INDEX(_rTZO, 1, 3), "00"),
                                        _delim, TEXT(INDEX(_rTZO, 1, 4), "00")
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
FORMAT_ISO_YEAR

Returns a year as text in ISO format.

Output
------------------------------------------------------------------------------------------------------------
 1 | text | ISO formatted year

Parameters
------------------------------------------------------------------------------------------------------------
YearCE | integer | Note that 1 BC = 0 CE, 2 BC = -1 CE
----------------------------------------------------------------------------------------------------------*/
FORMAT_ISO_YEAR = LAMBDA(YearCE,
    IF((YearCE = ""), "",
        IF(NOT(ISNUMBER(YearCE)), {#VALUE!},
            IF(NOT(IS_INTEGER(YearCE)), {#NUM!},
                LET(
                    _yearFmt, IF((YearCE >= 1000) * (YearCE <= 9999),
                        "0000;" & UNICHAR(8722) & "0000",
                        "+0000;" & UNICHAR(8722) & "0000"
                    ),
                    TEXT(YearCE, _yearFmt)
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
FORMAT_ISO_CALENDAR_DATE

Returns a calendar date as text in ISO format.

Output
------------------------------------------------------------------------------------------------------------
 1 | text | ISO formatted date

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] |
Day              | integer [1..31] |
[Basic]          | switch          | Display in basic format eg yyyyMMdd
                 |                 | Invalid when Day not provided and YearCE outside of range
                 |                 | -9999..9999 due to collision with yyyyddd ISO format.
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar. 
----------------------------------------------------------------------------------------------------------*/
FORMAT_ISO_CALENDAR_DATE = LAMBDA(YearCE, Month, Day, [Basic], [JulianCalendar],
    IF((YearCE = "") * (Month = "") * (Day = ""), "",
        IF(NOT(ISNUMBER(YearCE)), {#VALUE!},
            IF(((Month <> "") * NOT(ISNUMBER(Month))) + ((Day <> "") * NOT(ISNUMBER(Day))), {#VALUE!},
                IF((Month = "") * ISNUMBER(Day), {#VALUE!},
                    IF(Month = "", FORMAT_ISO_Year(YearCE),
                        IF(NOT(IS_VALID_DATE(YearCE, Month, Day, JulianCalendar)), {#NUM!},
                            LET(
                                _basic, N(Basic) <> 0,
                                _delim, IF(_basic, "", "-"),
                                IF(Day = "",
                                    IF(_basic * (ABS(YearCE) > 9999), {#VALUE!},
                                        CONCAT(
                                            FORMAT_ISO_Year(YearCE),
                                            _delim, TEXT(Month, "00")
                                        )
                                    ),
                                    CONCAT(
                                        FORMAT_ISO_Year(YearCE),
                                        _delim, TEXT(Month, "00"),
                                        _delim, TEXT(Day, "00")
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
FORMAT_ISO_ORDINAL_DATE

Returns an ordinal date as text in ISO format.

Output
------------------------------------------------------------------------------------------------------------
 1 | text | ISO formatted ordinal date

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | integer          | Note that 1 BC = 0 CE, 2 BC = -1 CE
OrdinalDay       | integer [1..366] |
[Basic]          | switch           | Display in basic format eg yyyyddd.
                 |                  | Invalid when YearCE outside of range -9999..9999 due to collision
                 |                  | with yyyyMMdd ISO format.
[JulianCalendar] | switch           | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                  | proleptic calendar. 
----------------------------------------------------------------------------------------------------------*/
FORMAT_ISO_ORDINAL_DATE = LAMBDA(YearCE, OrdinalDay, [Basic], [JulianCalendar],
    IF((YearCE = "") * (OrdinalDay = ""), "",
        IF(NOT(ISNUMBER(YearCE)), {#VALUE!},
            IF((OrdinalDay <> "") * NOT(ISNUMBER(OrdinalDay)), {#VALUE!},
                IF(OrdinalDay = "", FORMAT_ISO_Year(YearCE),
                    LET(
                        _basic, N(Basic) <> 0,
                        IF(_basic * (ABS(YearCE) > 9999), {#VALUE!},
                            LET(
                                _delim, IF(_basic, "", "-"),
                                IF(NOT(IS_VALID_ORDINAL_DATE(YearCE, OrdinalDay, JulianCalendar)), {#NUM!},
                                    CONCAT(
                                        FORMAT_ISO_Year(YearCE),
                                        _delim, TEXT(OrdinalDay, "000")
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
FORMAT_ISO_WEEK_DATE

Returns a week date as text in ISO format.

Output
------------------------------------------------------------------------------------------------------------
 1 | text | ISO formatted week date

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Note that 1 BC = 0 CE, 2 BC = -1 CE
ISOWeek          | integer [1..53] | Note most years have 52 ISO weeks
[ISOWeekDay]     | integer [1..7]  | ISO day of week Monday..Sunday
[Basic]          | switch          | Display in basic format eg yyyyWwwd
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar. 
----------------------------------------------------------------------------------------------------------*/
FORMAT_ISO_WEEK_DATE = LAMBDA(YearCE, ISOWeek, [ISOWeekDay], [Basic], [JulianCalendar],
    IF((YearCE = "") * (ISOWeek = "") * (ISOWeekDay = ""), "",
        IF(NOT(ISNUMBER(YearCE)), {#VALUE!},
            IF(((ISOWeek <> "") * NOT(ISNUMBER(ISOWeek))) + ((ISOWeekDay <> "") * NOT(ISNUMBER(ISOWeekDay))), {#VALUE!},
                IF((ISOWeek = "") * ISNUMBER(ISOWeekDay), {#VALUE!},
                    LET(
                        _delim, IF(N(Basic) = 0, "-", ""),
                        IF(ISOWeek = "", FORMAT_ISO_Year(YearCE),
                            IF(NOT(IS_VALID_WEEK_DATE(YearCE, ISOWeek, ISOWeekDay, JulianCalendar)), {#NUM!},
                                IF(ISOWeekDay = "",
                                    CONCAT(
                                        FORMAT_ISO_Year(YearCE),
                                        _delim, "W", TEXT(ISOWeek, "00")
                                    ),
                                    CONCAT(
                                        FORMAT_ISO_Year(YearCE),
                                        _delim, "W", TEXT(ISOWeek, "00"),
                                        _delim, TEXT(ISOWeekDay, "0")
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
FORMAT_ISO_DATE

Returns a date as text in ISO format.

Output
------------------------------------------------------------------------------------------------------------
 1 | text | ISO formatted date

Parameters
------------------------------------------------------------------------------------------------------------
Type             | text     | Type of date
                 |          |  C - calendar date
                 |          |  O - ordinal date
                 |          |  W - week date
                 |          |  Y - year only
YearCE           | integer  | Note that 1 BC = 0 CE, 2 BC = -1 CE
DatePart2        | integer  | [1..12] for calendar date, [1..53] for week date
DatePart3        | integer  | [1..31] for calendar date, [1..366] for ordinal date
[Basic]          | switch   | Display in basic format eg yyyyMMdd
[JulianCalendar] | switch   | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |          | proleptic calendar. 
----------------------------------------------------------------------------------------------------------*/
FORMAT_ISO_DATE = LAMBDA(Type, YearCE, DatePart2, DatePart3, [Basic], [JulianCalendar],
    IF(NOT(ISERROR(Type)) * (YearCE = "") * (DatePart2 = "") * (DatePart3 = ""), "",
        IFS(
            Type = "C", FORMAT_ISO_CALENDAR_DATE(YearCE, DatePart2, DatePart3, Basic, JulianCalendar),
            Type = "O", FORMAT_ISO_ORDINAL_DATE(YearCE, DatePart3, Basic, JulianCalendar),
            Type = "W", FORMAT_ISO_WEEK_DATE(YearCE, DatePart2, DatePart3, Basic, JulianCalendar),
            Type = "Y", FORMAT_ISO_YEAR(YearCE),
            TRUE, {#VALUE!}
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
FORMAT_ISO_DATETIME

Returns a date, time and time zone offset as text in ISO format.

Output
------------------------------------------------------------------------------------------------------------
 1 | text | ISO formatted date, time and time zone offset

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] |
Day              | integer [1..31] |
[Time]           | decimal [0..1]  | Time of day as decimal fraction of a day.
[TimeZoneOffset] | decimal         | Time zone offset from UTC as decimal fraction of a day.
                 | [-0.625..0.625] | Assumed to be UTC if ommitted. [-15:00..+15:00]
[Options]        | text            | String with elements: [B][<][~][Significance][Z]
                 |                 |  B : Display in basic format eg T0000
                 |                 |  < : Round by truncating components. Default is rounding to nearest.
                 |                 |  ~ : Floating display starting from Significance
                 |                 |  Significance : least significant component where:
                 |                 |    Null : Defaults to seconds if time present, otherwise day
                 |                 |       D : Day
                 |                 |       H : Hour
                 |                 |       M : Minute
                 |                 |       S : Second
                 |                 |       T : Millisecond (Ticks)
                 |                 |  Z : Display 'Z' for Zulu time zone +00:00
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar. 
----------------------------------------------------------------------------------------------------------*/
/*
FORMAT_ISO_DATETIME = LAMBDA(YearCE, Month, Day, [Time], [TimeZoneOffset], [Options], [JulianCalendar],
    IF((YearCE = "") * (Month = "") * (Day = "") * (Time = ""), "",
        LET(
            _hasDate, ISNUMBER(YearCE) * ISNUMBER(Month) * ISNUMBER(Day),
            _hasTime, ISNUMBER(Time),
            IF(_hasDate + _hasTime = 0, {#VALUE!},
                LET(
                    _basic, IFERROR(SEARCH("B", Options), 0) > 0,
                    _fixed, IFERROR(FIND("~", Options), 0) = 0,
                    _truncate, IFERROR(FIND("<", Options), 0) > 0,
                    _trySigChar, SEARCH_NTH_CHAR("DHMST", Options, 1, 1),
                    _precision, IFS(
                        INDEX(_trySigChar, 1, 1) = 0, IF(_fixed, 4, 0),
                        INDEX(_trySigChar, 1, 2) = "D", 1,
                        INDEX(_trySigChar, 1, 2) = "H", 2,
                        INDEX(_trySigChar, 1, 2) = "M", 3,
                        INDEX(_trySigChar, 1, 2) = "S", 4,
                        INDEX(_trySigChar, 1, 2) = "T", 5
                    ),
                    _usePrecision, IF(_fixed, _precision, 0),
                    
                    _timeOutOfRange, _hasTime * ((Time < 0) + (Time > 1) > 0),
                    _time, IF(_timeOutOfRange, 0, Time),
                    _resolve, IFS(
                        NOT(_hasDate),
                            HSTACK(
                                "",
                                ROUND_TIMESPAN(_time, _usePrecision, _truncate)
                            ),
                        NOT(IS_VALID_DATE(YearCE, Month, Day, JulianCalendar)),
                            HSTACK(
                                "#DATE!",
                                ROUND_TIMESPAN(_time, _usePrecision, _truncate)
                            ),
                        TRUE, 
                            LET(
                                _rDate, RESOLVE_DATE(YearCE, Month, Day, _time, _usePrecision, _truncate, JulianCalendar),
                                _sDate, FORMAT_ISO_CALENDAR_DATE(
                                    INDEX(_rDate, 1, 1),
                                    INDEX(_rDate, 1, 2),
                                    INDEX(_rDate, 1, 3),
                                    _basic,
                                    JulianCalendar
                                ),
                                HSTACK(
                                    IF(ISERROR(_sDate),"#DATE!", _sDate),
                                    INDEX(_rDate, 1, 4)
                                )
                            )
                    ),
                    _sDate, INDEX(_resolve, 1, 1),
                    _sTime, IF(NOT(_hasTime) * (_precision = 1) * _fixed, "",
                        IF(_timeOutOfRange, "#TIME!",
                            IFERROR(
                                FORMAT_ISO_TIME(
                                    IF(INDEX(_resolve, 1, 2) = 1, 0, INDEX(_resolve, 1, 2)),
                                    Options
                                ),
                                "#TIME!"
                            )
                        )
                    ),
                    _sTZO, IFERROR(FORMAT_ISO_TZO(TimeZoneOffset, Options), "#TZO!"),
                    IF(_hasTime,
                        CONCAT(_sDate, _sTime, _sTZO),
                        IF(_sTZO = "", _sDate,
                            CONCAT(_sDate, "T", _sTZO)
                        )
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
FORMAT_LITERARY_YEAR

Returns a year formatted in literary style.

Output
------------------------------------------------------------------------------------------------------------
 1 | text | Literary year

Parameters
------------------------------------------------------------------------------------------------------------
YearCE          | integer | Note that 1 BC = 0 CE, 2 BC = -1 CE
[AlwaysShowEra] | switch  | Always apply BCE/CE suffix. If not used, only years less than 1000 show an era.
----------------------------------------------------------------------------------------------------------*/
FORMAT_LITERARY_YEAR = LAMBDA(YearCE, [AlwaysShowEra],
    IF(YearCE = "", "",
        LET(
            _yearCE, INT(YearCE),
            _isCE, _yearCE >= 1,
            _year, IF(_isCE, _yearCE, 1 - _yearCE),
            _suffix, IFS(NOT(_isCE), " BCE",
                _yearCE < 1000, " CE",
                N(AlwaysShowEra) <> 0, " CE",
                TRUE, ""
            ),
            _year & _suffix
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
FORMAT_LITERARY_DATE

Returns a date formatted in literary style.

Output
------------------------------------------------------------------------------------------------------------
 1 | text | Literary date

Parameters
------------------------------------------------------------------------------------------------------------
YearCE                 | integer         | Note that 1 BC = 0 CE, 2 BC = -1 CE
Month                  | integer [1..12] |
Day                    | integer [1..31] |
[Time]                 | decimal [0..1]  | Time of day as decimal fraction of a day.
[Short]                | switch          | Return short format Jan..Dec
[InternationalEnglish] | switch          | Use the International English instead of local language set in Excel
[AlwaysShowEra]        | switch          | Always apply BCE/CE suffix. If not used, only years less than 1000
                       |                 | show an era.
[JulianCalendar]       | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                       |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
/*
FORMAT_LITERARY_DATE = LAMBDA(YearCE, Month, Day, [Time], [Short], [InternationalEnglish], [AlwaysShowEra], [JulianCalendar],
    IF((YearCE = "") * (Month = "") * (Day = ""), "",
        IF(NOT(ISNUMBER(Month)) + (NOT(ISNUMBER(YearCE)) * NOT(ISNUMBER(Day))), {#VALUE!},
            LET(
                fnFormatDate, LAMBDA(_carryDay,
                    LET(
                        _yearCE, IF(YearCE = "", 2000, YearCE),
                        _day, IF(Day = "", 1, INT(Day)),
                        IF(NOT(IS_VALID_DATE(_yearCE, Month, _day, JulianCalendar)), "#DATE!",
                            LET(
                                _rDate, IF(_carryDay,
                                    RESOLVE_DATE(_yearCE, Month, _day + 1, 0, 0, 0, JulianCalendar),
                                    HSTACK(_yearCE, Month, _day)
                                ),
                                _sMonth, MONTH_NAME(INDEX(_rDate, 1, 2), Short, InternationalEnglish),
                                _sDay, IF(ISNUMBER(Day), " " & INDEX(_rDate, 1, 3), ""),
                                _sYear, IF(ISNUMBER(YearCE), ", " & FORMAT_LITERARY_YEAR(INDEX(_rDate, 1, 1), AlwaysShowEra), ""),
                                CONCAT(_sMonth, _sDay, _sYear)
                            )
                        )
                    )    
                ),

                fnFormatTime, LAMBDA(
                    IF(Time = "", {"", 0},
                        IF(NOT(ISNUMBER(Time)), {" #TIME!", 0},
                            IF((Time < 0) + (Time > 1), {" #TIME!", 0},
                                LET(
                                    _rTime, ROUND_TIMESPAN(Time, 3, 0),
                                    _carryDay, N((_rTime = 1) * (Time < 1)),
                                    _fmt, IF(Time = 1, "[H]:mm", "h:mm AM/PM"),
                                    HSTACK(
                                        ", " & TEXT(_rTime, _fmt),
                                        _carryDay
                                    )
                                )
                            )
                        )
                    )
                ),
                
                _rTime, fnFormatTime(),
                _sDate, fnFormatDate(INDEX(_rTime, 1, 2)),
                CONCAT(_sDate, INDEX(_rTime, 1, 1))
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
FORMAT_US_DATE

Returns a date formatted in the US style.

Output
------------------------------------------------------------------------------------------------------------
 1 | text | US style date

Parameters
------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] |
Day              | integer [1..31] |
[Time]           | decimal [0..1)  | Time of day as decimal fraction of a day.
[Options]        | text            | String with elements: [Significance][DateSeparator][TimeSeparator][<]
                 |                 |   Significance: least significant component where:
                 |                 |    Null : Defaults to minutes if time present, otherwise day
                 |                 |       D : Day
                 |                 |       H : Hour
                 |                 |       M : Minute
                 |                 |       S : Second
                 |                 |       T : Millisecond (Ticks)
                 |                 |  DateSeparator: Character to separate date components. [,./-_]
                 |                 |  TimeSeparator: Character to separate time components. [,.:-_]
                 |                 |             < : Round by truncating components. Default is rounding to nearest.
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar. 
----------------------------------------------------------------------------------------------------------*/
/*
FORMAT_US_DATE = LAMBDA(YearCE, Month, Day, [Time], [Options], [JulianCalendar],
    IF((YearCE = "") * (Month = "") * (Day = ""), "",
        IF(NOT(ISNUMBER(YearCE)) + NOT(ISNUMBER(Month)) + NOT(ISNUMBER(Day)) + ((Time <> "") * NOT(ISNUMBER(Time))), {#VALUE!},
            LET(
                fnFormatDate, LAMBDA(_separator, _carryDay,
                    IF(NOT(IS_VALID_DATE(YearCE, Month, Day, JulianCalendar)), "#DATE!",
                        LET(
                            _rDay, INT(Day),
                            _rDate, IF(_carryDay,
                                RESOLVE_DATE(YearCE, Month, _rDay + 1, 0, 0, 0, JulianCalendar),
                                HSTACK(YearCE, Month, _rDay)
                            ),
                            _sYear, TEXT(INDEX(_rDate, 1, 1), "0000;" & UNICHAR(8722) & "0000;0000"),
                            _sMonth, TEXT(INDEX(_rDate, 1, 2), "0"),
                            _sDay, TEXT(INDEX(_rDate, 1, 3), "0"),
                            CONCAT(_sMonth, _separator, _sDay, _separator, _sYear)
                        )
                    )
                ),
                                        
                fnFormatTime, LAMBDA(_precision, _truncate, _separator,
                    IF(Time = "", {"", 0},
                        IF(NOT(ISNUMBER(Time)), {"#TIME!", 0},
                            IF((Time < 0) + (Time > 1), {" #TIME!", 0},
                                LET(
                                    _rTime, ROUND_TIMESPAN(Time, _precision, _truncate),
                                    _carryDay, N(_rTime = 1),
                                    _fmt, IFS(
                                        _precision = 1, "",
                                        _precision = 2, "h AM/PM",
                                        _precision = 3, "h\" & _separator & "mm AM/PM",
                                        _precision = 4, "h\" & _separator & "mm\" & _separator & "ss AM/PM",
                                        TRUE, "h\" & _separator & "mm\" & _separator & "ss.000 AM/PM"
                                    ),
                                    _sTime, TEXT(_rTime, _fmt),
                                    HSTACK(_sTime, _carryDay)
                                )
                            )
                        )
                    )
                ),

                _hasTime, ISNUMBER(Time),
                _truncate, IF(Options = "", FALSE,
                    IFERROR(FIND("<", Options), 0) > 0
                ),
                _usePrecision, IF(NOT(_hasTime), 1,
                    LET(
                        _trySigChar, SEARCH_NTH_CHAR("DHMST", Options, 1, 1),
                        IFS(
                            INDEX(_trySigChar, 1, 1) = 0, 3,
                            INDEX(_trySigChar, 1, 2) = "D", 1,
                            INDEX(_trySigChar, 1, 2) = "H", 2,
                            INDEX(_trySigChar, 1, 2) = "M", 3,
                            INDEX(_trySigChar, 1, 2) = "S", 4,
                            INDEX(_trySigChar, 1, 2) = "T", 5
                        )
                    )
                ),
                _tryDateSepChar, SEARCH_NTH_CHAR(",./-_", Options, 1, 1),
                _dateSeparator, IF(INDEX(_tryDateSepChar, 1, 1) = 0, "/",
                    INDEX(_tryDateSepChar, 1, 2)
                ),
                _tryTimeSepChar, SEARCH_NTH_CHAR(",.:-_", Options, 1, 1, INDEX(_tryDateSepChar, 1, 1) + 1),
                _timeSeparator, IF(INDEX(_tryTimeSepChar, 1, 1) = 0, ":",
                    INDEX(_tryTimeSepChar, 1, 2)
                ),
                
                _rTime, fnFormatTime(_usePrecision, _truncate, _timeSeparator),
                _sDate, fnFormatDate(_dateSeparator, INDEX(_rTime, 1, 2)),

                IF(_hasTime,
                    CONCAT(_sDate, " ", INDEX(_rTime, 1 ,1)),
                    _sDate
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------
FORMAT_MIL_DTG

Returns a date formatted in US Military message traffic style.

Output
----------------------------------------------------------------------------------------------------------
 1 | text | DTG formatted date

Parameters
----------------------------------------------------------------------------------------------------------
Year             | integer         |
                 | [1951..2050]    |
Month            | integer [1..12] |
Day              | integer [1..31] |
Time             | decimal [0..1)  | Time of day as decimal fraction of a day.
[TimeZoneOffset] | decimal         | Time zone offset from UTC as decimal fraction of a day.
                 | [-0.625..0.625] | Assumed to be UTC if ommitted. [-15:00..+15:00]
                 |                 | Time will be converted if the offset does not align with military
                 |                 | time zones.
[Short]          | switch          | Short time formt: hhmm, otherwise: hhmmss

Examples
----------------------------------------------------------------------------------------------------------
FORMAT_MIL_DTG(2023, 2, 12, 0.75, 600, 1)
Returns: 121800KFEB23

FORMAT_MIL_DTG( , , 12, 0.25)
Returns: 120600J
--------------------------------------------------------------------------------------------------------*/
/*
FORMAT_MIL_DTG = LAMBDA(Year, Month, Day, Time, [TimeZoneOffset], [Short],
    IF((Year = "") * (Month = "") * (Day = "") * (Time = ""), "",
        IF((NOT(ISNUMBER(Year)) * (Year <> "")) + (NOT(ISNUMBER(Month)) * (Month <> "")) + (NOT(ISNUMBER(Day)) * (Day <> "")), {#VALUE!},
            IF((Month <> "") * NOT(IS_VALID_DATE(Year, Month, Day, 0)), "#DATE!",
                LET(
                    _tzo, N(TimeZoneOffset),

                    fnFmtTime, LAMBDA(_time,
                        LET(
                            _timeFmt, IF(N(Short), "HHmm", "HHmmss"),
                            TEXT(_time, _timeFmt)
                        )
                    ),

                    fnResolveMilitaryTZ, LAMBDA(
                        IFS(
                            TimeZoneOffset = "", HSTACK(N(Time), "J"),
                            _tzo > 0.5, LET(
                                _shiftTZO, _tzo - 0.5,
                                _time, N(Time) - _shiftTZO,  
                                HSTACK(_time, "M")
                            ),
                            _tzo < -0.5, LET(
                                _shiftTZO, _tzo + 0.5,
                                _time, N(Time) - _shiftTZO,  
                                HSTACK(_time, "Y")
                            ),
                            TRUE, LET(
                                _militaryTZO, SIGN(_tzo) * MROUND(ABS(_tzo * 1440), 60) / 1440,
                                _shiftTZO, _tzo - _militaryTZO,
                                _time, N(Time) - _shiftTZO,
                                _idx, INT(_militaryTZO * 24) + 13,
                                _militaryTZ, CHOOSE(_idx, "Y", "X", "W", "V", "U", "T", "S", "R", "Q", "P", "O", "N", "Z", "A", "B", "C", "D", "E", "F", "G", "H", "I", "K", "L", "M"),
                                HSTACK(_time, _militaryTZ)
                            )
                        )
                    ),
            
                    _day, INT(Day),
                    _usePrecision, 4 - N(Short),
                    _militaryTime, fnResolveMilitaryTZ(),
                    _rDate, IF(Year = "",
                        RESOLVE_DATE(2000, 3, _day, INDEX(_militaryTime, 1, 1), _usePrecision),
                        RESOLVE_DATE(Year, Month, _day, INDEX(_militaryTime, 1, 1), _usePrecision)
                    ),
                    _sDay, TEXT(INDEX(_rDate, 3), "00"),
                    IF(Year = "",
                        CONCAT(_sDay, fnFmtTime(INDEX(_rDate, 4)), INDEX(_militaryTime, 1, 2)),
                        IF((INDEX(_rDate, 1) < 1951) + (INDEX(_rDate, 1) > 2050), "#RANGE!",
                            LET(
                                _sTime, fnFmtTime(INDEX(_rDate, 4)),
                                _sMonth, UPPER(MONTH_NAME(INDEX(_rDate, 2), 1, 1)),
                                _sYY, RIGHT(TEXT(INDEX(_rDate, 1), "00"), 2),
                                CONCAT(_sDay, _sTime, INDEX(_militaryTime, 1, 2), _sMonth, _sYY)
                            )
                        )
                    )
                )
            )
        )
    )
);







/*########################################################################################################
# CONVERSION                                                                                             #
########################################################################################################*/


/*--------------------------------------------------------------------------------------------------------
MJDATE_TO_EDATE

Returns an Excel Date/Time for the provided Modified Julian Date.
Note Excel Date/Time uses the Gregorian calendar.

Output
----------------------------------------------------------------------------------------------------------
 1 | decimal         | Excel Date/Time.
   | [1..2958466)    | 1900-01-01..9999-12-31

Parameters
----------------------------------------------------------------------------------------------------------
MJDate  | decimal          | Modified Julian Date
        | [15019..2973484) |
--------------------------------------------------------------------------------------------------------*/
MJDATE_TO_EDATE = LAMBDA(MJDate,
    IF(MJDate = "", "",
        IF(NOT(ISNUMBER(MJDate)), {#VALUE!},
            IF((MJDate < 15019) + (MJDate >= 2973484), {#NUM!}, 
                MJDate - 15018
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------
EDATE_TO_MJDATE

Returns the Modified Julian Date for the provided Excel Date/Time.
Note Excel Date/Time uses the Gregorian calendar.

Output
----------------------------------------------------------------------------------------------------------
 1 | decimal          | Modified Julian Date.
   | [15019..2973484) |

Parameters
----------------------------------------------------------------------------------------------------------
EDate | decimal      | Excel Date/Time
      | [1..2958466) | 1900-01-01..9999-12-31
--------------------------------------------------------------------------------------------------------*/
EDATE_TO_MJDATE = LAMBDA(EDate,
    IF(EDate = "", "", 
        IF(NOT(ISNUMBER(EDate)), {#VALUE!},
            EDate + 15018
        )
    )
);


/*--------------------------------------------------------------------------------------------------------
USDATE_TO_EDATE

Returns an Excel Date/Time for the provided US format date and time.

Output
----------------------------------------------------------------------------------------------------------
 1 | decimal | Excel Date/Time.

Parameters
----------------------------------------------------------------------------------------------------------
USDate | text | Date in US format ie. MM/dd/yyyy hh:mm:ss
--------------------------------------------------------------------------------------------------------*/
/*
USDATE_TO_EDATE = LAMBDA(USDate,
    IF(USDate = "", "",
        LET(
            _USDate, PARSE_US_DATE(USDate),
            _time, INDEX(_USDate, 1, 4),
            _year, INDEX(_USDate, 1, 1),
            _eDate, IF(_year = "", 0,
                DATE(_year, INDEX(_USDate, 1, 2), INDEX(_USDate, 1, 3))
            ),
            _eDate + _time
        )
    )
);


/*--------------------------------------------------------------------------------------------------------
EDATE_TO_USDATE

Returns a US format date and time for the provided Excel Date/Time.

Output
----------------------------------------------------------------------------------------------------------
 1 | text | US format date and time

Parameters
----------------------------------------------------------------------------------------------------------
EDate     | decimal | Excel Date/Time.
[Options] | text    | String with elements: [Significance][DateSeparator][TimeSeparator][<]
          |         |   Significance: least significant component where:
          |         |    Null : Defaults to minutes if time present, otherwise day
          |         |       D : Day
          |         |       H : Hour
          |         |       M : Minute
          |         |       S : Second
          |         |       T : Millisecond (Ticks)
          |         |  DateSeparator: Character to separate date components. [,./-_]
          |         |  TimeSeparator: Character to separate time components. [,.:-_]
          |         |             < : Round by truncating components. Default is rounding to nearest.
--------------------------------------------------------------------------------------------------------*/

/*EDATE_TO_USDATE = LAMBDA(EDate, [Options],
    IF(EDate = "", "", 
        IF(NOT(ISNUMBER(EDate)), {#VALUE!},
            LET(
                _yearCE, YEAR(EDate),
                _month, MONTH(EDate),
                _day, DAY(EDate),
                _time, EDate - INT(EDate),
                FORMAT_US_DATE(_yearCE, _month, _day, _time, Options, 0)
            )
        )
    )
);









/*--------------------------------------------------------------------------------------------------------
MJDATE_TO_ISODATETIME

Returns ISO format date, time and time zone offset from a Modified Julian Date.

Output
----------------------------------------------------------------------------------------------------------
 1 | text | ISO date, time and time zone offset.

Parameters
----------------------------------------------------------------------------------------------------------
MJDate             | decimal         | Modified Julian Date
[TimeZoneOffset]   | decimal         | Time zone offset from UTC as decimal fraction of a day.
                   | [-0.625..0.625] | -15:00..+15:00

[ToJulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                   |                | proleptic calendar. 
--------------------------------------------------------------------------------------------------------*/
MJDATE_TO_ISODATE = LAMBDA(MJDate, [TimeZoneOffset], [Options], [ToJulianCalendar],
    LET(
        _rDate, MJDATE_TO_CALENDAR_DATE(MJDate, _precision, _truncate, ToJulianCalendar),
        FORMAT_ISO_DATETIME(
            INDEX(_rDate, 1, 1),
            INDEX(_rDate, 1, 2),
            INDEX(_rDate, 1, 3),
            INDEX(_rDate, 1, 4),
            TimeZoneOffset,
            Precision,
            NoZulu,
            ToJulianCalendar
        )
    )
);























/*--------------------------------------------------------------------------------------------------------
ISODATETIME_TO_MJDATE

Returns the Modified Julian Date and time zone offset for a date and time provided in ISO format.

Output
----------------------------------------------------------------------------------------------------------
 1 | decimal         | Modified Julian Date
 2 | decimal         | Time zone offset from UTC as decimal fraction of a day.
   | [-0.625..0.625] | -15:00..+15:00

Parameters
----------------------------------------------------------------------------------------------------------
ISODateTime          | text   | ISO formatted date, time and time zone offset.
[FromJulianCalendar] | switch | Calculate from the Julian proleptic calendar. Default is Gregorian
                     |        | proleptic calendar. 
--------------------------------------------------------------------------------------------------------*/
ISODATETIME_TO_MJDATE = LAMBDA(ISODateTime, [FromJulianCalendar],
    IF(ISODateTime = "", {"", ""},
        LET(
            _isoDateTime, PARSE_ISO_DATETIME(ISODateTime, 0, FromJulianCalendar),
            IF(ISERROR(INDEX(_isoDateTime, 1, 1)), HSTACK(INDEX(_isoDateTime, 1, 1), ""),
                IF(INDEX(_isoDateTime, 1, 1) = "T", HSTACK({#N/A}, ""),
                    LET(
                        _MJDate, IFS(
                            INDEX(_isoDateTime, 1, 1) = "D",
                                MODIFIED_JULIAN_DATE(
                                    INDEX(_isoDateTime, 1, 2),
                                    INDEX(_isoDateTime, 1, 3),
                                    INDEX(_isoDateTime, 1, 4),
                                    INDEX(_isoDateTime, 1, 5),
                                    FromJulianCalendar
                                ),
                            INDEX(_isoDateTime, 1, 1) = "O",
                                ORDINAL_DATE_TO_MJDATE(
                                    INDEX(_isoDateTime, 1, 2),
                                    INDEX(_isoDateTime, 1, 4),
                                    INDEX(_isoDateTime, 1, 5),
                                    FromJulianCalendar
                                ),
                            INDEX(_isoDateTime, 1, 1) = "W",
                                WEEK_DATE_TO_MJDATE(
                                    INDEX(_isoDateTime, 1, 2),
                                    INDEX(_isoDateTime, 1, 3),
                                    INDEX(_isoDateTime, 1, 4),
                                    INDEX(_isoDateTime, 1, 5),
                                    FromJulianCalendar
                                )
                        ),
                        HSTACK(
                            _MJDate,
                            INDEX(_isoDateTime, 1, 6)
                        )
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------
ISODATETIME_TO_EDATE

Returns an Excel Date/Time for a date and time provided in ISO format.
Note Excel Date/Time uses the Gregorian calendar.

Output
----------------------------------------------------------------------------------------------------------
 1 | decimal         | Excel Date/Time.
   | [1..2958466)    | 1900-01-01..9999-12-31
 2 | decimal         | Time zone offset from UTC as decimal fraction of a day.
   | [-0.625..0.625] | -15:00..+15:00

Parameters
----------------------------------------------------------------------------------------------------------
ISODateTime             | text   | ISO formatted date, time and time zone offset. If time is ommitted,
                        |        | assumed to be at 00:00.
[FromJulianCalendar]    | switch | Calculate from the Julian proleptic calendar. Default is Gregorian
                        |        | proleptic calendar.
--------------------------------------------------------------------------------------------------------*/
ISODATETIME_TO_EDATE = LAMBDA(ISODateTime, [FromJulianCalendar],
    IF(ISODateTime = "", "",
        LET(
            _julianCalendar, N(FromJulianCalendar) <> 0,
            _isoDateTime, PARSE_ISO_DATETIME(ISODateTime, _julianCalendar),
            IF(ISERROR(INDEX(_isoDateTime, 1, 1)), HSTACK(INDEX(_isoDateTime, 1, 1), ""),
                LET(
                    _gDate, IF(_julianCalendar,
                        JULIAN_TO_GREGORIAN(
                            INDEX(_isoDateTime, 1, 1),
                            INDEX(_isoDateTime, 1, 2),
                            INDEX(_isoDateTime, 1, 3)
                        ),
                        CHOOSECOLS(_isoDateTime, 2, 3, 4)
                    ),
                    _eDate, DATE(
                        INDEX(_gDate, 1, 1),
                        INDEX(_gDate, 1, 2),
                        INDEX(_gDate, 1, 3)
                    ),
                    _eDateTime, _eDate + INDEX(_isoDate, 1, 4),
                    IF(_returnTZO,
                        HSTACK(
                            _eDateTime,
                            INDEX(_isoDate, 1, 5)
                        ),
                         _eDateTime
                    )
                )
            )
        )
    )
);



/*--------------------------------------------------------------------------------------------------------
EDATE_TO_ISODATE

Returns ISO format date, time and time zone offset from an Excel Date/Time.

Output
----------------------------------------------------------------------------------------------------------
 1 | text | ISO date.

Parameters
----------------------------------------------------------------------------------------------------------
EDate              | decimal     | Excel Date/Time.
[TimeZoneOffset]   | decimal     | Time zone offset in minutes from UTC.
                   | [-900..900] | Assumed to be UTC if ommitted.
[Precision]        | integer     | Select precision level, default is 3
                   |             |   0 - Floats from minute to millisecond
                   |             |   1 - Day
                   |             |   2 - Hour
                   |             |   3 - Minute
                   |             |   4 - Second
                   |             |   5 - Millisecond
[NoZulu]           | switch      | Use +00:00 instead of Z for UTC time zone.
[ToJulianCalendar] | switch      | Calculate in the Julian proleptic calendar. Default is Gregorian
                   |             | proleptic calendar. 
--------------------------------------------------------------------------------------------------------*/
EDATE_TO_ISODATE = LAMBDA(EDate, [TimeZoneOffset], [Precision], [NoZulu], [ToJulianCalendar],
    IF(EDate = "", "", 
        IF(NOT(ISNUMBER(EDate)), {#VALUE!},
            LET(
                _yearCE, YEAR(EDate),
                _month, MONTH(EDate),
                _day, DAY(EDate),
                _rDate, IF(N(ToJulianCalendar) = 0,
                    HSTACK(_yearCE, _month, _day),
                    GREGORIAN_TO_JULIAN(_yearCE, _month, _day)
                ),
                _time, EDate - INT(EDate),
                FORMAT_ISO_DATE(
                    INDEX(_rDate, 1, 1),
                    INDEX(_rDate, 1, 2),
                    INDEX(_rDate, 1, 3),
                    _time,
                    TimeZoneOffset,
                    Precision,
                    NoZulu,
                    ToJulianCalendar
                )
            )
        )
    )
);





/*--------------------------------------------------------------------------------------------------------
JDN_LOCAL_TO_ISODATE

Returns ISO format date, time and time zone offset for the provided Julian Day Number and local time.

Output
----------------------------------------------------------------------------------------------------------
 1 | text | ISO date.

Parameters
----------------------------------------------------------------------------------------------------------
LocalJDN           | integer     | Local Julian Day Number.
LocalTime          | decimal     | Local time of day as decimal fraction of a day or Excel Time data type.
[TimeZoneOffset]   | decimal     | Time zone offset in minutes from UTC.
                   | [-900..900] | Assumed to be UTC if ommitted.
[Precision]        | integer     | Select precision level, default is 3
                   |             |   0 - Floats from minute to millisecond
                   |             |   1 - Day
                   |             |   2 - Hour
                   |             |   3 - Minute
                   |             |   4 - Second
                   |             |   5 - Millisecond
[NoZulu]           | switch      | Use +00:00 instead of Z for UTC time zone.
[ToJulianCalendar] | switch      | Calculate in the Julian proleptic calendar. Default is Gregorian
                   |             | proleptic calendar. 
--------------------------------------------------------------------------------------------------------*/
JDN_LOCAL_TO_ISODATE = LAMBDA(LocalJDN, LocalTime, [TimeZoneOffset], [Precision], [NoZulu], [ToJulianCalendar],
    LET(
        _jdate, JDN_LOCAL_TO_JDATE(LocalJDN, LocalTime, N(TimeZoneOffset)),
        JDATE_TO_ISODATE(_jdate, TimeZoneOffset, Precision, NoZulu, ToJulianCalendar)
    )
);




/*--------------------------------------------------------------------------------------------------------
EDATE_TO_MJDATE

Returns the Modified Julian Date for the given Excel Date/Time.
Note Excel Date/Time is in the Gregorian calendar.

Output
----------------------------------------------------------------------------------------------------------
 1 | decimal | Modified Julian Date.

Parameters
----------------------------------------------------------------------------------------------------------
EDate | decimal | Excel Date/Time.
--------------------------------------------------------------------------------------------------------*/
EDATE_TO_MJDATE = LAMBDA(EDate,
    IF(EDate = "", "", 
        IF(NOT(ISNUMBER(EDate)), {#VALUE!},
            LET(
                _yearCE, YEAR(EDate),
                _month, MONTH(EDate),
                _day, DAY(EDate),
                _time, EDate - INT(EDate),
                MODIFIED_JULIAN_DATE(_yearCE, _month, _day, _time, 0)
            )
        )
    )
);





/*--------------------------------------------------------------------------------------------------------
EDATE_TO_JDN_LOCAL

Returns the Julian Day Number and local time for the provided Excel Date/Time.

Output
----------------------------------------------------------------------------------------------------------
 1 | integer        | Local Julian Day Number
 2 | decimal [0..1) | Local time of day. Decimal fraction of a day, implicitly converts to Excel Date/Time type.

Parameters
----------------------------------------------------------------------------------------------------------
EDate | decimal | Excel Date/Time.
--------------------------------------------------------------------------------------------------------*/
EDATE_TO_JDN_LOCAL = LAMBDA(EDate,
    IF(EDate = "", {"", ""}, 
        IF(NOT(ISNUMBER(EDate)), {#VALUE!, #VALUE!}, 
            LET(
                _yearCE, YEAR(EDate),
                _month, MONTH(EDate),
                _day, DAY(EDate),
                _time, EDate - INT(EDate),
                _jdn, JULIAN_DAY_NUMBER(_yearCE, _month, _day),
                HSTACK(_jdn, _time)
            )
        )
    )
);





/*--------------------------------------------------------------------------------------------------------
JDATE_TO_EDATE

Returns an Excel Date/Time for the provided Julian Date.

Output
----------------------------------------------------------------------------------------------------------
 1 | decimal | Excel Date/Time.

Parameters
----------------------------------------------------------------------------------------------------------
JDate          | decimal     | Julian Date
TimeZoneOffset | decimal     | Time zone offset in minutes from UTC.
               | [-900..900] | Assumed to be UTC if ommitted.
--------------------------------------------------------------------------------------------------------*/
JDATE_TO_EDATE = LAMBDA(JDate, TimeZoneOffset,
    IF(JDate = "", "",
        IF(NOT(ISNUMBER(JDate)), {#VALUE!},
            LET(
                _jdnLocal, JDATE_TO_JDN_LOCAL(JDate, N(TimeZoneOffset)),
                JDN_LOCAL_TO_EDATE(INDEX(_jdnLocal, 1, 1), INDEX(_jdnLocal, 1, 2))
            )
        )
    )
);









/*########################################################################################################
# END CALENDAR                                                                                           #
########################################################################################################*/
