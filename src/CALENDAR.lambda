/*##############################################################################################################
# CALENDAR v3.0                                                                                                #
#                                                                                                              #
# Module for working with dates in the Gregorian and Julian calendars outside the range of the Excel Date/Time #
# type.                                                                                                        #
#                                                                                                              #
# Module Dependencies: None                                                                                    #
#                                                                                                              #
# GENERAL                                                                                                      #
# ------------------------------------------------------------------------------------------------------------ #
# IS_EMPTY                   Tests if the parameter has an empty value. Errors return FALSE.                   #
# IS_NUMERIC_NULL            Tests if the parameter has a numeric value or is empty. Errors return FALSE.      #
# IS_INTEGER                 Tests if a number is an integer or very close to an integer. Use in place of      #
#                            MOD(N, 0) > 0 where N can be within a large range of magnitudes.                  #
# NULLIFY                    Ensures an empty cell reference is not resolved to zero.                          #
# DECIMALS                   Returns the number of decimal places for a rational number.                       #
# VALIDATE_CHARSET           Validates that the given text only contains characters in the specified character #
#                            set. Matching is case-insensitive by default.                                     #
# REPLACE_CHARS              Replaces each instance of a set of characters within text with another character. #
#                            Matching is case-insensitive by default. Note can be used to remove characters by #
#                            supplying an empty CharReplaceWith.                                               #
# SUBSTITUTE_I               Case-insensitive substitution of text. Similar to SUBSTITUTE function which is    #
#                            case-sensitive.                                                                   #
# FIND_NTH_CHAR              Locates the position of the Nth count of any one of a set of characters within    #
#                            the given text. The search is case-insensitive by default.                        #
# SPLIT_FOR_CHARS            Splits text at any character not in the given set. First element returned is the  #
#                            count number of substrings, then second element is the sequence of unmatched      #
#                            characters, followed by each substring. Matching is case-insensitive by default.  #
# SIFT_FOR_CHARS             Returns in sorted order the characters found in a text string found from a given  #
#                            set of characters. An upper limit can be set on the number of times any character #
#                            can be matched. Matching is case-insensitive by default.                          #
#                                                                                                              #
# TIMESPAN                                                                                                     #
# ------------------------------------------------------------------------------------------------------------ #
# VALIDATE_TIMESPAN          Validate each element of a sexagesimal representation of a timespan. A component  #
#                            can exceed its modulus if no higher order component is provided.                  #
# IS_VALID_TIMESPAN          Tests if sexagesimal representation of a timespan is valid. A component can       #
#                            exceed its modulus if no higher order element is provided.                        #
# TIMESPAN_LOW_ORDER         Returns a number representing the lowest order component of the sexagesimal       #
#                            representation of a timespan value.                                               #
# TIMESPAN_HIGH_ORDER        Returns a number representing the highest order component of the sexagesimal      #
#                            representation of a timespan value.                                               #
# TIMESPAN                   Returns a decimal timespan as a fraction of a day from a sexagesimal              #
#                            representation of time. Note components exceeding their modulus will carry.       #
# ROUND_TIMESPAN             Returns a decimal timespan value rounded to the specified low order component and #
#                            precision level.                                                                  #
# RESOLVE_TIMESPAN           Returns the sexagesimal representation of a timespan value expressed from the     #
#                            specified high order component and the given lowest order component rounded to    #
#                            the specified precision.                                                          #
# PARSE_TIMESPAN             Parses a text timespan expression into sexagesimal components.                    #
# FORMAT_TIMESPAN            Returns a timespan as text in the specified format from a given decimal timespan. #
#                                                                                                              #
# CALENDAR DATES                                                                                               #
# ------------------------------------------------------------------------------------------------------------ #
# YEAR_COMMON_ERA            Returns year value relative to the Common Era.                                    #
# PARSE_MONTH                Returns a number representing the month of year from a given month name.          #
# MONTH_NAME                 Returns name of month.                                                            #
# IS_LEAP_YEAR               Tests if a year includes a leap day in the given calendar.                        #
# IS_VALID_DATE              Tests if a date is valid for the given calendar.                                  #
# DAYS_IN_YEAR               Returns number of days in the given year of the specified calendar.               #
# DAYS_IN_MONTH              Returns number of days in the given month and year of the specified calendar.     #
# PARSE_ISO_CALENDAR_DATE    Parses an ISO formatted calendar date into respective parts of year, month and    #
#                            day.                                                                              #
# FORMAT_ISO_YEAR            Returns a year as text in ISO format.                                             #
# FORMAT_ISO_CALENDAR_DATE   Returns a calendar date as text in ISO format.                                    #
# JULIAN_DAY_NUMBER          Returns the Julian Day Number (JDN) of the provided date in the specified         #
#                            calendar. Note the Julian Day Number is an integer type and is an ordinal day     #
#                            number referenced from January 1, 4713 BC in the proleptic Julian calendar. It    #
#                            does not include any value for time of day.                                       #
# MODIFIED_JULIAN_DAY_NUMBER Returns the Modified Julian Day Number (MJDN) of the provided date in the         #
#                            specified calendar. Note the Modified Julian Day Number is an integer type and    #
#                            is an ordinal day number referenced from November 17, 1858 in the proleptic       #
#                            Gregorian calendar. It does not include any value for time of day.                #
# JDN_TO_MODIFIED            Converts a Julian Day Number (JDN) to a Modified Julian Day Number (MJDN).        #
# MODIFIED_TO_JDN            Converts a Modified Julian Day Number (MJDN) to a Julian Day Number (JDN).        #
# JDN_TO_CALENDAR_DATE       Converts a Julian Day Number (JDN) to a date in the specified calendar.           #
# MJDN_TO_CALENDAR_DATE      Converts a Modified Julian Day Number (MJDN) to a date in the specified calendar. #
# GREGORIAN_TO_JULIAN        Translates a date in the Gregorian proleptic calendar to the Julian proleptic     #
#                            calendar.                                                                         #
# JULIAN_TO_GREGORIAN        Translates a date in the Julian proleptic calendar to the Gregorian proleptic     #
#                            calendar.                                                                         #
# SECULAR_DIFFERENCE         Returns the number of days the Gregorian proleptic calendar is ahead of the       #
#                            Julian proleptic calendar for a given date.                                       #
#                                                                                                              #
# TIME ZONES                                                                                                   #
# ------------------------------------------------------------------------------------------------------------ #
# IS_VALID_TZO               Tests if a time zone offset in minutes is within the range -900..+900             #
# TIMESPAN_TO_TZO            Converts a deimal timespan into time zone offset minutes.                         #
# TZO_TO_TIMESPAN            Converts time zone offset minutes into a decimal timespan.                        #
# PARSE_ISO_TZO              Parses an ISO formatted time zone offset into a decimal timespan.                 #
# FORMAT_ISO_TZO             Returns a time zone offset as text in ISO format.                                 #
# MILITARY_TZO               Returns the time zone offset in minutes of a military time zone designator.       #
# TZO_TO_MILITARY            Returns the closest military time zone designator, its offset in minutes and the  #
#                            time adjustment to that time zone for the provided time zone offset in minutes.   #
# SHIFT_TIMEZONE             Translates a Modified Julian Date from one time zone to another. If a time zone   #
#                            is omitted it is assumed to be UTC.                                               #
#                                                                                                              #
# DATE AND TIME                                                                                                #
# ------------------------------------------------------------------------------------------------------------ #
# IS_VALID_TIME_OF_DAY       Tests if sexagesimal representation of time is valid for a 24 hour day.           #
# JULIAN_DATE                Returns the Julian Date of the provided date and time of day in the specified     #
#                            calendar. Note that the decimal time component of Julian Date is based from       #
#                            midday.                                                                           #
# MODIFIED_JULIAN_DATE       Returns the Modified Julian Date of the provided date and time of day in the      #
#                            specified calendar. Note that the time component of Modified Julian Date is       #
#                            based from midnight.                                                              #
# JDATE_TO_MODIFIED          Converts a Julian Date (JDATE) to a Modified Julian Date (MJDATE). Note that the  #
#                            decimal time component of MJDATE is based from midnight.                          #
# MODIFIED_TO_JDATE          Converts a Modified Julian Date (MJDATE) to a Julian Date (JDATE). Note that the  #
#                            decimal time component of JDATE is based from midday.                             #
# JDATE_TO_CALENDAR_DATE     Converts a Julian Date (JDATE) to a date and time in the specified calendar.      #
# MJDATE_TO_CALENDAR_DATE    Converts a Modified Julian Date (MJDATE) to a date and time in the specified      #
#                            calendar.                                                                         #
# RESOLVE_DATETIME           Returns the resolved date and time from the provided components to a low order    #
#                            component rounded to the specified precision.                                     #
# RESOLVE_MJDATE             Returns the date and sexagesimal representation of the time value with the given  #
#                            lowest order component rounded to the specified precision.                        #
# MJDATE_ADDITION            Returns the addition of a timespan complication to a given Modified Julian Date.  #
#                            Note if date components of years, quarters or months are added for a MJDate       #
#                            expressed in UTC rather than local time, then results may be inconsistent due to  #
#                            the bounds of calendar days.                                                      #
# PARSE_ISO_TIME             Parses an ISO formatted time of day into decimal time of day.                     #
# FORMAT_ISO_TIME            Returns a time of day as text in ISO format.                                      #
# PARSE_ISO_DATETIME         Parses an ISO formatted date and time into respective date parts, time, and time  #
#                            zone offset from UTC. Providing a time zone offset on its own is invalid for      #
#                            this function.                                                                    #
# FORMAT_ISO_DATETIME        Returns a date, time and time zone offset as text in ISO format.                  #
# PARSE_LITERARY_YEAR        Returns a number representing the year relative to the common era from a given    #
#                            literary year.                                                                    #
# FORMAT_LITERARY_YEAR       Returns a year formatted in literary style.                                       #
# PARSE_LITERARY_DATE        Parses a literary date into respective parts of year, month, day and time of day. #
# FORMAT_LITERARY_DATE       Returns a date formatted in literary style.                                       #
# PARSE_US_DATE              Parses a US formatted date into respective parts of year, month, day and time of  #
#                            day.                                                                              #
# FORMAT_US_DATE             Returns a date formatted in the US style.                                         #
# PARSE_MIL_DTG              Parses a date-time group in the format used by US Military message traffic, into  #
#                            respective parts of year, month, day, time of day and time zone offset in         #
#                            minutes from UTC.                                                                 #
# FORMAT_MIL_DTG             Returns a date-time group formatted in US Military message traffic style.         #
#                                                                                                              #
# ORDINAL DATES                                                                                                #
# ------------------------------------------------------------------------------------------------------------ #
# IS_VALID_ORDINAL_DATE      Tests if an ordinal date is valid for the given calendar.                         #
# PARSE_ISO_ORDINAL_DATE     Parses an ISO formatted ordinal date into respective parts of year, and ordinal   #
#                            day.                                                                              #
# FORMAT_ISO_ORDINAL_DATE    Returns an ordinal date as text in ISO format.                                    #
# ORDINAL_DATE_TO_MJDATE     Converts an ordinal date and time in the specified calendar to a Modified Julian  #
#                            Date.                                                                             #
# MJDATE_TO_ORDINAL_DATE     Converts a Modified Julian Date (MJDATE) to an ordinal date and time in the       #
#                            specified calendar.                                                               #
#                                                                                                              #
# WEEKS                                                                                                        #
# ------------------------------------------------------------------------------------------------------------ #
# CONVERT_WEEKDAY_NUMBER     Returns an integer for the day of the week from the traditonal numbering scheme   #
#                            to the ISO definition, or vice versa.                                             #
# PARSE_WEEKDAY              Returns a number representing the day of the week from a given text weekday name. #
# WEEKDAY_NAME               Returns name of an ISO day of week number as text.                                #
# DAY_OF_WEEK                Returns an integer for the day of the week for a given Modified Julian Date.      #
# WEEKDAY_OF_MONTH           Returns a Modified Julian Date for a given day of week, relative week for the     #
#                            month, year and time of day of the specified calendar.                            #
# IS_VALID_WEEK_DATE         Tests if a week date is valid for the given calendar.                             #
# WEEKS_IN_YEAR              Returns the count of ISO defined weeks in a given year of the specified calendar. #
# PARSE_ISO_WEEK_DATE        Parses an ISO formatted week date into respective parts of year, week and         #
#                            weekday.                                                                          #
# FORMAT_ISO_WEEK_DATE       Returns a week date as text in ISO format.                                        #
# WEEK_DATE_TO_MJDATE        Converts a week date of year, ISO defined week number, ISO weekday, and time in   #
#                            the specified calendar to a Modified Julian Date (MJDATE).                        #
# MJDATE_TO_WEEK_DATE        Converts a Modified Julian Date (MJDATE) to the year, ISO defined week number,    #
#                            ISO weekday, time, and weeks in the year in the specified calendar.               #
# WEEK_NUMBER                Returns the ISO defined week number for a given Modified Julian Date in the       #
#                            specified calendar.                                                               #
#                                                                                                              #
# QUARTERS                                                                                                     #
# ------------------------------------------------------------------------------------------------------------ #
# DAYS_IN_QUARTER            Returns the count of days in a quarter of a given year of the specified calendar. #
# QUARTER_DATE_TO_MJDATE     Converts a date expressed as fiscal year, quarter, day of quarter and time in     #
#                            the specified calendar to a Modified Julian Date (MJDATE).                        #
# MJDATE_TO_QUARTER_DATE     Converts a Modified Julian Date (MJDATE) to a date expressed as fiscal year,      #
#                            quarter, day of quarter and time in the specified calendar.                       #
#                                                                                                              #
# DELTAS                                                                                                       #
# ------------------------------------------------------------------------------------------------------------ #
# DELTA_INTERVAL             Returns the timespan difference between Modified Julian Dates in the specified    #
#                            units.                                                                            #
# DELTA_HOURS                Returns the timespan difference between Modified Julian Dates in hours.           #
# DELTA_MINUTES              Returns the timespan difference between Modified Julian Dates in minutes.         #
# DELTA_SECONDS              Returns the timespan difference between Modified Julian Dates in seconds.         #
# DELTA_DHMS                 Returns the sexagesimal difference between Modified Julian Dates with the given   #
#                            lowest order component rounded to the specified precision.                        #
# DELTA_TIMESPAN             Returns the timespan difference between Modified Julian Dates.                    #
# DELTA_WEEKS                Returns the timespan difference between Modified Julian Dates in weeks.           #
# DELTA_MONTHS               Returns the timespan difference between Modified Julian Dates in months. Where    #
#                            the difference includes partial months, the fraction is calculated on the basis   #
#                            of days in the month of the calendar. If the Modified Julian Dates are expressed  #
#                            in UTC rather than local time then a small margin of error will be introduced due #
#                            to the bounds of calendar days.                                                   #
# DELTA_QUARTERS             Returns the timespan difference between Modified Julian Dates in quarters. Where  #
#                            the difference includes partial quarters, the fraction is calculated on the basis #
#                            of days in the quarter of the calendar. If the Modified Julian Dates are          #
#                            expressed in UTC rather than local time then a small margin of error will be      #
#                            introduced due to the bounds of calendar days.                                    #
# DELTA_YEARS                Returns the timespan difference between Modified Julian Dates in years. Where the #
#                            difference includes partial years, the fraction is calculated on the basis of     #
#                            days in the year of the calendar. If the Modified Julian Dates are expressed in   #
#                            UTC rather than local time then a small margin of error will be introduced due to #
#                            the bounds of calendar days.                                                      #
# DELTA_WEEK_DAYS            Returns the timespan difference between Modified Julian Dates in weeks and days.  #
# DELTA_YEAR_WEEK_DAYS       Returns the timespan difference between Modified Julian Dates in years, weeks,    #
#                            and days. Note the number of weeks per year can vary between 52 and 53. If an     #
#                            absolute number of weeks is being sought then use either DELTA_WEEK_DAYS or       #
#                            DELTA_WEEKS functions. If the Modified Julian Dates are expressed in UTC rather   #
#                            than local time then a small margin of error will be introduced due to the bounds #
#                            of calendar days.                                                                 #
# DELTA_MONTH_DAYS           Returns the timespan difference between Modified Julian Dates in months and days. #
#                            If the Modified Julian Dates are expressed in UTC rather than local time then a   #
#                            small margin of error will be introduced due to the bounds of calendar days.      #
# DELTA_QUARTER_DAYS         Returns the timespan difference between Modified Julian Dates in quarters and     #
#                            days. If the Modified Julian Dates are expressed in UTC rather than local time    #
#                            then a small margin of error will be introduced due to the bounds of calendar     #
#                            days.                                                                             #
#                                                                                                              #
# EXTENTS                                                                                                      #
# ------------------------------------------------------------------------------------------------------------ #
# EXTENT_OF_DAYS             Returns the inclusive extent of days spanned by two Modified Julian Dates         #
#                            expressed in local time. If the Modified Julian Dates are expressed in UTC rather #
#                            than local time then inconsistent results may be produced due to the bounds of    #
#                            calendar days.                                                                    #
# EXTENT_OF_WEEKS            Returns the inclusive extent of weeks spanned by two Modified Julian Dates        #
#                            expressed in local time. If the Modified Julian Dates are expressed in UTC rather #
#                            than local time then inconsistent results may be produced due to the bounds of    #
#                            calendar days.                                                                    #
# EXTENT_OF_MONTHS           Returns the inclusive extent of months spanned by two Modified Julian Dates       #
#                            expressed in local time. If the Modified Julian Dates are expressed in UTC rather #
#                            than local time then inconsistent results may be produced due to the bounds of    #
#                            calendar days.                                                                    #
# EXTENT_OF_QUARTERS         Returns the inclusive extent of quarters spanned by two Modified Julian Dates     #
#                            expressed in local time. If the Modified Julian Dates are expressed in UTC rather #
#                            than local time then inconsistent results may be produced due to the bounds of    #
#                            calendar days.                                                                    #
# EXTENT_OF_YEARS            Returns the inclusive extent of years spanned by two Modified Julian Dates        #
#                            expressed in local time. If the Modified Julian Dates are expressed in UTC rather #
#                            than local time then inconsistent results may be produced due to the bounds of    #
#                            calendar days.                                                                    #
#                                                                                                              #
# CONVERSIONS                                                                                                  #
# ------------------------------------------------------------------------------------------------------------ #
# TIMESPAN_TO_EXCELTIME      Converts a TimeSpan to an Excel Date/Time.                                        #
# EXCELTIME_TO_TIMESPAN      Converts an Excel Date/Time to a TimeSpan.                                        #
# MJDATE_TO_EXCELDATE        Converts a Modified Julian Date to an Excel Date/Time.                            #
# EXCELDATE_TO_MJDATE        Converts an Excel Date/Time to a Modified Julian Date.                            #
# USDATE_TO_EXCELDATE        Converts a US format date to an Excel Date/Time.                                  #
# EXCELDATE_TO_USDATE        Converts an Excel Date/Time to a US format date.                                  #
# ISO_DATETIME_TO_EXCELDATE  Converts an ISO formatted date and time to an Excel Date/Time and time zone       #
#                            offset.                                                                           #
# EXCELDATE_TO_ISO_DATETIME  Converts an Excel Date/Time and time zone offset to an ISO formatted date and     #
#                            time.                                                                             #
# ISO_DATETIME_TO_MJDATE     Converts an ISO formatted date and time to a Modified Julian Date and time zone   #
#                            offset.                                                                           #
# MJDATE_TO_ISO_DATETIME     Converts a Modified Julian Date and time zone offset to an ISO formatted date and #
#                            time.                                                                             #
#                                                                                                              #
##############################################################################################################*/


/*##############################################################################################################
# GENERAL                                                                                                      #
##############################################################################################################*/


/*--------------------------------------------------------------------------------------------------------------
IS_EMPTY

Tests if the parameter has an empty value. Errors return FALSE.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean | 

Parameters
----------------------------------------------------------------------------------------------------------------
Value | variant |

Examples
----------------------------------------------------------------------------------------------------------------
IS_EMPTY("")
Returns TRUE

IS_EMPTY(1)
Returns FALSE

IS_EMPTY(#N/A)
Returns FALSE
--------------------------------------------------------------------------------------------------------------*/
IS_EMPTY = LAMBDA(Value,
    IF(ISERROR(Value), FALSE,
        Value = ""
    )
);


/*--------------------------------------------------------------------------------------------------------------
IS_NUMERIC_NULL

Tests if the parameter has a numeric value or is empty. Errors return FALSE.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean | 

Parameters
----------------------------------------------------------------------------------------------------------------
Value | variant |

Examples
----------------------------------------------------------------------------------------------------------------
IS_NUMERIC_NULL(1)
Returns TRUE

IS_NUMERIC_NULL("")
Returns TRUE

IS_NUMERIC_NULL("X")
Returns FALSE

IS_NUMERIC_NULL(#VALUE!)
Returns FALSE
--------------------------------------------------------------------------------------------------------------*/
IS_NUMERIC_NULL = LAMBDA(Value,
    IFS(
        ISERROR(Value), FALSE,
        Value = "", TRUE,
        ISNUMBER(Value), TRUE,
        TRUE, FALSE
    )    
);


/*--------------------------------------------------------------------------------------------------------------
IS_INTEGER

Tests if a number is an integer or very close to an integer. Use in place of MOD(N, 0) > 0 where N
can be within a large range of magnitudes.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean | 

Parameters
----------------------------------------------------------------------------------------------------------------
N | decimal | 

Examples
----------------------------------------------------------------------------------------------------------------
IS_INTEGER(1)
Returns TRUE

IS_INTEGER(0.5)
Returns FALSE

IS_INTEGER("3")
Returns #VALUE!
--------------------------------------------------------------------------------------------------------------*/
IS_INTEGER = LAMBDA(N,
    IF(NOT(ISNUMBER(N)), {#VALUE!},
        LET(
            _integer, INT(N),
            ROUNDDOWN(N - _integer, 15) = 0
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
NULLIFY

Ensures an empty cell reference is not resolved to zero.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | variant | 

Parameters
----------------------------------------------------------------------------------------------------------------
Value | variant |

Examples
----------------------------------------------------------------------------------------------------------------
NULLIFY(A1), where A1 is empty
Returns ""
--------------------------------------------------------------------------------------------------------------*/
NULLIFY = LAMBDA(Value,
    IF(ISBLANK(Value), "", Value)
);


/*--------------------------------------------------------------------------------------------------------------
DECIMALS

Returns the number of decimal places for a rational number.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [0..] | max value 15 for values > 1

Parameters
----------------------------------------------------------------------------------------------------------------
N | decimal | 
--------------------------------------------------------------------------------------------------------------*/
DECIMALS = LAMBDA(N,
    IFS(
        N = "", "",
        NOT(ISNumber(N)), {#VALUE!},
        N = 0, 0,
        TRUE, LET(
            // IEEE 754 floating point arithmetic introduces errors in the mathematical algorithm:
            // num -> frac = MOD(num, 1); smallest n where frac * 10^n = INT(frac * 10^n)
            // MOD involves subraction, which for a numbers >> 1 with a small decimal part produces
            // an error margin that results in a much larger n 
            // eg num = 10^12 + 0.1 ; MOD(num, 1) - 0.1 = -0.000244...
            // n should = 1, however the algorithm results in a run-away n
            // Using Excel string formatting instead
            _num1, ABS(N),
            _frac1, _num1 - INT(_num1),
            _shift, IFERROR(CEILING(-LOG10(_frac1), 1) - 1, 0),
            _num2, _num1 * POWER(10, _shift),
            _sNum2, TEXT(_num2,"0.000000000000000"),
            _sFrac, RIGHT(_sNum2, 15),
            IF(_sFrac = "000000000000000", 0,
                LET(
                    _last, REDUCE("", SEQUENCE(15,,15, -1),
                        LAMBDA(_acc, _curr,
                            IF(_acc <> "", _acc,
                                IF(MID(_sFrac, _curr, 1) = "0", "", _curr)
                            )
                        )
                    ),
                    _last + _shift
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
VALIDATE_CHARSET

Validates that the given text only contains characters in the specified character set.
Matching is case-insensitive by default.

Array compatible: Text parameter only

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
----------------------------------------------------------------------------------------------------------------
Text              | text    | Text to validate
CharSet           | text    | Valid characters
[CaseInsensitive] | boolean | Ignore case when matching
--------------------------------------------------------------------------------------------------------------*/
VALIDATE_CHARSET = LAMBDA(Text, CharSet, [CaseSensitive],
    IFS(
        CharSet = "", FALSE,
        Text = "", FALSE,
        TRUE, LET(
            _ignoreCase, N(CaseSensitive) = 0,
            _text, IF(_ignoreCase, UPPER(Text), Text),
            _chars, IF(_ignoreCase, UPPER(CharSet), CharSet),
            _escapeText, SUBSTITUTE(SUBSTITUTE(_text, "&", "&amp;"), "<", "&lt;"),
            _xml, "<xml><s>" & _escapeText & "</s></xml>",
            _xpath, "//s[translate(.,'" & _chars & "','')='']",
            NOT(ISERROR(FILTERXML(_xml, _xpath)))
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
REPLACE_CHARS

Replaces each instance of a set of characters within text with another character.
Matching is case-insensitive by default. Note can be used to remove characters by supplying an empty CharReplaceWith.

Array compatible: Text parameter only

Output
----------------------------------------------------------------------------------------------------------------
 1 | text |

Parameters
----------------------------------------------------------------------------------------------------------------
Text            | text    | Text within which to replace characters
CharSet         | text    | Set of characters to be replaced
CharReplaceWith | text    | Target character with which to replace each character in CharSet
[CaseSensitive] | boolean | Match on letter case

Examples
----------------------------------------------------------------------------------------------------------------
REPLACE_CHARS("abc:def/g/h", ":/", "")
Returns: abcdefgh

REPLACE_CHARS("abc:def/g/h", ":/", "_")
Returns: abc_def_g_h
--------------------------------------------------------------------------------------------------------------*/
REPLACE_CHARS = LAMBDA(Text, CharSet, CharReplaceWith, [CaseSensitive],
    LET(
        _charNew, LEFT(CharReplaceWith),
        _ignoreCase, N(CaseSensitive) = 0,
        MAP(Text,
            LAMBDA(_text,
                IFS(
                    CharSet = "", _text,
                    _text = "", "",
                    _ignoreCase,
                        REDUCE(_text, SEQUENCE(LEN(CharSet)),
                            LAMBDA(acc, curr,
                                LET(
                                    _charL, LOWER(MID(CharSet, curr, 1)),
                                    _textL, SUBSTITUTE(acc, _charL, _charNew),
                                    SUBSTITUTE(_textL, UPPER(_charL), _charNew)
                                )
                            )
                        ),
                    TRUE, REDUCE(_text, SEQUENCE(LEN(CharSet)),
                        LAMBDA(acc, curr,
                            SUBSTITUTE(acc, MID(CharSet, curr, 1), _charNew)
                        )
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
SUBSTITUTE_I

Case-insensitive substitution of text. Similar to SUBSTITUTE function which is case-sensitive.

Array compatible: Text parameter only

Output
----------------------------------------------------------------------------------------------------------------
 1 | text |

Parameters
----------------------------------------------------------------------------------------------------------------
Text          | text    | Text within which to replace matched text
OldText       | text    | Text to be replaced
NewText       | text    | Text with which to replace OldText
[InstanceNum] | integer | Specifiy which occurance to replace. If ommitted or 0 then all occurances are replaced.
              |         | Negative instance matches from end.

Examples
----------------------------------------------------------------------------------------------------------------
SUBSTITUTE_I("abc:def:ghi:jkl", ":", "")
Returns: abcdefghijkl

SUBSTITUTE_I("abc:def:ghi:jkl", ":", "-", 2)
Returns: abc:def-ghi:jkl
--------------------------------------------------------------------------------------------------------------*/
SUBSTITUTE_I = LAMBDA(Text, OldText, NewText, [InstanceNum],
    IF(OldText = "", NULLIFY(Text),
        LET(
            _oldLen, LEN(OldText),
            _lenDiff, LEN(NewText) - _oldLen,
            _instance, N(InstanceNum),
            MAP(Text,
                LAMBDA(_text,
                    IF(_text = "", "",
                        LET(
                            _maxInstance, INT(LEN(_text) / _oldLen),
                            _pos, SCAN(0, SEQUENCE(1, _maxInstance),
                                LAMBDA(_acc, _curr,
                                    IF(_acc = "", "", IFERROR(SEARCH(OldText, _text, _acc + 1), ""))
                                )
                            ),
                            _count, COUNT(_pos),
                            IFS(
                                _count = 0, _text,
                                ABS(_instance) > _count, _text,
                                _instance > 0, REPLACE(_text, INDEX(_pos, 1, _instance), _oldLen, NewText),
                                _instance < 0, REPLACE(_text, INDEX(_pos, 1, _count + _instance + 1), _oldLen, NewText),
                                TRUE, LET(
                                    _nPos, TAKE(_pos, 1, _count) + SEQUENCE(1, _count, 0, _lenDiff),
                                    REDUCE(_text, _nPos,
                                        LAMBDA(_acc, _curr,
                                            REPLACE(_acc, _curr, _oldLen, NewText)
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
FIND_NTH_CHAR

Locates the position of the Nth count of any one of a set of characters within the given text.
Search is case-insensitive by default.

Array compatible: Text parameter as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Character position in text.
 2 | char    | Character found. Returned if ReturnChar is set

Parameters
----------------------------------------------------------------------------------------------------------------
Text            | text             | Text to search within
Chars           | text             | Characters to search for
N               | integer          | Nth count of any of the characters
                |                  | Negative values will perform a reverse search from the end of the text.
[CaseSensitive] | switch           | Search is case-sensitive.           
[ReturnChar]    | switch           | Also return the character found
[LowerPos]      | integer          | Position to start the search from.
                | [1..LEN(Text)]   | Negative values are relative to the end of the text.
                | [-LEN(Text)..-1] | Defaults to beginning of the text.
[UpperPos]      | integer          | Position limit of the search.
                | [1..LEN(Text)]   | Negative values are relative to the end of the text.
                | [-LEN(Text)..-1] | Defaults to end of the text.

Examples
----------------------------------------------------------------------------------------------------------------
FIND_NTH_CHAR("1234_A_B_A_0", "AB", 1)
Returns: 6 i.e. 1st A or B is at position 6

FIND_NTH_CHAR("1234_A_b_a_0", "ab", 2, 1)
Returns: 10 i.e. 2nd a or b, case-sensitive is at position 10

FIND_NTH_CHAR("1234_A_B_A_0", "ab", 2, 0, 1, 7)
Returns: {10, A} i.e. 2nd a or b, case-insensitive is at position 10, searching from position 7. A was found.

FIND_NTH_CHAR("1234_A_B_A_0", "AB", -2, 1, 1, -4)
Returns: {6, A} i.e. 2nd A or B, case-sensitive is at position 6, using reverse search from 4 characters from end.
         A was found
--------------------------------------------------------------------------------------------------------------*/
FIND_NTH_CHAR = LAMBDA(Text, Chars, N, [CaseSensitive], [ReturnChar], [LowerPos], [UpperPos],
    LET(
        _ignoreCase, N(CaseSensitive) = 0,
        _outChar, N(ReturnChar) <> 0,
        _n, INT(N(N)),
        _returnNone, IF(_outChar, {0, ""}, 0),
        _lowPos, IF(N(LowerPos) = 0, 1, LowerPos),
        fnNthChar, LAMBDA(_rowText,
            IF((Chars = "") + (_n = 0), _returnNone,
                LET(
                    _len, LEN(_rowText),
                    _startPos, IF(_lowPos < 1, _len + _lowPos + 1, _lowPos),
                    _endPos, IFS(
                        NOT(ISNUMBER(UpperPos)), _len,
                        UpperPos > 0, UpperPos,
                        UpperPos < 0, _len + UpperPos + 1,
                        TRUE, 0
                    ),
                    IF((_startPos > _len) + (_startPos > _endPos), _returnNone,
                        LET(
                            _searchText, MID(_rowText, _startPos, _endPos - _startPos + 1),
                            _casedText, IF(_ignoreCase, UPPER(_searchText), _searchText),
                            _searchLen, LEN(_searchText),
                            _chars, MID(Chars, SEQUENCE(1, LEN(Chars)), 1),
                            _casedChars, IF(_ignoreCase, UPPER(_chars), _chars),
                            _findCount, LET(
                                _removed, REDUCE(_casedText, _casedChars,
                                    LAMBDA(_acc, _curr, SUBSTITUTE(_acc, _curr, ""))
                                ),
                                _searchLen - LEN(_removed)
                            ),
                            IF(_findCount < ABS(_n), _returnNone,
                                LET(
                                    // nth can count from end backwards
                                    _nth, IF(_n > 0, _n, _findCount + _n + 1),
                                    _nthPos, REDUCE(0, SEQUENCE(1, _nth),
                                        LAMBDA(_acc, _curr,
                                            IF(_acc < 0, -1,
                                                LET(
                                                    _nextPosChars, IFERROR(FIND(_casedChars, _casedText, _acc + 1), 0),
                                                    _nextPos, MIN(FILTER(_nextPosChars, _nextPosChars > 0, 0)),
                                                    IF(_nextPos = 0, -1, _nextPos)
                                                )
                                            )
                                        )
                                    ),
                                    _outPos, _nthPos + _startPos - 1,
                    
                                    IFS(
                                        _outPos < 1, _returnNone,
                                        _outChar, HSTACK(_outPos, MID(_searchText, _nthPos, 1)),
                                        TRUE, _outPos
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ),
        DROP(
            REDUCE({0}, SEQUENCE(ROWS(Text)),
                LAMBDA(_acc, _curr,
                    VSTACK(_acc, fnNthChar(INDEX(Text, _curr)))
                )
            ), 1
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
SPLIT_FOR_CHARS

Splits text at any character not in the given set. First element returned is the count of substrings, then second
element is the sequence of unmatched characters, followed by each substring. Matching is case-insensitive by default.

Array compatible: Text parameter as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Number of substrings (n)
 2 | text    | Unmatched characters
 3 | text    | Array of substrings [1..n]

Parameters
----------------------------------------------------------------------------------------------------------------
Text            | text    | Text to split
Chars           | text    | Valid characters for each substring
[Limit]         | integer | Limit at which to stop splitting
[CaseSensitive] | boolean | Match letter case

Examples
----------------------------------------------------------------------------------------------------------------
SPLIT_FOR_CHARS("A12b34B56", "123456")
Returns: {4, "AbB", , 12, 34, 56}
--------------------------------------------------------------------------------------------------------------*/
SPLIT_FOR_CHARS = LAMBDA(Text, Chars, [Limit], [CaseSensitive],
    LET(
        _limit, MAX(INT(N(Limit)), 0),
        IF((Text = "") + (Chars = "") + (_limit = 1), HSTACK(1, "", NULLIFY(Text)),
            LET(
                _ignoreCase, N(CaseSensitive) = 0,
                _chars, MID(Chars, SEQUENCE(LEN(Chars)), 1),
                fnMatchChar, LAMBDA(_c,
                    LET(
                        _charMatches, IF(_ignoreCase,
                            _c = _chars,
                            CODE(_c) = CODE(_chars)
                        ),
                        N(MAX(N(_charMatches)) <> 0)
                    ) 
                ),
                fnSplitAround, LAMBDA(_rowText,
                    LET(
                        _len, LEN(_rowText),
                        _firstChar, LEFT(_rowText, 1),
                        _init, IF(fnMatchChar(_firstChar),
                            HSTACK("", _firstChar, 1),
                            HSTACK(_firstChar, "", 0)
                        ),
                        _split, REDUCE(_init, SEQUENCE(1, _len - 1, 2),
                            LAMBDA(_acc, _curr,
                                LET(
                                    _accLastCol, COLUMNS(_acc),
                                    _currChar, MID(_rowText, _curr, 1),
                                    IF((_limit > 1) * (_accLastCol - 2 = _limit),
                                        HSTACK(TAKE(_acc, 1, _accLastCol - 2), INDEX(_acc, 1, _accLastCol - 1) & _currChar, 1),
                                        LET(
                                            _lastMatch, INDEX(_acc, 1, _accLastCol),
                                            _thisMatch, fnMatchChar(_currChar),
                                            IF(_thisMatch,
                                                IF(_lastMatch,
                                                    HSTACK(TAKE(_acc, 1, _accLastCol - 2), INDEX(_acc, 1, _accLastCol - 1) & _currChar, 1),
                                                    HSTACK(TAKE(_acc, 1, _accLastCol - 1), _currChar, 1)
                                                ),
                                                HSTACK(INDEX(_acc, 1, 1) & _currChar, DROP(TAKE(_acc, 1, _accLastCol - 1),, 1), 0)
                                            )
                                        )
                                    )
                                )
                            )
                        ),
                        _splitLastCol, COLUMNS(_split),
                        IF(INDEX(_split, 1, _splitLastCol) = 0,
                            HSTACK(_splitLastCol - 1, DROP(_split, , -1), ""),
                            HSTACK(_splitLastCol - 2, DROP(_split, , -1))
                        )
                    )
                ),
                DROP(
                    REDUCE({0}, SEQUENCE(ROWS(Text)),
                        LAMBDA(_acc, _curr,
                            VSTACK(_acc, fnSplitAround(INDEX(Text, _curr)))
                        )
                    ), 1
                )
            )
        )
    )
);

/*--------------------------------------------------------------------------------------------------------------
SIFT_FOR_CHARS

Returns in sorted order the characters found in a text string found from a given set of characters. An upper limit
can be set on the number of times any character can be matched. Matching is case-insensitive by default.

Array compatible: Text parameter only

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | Matched characters, sorted

Parameters
----------------------------------------------------------------------------------------------------------------
Text            | text    | Text to sift
Chars           | text    | Characters to match
[Limit]         | integer | Upper limit for matches
                |         | 0 for no limit
                |         | Defaults to 1
[CaseSensitive] | boolean | Match letter case

Examples
----------------------------------------------------------------------------------------------------------------
SIFT_FOR_CHARS("CDA_b_B", "abc")
Returns: "AbC"
--------------------------------------------------------------------------------------------------------------*/
SIFT_FOR_CHARS = LAMBDA(Text, Chars, [Limit], [CaseSensitive],
    IF((Text = "") + (Chars = ""), "",
        LET(
            _limit, IF(ISNUMBER(Limit), MAX(INT(Limit), 0), 1),
            _ignoreCase, N(CaseSensitive) = 0,
            _targetChars, LET(
                _charArray, MID(Chars, SEQUENCE(LEN(Chars)), 1),
                IF(_ignoreCase, UNIQUE(_charArray),
                    UNIQUE(CODE(_charArray))
                 )
            ),
            fnMatchChar, LAMBDA(_refChars,
                BYROW(_refChars,
                    LAMBDA(_c,
                        LET(
                            _charMatches, IF(_ignoreCase,
                                _c = _targetChars,
                                CODE(_c) = _targetChars
                            ),
                            N(MAX(N(_charMatches)) <> 0)
                        )
                    )
                ) 
            ),
            fnSiftChars, LAMBDA(_text,
                LET(
                    _charList, MID(_text, SEQUENCE(LEN(_text)), 1),
                    _charFiltered, FILTER(_charList, fnMatchChar(_charList), ""),
                    _charSorted, IF(_ignoreCase,
                        SORT(_charFiltered),
                        SORTBY(_charFiltered, _charFiltered, 1, IFERROR(CODE(_charFiltered), 0), 1)
                    ),
                    _charLimited, IF(_limit = 0, _charSorted,
                        LET(
                            _repeats, SCAN(0, SEQUENCE(ROWS(_charSorted)),
                                LAMBDA(_acc, _curr,
                                    IF(_acc = 0, 1,
                                        IF(_ignoreCase,
                                            IF(INDEX(_charSorted, _curr) = INDEX(_charSorted, _curr - 1), _acc + 1, 1),
                                            IF(CODE(INDEX(_charSorted, _curr)) = CODE(INDEX(_charSorted, _curr - 1)), _acc + 1, 1)
                                        )
                                    )
                                )
                            ),
                            FILTER(_charSorted, _repeats <= _limit, "")
                        )
                    ),
                    TEXTJOIN("", TRUE, _charLimited)
                )
            ),
            MAP(Text, LAMBDA(_element, fnSiftChars(_element))
            )
        )
    )
); 


/*##############################################################################################################
# TIMESPAN                                                                                                     #
##############################################################################################################*/


/*--------------------------------------------------------------------------------------------------------------
VALIDATE_TIMESPAN

Validate each element of a sexagesimal representation of a timespan.
A component can exceed its modulus if no higher order component is provided.

Array compatible: As columns

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | decimal [0..]    | Days
 3 | decimal [0..24)  | Hours
 4 | decimal [0..60)  | Minutes
 5 | decimal [0..60)  | Seconds

Parameters
----------------------------------------------------------------------------------------------------------------
TimeSpan_C5 | array   C[2..5]  |
   Sign     | integer [-1,0,1] |
   Days     | decimal [0..]    | Fractional allowed if hours, minutes and seconds empty.
   Hours    | decimal [0..24)  | Fractional allowed if minutes and seconds empty.
   Minutes  | decimal [0..60)  | Fractional allowed if seconds empty.
   Seconds  | decimal [0..60)  | Fractional allowed
--------------------------------------------------------------------------------------------------------------*/
VALIDATE_TIMESPAN = LAMBDA(TimeSpan_C5,
    LET(
        fnValidateTimeSpan, LAMBDA(_timeSpan,
            LET(
                _colCount, COLUMNS(TimeSpan_C5),
                IFS(
                    (_colCount > 5) + (_colCount < 2), ({#REF!} * SEQUENCE(1, _colCount)),
                    MAX(N(NOT(IS_EMPTY(_timeSpan)))) = 0, TAKE({"","","","",""}, 1, _colCount),
                    TRUE, LET(
                        _sign, LET(
                            _s, INDEX(_timeSpan, 1, 1),
                            IFS(
                                ISERROR(_s), HSTACK(_s),
                                NOT(ISNUMBER(_s)), {#VALUE!},
                                MAX(N(_s = {-1,0,1})) = 0, {#NUM!},
                                TRUE, _s
                            )
                        ),
                        _isZeroed, IFERROR(_sign, 1) = 0,
                        _high, IFS(
                            NOT(IS_EMPTY(IFERROR(INDEX(_timeSpan, 1, 2), ""))), 1,
                            NOT(IS_EMPTY(IFERROR(INDEX(_timeSpan, 1, 3), ""))), 2,
                            NOT(IS_EMPTY(IFERROR(INDEX(_timeSpan, 1, 4), ""))), 3,
                            NOT(IS_EMPTY(IFERROR(INDEX(_timeSpan, 1, 5), ""))), 4,
                            TRUE, 0
                        ),
                        IF(_high = 0, HSTACK(_sign, ({#VALUE!} * SEQUENCE(1, _colCount-1))),
                            LET(
                                _low, IFS(
                                    NOT(IS_EMPTY(IFERROR(INDEX(_timeSpan, 1, 5),""))), 4,
                                    NOT(IS_EMPTY(IFERROR(INDEX(_timeSpan, 1, 4),""))), 3,
                                    NOT(IS_EMPTY(IFERROR(INDEX(_timeSpan, 1, 3),""))), 2,
                                    NOT(IS_EMPTY(IFERROR(INDEX(_timeSpan, 1, 2),""))), 1,
                                    TRUE, 0
                                ),
                                fnValidateComponentValue, LAMBDA(_idx, _modulus,
                                    IF((_high > _idx) + (_low < _idx), "",
                                        LET(
                                            _comp, INDEX(_timeSpan, 1, _idx + 1),
                                            IFS(
                                                ISERROR(_comp), HSTACK(_comp),
                                                NOT(ISNUMBER(_comp)), {#VALUE!},
                                                _comp < 0, {#NUM!},
                                                _isZeroed * (_comp > 0), {#NUM!},
                                                (_high < _idx) * (_comp >= _modulus), {#NUM!},
                                                (_low > _idx) * NOT(IS_INTEGER(_comp)), {#NUM!},
                                                TRUE, _comp
                                            )
                                        )
                                    )
                                ),
                                _days, fnValidateComponentValue(1, 0),
                                _hours, fnValidateComponentValue(2, 24),
                                _minutes, fnValidateComponentValue(3, 60),
                                _seconds, fnValidateComponentValue(4, 60),
                                TAKE(
                                    HSTACK(_sign, _days, _hours, _minutes, _seconds),
                                    1, _colCount
                                )
                            )
                        )
                    )
                )
            )
        ),
        _rowCount, ROWS(TimeSpan_C5),
        DROP(
            REDUCE({""}, SEQUENCE(_rowCount),
                LAMBDA(_acc, _curr,
                    VSTACK(
                        _acc,
                        fnValidateTimeSpan(INDEX(TimeSpan_C5, _curr, ))
                    )
                )
            ), 1
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
IS_VALID_TIMESPAN

Tests if sexagesimal representation of a timespan is valid.
A component can exceed its modulus if no higher order component is provided.

Array compatible: As columns

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
----------------------------------------------------------------------------------------------------------------
TimeSpan_C5 | array   C[2..5]  |
   Sign     | integer [-1,0,1] |
   Days     | decimal [0..]    | Fractional allowed if hours, minutes and seconds empty.
   Hours    | decimal [0..24)  | Fractional allowed if minutes and seconds empty.
   Minutes  | decimal [0..60)  | Fractional allowed if seconds empty.
   Seconds  | decimal [0..60)  | Fractional allowed
--------------------------------------------------------------------------------------------------------------*/
IS_VALID_TIMESPAN = LAMBDA(TimeSpan_C5,
    BYROW(TimeSpan_C5,
        LAMBDA(_timeSpan,
            IF(MAX(N(NOT(IS_EMPTY(_timeSpan)))) = 0, FALSE,
                LET(
                    _validateTimeSpan, VALIDATE_TIMESPAN(_timeSpan),
                    MAX(N(ISERROR(_validateTimeSpan))) = 0
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
TIMESPAN_LOW_ORDER

Returns a number representing the lowest order element of the sexagesimal representation of a timespan value.
Assumes the timespan is validly resolved.

Array compatible: As columns

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Order, #N/A for zero
   |         |  1 - Day
   |         |  2 - Hour
   |         |  3 - Minute
   |         |  4 - Second

Parameters
----------------------------------------------------------------------------------------------------------------
TimeSpan_C5 | array   C[2..5]  |
   Sign     | integer [-1,0,1] |
   Days     | decimal [0..]    | Fractional allowed if hours, minutes and seconds empty.
   Hours    | decimal [0..24)  | Fractional allowed if minutes and seconds empty.
   Minutes  | decimal [0..60)  | Fractional allowed if seconds empty.
   Seconds  | decimal [0..60)  | Fractional allowed
--------------------------------------------------------------------------------------------------------------*/
TIMESPAN_LOW_ORDER = LAMBDA(TimeSpan_C5,
    BYROW(TimeSpan_C5,
        LAMBDA(_timeSpan,
            LET(
                _colCount, COLUMNS(_timeSpan),
                IFS(
                    (_colCount > 5) + (_colCount < 2), {#REF!},
                    MAX(N(NOT(IS_EMPTY(_timeSpan)))) = 0, {#VALUE!},
                    TRUE, LET(
                        _sign, INDEX(_timeSpan, 1, 1),
                        _days, N(INDEX(_timeSpan, 1, 2)),
                        _hours, IF(_colCount < 3, 0, N(INDEX(_timeSpan, 1, 3))),
                        _minutes, IF(_colCount < 4, 0, N(INDEX(_timeSpan, 1, 4))),
                        _seconds, IF(_colCount < 5, 0, N(INDEX(_timeSpan, 1, 5))),
                        IFS(
                            NOT(ISNUMBER(_sign)), {#VALUE!},
                            MAX(N(_sign = {-1,0,1})) = 0, {#VALUE!},
                            _sign = 0, {#N/A},
                            TRUE, LET(
                                _totalSecs, (_days * 86400) + (_hours * 3600) + (_minutes * 60) + _seconds,
                                IFS(
                                    ISERROR(_totalSecs), {#VALUE!},
                                    _totalSecs < 0, {#VALUE!},
                                    _totalSecs = 0, {#N/A},
                                    NOT(IS_INTEGER(_totalSecs / 60)), 4,
                                    NOT(IS_INTEGER(_totalSecs / 3600)), 3,
                                    NOT(IS_INTEGER(_totalSecs / 86400)), 2,
                                    TRUE, 1
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
TIMESPAN_HIGH_ORDER

Returns a number representing the highest order component of the sexagesimal representation of a timespan value.

Array compatible: As columns

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Order, #N/A for zero
   |         |  1 - Day
   |         |  2 - Hour
   |         |  3 - Minute
   |         |  4 - Second

Parameters
----------------------------------------------------------------------------------------------------------------
TimeSpan_C5 | array   C[2..5]  |
   Sign     | integer [-1,0,1] |
   Days     | decimal [0..]    | Fractional allowed if hours, minutes and seconds empty.
   Hours    | decimal [0..24)  | Fractional allowed if minutes and seconds empty.
   Minutes  | decimal [0..60)  | Fractional allowed if seconds empty.
   Seconds  | decimal [0..60)  | Fractional allowed
--------------------------------------------------------------------------------------------------------------*/
TIMESPAN_HIGH_ORDER = LAMBDA(TimeSpan_C5,
    BYROW(TimeSpan_C5,
        LAMBDA(_timeSpan,
            LET(
                _colCount, COLUMNS(_timeSpan),
                IFS(
                    (_colCount > 5) + (_colCount < 2), {#REF!},
                    MAX(N(NOT(IS_EMPTY(_timeSpan)))) = 0, {#VALUE!},
                    TRUE, LET(
                        _sign, INDEX(_timeSpan, 1, 1),
                        _days, N(INDEX(_timeSpan, 1, 2)),
                        _hours, IF(_colCount < 3, 0, N(INDEX(_timeSpan, 1, 3))),
                        _minutes, IF(_colCount < 4, 0, N(INDEX(_timeSpan, 1, 4))),
                        _seconds, IF(_colCount < 5, 0, N(INDEX(_timeSpan, 1, 5))),
                        IFS(
                            NOT(ISNUMBER(_sign)), {#VALUE!},
                            MAX(N(_sign = {-1,0,1})) = 0, {#VALUE!},
                            _sign = 0, {#N/A},
                            TRUE, LET(
                                _totalSecs, (_days * 86400) + (_hours * 3600) + (_minutes * 60) + _seconds,
                                IFS(
                                    ISERROR(_totalSecs), {#VALUE!},
                                    _totalSecs < 0, {#VALUE!},
                                    _totalSecs = 0, {#N/A},
                                    _totalSecs >= 86400, 1,
                                    _totalSecs >= 3600, 2,
                                    _totalSecs >= 60, 3,
                                    TRUE, 4
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
TIMESPAN

Returns a decimal timespan as a fraction of a day from a sexagesimal representation of time.
Note components exceeding their modulus will carry.

Array compatible: As columns

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Timespan as fraction of a day. Implicitly converts to Excel Date/Time type for non-negative
   |         | values.

Parameters
----------------------------------------------------------------------------------------------------------------
TimeSpan_C5 | array   C[2..5]  |
   Sign     | integer [-1,0,1] |
   Days     | decimal [0..]    | Fractional allowed if hours, minutes and seconds empty.
   Hours    | decimal [0..24)  | Fractional allowed if minutes and seconds empty.
   Minutes  | decimal [0..60)  | Fractional allowed if seconds empty.
   Seconds  | decimal [0..60)  | Fractional allowed
--------------------------------------------------------------------------------------------------------------*/
TIMESPAN = LAMBDA(TimeSpan_C5,
    BYROW(TimeSpan_C5,
        LAMBDA(_timeSpan,
            LET(
                _colCount, COLUMNS(_timeSpan),
                IFS(
                    (_colCount > 5) + (_colCount < 2), {#REF!},
                    MAX(N(NOT(IS_EMPTY(_timeSpan)))) = 0, "",
                    MAX(N(ISERROR(_timeSpan))) = 1, {#VALUE!},
                    TRUE, LET(
                        _sign, INDEX(_timeSpan, 1, 1),
                        _days, N(INDEX(_timeSpan, 1, 2)),
                        _hours, IF(_colCount < 3, 0, N(INDEX(_timeSpan, 1, 3))),
                        _minutes, IF(_colCount < 4, 0, N(INDEX(_timeSpan, 1, 4))),
                        _seconds, IF(_colCount < 5, 0, N(INDEX(_timeSpan, 1, 5))),
                        IFS(
                            NOT(ISNUMBER(_sign)), {#VALUE!},
                            MAX(N(_sign = {-1,0,1})) = 0, {#VALUE!},
                            _sign = 0, 0,
                            TRUE, _sign * (_days + (_hours / 24) + (_minutes / 1440) + (_seconds / 86400))
                        )
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
ROUND_TIMESPAN

Returns a decimal timespan value rounded to the specified low order component and precision level.

Array compatible: TimeSpan_D only

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | TimeSpan

Parameters
----------------------------------------------------------------------------------------------------------------
TimeSpan_D  | decimal | Decimal timespan where a day = 1
[LowOrder]  | integer | Lowest-order component to round at. Defaults to Second.
            | [1..4]  |  1 - Day
            |         |  2 - Hour
            |         |  3 - Minute
            |         |  4 - Second
[Precision] | integer | Select precision level
            | [0..9]  | Defaults to 0
[Truncate]  | switch  | Round to precision by truncating components. Default is rounding to nearest.
--------------------------------------------------------------------------------------------------------------*/
ROUND_TIMESPAN = LAMBDA(TimeSpan_D, [LowOrder], [Precision], [Truncate],
    LET(
        _lowOrder, IFS(
            NOT(ISNUMBER(LowOrder)), 4,
            LowOrder < 1, 1,
            LowOrder > 4, 4,
            TRUE, INT(LowOrder)
        ),
        _precision, IFS(
            NOT(ISNUMBER(Precision)), 0,
            Precision < 0, 0,
            Precision > 9, 9,
            TRUE, INT(Precision)
        ),
        _truncate, N(Truncate) <> 0,
        MAP(TimeSpan_D, 
            LAMBDA(_timeSpan,
                IFS(
                    IS_EMPTY(_timeSpan), "",
                    NOT(ISNUMBER(_timeSpan)), {#VALUE!},
                    _timeSpan = 0, 0,
                    _truncate, IFS(
                        _lowOrder = 1, ROUNDDOWN(_timeSpan, _precision),
                        _lowOrder = 2, ROUNDDOWN(_timeSpan * 24, _precision) / 24,
                        _lowOrder = 3, ROUNDDOWN(_timeSpan * 1440, _precision) / 1440,
                        _lowOrder = 4, ROUNDDOWN(_timeSpan * 86400, _precision) / 86400
                    ),
                    TRUE, IFS(
                        _lowOrder = 1, ROUND(_timeSpan, _precision),
                        _lowOrder = 2, ROUND(_timeSpan * 24, _precision) / 24,
                        _lowOrder = 3, ROUND(_timeSpan * 1440, _precision) / 1440,
                        _lowOrder = 4, ROUND(_timeSpan * 86400, _precision) / 86400
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
RESOLVE_TIMESPAN

Returns the sexagesimal representation of a timespan value expressed from the specified high order component
and the given lowest order component rounded to the specified precision.

Array compatible: TimeSpan_D as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Days
 3 | integer [0..23]  | Hours
 4 | integer [0..59]  | Minutes
 5 | decimal [0..60)  | Seconds

Parameters
----------------------------------------------------------------------------------------------------------------
TimeSpan_D    | decimal | Decimal timespan where a day = 1
[HighOrder]   | integer | Highest-order component. Defaults to Day.
              | [1..4]  |  1 - Day
              |         |  2 - Hour
              |         |  3 - Minute
              |         |  4 - Second
[LowOrder]    | integer | Lowest-order component. Defaults to Second.
              | [1..4]  |  1 - Day
              |         |  2 - Hour
              |         |  3 - Minute
              |         |  4 - Second
[Precision]   | integer | Select precision level
              | [0..9]  | Null - Floating
[Truncate]    | switch  | Round to precision by truncating components. Default is rounding to nearest.
--------------------------------------------------------------------------------------------------------------*/
RESOLVE_TIMESPAN = LAMBDA(TimeSpan_D, [HighOrder], [LowOrder], [Precision], [Truncate],
    LET(
        _maxPrecision, 9,
        
        _lowOrder, IFS(
            NOT(ISNUMBER(LowOrder)), 4,
            LowOrder < 1, 4,
            LowOrder > 4, 4,
            TRUE, INT(LowOrder)
        ),
        
        _highOrder, LET(
            _high, IFS(
                NOT(ISNUMBER(HighOrder)), 1,
                HighOrder < 1, 1,
                HighOrder > 4, 4,
                TRUE, INT(HighOrder)
            ),
            IF(_high > _lowOrder, _lowOrder, _high)
        ),
        
        _float, NOT(ISNUMBER(Precision)),
        _truncate, ISNUMBER(Precision) * (N(Truncate) <> 0),
        _precision, IFS(
            NOT(ISNUMBER(Precision)), "",
            Precision < 0, 0,
            Precision > _maxPrecision, _maxPrecision,
            TRUE, INT(Precision)
        ),
        
        fnRoundLastComponent, LAMBDA(_number,
            IFS(
                _float, _number,
                _truncate, ROUNDDOWN(_number, _precision),
                TRUE, ROUND(_number, _precision)
            )
        ),

        fnCheckSign, LAMBDA(_sign, _d, _h, _m, _s,
            IFS(
                _s > 0, _sign,
                _m > 0, _sign,
                _h > 0, _sign,
                _d > 0, _sign,
                TRUE, 0
            )
        ),
           
        fnResolveTimeSpan, LAMBDA(_timeSpan,
            IFS(
                _timeSpan = "", {"", "", "", "", ""},
                NOT(ISNUMBER(_timeSpan)), {#VALUE!, "", "", "", ""},
                _timeSpan = 0, MAP(SEQUENCE(1,5),
                    LAMBDA(_n,
                        IFS(
                            _n = 1, 0,
                            _n - 1 < _highOrder, "",
                            _n - 1 > _lowOrder, "",
                            TRUE, 0
                        )
                    )
                ),
                TRUE, LET(
                    _absTimeSpan, ABS(_timeSpan),
                    _sign, SIGN(_timeSpan),
                    IFS(
                        _highOrder = 1, IFS(
                            _lowOrder = 4, LET(
                                _rDay, INT(_absTimeSpan),
                                _hours, MOD(_absTimeSpan, 1) * 24,
                                _rHour, INT(_hours),
                                _minutes, MOD(_hours, 1) * 60,
                                _rMinute, INT(_minutes),
                                _seconds, MOD(_minutes, 1) * 60,
                                // Round second last because arithmetic rounding of the timespan decimal value
                                // can bring in floating point errors.
                                // Sign checked for rounding down to zero.
                                // Second checked for rounding up to minute.
                                _rSecond, fnRoundLastComponent(_seconds),
                                _rSign, fnCheckSign(_sign, _rDay, _rHour, _rMinute, _rSecond),
                                IFS(
                                    _rSecond < 60, HSTACK(_rSign, _rDay, _rHour, _rMinute, _rSecond),
                                    _rMinute <= 58, HSTACK(_rSign, _rDay, _rHour, _rMinute + 1, 0),
                                    _rHour <= 22, HSTACK(_rSign, _rDay, _rHour + 1, 0, 0),
                                    TRUE, HSTACK(_rSign, _rDay + 1, 0, 0, 0)
                                )
                            ),
                        
                            _lowOrder = 3, LET(
                                _rDay, INT(_absTimeSpan),
                                _hours, MOD(_absTimeSpan, 1) * 24,
                                _rHour, INT(_hours),
                                _minutes, MOD(_hours, 1) * 60,
                                // Round minute last because arithmetic rounding of the timespan decimal value
                                // can bring in floating point errors.
                                // Sign checked for rounding down to zero.
                                // Minute checked for rounding up to hour.
                                _rMinute, fnRoundLastComponent(_minutes),
                                _rSign, fnCheckSign(_sign, _rDay, _rHour, _rMinute, 0),
                                IFS(
                                    _rMinute < 60, HSTACK(_rSign, _rDay, _rHour, _rMinute, ""),
                                    _rHour <= 22, HSTACK(_rSign, _rDay, _rHour + 1, 0, ""),
                                    TRUE, HSTACK(_rSign, _rDay + 1, 0, 0, "")
                                )
                            ),
                            _lowOrder = 2, LET(
                                _rDay, INT(_absTimeSpan),
                                _hours, MOD(_absTimeSpan, 1) * 24,
                                // Round hour last because arithmetic rounding of the timespan decimal value
                                // can bring in floating point errors.
                                // Sign checked for rounding down to zero.
                                // Hour checked for rounding up to day.
                                _rHour, fnRoundLastComponent(_hours),
                                _rSign, fnCheckSign(_sign, _rDay, _rHour, 0, 0),
                                IFS(
                                    _rHour < 24, HSTACK(_rSign, _rDay, _rHour, "", ""),
                                    TRUE, HSTACK(_rSign, _rDay + 1, 0, "", "")
                                )
                            ),
                            _lowOrder = 1, LET(
                                _rDay, fnRoundLastComponent(_absTimeSpan),
                                _rSign, fnCheckSign(_sign, _rDay, 0, 0, 0),
                                HSTACK(_rSign, _rDay, "", "", "")
                            )
                        ),

                        _highOrder = 2, IFS(
                            _lowOrder = 4, LET(
                                _hours, _absTimeSpan * 24,
                                _rHour, INT(_hours),
                                _minutes, MOD(_hours, 1) * 60,
                                _rMinute, INT(_minutes),
                                _seconds, MOD(_minutes, 1) * 60,
                                // Round second last because arithmetic rounding of the timespan decimal value
                                // can bring in floating point errors.
                                // Sign checked for rounding down to zero.
                                // Second checked for rounding up to minute.
                                _rSecond, fnRoundLastComponent(_seconds),
                                _rSign, fnCheckSign(_sign, 0, _rHour, _rMinute, _rSecond),
                                IFS(
                                    _rSecond < 60, HSTACK(_rSign, "", _rHour, _rMinute, _rSecond),
                                    _rMinute <= 58, HSTACK(_rSign, "", _rHour, _rMinute + 1, 0),
                                    TRUE, HSTACK(_rSign, "", _rHour + 1, 0, 0)
                                )
                            ),
                        
                            _lowOrder = 3, LET(
                                _hours, _absTimeSpan * 24,
                                _rHour, INT(_hours),
                                _minutes, MOD(_hours, 1) * 60,
                                // Round minute last because arithmetic rounding of the timespan decimal value
                                // can bring in floating point errors.
                                // Sign checked for rounding down to zero.
                                // Minute checked for rounding up to hour.
                                _rMinute, fnRoundLastComponent(_minutes),
                                _rSign, fnCheckSign(_sign, 0, _rHour, _rMinute, 0),
                                IF(_rMinute < 60,
                                    HSTACK(_rSign, "", _rHour, _rMinute, ""),
                                    HSTACK(_rSign, "", _rHour + 1, 0, "")
                                )
                            ),
                            _lowOrder = 2, LET(
                                _hours, _absTimeSpan * 24,
                                // Round hour last because arithmetic rounding of the timespan decimal value
                                // can bring in floating point errors.
                                // Sign checked for rounding down to zero.
                                // Hour checked for rounding up to day.
                                _rHour, fnRoundLastComponent(_hours),
                                _rSign, fnCheckSign(_sign, 0, _rHour, 0, 0),
                                HSTACK(_rSign, "", _rHour, "", "")
                            )
                        ),

                        _highOrder = 3, IFS(
                            _lowOrder = 4, LET(
                                _minutes, _absTimeSpan * 1440,
                                _rMinute, INT(_minutes),
                                _seconds, MOD(_minutes, 1) * 60,
                                // Round second last because arithmetic rounding of the timespan decimal value
                                // can bring in floating point errors.
                                // Sign checked for rounding down to zero.
                                // Second checked for rounding up to minute.
                                _rSecond, fnRoundLastComponent(_seconds),
                                _rSign, fnCheckSign(_sign, 0, 0, _rMinute, _rSecond),
                                IF(_rSecond < 60,
                                    HSTACK(_rSign, "", "", _rMinute, _rSecond),
                                    HSTACK(_rSign, "", "", _rMinute + 1, 0)
                                )
                            ),
                        
                            _lowOrder = 3, LET(
                                _minutes, _absTimeSpan * 1440,
                                // Round minute last because arithmetic rounding of the timespan decimal value
                                // can bring in floating point errors.
                                // Sign checked for rounding down to zero.
                                // Minute checked for rounding up to hour.
                                _rMinute, fnRoundLastComponent(_minutes),
                                _rSign, fnCheckSign(_sign, 0, 0, _rMinute, 0),
                                HSTACK(_rSign, "", "", _rMinute, "")
                            )
                        ),

                        _highOrder = 4, IFS(
                            _lowOrder = 4, LET(
                                _seconds, _absTimeSpan * 86400,
                                // Round second last because arithmetic rounding of the timespan decimal value
                                // can bring in floating point errors.
                                // Sign checked for rounding down to zero.
                                // Second checked for rounding up to minute.
                                _rSecond, fnRoundLastComponent(_seconds),
                                _rSign, fnCheckSign(_sign, 0, 0, 0, _seconds),
                                HSTACK(_rSign, "", "", "", _rSecond)
                            )
                        )
                    )
                )
            )
        ),
        _rowCount, ROWS(TimeSpan_D),
        DROP(
            REDUCE({""}, SEQUENCE(_rowCount),
                LAMBDA(_acc, _curr,
                    VSTACK(
                        _acc,
                        fnResolveTimeSpan(INDEX(TimeSpan_D, _curr, 1))
                    )
                )
            ), 1
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_TIMESPAN

Parses a text timespan expression into sexagesimal components.

Array compatible: TimeSpanText as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal [0..1] | Time of day as decimal fraction of a day.

Output when AsComplication switch set
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Days
 3 | integer [0..23]  | Hours
 4 | integer [0..59]  | Minutes
 5 | decimal [0..60)  | Seconds

Parameters
----------------------------------------------------------------------------------------------------------------
TimeSpanText     | text   | Formatted TimeSpan
[AsComplication] | switch | Output component parts

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_TIMESPAN("12:00")
Returns: 0.5

PARSE_TIMESPAN("24:00:01")
Returns: #NUM!  i.e. range is 0 to 24 hours 
--------------------------------------------------------------------------------------------------------------*/
PARSE_TIMESPAN = LAMBDA(TimeSpanText, [AsComplication],
    LET(
        _asValue, N(AsComplication) = 0,
        _logicTable, {
            // terms, pattern, high, low, skipLastCol, hasDecimal
            5, ".::.", 1, 4, FALSE, TRUE;    // d.hh:mm:ss.000
            4, ".::", 1, 4, FALSE, FALSE;    // d.hh:mm:ss
            4, "::.", 2, 4, FALSE, TRUE;     // h:mm:ss.000
            3, ".:", 1, 3, FALSE, FALSE;     // d.hh:mm
            3, "::", 2, 4, FALSE, FALSE;     // h:mm:ss
            3, ":.", 3, 4, FALSE, TRUE;      // m:ss.000
            2, ":", 2, 3, FALSE, FALSE;      // h:mm
            2, ".", 1, 1, FALSE, TRUE;       // d.000
            1, "", 1, 1, FALSE, FALSE;       // d
            6, "dh'.""", 1, 4, TRUE, TRUE;  // 0d00h00'00.000"
            5, "dh'""", 1, 4, TRUE, FALSE;  // 0d00h00'00"
            5, "dh.'", 1, 3, TRUE, TRUE;    // 0d00h00.000'
            5, "h'.""", 2, 4, TRUE, TRUE;   // 0h00'00.000"
            4, "dh'", 1, 3, TRUE, FALSE;    // 0d00h00'
            4, "h'""", 2, 4, TRUE, FALSE;   // 0h00'00"
            4, "d.h", 1, 2, TRUE, TRUE;     // 0d00.000h
            4, "h.'", 2, 3, TRUE, TRUE;     // 0h00.000'
            4, "'.""", 3, 4, TRUE, TRUE;    // 0'00.000"
            3, "dh", 1, 2, TRUE, FALSE;     // 0d00h
            3, "h'", 2, 3, TRUE, FALSE;     // 0h00'
            3, "'""", 3, 4, TRUE, FALSE;    // 0'00"
            3, ".d", 1, 1, TRUE, TRUE;      // 0.000d
            3, ".h", 2, 2, TRUE, TRUE;      // 0.000h
            3, ".'", 3, 3, TRUE, TRUE;      // 0.000'
            3, ".""", 4, 4, TRUE, TRUE;     // 0.000"
            2, "d", 1, 1, TRUE, FALSE;      // 0d
            2, "h", 2, 2, TRUE, FALSE;      // 0h
            2, "'", 3, 3, TRUE, FALSE;      // 0'
            2, """", 4, 4, TRUE, FALSE      // 0"
        },
        fnParseComplication, LAMBDA(_timeSpanText,
            LET(
                _timeSpanText1, IF(IFERROR(FIND(" ", _timeSpanText), 0) = 0,
                    _timeSpanText,
                    IF(FIND_NTH_CHAR(_timeSpanText, "dh'""", 1) > 0,
                        SUBSTITUTE(_timeSpanText, " ", ""),
                        {#VALUE!}
                    )
                ),
                _firstChar, LEFT(_timeSpanText1, 1),
                _hasSign, IFS(
                    _firstChar = "+", TRUE,
                    _firstChar = "-", TRUE,
                    _firstChar = UNICHAR(8722), TRUE,
                    TRUE, FALSE
                ),
                _nominalSign, IFS(
                    _firstChar = "-", -1,
                    _firstChar = UNICHAR(8722), -1,
                    TRUE, 1
                ),
                _uTimeSpan, IF(_hasSign, MID(_timeSpanText1, 2, LEN(_timeSpanText1) - 1), _timeSpanText1),
                _split, SPLIT_FOR_CHARS(_uTimeSpan, "0123456789"),
                _terms, INDEX(_split, 1, 1), 
                _pattern, INDEX(_split, 1, 2),
                _match, FILTER(_logicTable, (CHOOSECOLS(_logicTable, 1) = _terms) * (CHOOSECOLS(_logicTable, 2) = _pattern), ""),
                IF(COLUMNS(_match) = 1, {#VALUE!},
                    LET( 
                        _high, INDEX(_match, 1, 3),
                        _low, INDEX(_match, 1, 4),
                        _nCols, _terms - N(INDEX(_match, 1, 5)),
                        _lastCol, 2 + _nCols,
                        _hasDecimals, INDEX(_match, 1, 6),
                        _expressedTerms, if(_hasDecimals,
                            LET(
                                _decimals, MIN(LEN(INDEX(_split, 1, _lastCol)), 9),
                                IFS(
                                    _nCols > 2,
                                        HSTACK(
                                            VALUE(DROP(TAKE(_split, 1, _lastCol - 2),, 2)),
                                            VALUE(INDEX(_split, 1, _lastCol - 1)) + (VALUE(LEFT(INDEX(_split, 1, _lastCol), _decimals)) / (10 ^ _decimals))
                                        ),
                                    _nCols = 2,
                                        HSTACK(
                                            VALUE(INDEX(_split, 1, _lastCol - 1)) + (VALUE(LEFT(INDEX(_split, 1, _lastCol), _decimals)) / (10 ^ _decimals))
                                        ),
                                    TRUE, {#VALUE!}
                                )
                            ),
                            HSTACK(
                                VALUE(DROP(TAKE(_split, 1, _lastCol),, 2))
                            )
                        ),
                        _trueSign, IF(MAX(N(_expressedTerms > 0)) = 0, 0, _nominalSign), 
                        IFS(
                            (_high = 1) * (_low = 4),
                                HSTACK(
                                    _trueSign,   
                                    _expressedTerms
                                ),
                            (_high > 1) * (_low = 4),
                                HSTACK(
                                    _trueSign,
                                    TAKE({"","",""}, 1, _high - 1),
                                    _expressedTerms
                                ),
                            (_high = 1) * (_low < 4),
                                HSTACK(
                                    _trueSign,
                                    _expressedTerms,
                                    TAKE({"","",""}, 1, 4 - _low)
                                ),
                            TRUE,
                                HSTACK(
                                    _trueSign,
                                    TAKE({"","",""}, 1, _high - 1),
                                    _expressedTerms,
                                    TAKE({"","",""}, 1, 4 - _low)
                                )
                        )
                    )
                )
            )
        ),
        
        DROP(
            REDUCE({""}, SEQUENCE(ROWS(TimeSpanText)),
                LAMBDA(_acc, _curr,
                    LET(
                        _ts, INDEX(TimeSpanText, _curr, ),
                        _out, IF(_asValue,
                            IFS(
                                _ts = "", "",
                                ISNUMBER(_ts), _ts,
                                TRUE, LET(
                                    _complication, fnParseComplication(_ts),
                                    IF(ISERROR(INDEX(_complication, 1, 1)),
                                        {#VALUE!},
                                        TIMESPAN(_complication)
                                    )
                                )
                            ),
                            IF(
                                _ts = "", {"", "", "", "", ""},
                                fnParseComplication(_ts)
                            )
                        ),
                        VSTACK(
                            _acc,
                            _out
                        )
                    )
                )
            ), 1
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
FORMAT_TIMESPAN

Returns a timespan as text in the specified format from a given decimal timespan.

Array compatible: TimeSpan_D only

Output
----------------------------------------------------------------------------------------------------------------
 1 | text    | Formatted timespan d.HH:mm:ss.000

Parameters
----------------------------------------------------------------------------------------------------------------
TimeSpan_D     | decimal | Decimal timespan where a day = 1
[Options]      | text    | String with elements: [T|E][+][P][_][~|<][HighOrder][LowOrder][Precision]
               |         |      T, E : Traditional or European Style. Modern style when not present.
               |         |         + : Display positive sign for non-negative values
               |         |         P : Modern style: pad leading value with zero.
               |         |             Traditional and European styles: pad all values except first with zero.
               |         |         _ : Insert spacing. Not applicable to modern style.
               |         |      ~, < : Force rounding method of low order component: ~ round nearest, < round down
               |         |             If neither specified then defaults to behaviour of the style.
               |         |             Modern style: Round down for days, hours and minutes; round to nearest for seconds.
               |         |             Traditional and European styles: When no precision specified round down for days,
               |         |             hours and minutes; round to nearest for seconds.
               |         | HighOrder : High order component. Upper case to set explicitly. Lower case allows floating
               |         |             from expressing in the given component up to days as needed.
               |         | LowOrder  : Low order component. Upper case to set explicitly. Lower case allows floating
               |         |             from expressing in the given component down to seconds as needed.
               |         | If only a single option is given, it is assumed to be LowOrder.
               |         | Both elements take the following:
               |         |      D, d : Day
               |         |      H, h : Hour
               |         |      M, m : Minute
               |         |      S, s : Second
               |         | Precision : [0-9]
               |         |             Decimal places to display.
               |         |             Modern style: Only applies to seconds.
               |         |             Traditional and European styles: Applies to low order component.
Examples
----------------------------------------------------------------------------------------------------------------
FORMAT_TIMESPAN(1.7865, "")
Returns: 1.18:52:33.6

FORMAT_TIMESPAN(1.7865, "HS3")
Returns: 42:52:33.600

FORMAT_TIMESPAN(1.7865, "T+_HS")
Returns: + 42h 52m 33s"

FORMAT_TIMESPAN(1.7865, "ES")
Returns: 1h18h52'34"
--------------------------------------------------------------------------------------------------------------*/
FORMAT_TIMESPAN = LAMBDA(TimeSpan_D, [Options],
    LET(
        _style, LEFT(SIFT_FOR_CHARS(Options, "TE", 1)),
        _signPositive, IFERROR(FIND("+", Options), 0) > 0,
        _padding, IFERROR(SEARCH("P", Options), 0) > 0,
        _spacing, IFERROR(FIND("_", Options), 0) > 0,
        _rounding, IFS(
            IFERROR(FIND("~", Options), 0) > 0, 1,
            IFERROR(FIND("<", Options), 0) > 0, -1,
            TRUE, 0
        ),
        
        // precision (max 9 decimals for nanoseconds)
        _tryPrecision, FIND_NTH_CHAR(Options, "0123456789", 1, 0, 1),
        _precision, IF(INDEX(_tryPrecision, 1, 1) = 0, "", VALUE(INDEX(_tryPrecision, 1, 2))),
        
        _orderSpec, SIFT_FOR_CHARS(Options, "DHMS", 2),
        _high, IFS(
            _orderSpec = "", {0; 0},
            LEN(_orderSpec) = 1, {0; 0},
            TRUE, LET(
                _h, LEFT(_orderSpec, 1),
                VSTACK(
                    N(CODE(_h) < 100),
                    XMATCH(_h, {"D", "H", "M", "S"}, 0)
                )
            )
        ),
        _hardHigh, INDEX(_high, 1),
        _highOrder, INDEX(_high, 2),

        _low, IF(_orderSpec = "", {0; 0},
            LET(
                _h, RIGHT(LEFT(_orderSpec, 2), 1),
                VSTACK(
                    N(CODE(_h) < 100),
                    XMATCH(_h, {"D", "H", "M", "S"}, 0)
                )
            )
        ),
        _hardLow, INDEX(_low, 1),
        _lowOrder, INDEX(_low, 2),

        fnFormatTimeSpan, LAMBDA(_timeSpan,
            IFS(
                IS_EMPTY(_timeSpan), "",
                NOT(ISNUMBER(_timeSpan)), {#VALUE!},
                TRUE, LET(
                    _provider, IFS(
                        _style = "",
                            _FORMAT_PROVIDER_TIMESPAN_MODERN(_timeSpan, _signPositive, _padding, _precision, _rounding, _hardHigh, _highOrder, _hardLow, _lowOrder),
                        _style = "T",
                            _FORMAT_PROVIDER_TIMESPAN_TRADITIONAL(_timeSpan, _signPositive, _padding, _spacing, _precision, _rounding, _hardHigh, _highOrder, _hardLow, _lowOrder),
                        _style = "E",
                            _FORMAT_PROVIDER_TIMESPAN_EUROPEAN(_timeSpan, _signPositive, _padding, _spacing, _precision, _rounding, _hardHigh, _highOrder, _hardLow, _lowOrder)
                    ),

                    _count, INDEX(_provider, 1, 2) - INDEX(_provider, 1, 1) + 1,
                    _designator, IF(INDEX(_provider, 2, 1) = "", "",
                        INDEX(_provider, 2, 1) & IF(INDEX(_provider, 1, 6), " ", "")
                    ),
                    _parts, MAP(SEQUENCE(1, _count),
                        LAMBDA(_n,
                            LET(
                                _fmt, IFS(
                                    _n = _count, INDEX(_provider, 1, 5),
                                    _n = 1, INDEX(_provider, 1, 3),
                                    TRUE, INDEX(_provider, 1, 4)
                                ),
                                _col, INDEX(_provider, 1, 1) + _n,
                                _part, TEXT(INDEX(_provider, 3, _col), _fmt),
                                _delim, INDEX(_provider, 2, _col),
                                _spc, IF(INDEX(_provider, 1, 6) * (_n < _count), " ", ""),
                                _part & _delim & _spc
                            )
                        )
                    ),
                    CONCAT(_designator, _parts)
                )
            )
        ),

        MAP(TimeSpan_D,
            LAMBDA(_element,
                fnFormatTimeSpan(_element)
            )
        )
    )
);

_FORMAT_PROVIDER_TIMESPAN_MODERN = LAMBDA(TimeSpan_D, SignPositive, Padding, Precision, Rounding, HardHigh, HighOrder, HardLow, LowOrder,
    // Rounding: -1 always round down (truncate = 1)
    //            1 always round to nearest (truncate = 0)
    //            0 default; if resolving to seconds then round to nearest, otherwise round down
    
    LET(
        fnExpressedOrder, LAMBDA(_timeSpan, _direction,
            // _direction = -1 : low end
            //               1 : high end
            LET(
                _sign, INDEX(_timeSpan, 1, 1),
                IF(_sign = 0, {#N/A},
                    LET(
                        _nonZero, N((0 + DROP(_timeSpan, , 1)) <> 0),
                        XMATCH(1, _nonZero, 0, _direction)
                    )
                )
            )
        ),

        _maxPrecision, 9,

        _resolveUsingSeconds, IFS(
            HardLow = 0, TRUE,
            LowOrder = 4, TRUE,
            TRUE, FALSE
        ),

        _resolvePrecision, IFS(
            NOT(_resolveUsingSeconds), 0,
            ISNUMBER(Precision), Precision,
            HardLow = 1, 0,
            TRUE, _maxPrecision
        ),
        
        _resolveTruncate, IFS(
            Rounding = 1, FALSE,
            Rounding = -1, TRUE,
            TRUE, NOT(_resolveUsingSeconds)
        ),

        _resolveHighOrder, IFS(
            HardHigh = 0, 1,
            // high order days or hours
            HighOrder <= 2, HighOrder,
            // modern style high order can only be minutes when seconds explicitly expressed with decimals
            (HighOrder = 3) * (HardLow = 1) * (LowOrder = 4) * (N(Precision) > 0), 3, 
            // otherwise high order is hours
            TRUE, 2
        ),

        _resolveLowOrder, IFS(
            HardLow = 0, 4,
            // modern style low order can only be minutes or seconds
            LowOrder >= 3, LowOrder,
            // otherwise low order is minutes
            TRUE, 3
        ),
        
        _resolveTimeSpan, RESOLVE_TIMESPAN(TimeSpan_D, _resolveHighOrder, _resolveLowOrder, _resolvePrecision, _resolveTruncate),

        _showLowOrder, IF(HardLow, _resolveLowOrder,
            // floating
            LET(
                // modern style low order can only be minutes or seconds
                _minLowOrder, IF(LowOrder = 4, 4, 3),
                _hasLowOrder, IFNA(fnExpressedOrder(_resolveTimeSpan, -1), _minLowOrder),
                MAX(_minLowOrder, _hasLowOrder)
            )
        ),

        _maxFractionalDigits, IFS(
            ISNUMBER(Precision), Precision,
            HardLow = 1, 0,
            TRUE, _maxPrecision
        ),

        _showFractionalDigits, IFS(
            NOT(_resolveUsingSeconds), 0,
            HardLow = 1, _maxFractionalDigits,
            TRUE, MIN(DECIMALS(INDEX(_resolveTimeSpan, 1, 5)), _maxFractionalDigits)
        ),

        _showHighOrder, IF(HardHigh, _resolveHighOrder,
            // floating    
            LET(
                // modern style floating high order can only be days or hours
                _maxHighOrder, IF(HighOrder = 1, 1, 2),
                _hasHighOrder, IFNA(fnExpressedOrder(_resolveTimeSpan, 1), _maxHighOrder),
                MIN(_maxHighOrder, _hasHighOrder)
            )
        ),
        
        _leadFmt, IF(Padding, "00", "0"),
        _midFmt, "00",
        _lastFmt, IF(_showFractionalDigits = 0, _midFmt,
            _midFmt & LEFT(".000000000", _showFractionalDigits + 1)
        ),
        
        _designator, IFS(
            INDEX(_resolveTimeSpan, 1, 1) < 0, UNICHAR(8722),
            SignPositive, "+",
            TRUE, ""
        ),

        _delims, IF(_showLowOrder = 4,
            {".", ":", ":", ""},
            {".", ":", "", ""}
        ),
        
        VSTACK(
            HSTACK(_showHighOrder, _showLowOrder, _leadFmt, _midFmt, _lastFmt, FALSE),
            HSTACK(_designator, _delims, _showFractionalDigits),
            _resolveTimeSpan
        )
    )
);

_FORMAT_PROVIDER_TIMESPAN_TRADITIONAL = LAMBDA(TimeSpan_D, SignPositive, Padding, Spacing, Precision, Rounding, HardHigh, HighOrder, HardLow, LowOrder,
    // Rounding: -1 always round down (truncate = 1)
    //            1 always round to nearest (truncate = 0)
    //            0 default; when resolving to seconds round to nearest, otherwise round down, unless specifiing a precision
    
    LET(
        fnExpressedOrder, LAMBDA(_timeSpan, _direction,
            // _direction = -1 : low end
            //               1 : high end
            LET(
                _sign, INDEX(_timeSpan, 1, 1),
                IF(_sign = 0, {#N/A},
                    LET(
                        _nonZero, N((0 + DROP(_timeSpan, , 1)) <> 0),
                        XMATCH(1, _nonZero, 0, _direction)
                    )
                )
            )
        ),

        _maxPrecision, 9,

        _setPrecision, ISNUMBER(Precision),
        _resolvePrecision, IFS(
            _setPrecision, Precision,
            HardLow = 1, 0,
            TRUE, _maxPrecision
        ),
        
        _resolveHighOrder, IF(HardHigh = 0, 1, HighOrder),
        _resolveLowOrder, IF(HardLow = 0, 4, LowOrder),

        _resolveTruncate, IFS(
            Rounding = 1, FALSE,
            Rounding = -1, TRUE,
            _resolveLowOrder = 4, FALSE,
            TRUE, (_resolvePrecision = 0)
        ),
        
        _resolveTimeSpan, RESOLVE_TIMESPAN(TimeSpan_D, _resolveHighOrder, _resolveLowOrder, _resolvePrecision, _resolveTruncate),

        _showLowOrder, IF(HardLow, _resolveLowOrder,
            // floating
            LET(
                _hasLowOrder, IFNA(fnExpressedOrder(_resolveTimeSpan, -1), IF(LowOrder = 0, 4, LowOrder)),
                MAX(LowOrder, _hasLowOrder)
            )
        ),

        _showFractionalDigits, IF(HardLow = 1, _resolvePrecision,
            MIN(DECIMALS(INDEX(_resolveTimeSpan, 1, _showLowOrder + 1)), _resolvePrecision)
        ),

        _showHighOrder, IF(HardHigh, _resolveHighOrder,
            // floating
            LET(
                _hasHighOrder, IFNA(fnExpressedOrder(_resolveTimeSpan, 1), _showLowOrder),
                IF(HighOrder = 0, _hasHighOrder, 
                    MIN(HighOrder, _hasHighOrder)
                )
            )
        ),
        
        _leadFmt, "0",
        _midFmt, IF(Padding, "00", "0"),
        _lastFmt, IF(_showFractionalDigits = 0, _midFmt,
            _midFmt & LEFT(".000000000", _showFractionalDigits + 1)
        ),
        
        _designator, IFS(
            INDEX(_resolveTimeSpan, 1, 1) < 0, UNICHAR(8722),
            SignPositive, "+",
            TRUE, ""
        ),

        _delims, {"d", "h", "m", "s"},
        
        VSTACK(
            HSTACK(_showHighOrder, _showLowOrder, _leadFmt, _midFmt, _lastFmt, Spacing),
            HSTACK(_designator, _delims, _showFractionalDigits),
            _resolveTimeSpan
        )
    )
);

_FORMAT_PROVIDER_TIMESPAN_EUROPEAN = LAMBDA(TimeSpan_D, SignPositive, Padding, Spacing, Precision, Rounding, HardHigh, HighOrder, HardLow, LowOrder,
    LET(
        _provider, _FORMAT_PROVIDER_TIMESPAN_TRADITIONAL(TimeSpan_D, SignPositive, Padding, Spacing, Precision, Rounding, HardHigh, HighOrder, HardLow, LowOrder),
        _designator, INDEX(_provider, 2, 1),
        _showFractionalDigits, INDEX(_provider, 2, 6),
        _delims, {"d", "h", "'", """"},
        VSTACK(
            CHOOSEROWS(_provider, 1),
            HSTACK(_designator, _delims, _showFractionalDigits),
            CHOOSEROWS(_provider, 3)
        )
    )
);




/*##############################################################################################################
# CALENDAR DATES                                                                                               #
##############################################################################################################*/


/*--------------------------------------------------------------------------------------------------------------
YEAR_COMMON_ERA

Returns year value relative to the Common Era.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | 1 CE = 1, 1 BCE = 0, 2 BCE = -1

Parameters
----------------------------------------------------------------------------------------------------------------
Year  | integer [1..] | Positive non-zero integer.
BCE   | switch        | Before Common Era.
--------------------------------------------------------------------------------------------------------------*/
YEAR_COMMON_ERA = LAMBDA(Year, BCE,
    IFS(
        Year = "", "",
        NOT(ISNUMBER(Year)), {#VALUE!},
        TRUE, LET(
            _year, INT(Year),
            IF(_year < 1, {#NUM!},
                IF(N(BCE), 1 - _year, _year)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_MONTH

Returns a number representing the month of year from a given text month name.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [1..12] | Month

Parameters
----------------------------------------------------------------------------------------------------------------
MonthText | text | Month name

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_MONTH("Feb")
Returns: 2

PARSE_MONTH("January")
Returns: 1

PARSE_MONTH("J")
Returns: #VALUE!

PARSE_MONTH("Marzo")
Returns: 3 (if local language is set to Italian)
--------------------------------------------------------------------------------------------------------------*/
PARSE_MONTH = LAMBDA(MonthText,
    IF(MonthText = "", "",
        MONTH(DATEVALUE(MonthText & " 2000"))
    )
);


/*--------------------------------------------------------------------------------------------------------------
MONTH_NAME

Returns a month as text.

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | Month name

Parameters
----------------------------------------------------------------------------------------------------------------
Month                  | integer [1..12] | Month
[Short]                | switch          | Return short format Jan..Dec
[InternationalEnglish] | switch          | International English instead of local language set in Excel
--------------------------------------------------------------------------------------------------------------*/
MONTH_NAME = LAMBDA(Month, [Short], [InternationalEnglish],
    IFS(
        Month = "", "",
        NOT(ISNUMBER(Month)), #VALUE!,
        TRUE, LET(
            _useShort, N(Short) <> 0,
            _useLocalLang, N(InternationalEnglish) = 0,
            _month, INT(Month),
            IF(_useLocalLang,
                LET(
                    _dayOfMonth, DATE(2000, _month, 1),
                    _fmt, IF(_useShort, "MMM", "MMMM"),
                    TEXT(_dayOfMonth, _fmt)
                ),
                IF(
                    _useShort,
                    INDEX(
                        {
                            "Jan";
                            "Feb";
                            "Mar";
                            "Apr";
                            "May";
                            "Jun";
                            "Jul";
                            "Aug";
                            "Sep";
                            "Oct";
                            "Nov";
                            "Dec"
                        },
                        _month
                    ),
                    INDEX(
                        {
                            "January";
                            "February";
                            "March";
                            "April";
                            "May";
                            "June";
                            "July";
                            "August";
                            "September";
                            "October";
                            "November";
                            "December"
                        },
                        _month
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
IS_LEAP_YEAR

Tests if a year includes a leap day in the given calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean | null if empty

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE           | decimal | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
IS_LEAP_YEAR = LAMBDA(YearCE, [JulianCalendar],
    IFS(
        YearCE = "", "",
        NOT(ISNUMBER(YearCE)), {#VALUE!},
        TRUE, LET(
            _yearCE, INT(YearCE),
            IF(
                N(JulianCalendar) = 0,
                IFS(MOD(_yearCE, 400) = 0, TRUE,
                    MOD(_yearCE, 100) = 0, FALSE,
                    TRUE, MOD(_yearCE, 4) = 0
                ),
                MOD(_yearCE, 4) = 0
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
IS_VALID_DATE

Tests if a date is valid for the given calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] | Month of year
[Day]            | decimal [1..32) | Day of month
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
IS_VALID_DATE = LAMBDA(YearCE, Month, [Day], [JulianCalendar],
    IFS(
        NOT(ISNUMBER(YearCE)) + NOT(ISNUMBER(Month)), FALSE, // cannot ommit year or month
        NOT(IS_INTEGER(YearCE) * IS_INTEGER(Month)), FALSE, // year and month cannot be fractional
        (Month < 1) + (Month > 12), FALSE, 
        Day = "", TRUE,
        TRUE, LET(
            _day, INT(Day),
            IF(_day < 1, FALSE,
                LET(
                    _daysInMonth, DAYS_IN_MONTH(Month, YearCE, JulianCalendar),
                    IF(ISERROR(_daysInMonth), FALSE,
                        _day <= _daysInMonth
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
DAYS_IN_YEAR

Returns number of days in the given year of the specified calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [365,366]

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE           | integer | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian proleptic
                 |         | calendar.
--------------------------------------------------------------------------------------------------------------*/
DAYS_IN_YEAR = LAMBDA(YearCE, [JulianCalendar],
    IFS(
        YearCE = "", "",
        NOT(ISNUMBER(YearCE)), {#VALUE!},
        IS_LEAP_YEAR(YearCE, JulianCalendar), 366,
        TRUE, 365
    )
);


/*--------------------------------------------------------------------------------------------------------------
DAYS_IN_MONTH

Returns number of days in the given month and year of the specified calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [1..31]

Parameters
----------------------------------------------------------------------------------------------------------------
Month            | integer [1..12] | Month of year
[YearCE]         | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
DAYS_IN_MONTH = LAMBDA(Month, [YearCE], [JulianCalendar],
    IFS(
        Month = "", "",
        NOT(ISNUMBER(Month)), {#VALUE!},
        TRUE, LET(
            _month, INT(Month),
            IFS(
                _month < 1, {#NUM!},
                _month > 12, {#NUM!},

                // February
                _month = 2,
                    LET(
                        _leapDay, IF(ISNUMBER(YearCE),
                            N(IS_LEAP_YEAR(YearCE, JulianCalendar)),
                            0
                        ),
                        28 + _leapDay
                    ),

                // Jan, Mar, Apr, May, Jun, Jul
                _month <= 7, 30 + MOD(_month, 2),
                
                // Aug, Sep, Oct, Nov, Dec
                TRUE, 31 - MOD(_month, 2)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_ISO_CALENDAR_DATE

Parses an ISO formatted calendar date into respective parts of year, month and day.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | YearCE
 2 | integer | Month
 3 | integer | Day

Parameters
----------------------------------------------------------------------------------------------------------------
ISOCalendarDate  | text   | Date in ISO format ie. yyyy-MM-dd
[JulianCalendar] | switch | Validate in the Julian proleptic calendar. Default is Gregorian
                 |        | proleptic calendar.

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_ISO_CALENDAR_DATE("2023-05-23")
Returns: {2023, 5, 23}

PARSE_ISO_CALENDAR_DATE("1900-02-29", 1)
Returns: {2023, 2, 29} i.e. Feb 29, 1900 is valid in the Julian calendar
--------------------------------------------------------------------------------------------------------------*/
PARSE_ISO_CALENDAR_DATE = LAMBDA(ISOCalendarDate, [JulianCalendar],
    IFS(
        ISOCalendarDate = "", {"", "", ""},
        NOT(VALIDATE_CHARSET(ISOCalendarDate, "+-0123456789" & UNICHAR(8722))), {#VALUE!, "", ""},
        TRUE, LET(
            _firstChar, LEFT(ISOCalendarDate, 1),
            _isSigned, IFS(
                _firstChar = "+", TRUE,
                _firstChar = "-", TRUE,
                _firstChar = UNICHAR(8722), TRUE,
                TRUE, FALSE
            ),
            _sign, IFS(
                NOT(_isSigned), 1,
                _firstChar = "-", -1,
                _firstChar = UNICHAR(8722), -1,
                TRUE, 1
            ),
            _unSigned, IF(_isSigned,
                RIGHT(ISOCalendarDate, LEN(ISOCalendarDate) - 1),
                ISOCalendarDate
            ),
            _len, LEN(_unSigned),
            _pattern, REPLACE_CHARS(_unSigned, "0123456789", "_"),
            _tryParse, IFS(
                _len >= 10, IFS(
                    _pattern = RIGHT("_______________-__-__", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 6)),
                        VALUE(MID(_unSigned, _len - 4, 2)),
                        VALUE(RIGHT(_unSigned, 2))
                    ),
                    _pattern = RIGHT("_______________-__", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 3)),
                        VALUE(RIGHT(_unSigned, 2)),
                        ""
                    ),
                    _pattern = RIGHT("___________________", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 4)),
                        VALUE(MID(_unSigned, _len - 3, 2)),
                        VALUE(RIGHT(_unSigned, 2))
                    ),
                    TRUE, ""
                ),
                _len >= 8, IFS(
                    _pattern = RIGHT("______-__", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 3)),
                        VALUE(RIGHT(_unSigned, 2)),
                        ""
                    ),
                    _pattern = RIGHT("_________", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 4)),
                        VALUE(MID(_unSigned, _len - 3, 2)),
                        VALUE(RIGHT(_unSigned, 2))
                    ),
                    TRUE, ""
                ),
                _len = 7, IF(
                    _pattern = "____-__",
                    HSTACK(
                        VALUE(LEFT(_unSigned, 4)),
                        VALUE(RIGHT(_unSigned, 2)),
                        ""
                    ),
                    ""
                ),
                (_len >= 4) * (_len <= 5),  IF(
                    _pattern = RIGHT("_____", _len),
                    HSTACK(
                        VALUE(_unSigned),
                        "",
                        ""
                    ),
                    ""
                ),
                TRUE, ""
            ),

            IF(INDEX(_tryParse, 1, 1) = "", {#VALUE!, "", ""},
                LET(
                    _year, _sign * INDEX(_tryParse, 1, 1),
                    _month, INDEX(_tryParse, 1, 2),
                    IFS(
                        _month = "", HSTACK(_year, "", ""),
                        (_month < 1) + (_month > 12), HSTACK(_year, {#NUM!}, ""),
                        TRUE, LET(
                            _day, INDEX(_tryParse, 1, 3),
                            IF(_day = "",
                                HSTACK(_year, _month, ""),    
                                IF(IS_VALID_DATE(_year, _month, _day, JulianCalendar),
                                    HSTACK(_year, _month, _day),
                                    HSTACK(_year, _month, {#NUM!})
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
FORMAT_ISO_YEAR

Returns a year as text in ISO format.

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | ISO formatted year

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE | integer | Note that 1 BC = 0 CE, 2 BC = -1 CE
--------------------------------------------------------------------------------------------------------------*/
FORMAT_ISO_YEAR = LAMBDA(YearCE,
    IFS(
        YearCE = "", "",
        NOT(ISNUMBER(YearCE)), {#VALUE!},
        NOT(IS_INTEGER(YearCE)), {#NUM!},
        TRUE, LET(
            _yearFmt, IF((YearCE >= 1000) * (YearCE <= 9999),
                "0000;" & UNICHAR(8722) & "0000",
                "+0000;" & UNICHAR(8722) & "0000"
            ),
            TEXT(YearCE, _yearFmt)
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
FORMAT_ISO_CALENDAR_DATE

Returns a calendar date as text in ISO format.

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | ISO formatted date

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] |
Day              | integer [1..31] |
[Basic]          | switch          | Display in basic format eg yyyyMMdd
                 |                 | Invalid when Day not provided and YearCE outside of range
                 |                 | -9999..9999 due to collision with yyyyddd ISO format.
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar. 
--------------------------------------------------------------------------------------------------------------*/
FORMAT_ISO_CALENDAR_DATE = LAMBDA(YearCE, Month, Day, [Basic], [JulianCalendar],
    IFS(
        (YearCE = "") * (Month = "") * (Day = ""), "",
        NOT(ISNUMBER(YearCE)), {#VALUE!},
        NOT(IS_NUMERIC_NULL(Month)), {#VALUE!},
        NOT(IS_NUMERIC_NULL(Day)), {#VALUE!},
        NOT(ISNUMBER(Month)) * ISNUMBER(Day), {#VALUE!},
        NOT(ISNUMBER(Month)), FORMAT_ISO_Year(YearCE),
        NOT(IS_VALID_DATE(YearCE, Month, Day, JulianCalendar)), {#NUM!},
        TRUE, LET(
            _basic, N(Basic) <> 0,
            _delim, IF(_basic, "", "-"),
            IFS(
                _basic * (ABS(YearCE) > 9999), {#VALUE!},
                ISNUMBER(Day), CONCAT(
                    FORMAT_ISO_Year(YearCE),
                    _delim, TEXT(Month, "00"),
                    _delim, TEXT(Day, "00")
                ),
                TRUE, CONCAT(
                    FORMAT_ISO_Year(YearCE),
                    _delim, TEXT(Month, "00")
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
JULIAN_DAY_NUMBER

Returns the Julian Day Number (JDN) of the provided date in the specified calendar.
Note the Julian Day Number is an integer type and is an ordinal day number referenced from January 1,
4713 BC in the proleptic Julian calendar. It does not include any value for time of day.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Julian Day Number

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] | Month of year
Day              | integer [1..31] | Day of month
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
JULIAN_DAY_NUMBER = LAMBDA(YearCE, Month, Day, [JulianCalendar],
    IFS(
        (YearCE = "") * (Month = "") * (Day = ""), "",
        NOT(IS_VALID_DATE(YearCE, Month, Day, JulianCalendar)), {#NUM!},
        TRUE, LET(
            _day, INT(Day),
            _gregorian, N(JulianCalendar) = 0,
            _YEAR4801BCE, -4800,
            _G4801BCE_JD, -32045,
            _J4801BCE_JD, -32083,
            _DaysIn5MonthsFromMarch, 153,
            _MarchShiftYear, INT((14 - Month) / 12),
            _years, YearCE - _YEAR4801BCE - _MarchShiftYear,
            _MarchShiftMonth, Month + (12 * _MarchShiftYear) - 3,
            _days, 365 * _years + INT(_years / 4) + INT((_DaysIn5MonthsFromMarch * _MarchShiftMonth + 2) / 5) + _day,
            _days + IF(_gregorian,
                _G4801BCE_JD - INT(_years / 100) + INT(_years / 400),
                _J4801BCE_JD
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
MODIFIED_JULIAN_DAY_NUMBER

Returns the Modified Julian Day Number (MJDN) of the provided date in the specified calendar.
Note the Modified Julian Day Number is an integer type and is an ordinal day number referenced from November 17,
1858 in the proleptic Gregorian calendar. It does not include any value for time of day.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Modified Julian Day Number

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] | Month of year
Day              | integer [1..31] | Day of month
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
MODIFIED_JULIAN_DAY_NUMBER = LAMBDA(YearCE, Month, Day, [JulianCalendar],
    LET(
        _JDN, JULIAN_DAY_NUMBER(YearCE, Month, Day, JulianCalendar),
        IF(NOT(ISNUMBER(_JDN)), _JDN,
            JDN_TO_MODIFIED(_JDN)
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
JDN_TO_MODIFIED

Converts a Julian Day Number (JDN) to a Modified Julian Day Number (MJDN).

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Modified Julian Day Number

Parameters
----------------------------------------------------------------------------------------------------------------
JDN | integer | Julian Day Number
--------------------------------------------------------------------------------------------------------------*/
JDN_TO_MODIFIED = LAMBDA(JDN,
    IF(JDN = "", "",
        INT(JDN) - 2400001
    )
);


/*--------------------------------------------------------------------------------------------------------------
MODIFIED_TO_JDN

Converts a Modified Julian Day Number (MJDN) to a Julian Day Number (JDN).

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Julian Day Number

Parameters
----------------------------------------------------------------------------------------------------------------
MJDN | integer | Modified Julian Day Number
--------------------------------------------------------------------------------------------------------------*/
MODIFIED_TO_JDN = LAMBDA(MJDN,
    IF(MJDN = "", "",
        INT(MJDN) + 2400001
    )
);


/*--------------------------------------------------------------------------------------------------------------
JDN_TO_CALENDAR_DATE

Converts a Julian Day Number to a date in the specified calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day of month

Parameters
----------------------------------------------------------------------------------------------------------------
JDN              | integer | Julian Day Number
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
JDN_TO_CALENDAR_DATE = LAMBDA(JDN, [JulianCalendar],
    IFS(
        JDN = "", {"", "", ""},
        NOT(ISNUMBER(JDN)), {#VALUE!, "", ""},
        TRUE, LET(
            _JDN, INT(JDN),
            _gregorian, N(JulianCalendar) = 0,
            _YEAR4801BCE, -4800,
            _DaysIn4Year, 1461,
            _DaysInYear, 365,
            _MonthCorrectionDays, 308,
            _DaysIn4Months, 122,
            _DaysIn5MonthsFromMarch, 153,
            IF(_gregorian,
                LET(
                    _G4801BCE_JD0, -32045,
                    _GregDaysIn400Year, 146097,
                    _GregDaysIn100Year, 36524,
                    _days0, _jdn - _G4801BCE_JD0 - 1,
                    _quadCent, INT(_days0 / _GregDaysIn400Year),
                    _days1, _days0 - _quadCent * _GregDaysIn400Year,
                    _remCent, INT((INT(_days1 / _GregDaysIn100Year) + 1) * 0.75),
                    _days2, _days1 - _remCent * _GregDaysIn100Year,
                    _quadYr, INT(_days2 / _DaysIn4Year),
                    _days3, _days2 - _quadYr * _DaysIn4Year,
                    _remYr, INT((INT(_days3 / _DaysInYear) + 1) * 0.75),
                    _days4, _days3 - _remYr * _DaysInYear,
                    _y, _quadCent * 400 + _remCent * 100 + _quadYr * 4 + _remYr,
                    _m, INT((_days4 * 5 + _MonthCorrectionDays) / _DaysIn5MonthsFromMarch) - 2,
                    _day, _days4 - INT((_m + 4) * _DaysIn5MonthsFromMarch / 5) +
                        _DaysIn4Months + 1,
                    _year, _YEAR4801BCE + _y + INT((_m + 2) / 12),
                    _month, MOD(_m + 2, 12) + 1,
                    HSTACK(_year, _month, _day)
                ),
                LET(
                    _J4801BCE_JD0, -32083,
                    _days0, _jdn - _J4801BCE_JD0 - 1,
                    _quadYr, INT(_days0 / _DaysIn4Year),
                    _days1, _days0 - _quadYr * _DaysIn4Year,
                    _remYr, INT((INT(_days1 / _DaysInYear) + 1) * 0.75),
                    _days2, _days1 - _remYr * _DaysInYear,
                    _y, _quadYr * 4 + _remYr,
                    _m, INT((_days2 * 5 + _MonthCorrectionDays) / _DaysIn5MonthsFromMarch) - 2,
                    _day, _days2 - INT((_m + 4) * _DaysIn5MonthsFromMarch / 5) +
                        _DaysIn4Months + 1,
                    _year, _YEAR4801BCE + _y + INT((_m + 2) / 12),
                    _month, MOD(_m + 2, 12) + 1,
                    HSTACK(_year, _month, _day)
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
MJDN_TO_CALENDAR_DATE

Converts a Modified Julian Day Number (MJDN) to a date in the specified calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day of month

Parameters
----------------------------------------------------------------------------------------------------------------
MJDN             | integer | Modified Julian Day Number
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
MJDN_TO_CALENDAR_DATE = LAMBDA(MJDN, [JulianCalendar],
    LET(
        _JDN, MODIFIED_TO_JDN(MJDN),
        IF(NOT(ISNUMBER(_JDN)), _JDN,
            JDN_TO_CALENDAR_DATE(_JDN, JulianCalendar)
        )
    )
);

/*--------------------------------------------------------------------------------------------------------------
GREGORIAN_TO_JULIAN

Translates a date in the Gregorian proleptic calendar to the Julian proleptic calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month  | integer [1..12] | 
Day    | integer [1..31] |
--------------------------------------------------------------------------------------------------------------*/
GREGORIAN_TO_JULIAN = LAMBDA(YearCE, Month, Day,
    LET(
        _JDN, JULIAN_DAY_NUMBER(YearCE, Month, Day, 0),
        IFS(ISERROR(_JDN), {#VALUE!, "", ""},
            _JDN = "", {"", "", ""},
            TRUE, JDN_TO_CALENDAR_DATE(_JDN, 1)
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
JULIAN_TO_GREGORIAN

Translates a date in the Julian proleptic calendar to the Gregorian proleptic calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month  | integer [1..12] | 
Day    | integer [1..31] | 
--------------------------------------------------------------------------------------------------------------*/
JULIAN_TO_GREGORIAN = LAMBDA(YearCE, Month, Day,
    LET(
        _JDN, JULIAN_DAY_NUMBER(YearCE, Month, Day, 1),
        IFS(ISERROR(_JDN), {#VALUE!, "", ""},
            _JDN = "", {"", "", ""},
            TRUE, JDN_TO_CALENDAR_DATE(_JDN, 0)
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
SECULAR_DIFFERENCE

Returns the number of days the Gregorian proleptic calendar is ahead of the Julian proleptic calendar for
a given date.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Days difference. Negative values are when the Julian proleptic calender is ahead.

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE               | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month                | integer [1..12] | 
Day                  | integer [1..31] | 
[FromJulianCalendar] | switch          | Provided date is in Julian calendar.
                     |                 | Default is the Gregorian calendar.
--------------------------------------------------------------------------------------------------------------*/
SECULAR_DIFFERENCE = LAMBDA(YearCE, Month, Day, [FromJulianCalendar],
    IF(N(FromJulianCalendar) = 0,
        // From Gregorian calendar
        LET(
            _JDN_G, JULIAN_DAY_NUMBER(YearCE, Month, Day, 0),
            IF(ISERROR(_JDN_G), {#VALUE!},
                IF(_JDN_G = "", "",
                    LET(
                        _JDN_J, IF((Month = 2) * (Day = 29),
                            IF(IS_LEAP_YEAR(YearCE, 1),
                                JULIAN_DAY_NUMBER(YearCE, 2, 29, 1),
                                JULIAN_DAY_NUMBER(YearCE, 2, 28, 1)
                            ),
                            JULIAN_DAY_NUMBER(YearCE, Month, Day, 1)
                        ),
                        _JDN_J - _JDN_G
                    )
                )
            )
        ),
        
        // From Julian calendar
        LET(
            _date_G, JULIAN_TO_GREGORIAN(YearCE, Month, Day),
            IF(ISERROR(INDEX(_date_G, 1, 1)), {#VALUE!},
                IF(INDEX(_date_G, 1, 1) = "", "",
                    SECULAR_DIFFERENCE(
                        INDEX(_date_G, 1, 1),
                        INDEX(_date_G, 1, 2),
                        INDEX(_date_G, 1, 3),
                        0
                    )
                )
            )
        )
    )
);











/*##############################################################################################################
# TIME ZONES                                                                                                   #
##############################################################################################################*/


/*--------------------------------------------------------------------------------------------------------------
IS_VALID_TZO

Tests if a time zone offset in minutes is within the range -15:00..+15:00

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
----------------------------------------------------------------------------------------------------------------
TZOMinutes | decimal [-900..900] | Fractional allowed if minute and second empty.
--------------------------------------------------------------------------------------------------------------*/
IS_VALID_TZO = LAMBDA(TZOMinutes,
    IFS(
        IS_EMPTY(TZOMinutes), FALSE,
        NOT(ISNUMBER(TZOMinutes)), FALSE,
        ABS(TZOMinutes) > 900, FALSE,
        TRUE, TRUE
    )
);


/*--------------------------------------------------------------------------------------------------------------
TIMESPAN_TO_TZO

Converts a deimal timespan into time zone offset minutes.

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
----------------------------------------------------------------------------------------------------------------
TZOTimeSpan | decimal [-0.625..0.625] |
--------------------------------------------------------------------------------------------------------------*/
TIMESPAN_TO_TZO = LAMBDA(TZOTimeSpan,
    IF(IS_EMPTY(TZOTimeSpan), "",
        LET(
            _tzo, TZOTimeSpan * 1440,
            IF(IS_VALID_TZO(_tzo), _tzo, {#NUM!})
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
TZO_TO_TIMESPAN

Converts time zone offset minutes into a decimal timespan.

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean | Time Zone Offset expressed as a TimeSpan 

Parameters
----------------------------------------------------------------------------------------------------------------
TZOTimeSpan | decimal [-0.625..0.625] |
--------------------------------------------------------------------------------------------------------------*/
TZO_TO_TIMESPAN = LAMBDA(TZOMinutes,
    IFS(
        IS_EMPTY(TZOMinutes), "",
        NOT(IS_VALID_TZO(TZOMinutes)), {#NUM!},
        TRUE, TZOMinutes / 1440
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_ISO_TZO

Parses an ISO formatted time zone offset into time zone offset minutes.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal [-900..900] | Time zone offset in minutes

Parameters
----------------------------------------------------------------------------------------------------------------
ISOTimeZoneOffset | text | Time zone offset in ISO format ie. ±hh:mm

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_ISO_TZO("Z")
Returns: 0 i.e. UTC time zone (Zulu)

PARSE_ISO_TIME("−06:00")
Returns: -360

PARSE_ISO_TIME("+16:00")
Returns: #NUM! i.e. range is −15:00 to +15:00
--------------------------------------------------------------------------------------------------------------*/
PARSE_ISO_TZO = LAMBDA(ISOTimeZoneOffset,
    IFS(
        IS_EMPTY(ISOTimeZoneOffset), "",
        (LEN(ISOTimeZoneOffset) = 1) * (CODE(ISOTimeZoneOffset) = 90), 0,
        TRUE, LET(
            _sChar, LEFT(ISOTimeZoneOffset, 1),
            _sign, IFS(
                _sChar = "+", 1,
                _sChar = "-", -1,
                UNICODE(_sChar) = 8722, -1,
                TRUE, 0
            ),
            IF(_sign = 0, {#VALUE!},
                LET(
                    _tz, MID(ISOTimeZoneOffset, 2, LEN(ISOTimeZoneOffset) - 1),
                    _pattern, REPLACE_CHARS(_tz, "0123456789", "_"),
                    _tryParse, IFS(
                        _pattern = "__:__:__",
                            HSTACK(
                                VALUE(LEFT(_tz, 2)),
                                VALUE(MID(_tz, 4, 2)),
                                VALUE(RIGHT(_tz, 2))
                            ),
                        _pattern = "__:__",
                            HSTACK(
                                VALUE(LEFT(_tz, 2)),
                                VALUE(RIGHT(_tz, 2)),
                                0
                            ),
                        _pattern = "______",
                            HSTACK(
                                VALUE(LEFT(_tz, 2)),
                                VALUE(MID(_tz, 3, 2)),
                                VALUE(RIGHT(_tz, 2))
                            ),
                        _pattern = "____",
                            HSTACK(
                                VALUE(LEFT(_tz, 2)),
                                VALUE(RIGHT(_tz, 2)),
                                0
                            ),
                        _pattern = "__",
                            HSTACK(VALUE(_tz), 0, 0),
                        TRUE, {#VALUE!}
                    ),
                    
                    IFS(
                        ISERROR(INDEX(_tryParse, 1, 1)), {#VALUE!},
                        NOT(IS_VALID_TIME_OF_DAY(
                            INDEX(_tryParse, 1, 1),
                            INDEX(_tryParse, 1, 2),
                            INDEX(_tryParse, 1, 3)
                        )), {#NUM!},
                        TRUE, TIMESPAN_TO_TZO(
                            _sign * TIMESPAN(
                                HSTACK(_sign, 0, _tryParse)
                            )
                        )
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
FORMAT_ISO_TZO

Returns a time zone offset as text in ISO format.

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | ISO formatted time zone offset

Parameters
----------------------------------------------------------------------------------------------------------------
TZOMinutes | decimal     | Time zone offset from UTC in minutes.
           | [-900..900] | Assumed to be UTC if ommitted. [-15:00..+15:00]
[Options]  | text        | String with elements: [B][Z]
           |             |  B : Display in basic format eg +0000
           |             |  Z : Display 'Z' for Zulu time zone +00:00
--------------------------------------------------------------------------------------------------------------*/
FORMAT_ISO_TZO = LAMBDA(TZOMinutes, [Options],
    IFS(
        IS_EMPTY(TZOMinutes), "",
        NOT(ISNUMBER(TZOMinutes)), {#VALUE!},
        NOT(IS_VALID_TZO(TZOMinutes)), {#NUM!},
        TRUE, LET(
            _basic, IFERROR(SEARCH("B", Options), 0) > 0,
            _zulu, IFERROR(SEARCH("Z", Options), 0) > 0,
            _tzo, ABS(TZOMinutes),
            IF((_tzo = 0) * _zulu, "Z",
                LET(
                    _sign, IF(TZOMinutes >= 0, "+", UNICHAR(8722)), 
                    _delim, IF(_basic, "", ":"),
                    _rTZO, RESOLVE_TIMESPAN(TZO_TO_TIMESPAN(_tzo), 2, 4, 0),
                    IF(INDEX(_rTZO, 5) > 0, 
                        CONCAT(
                            _sign,
                            TEXT(INDEX(_rTZO, 1, 3), "00"),
                            _delim, TEXT(INDEX(_rTZO, 1, 4), "00"),
                            _delim, TEXT(INDEX(_rTZO, 1, 5), "00")
                        ),
                        CONCAT(
                            _sign,
                            TEXT(INDEX(_rTZO, 1, 3), "00"),
                            _delim, TEXT(INDEX(_rTZO, 1, 4), "00")
                        )
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------
MILITARY_TZO

Returns the time zone offset in minutes of a military time zone designator.

Output
----------------------------------------------------------------------------------------------------------
 1 | decimal     | Time zone offset in minutes
   | [-720..720] | [-12:00..+12:00]

Parameters
----------------------------------------------------------------------------------------------------------
Designator | text | Military time zone designator 
           |      | [ABCDEFGHIJKLMNOPQRSTUVWXYZ]

Examples
----------------------------------------------------------------------------------------------------------
MILITARY_TZO("A")
Returns: 60

FORMAT_MIL_DTG("J")
Returns: #N/A (local time zone)
--------------------------------------------------------------------------------------------------------*/
MILITARY_TZO = LAMBDA(Designator,
    IF(IS_EMPTY(Designator), "",
        LET(
            _code, CODE(Designator) - 64,
            IFS(
                _code <= 0, {#VALUE!},
                _code > 26, {#VALUE!},
                _code = 10, {#N/A}, // J = Local Time
                _code = 26, 0, // Z = UTC
                _code <= 9, _code * 60, // ABCDEFGHI -> +1..+9
                _code <= 13, (_code - 1) * 60,  // KLM -> +10..+12
                _code <= 25, (13 - _code) * 60 // NOPQRSTUVWXY -> -1..-12
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------
TZO_TO_MILITARY

Returns the closest military time zone designator, its offset in minutes and the time adjustment to that
time zone for the provided time zone offset in minutes.

Output
----------------------------------------------------------------------------------------------------------
 1 | text            |  Military time zone designator
   |                 | [ABCDEFGHIJKLMNOPQRSTUVWXYZ]
 2 | integer         | Time zone offset in minutes
   | [-720..720]     | [-12:00..+12:00]
 3 | decimal         | Time adjustment
   | [-0.125..0.125] | [-3:00..+3:00]

Parameters
----------------------------------------------------------------------------------------------------------
[TZOMinutes] | decimal     | Time zone offset from UTC in minutes
             | [-900..900] | Assumed to be UTC if ommitted. [-15:00..+15:00]

Examples
----------------------------------------------------------------------------------------------------------
TZO_TO_MILITARY(60)
Returns: {A, 60, 0}

TZO_TO_MILITARY("")
Returns: {J, ,0} (local time zone)

TZO_TO_MILITARY(570)
Returns: {K, 600, 0.020833}

TZO_TO_MILITARY(840)
Returns: {M, 720, -0.08333}
--------------------------------------------------------------------------------------------------------*/
TZO_TO_MILITARY = LAMBDA(TZOMinutes,
    IFS(
        IS_EMPTY(TZOMinutes), {"J", "", 0},
        NOT(IS_VALID_TZO(TZOMinutes)), {#VALUE!, "", ""},
        TRUE, IFS(
            TZOMinutes = 0, HSTACK("Z", 0, 0),
            TZOMinutes > 720, HSTACK("M", 720, (720 - TZOMinutes) / 1440),
            TZOMinutes < -720, HSTACK("Y", -720, (-720 - TZOMinutes) / 1440),
            TRUE, LET(
                _militaryTZO, SIGN(TZOMinutes) * MROUND(ABS(TZOMinutes), 60),
                _idx, INT(_militaryTZO / 60) + 13,
                _militaryTZ, CHOOSE(_idx, "Y", "X", "W", "V", "U", "T", "S", "R", "Q", "P", "O", "N", "Z", "A", "B", "C", "D", "E", "F", "G", "H", "I", "K", "L", "M"),
                HSTACK(_militaryTZ, _militaryTZO, (_militaryTZO - TZOMinutes) / 1440)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------
SHIFT_TIMEZONE

Translates a Modified Julian Date from one time zone to another. If a time zone is omitted it is assumed
to be UTC.

Output
----------------------------------------------------------------------------------------------------------
 1 | text  | ISO formated date and time

Parameters
----------------------------------------------------------------------------------------------------------
MJDate                | decimal     | Modified Julian Date
[ReferenceTZOMinutes] | decimal     | Time zone offset referenced by the MJDate
                      | [-900..900] | Assumed to be UTC if ommitted. [-15:00..+15:00]
[TranslateTZOMinutes] | decimal     | Time zone offset to translate the MJDate to.
                      | [-900..900] | Assumed to be UTC if ommitted. [-15:00..+15:00]
--------------------------------------------------------------------------------------------------------*/
SHIFT_TIMEZONE = LAMBDA(MJDate, [ReferenceTZOMinutes], [TranslateTZOMinutes],
    IFS(
        IS_EMPTY(MJDate), "",
        NOT(ISNUMBER(MJDate)), {#VALUE!},
        TRUE, LET(
            _referenceTZ, N(ReferenceTZOMinutes),
            _translateTZ, N(TranslateTZOMinutes),
            _difference, (_translateTZ - _referenceTZ) / 1440,
            HSTACK(MJDate + _difference, _translateTZ)
        )
    )
);


/*##############################################################################################################
# DATE AND TIME                                                                                                #
##############################################################################################################*/


/*--------------------------------------------------------------------------------------------------------------
IS_VALID_TIME_OF_DAY

Tests if sexagesimal representation of time is valid for a 24 hour day.

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
----------------------------------------------------------------------------------------------------------------
Hour           | decimal [0..24) | Fractional allowed if minute and second empty.
Minute         | decimal [0..60) | Fractional allowed if second empty.
Second         | decimal [0..60) | Fractional allowed
[Accept24Hour] | switch          | Accept time of 24:00:00 to represent midnight next day.
--------------------------------------------------------------------------------------------------------------*/
IS_VALID_TIME_OF_DAY = LAMBDA(Hour, Minute, Second, [Accept24Hour],
    LET(
        _accept24hour, N(Accept24Hour) <> 0,
        IFS(
            ISNUMBER(Hour) * ISNUMBER(Minute) * ISNUMBER(Second),
                IFS(
                    (_accept24hour * (Hour = 24) * (Minute = 0) * (Second = 0)) > 0, TRUE,
                    NOT(IS_INTEGER(Hour) * IS_INTEGER(Minute)), FALSE,
                    (Hour < 0) + (Hour > 23), FALSE,
                    (Minute < 0) + (Minute > 59), FALSE,
                    (Second < 0) + (Second >= 60), FALSE,
                    TRUE, TRUE
                ),
            ISNUMBER(Hour) * ISNUMBER(Minute) * (Second = ""),
                IFS(
                    (_accept24hour * (Hour = 24) * (Minute = 0)) > 0, TRUE,
                    NOT(IS_INTEGER(Hour)), FALSE,
                    (Hour < 0) + (Hour > 23), FALSE,
                    (Minute < 0) + (Minute >= 60), FALSE,
                    TRUE, TRUE
                ),
            ISNUMBER(Hour) * (Minute = "") * (Second = ""),
                IF((_accept24hour * (Hour = 24)) > 0, TRUE,
                    ((Hour >= 0) * (Hour < 24)) > 0
                ),
            (Hour = "") * ISNUMBER(Minute) * ISNUMBER(Second),
                IFS(
                    NOT(IS_INTEGER(Minute)), FALSE,
                    (Minute < 0) + (Minute > 59), FALSE,
                    (Second < 0) + (Second >= 60), FALSE,
                    TRUE, TRUE
                ),
            (Hour = "") * ISNUMBER(Minute) * (Second = ""),
                ((Minute >= 0) * (Minute < 60)) <> 0,
            (Hour = "") * (Minute = "") * ISNUMBER(Second),
                ((Second >= 0) * (Second < 60)) <> 0,
            TRUE, FALSE
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
JULIAN_DATE

Returns the Julian Date of the provided date and time of day in the specified calendar.
Note that the decimal time component of Julian Date is based from midday.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Julian Date

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] | Month of year
Day              | intger  [1..31] | Day of month
]Time]           | decimal [0..1)  | Time of day
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
JULIAN_DATE = LAMBDA(YearCE, Month, Day, [Time], [JulianCalendar],
    LET(
        _JDN, JULIAN_DAY_NUMBER(YearCE, Month, Day, JulianCalendar),
        IF(NOT(ISNUMBER(_JDN)), _JDN,
            LET(
                _timeAfterMidday, N(Time) - 0.5,
                _JDN + _timeAfterMidday
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
MODIFIED_JULIAN_DATE

Returns the Modified Julian Date of the provided date and time of day in the specified calendar.
Note that the time component of Modified Julian Date is based from midnight.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Modified Julian Date

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] | Month of year
Day              | integer [1..31] | Day of month
[Time]           | decimal [0..1)  | Time of day
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
MODIFIED_JULIAN_DATE = LAMBDA(YearCE, Month, Day, [Time], [JulianCalendar],
    LET(
        _MJDN, MODIFIED_JULIAN_DAY_NUMBER(YearCE, Month, Day, JulianCalendar),
        IF(NOT(ISNUMBER(_MJDN)), _MJDN,
            _MJDN + N(Time)
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
JDATE_TO_MODIFIED

Converts a Julian Date (JDATE) to a Modified Julian Date (MJDATE).
Note that the decimal time component of MJDATE is based from midnight.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Modified Julian Date

Parameters
----------------------------------------------------------------------------------------------------------------
JDate | decimal | Julian Date
--------------------------------------------------------------------------------------------------------------*/
JDATE_TO_MODIFIED = LAMBDA(JDate,
    IF(JDate = "", "",
        JDate - 2400000.5
    )
);


/*--------------------------------------------------------------------------------------------------------------
MODIFIED_TO_JDATE

Converts a Modified Julian Date (MJDATE) to a Julian Date (JDATE).
Note that the decimal time component of JDATE is based from midday.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Julian Date

Parameters
----------------------------------------------------------------------------------------------------------------
MJDate | decimal | Modified Julian Date
--------------------------------------------------------------------------------------------------------------*/
MODIFIED_TO_JDATE = LAMBDA(MJDate,
    IF(MJDate = "", "",
        MJDate + 2400000.5
    )
);


/*--------------------------------------------------------------------------------------------------------------
JDATE_TO_CALENDAR_DATE

Converts a Julian Date (JDATE) to a date and time in the specified calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day of month
 4 | decimal [0..1)  | Time of day

Parameters
----------------------------------------------------------------------------------------------------------------
JDate            | decimal | Julian Date
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
JDATE_TO_CALENDAR_DATE = LAMBDA(JDate, [JulianCalendar],
    IFS(
        JDate = "", {"", "", "", ""},
        NOT(ISNUMBER(JDate)), {#VALUE!, "", "", ""},
        TRUE, LET(
            _JDN, INT(JDate + 0.5),
            _timeOfDay, JDate - _JDN + 0.5,
            _cDate, JDN_TO_CALENDAR_DATE(_JDN, JulianCalendar),
            HSTACK(_cDate, _timeOfDay)
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
MJDATE_TO_CALENDAR_DATE

Converts a Modified Julian Date (MJDATE) to a date and time in the specified calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day of month
 4 | decimal [0..1)  | Time of day

Parameters
----------------------------------------------------------------------------------------------------------------
MJDate           | decimal | Modified Julian Date
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
MJDATE_TO_CALENDAR_DATE = LAMBDA(MJDate, [JulianCalendar],
    IF(MJDate = "", {"", "", "", ""},
        IF(NOT(ISNUMBER(MJDate)), {#VALUE!, "", "", ""},
            LET(
                _JDate, MODIFIED_TO_JDATE(MJDate),
                JDATE_TO_CALENDAR_DATE(_JDate, JulianCalendar)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
RESOLVE_DATETIME

Returns the resolved date and time from the provided components to a low order component rounded to the
specified precision.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day of month
 4 | decimal [0..1)  | Time of day

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] | Month of year
Day              | integer [1..31] | Day of month
[TimeSpan]       | decimal         | TimeSpan or Time of day
[LowOrder]       | integer [-1..4] | Low-order component
                 |                 | -1 - YearCE
                 |                 |  0 - Month
                 |                 |  1 - Day
                 |                 |  2 - Hour
                 |                 |  3 - Minute
                 |                 |  4 - Second
[Precision]      | integer [0..9]  | Select precision level. Not applicable when LowOrder = 1,2
[Truncate]       | switch          | Round to precision by truncating components. Default is rounding to nearest.
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
RESOLVE_DATETIME = LAMBDA(YearCE, Month, Day, [TimeSpan], [LowOrder], [Precision], [Truncate], [JulianCalendar],
    IFS(
        IS_EMPTY(YearCE) * IS_EMPTY(Month) * IS_EMPTY(Day) * IS_EMPTY(TimeSpan), {"", "", "", ""},
        NOT(IS_VALID_DATE(YearCE, Month, N(Day), JulianCalendar)), {#VALUE!, "", "", ""},
        TRUE, LET(
            _day, INT(Day),
            _timeSpan, N(TimeSpan),
            _lowOrder, IFS(
                NOT(ISNUMBER(LowOrder)), 4,
                LowOrder < -1, -1,
                LowOrder > 4, 4,
                TRUE, INT(LowOrder)
            ),
            _precision, IFS(
                NOT(ISNUMBER(Precision)), 0,
                Precision < 0, 0,
                Precision > 9, 9,
                TRUE, INT(Precision)
            ),
            _truncate, N(Truncate) <> 0,
            _rDayTime, IFS(
                _lowOrder = -1, HSTACK(
                    IF(_truncate, INT(_timeSpan), ROUND(_timeSpan, 0)),
                    0
                ),
                _lowOrder = 0, LET(
                    _carryDay, INT(_timeSpan),
                    _timeOfDay, _timeSpan - _carryDay,
                    HSTACK(_carryDay, _timeOfDay)
                ),
                TRUE, LET(
                    _roundTime, ROUND_TIMESPAN(_timeSpan, _lowOrder, _precision, _truncate),
                    _carryDay, INT(_roundTime),
                    _timeOfDay, _roundTime - _carryDay,
                    HSTACK(_carryDay, _timeOfDay)
                )
            ),
            _rCarryDays, INDEX(_rDayTime, 1, 1),
            _rTime, INDEX(_rDayTime, 1, 2),
            _rDate, IF(_rCarryDays = 0, HSTACK(YearCE, Month, _day),
                LET(
                    _MJDN, MODIFIED_JULIAN_DAY_NUMBER(YearCE, Month, _day),
                    MJDN_TO_CALENDAR_DATE(_MJDN + _rCarryDays)
                )
            ),
            _rYear, INDEX(_rDate, 1, 1),
            _rMonth, INDEX(_rDate, 1, 2),
            _rDay, INDEX(_rDate, 1, 3),
            
            IFS(
                _lowOrder = - 1, _rYear + IF(_truncate, 0, N(_rMonth > 6)),
                _lowOrder = 0, IF(_truncate, HSTACK(_rYear, _rMonth),
                    LET(
                        _daysInMonth, DAYS_IN_MONTH(_rMonth, _rYear, JulianCalendar),
                        _carryMonth, ROUND(((_rDay - 1 + _rTime) / _daysInMonth), 0),
                        IFS(
                            _carryMonth = 0, HSTACK(_rYear, _rMonth),
                            _rMonth = 12, HSTACK(_rYear + 1, 1),
                            TRUE, HSTACK(_rYear, _rMonth + 1)
                        )
                    )
                ),
                _lowOrder = 1, HSTACK(_rYear, _rMonth, _rDay + _rTime), 
                TRUE, HSTACK(_rYear, _rMonth, _rDay, _rTime)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
RESOLVE_MJDATE

Returns the date and sexagesimal representation of the time value with the given lowest order component
rounded to the specified precision.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day of month
 4 | integer [0..23] | Hour
 5 | integer [0..59] | Minute
 6 | decimal [0..60) | Second

Parameters
----------------------------------------------------------------------------------------------------------------
MJDate           | decimal        | Modified Julian Date
[LowOrder]       | integer [1..6] | Low-order component
                 |                | -1 - YearCE
                 |                |  0 - Month
                 |                |  1 - Day
                 |                |  2 - Hour
                 |                |  3 - Minute
                 |                |  4 - Second
[Precision]      | integer [0..9] | Select precision level. Not applicable when LowOrder = 1,2
[Truncate]       | switch         | Round to precision by truncating components. Default is rounding to nearest.
[JulianCalendar] | switch         | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
RESOLVE_MJDATE = LAMBDA(MJDate, [LowOrder], [Precision], [Truncate], [JulianCalendar],
    IFS(
        IS_EMPTY(MJDate), {"", "", "", "", "", ""},
        NOT(ISNUMBER(MJDate)), {#VALUE!, "", "", "", "", ""},
        TRUE, LET(            
            _lowOrder, IFS(
                NOT(ISNUMBER(LowOrder)), 4,
                LowOrder < -1, -1,
                LowOrder > 4, 4,
                TRUE, INT(LowOrder)
            ),
            _precision, IFS(
                NOT(ISNUMBER(Precision)), 0,
                Precision < 0, 0,
                Precision > 9, 9,
                TRUE, INT(Precision)
            ),
            _truncate, N(Truncate) <> 0,

            _MJDN, INT(MJDATE),
            _timeOfDay, MJDATE - _MJDN,
            _rDayTime, IF(_lowOrder <= 0, {0, 0, 0, 0, 0},
                RESOLVE_TIMESPAN(_timeOfDay, 1, _lowOrder, _precision, _truncate)
            ),
            _rCarryDays, INT(INDEX(_rDayTime, 1, 2)),
            _rFractionalDay, IF(_lowOrder = 1, INDEX(_rDayTime, 1, 2) - _rCarryDays, 0),
            _rHour, INDEX(_rDayTime, 1, 3),
            _rMinute, INDEX(_rDayTime, 1, 4),
            _rSecond, INDEX(_rDayTime, 1, 5),
            _rDate, MJDN_TO_CALENDAR_DATE(_MJDN + _rCarryDays),
            _rYear, INDEX(_rDate, 1, 1),
            _rMonth, INDEX(_rDate, 1, 2),
            _rDay, INDEX(_rDate, 1, 3) + IF(_lowOrder <> 1, 0, ),
            IFS(
                _lowOrder = -1, HSTACK(
                    _rYear + IF(_truncate, 0, N(_rMonth > 6)),
                    "", "", "", "", ""
                ),
                _lowOrder = 0, IF(_truncate,
                    HSTACK(_rYear, _rMonth, "", "", "", ""),
                    LET(
                        _daysInMonth, DAYS_IN_MONTH(_rMonth, _rYear, JulianCalendar),
                        _carryMonth, ROUND((_rDay - 1 + _timeOfDay) / _daysInMonth, 0),
                        IFS(
                            _carryMonth = 0, HSTACK(_rYear, _rMonth, "", "", "", ""),
                            _rMonth = 12, HSTACK(_rYear + 1, 1, "", "", "", ""),
                            TRUE, HSTACK(_rYear, _rMonth + 1, "", "", "", "")
                        )
                    )
                ),
                _lowOrder = 1, HSTACK(_rYear, _rMonth, _rDay + _rFractionalDay, "", "", ""),
                _lowOrder = 2, HSTACK(_rYear, _rMonth, _rDay, _rHour, "", ""),
                _lowOrder = 3, HSTACK(_rYear, _rMonth, _rDay, _rHour, _rMinute, ""),
                _lowOrder = 4, HSTACK(_rYear, _rMonth, _rDay, _rHour, _rMinute, _rSecond)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
MJDATE_ADDITION

Returns the addition of a timespan complication to a given Modified Julian Date.
Note if date components of years, quarters or months are added for a MJDate expressed in UTC rather than
local time, then results may be inconsistent due to the bounds of calendar days.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Modified Julian Date

Parameters
----------------------------------------------------------------------------------------------------------------
LocalMJDate      | decimal     | Modified Julian Date in local time zone
[AddTimeSpan]    | decimal     | Add timespan.
[AddWeeks]       | decimal     | Add weeks timespan. Fractional part carries to day.
[AddMonths]      | decimal     | Add months timespan. Fractional part carries to day.
[AddQuarters]    | decimal     | Add quarters timespan. Fractional part carries to month and day.
[AddYears]       | decimal     | Add years timespan. Fractional part carries to month and day.
[JulianCalendar] | switch      | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |             | proleptic calendar. Only needed if date parts of years, quarters or months
                 |             | are added.
--------------------------------------------------------------------------------------------------------------*/
MJDATE_ADDITION = LAMBDA(LocalMJDate, [AddTimeSpan], [AddWeeks], [AddMonths], [AddQuarters], [AddYears], [JulianCalendar],
    IFS(
        LocalMJDate = "", "",
        NOT(ISNUMBER(LocalMJDate)), {#VALUE!},
        (N(AddTimeSpan) = 0) * (N(AddWeeks) = 0) * (N(AddMonths) = 0) * (N(AddQuarters) = 0) * (N(AddYears) = 0), LocalMJDate,
        TRUE, LET(
            _hasDatePartsAdded, ((N(AddMonths) <> 0) + (N(AddQuarters) <> 0) + (N(AddYears) <> 0)) <> 0,
            _baseMJDate, IF(NOT(_hasDatePartsAdded), LocalMJDate,
                LET(
                    _decMonths, (N(AddYears) * 12) + (N(AddQuarters) * 3) + N(AddMonths),
                    _addTotalMonths, INT(_decMonths),
                    _partialMonths, _decMonths - _addTotalMonths,
                    _startDate, MJDATE_TO_CALENDAR_DATE(LocalMJDate, JulianCalendar),
                    _shiftMonths, INDEX(_startDate, 1, 2) - 1 + _addTotalMonths,
                    _resultYear, INDEX(_startDate, 1, 1) + INT(_shiftMonths / 12),
                    _resultMonth, MOD(_shiftMonths, 12) + 1,
                    _MJDateMonth, MODIFIED_JULIAN_DATE(_resultYear, _resultMonth, 1, 0, JulianCalendar) - 1,
                    _avgDaysMonth, IF(N(JulianCalendar), 30.4375, 30.436875),
                    _MJDateMonth + INDEX(_startDate, 1, 3) + ROUND(_partialMonths * _avgDaysMonth, 0) + INDEX(_startDate, 1, 4)
                )
            ),
            _baseMJDate + N(AddTimeSpan) + ROUND(N(AddWeeks) * 7, 0)
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_ISO_TIME

Parses an ISO formatted time of day into decimal time of day.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal [0..1] | Time of day as decimal fraction of a day.

Output when AsComplication switch set
----------------------------------------------------------------------------------------------------------------
 1 | integer [0..24]  | Hours
 2 | integer [0..59]  | Minutes
 3 | decimal [0..60)  | Seconds

Parameters
----------------------------------------------------------------------------------------------------------------
ISOTime          | text   | Time in ISO format ie. Thh:mm:ss.000
[AsComplication] | switch | Output component parts

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_ISO_TIME("12:00")
Returns: 0.5

PARSE_ISO_TIME("24:00:01")
Returns: #NUM!  i.e. range is 0 to 24 hours 
--------------------------------------------------------------------------------------------------------------*/
PARSE_ISO_TIME = LAMBDA(ISOTime, [AsComplication],
    IF(ISOTime = "", "",
        LET(
            _asValue, N(AsComplication) = 0,
            IF(CODE(ISOTime) <> 84, IF(_asValue, {#VALUE!}, {#VALUE!, "", ""}),
                LET(
                    _len, LEN(ISOTime) - 1,
                    _timePart, RIGHT(ISOTime, _len),
                    _pattern, REPLACE_CHARS(_timePart, "0123456789", "_"),
                    _tryParse, IFS(
                        LEFT(_pattern, 10) = "__:__:__._", LET(
                            _decimals, _len - 9,
                            HSTACK(
                                VALUE(LEFT(_timePart, 2)),
                                VALUE(MID(_timePart, 4, 2)),
                                VALUE(MID(_timePart, 7, 2)) + (VALUE(RIGHT(_timePart, _decimals)) / (10 ^ _decimals))
                            )
                        ),
                        _pattern = "__:__:__",
                            HSTACK(
                                VALUE(LEFT(_timePart, 2)),
                                VALUE(MID(_timePart, 4, 2)),
                                VALUE(RIGHT(_timePart, 2))
                            ),
                        _pattern = "__:__",
                            HSTACK(
                                VALUE(LEFT(_timePart, 2)),
                                VALUE(RIGHT(_timePart, 2)),
                                0
                            ),
                        LEFT(_pattern, 8) = "______._", LET(
                            _decimals, _len - 7,
                            HSTACK(
                                VALUE(LEFT(_timePart, 2)),
                                VALUE(MID(_timePart, 3, 2)),
                                VALUE(MID(_timePart, 5, 2)) + (VALUE(RIGHT(_timePart, _decimals)) / (10 ^ _decimals))
                            )    
                        ),
                        _pattern = "______",
                            HSTACK(
                                VALUE(LEFT(_timePart, 2)),
                                VALUE(MID(_timePart, 3, 2)),
                                VALUE(RIGHT(_timePart, 2))
                            ),
                        _pattern = "____",
                            HSTACK(
                                VALUE(LEFT(_timePart, 2)),
                                VALUE(RIGHT(_timePart, 2)),
                                0
                            ),
                        _pattern = "__",
                            HSTACK(
                                VALUE(_timePart), 0, 0
                            ),
                        TRUE, {#VALUE!}
                    ),
                    IFS(
                        ISERROR(INDEX(_tryParse, 1, 1)), IF(_asValue, {#VALUE!}, {#VALUE!, "", ""}),
                        NOT(IS_VALID_TIME_OF_DAY(
                                INDEX(_tryParse, 1, 1),
                                INDEX(_tryParse, 1, 2),
                                INDEX(_tryParse, 1, 3), 1
                            )
                        ), IF(_asValue, {#NUM!}, {#NUM!, "", ""}),
                        _asValue, TIMESPAN( 
                            HSTACK(1, 0 , _tryParse)
                        ),
                        TRUE, _tryParse
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
FORMAT_ISO_TIME

Returns a time as text in ISO format.

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | ISO formatted time

Parameters
----------------------------------------------------------------------------------------------------------------
Time             | decimal [0..1] | Time of day as decimal fraction of a day.
[Options]        | text           | String with elements: [B][<][LowOrder][Precision]
                 |                |        B : Display in basic format eg T000000
                 |                |        < : Round by truncating components. Default is rounding to nearest.
                 |                | LowOrder : low order component
                 |                |     Null : Defaults to seconds
                 |                |        H : Hour
                 |                |        M : Minute
                 |                |        S : Second
                 |                | Precision: [0-9] Only has an effect when low order component is seconds.
Examples
----------------------------------------------------------------------------------------------------------------
FORMAT_ISO_TIME(0.25)
Returns: T06:00:00

PARSE_ISO_TIME(0.6747, "M<")
Returns: T16:11
--------------------------------------------------------------------------------------------------------------*/
FORMAT_ISO_TIME = LAMBDA(Time, [Options],
    IFS(
        Time = "", "",
        NOT(ISNUMBER(Time)), {#VALUE!},
        (Time < 0) + (Time > 1), {#NUM!},
        TRUE, LET(
            _basic, IFERROR(SEARCH("B", Options), 0) > 0,
            _truncate, IFERROR(FIND("<", Options), 0) > 0,
            _tryLowOrderChar, FIND_NTH_CHAR(Options, "HMS", 1, 1, 1),
            _lowOrder, IFS(
                INDEX(_tryLowOrderChar, 1, 1) = 0, 4,
                INDEX(_tryLowOrderChar, 1, 2) = "H", 2,
                INDEX(_tryLowOrderChar, 1, 2) = "M", 3,
                INDEX(_tryLowOrderChar, 1, 2) = "S", 4
            ),
            _precision, IF(_lowOrder < 4, 0,
                LET(
                    _tryPrecisionChar, FIND_NTH_CHAR(Options, "0123456789", 1, 0, 1),
                    IF(INDEX(_tryPrecisionChar, 1, 1) = 0, 0,
                        VALUE(INDEX(_tryPrecisionChar, 1, 2))
                    )
                )
            ),
            
            _rTime, RESOLVE_TIMESPAN(Time, 2, _lowOrder, _precision, _truncate),
            _delim, IF(_basic, "", ":"),
            IFS(
                _lowOrder = 4, LET(
                    _secFmt, IF(_precision = 0, "00", LEFT("00.000000000", _precision + 3)),
                    CONCAT(
                        "T", TEXT(INDEX(_rTime, 1, 3), "00"),
                        _delim, TEXT(INDEX(_rTime, 1, 4), "00"),
                        _delim, TEXT(INDEX(_rTime, 1, 5), _secFmt)
                    )
                ),
                _lowOrder = 3,
                    CONCAT(
                        "T", TEXT(INDEX(_rTime, 1, 3), "00"),
                        _delim, TEXT(INDEX(_rTime, 1, 4), "00")
                    ),
                _lowOrder = 2,
                    "T" & TEXT(INDEX(_rTime, 1, 3), "00")
            )
        )
    )
);




/*--------------------------------------------------------------------------------------------------------------
PARSE_ISO_DATETIME

Parses an ISO formatted date and time into respective date parts, time, and time zone offset from UTC.
Providing a time zone offset on its own is invalid for this function.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year
 2 | integer         | Month
 3 | integer         | Day
 4 | decimal [0..1]  | Time
 5 | decimal         | Time zone offset from UTC
   | [-0.625..0.625] | 

Parameters
----------------------------------------------------------------------------------------------------------------
ISODateTime        | text   | Date time in ISO format ie. yyyy-MM-ddThh:mm:ss+hh:mm
[AllowMixedStyles] | switch | Relax validation for no mixing of basic and extended formats. eg. yyyyMMddThh:mm
[JulianCalendar]   | switch | Validate in the Julian proleptic calendar. Default is Gregorian
                   |        | proleptic calendar.

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_ISO_DATETIME("2023-05-23")
Returns: {2023, 5, 23, , }

PARSE_ISO_DATETIME("2023-05-23T06:00")
Returns: {2023, 5, 23, 0.25, }

PARSE_ISO_DATETIME("T12:00")
Returns: { , , , 0.5, }

PARSE_ISO_DATETIME("T12:00−06:00")
Returns: { , , , 0.5, -360}

PARSE_ISO_DATETIME("2023-05-23T+09:00")
Returns: {2023, 5, 23, , 540}
--------------------------------------------------------------------------------------------------------------*/
PARSE_ISO_DATETIME = LAMBDA(ISODateTime, [AllowMixedStyles], [JulianCalendar],
    IFS(
        IS_EMPTY(ISODateTime), {"", "", "", "", ""},
        NOT(VALIDATE_CHARSET(ISODateTime, "+,-.0123456789:TWZ" & UNICHAR(8722), 1)), {#VALUE!, "", "", "", ""},
        TRUE, LET(
            _Tpos, IFERROR(FIND("T", ISODateTime), 0),
            _parts, IF(_Tpos = 0, 
                HSTACK(ISODateTime, "", ""),
                LET(
                    _len, LEN(ISODateTime),
                    _datePart, LEFT(ISODateTime, _Tpos - 1),
                    _TZpos, FIND_NTH_CHAR(ISODateTime, "Z+-" & UNICHAR(8722), 1, 1, 0, _Tpos + 1),
                    IFS(
                        _TZpos = 0,
                        HSTACK(
                            _datePart,
                            RIGHT(ISODateTime, _len - _Tpos + 1),
                            ""
                        ),
                        _TZpos = _Tpos + 1,
                        HSTACK(
                            _datePart,
                            "",
                            RIGHT(ISODateTime, _len - _TZpos + 1)
                        ),
                        TRUE,
                        HSTACK(
                            _datePart,
                            MID(ISODateTime, _Tpos, _TZPos - _Tpos),
                            RIGHT(ISODateTime, _len - _TZpos + 1)
                        )
                    )
                )
            ),
            _failStyleCheck, IF(N(AllowMixedStyles) <> 0, FALSE,
                LET(
                    _fmtDate, IFS(
                        INDEX(_parts, 1, 1) = "", 3,
                        IFERROR(FIND("-", INDEX(_parts, 1, 1), 5), 0) > 0, 2,
                        TRUE, 1
                    ),
                    _fmtTime, IFS(
                        INDEX(_parts, 1, 2) = "", 3,
                        LEN(INDEX(_parts, 1, 2)) = 3, 3,
                        IFERROR(FIND(":", INDEX(_parts, 1, 2), 4), 0) > 0, 2,
                        TRUE, 1
                    ),
                    _fmtTZO, IFS(
                        INDEX(_parts, 1, 3) = "", 3,
                        CODE(INDEX(_parts, 1, 3)) = 90, 3,
                        LEN(INDEX(_parts, 1, 3)) = 3, 3,
                        IFERROR(FIND(":", INDEX(_parts, 1, 3), 4), 0) > 0, 2,
                        TRUE, 1
                    ),
                    IFS(
                        BITAND(_fmtDate, _fmtTime) = 0, TRUE,
                        BITAND(_fmtDate, _fmtTZO) = 0, TRUE,
                        BITAND(_fmtTime, _fmtTZO) = 0, TRUE,
                        TRUE, FALSE
                    )
                )
            ),
            IF(_failStyleCheck, {#N/A, "", "", "", ""},
                LET(
                    _time, PARSE_ISO_TIME(INDEX(_parts, 1, 2)),
                    _tzo, PARSE_ISO_TZO(INDEX(_parts, 1, 3)),
                    IF(INDEX(_parts, 1, 1) = "",
                        IF(IS_EMPTY(_time),
                            HSTACK("", "", "", {#VALUE!}, _tzo),
                            HSTACK("", "", "", _time, _tzo)
                        ),
                        LET(
                            _date, PARSE_ISO_CALENDAR_DATE(INDEX(_parts, 1, 1), JulianCalendar),
                            HSTACK(_date, _time, _tzo)
                        )
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
FORMAT_ISO_DATETIME

Returns a date, time and time zone offset as text in ISO format.

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | ISO formatted date, time and time zone offset

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] |
Day              | integer [1..31] |
[Time]           | decimal [0..1]  | Time of day as decimal fraction of a day.
[TZOMinutes]     | decimal         | Time zone offset from UTC in minutes
                 | [-900..900]     | Assumed to be UTC if ommitted. [-15:00..+15:00]
[Options]        | text            | String with elements: [B][<][LowOrder][Precision][Z]
                 |                 |        B : Display in basic format eg T0000
                 |                 |        < : Round by truncating components. Default is rounding to nearest.
                 |                 | LowOrder : low order component to display
                 |                 |     Null : Defaults to seconds if time present, otherwise day
                 |                 |        D : Day
                 |                 |        H : Hour
                 |                 |        M : Minute
                 |                 |        S : Second
                 |                 | Precision: [0-9] Only has an effect when low order component is seconds.
                 |                 |        Z : Display 'Z' for Zulu time zone +00:00
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar. 
--------------------------------------------------------------------------------------------------------------*/
FORMAT_ISO_DATETIME = LAMBDA(YearCE, Month, Day, [Time], [TZOMinutes], [Options], [JulianCalendar],
    IF(IS_EMPTY(YearCE) * IS_EMPTY(Month) * IS_EMPTY(Day) * IS_EMPTY(Time), "",
        LET(
            _hasDate, NOT(IS_EMPTY(YearCE)) * NOT(IS_EMPTY(Month)) * NOT(IS_EMPTY(Day)),
            _hasTime, NOT(IS_EMPTY(Time)),
            IF(NOT(_hasDate) * NOT(_hasTime), {#VALUE!},
                LET(
                    _basic, IFERROR(SEARCH("B", Options), 0) > 0,
                    _truncate, IFERROR(FIND("<", Options), 0) > 0,
                    _tryLowOrderChar, FIND_NTH_CHAR(Options, "DHMS", 1, 0, 1),
                    _lowOrder, IFS(
                        INDEX(_tryLowOrderChar, 1, 1) = 0, IF(_hasTime, 4, 1),
                        INDEX(_tryLowOrderChar, 1, 2) = "D", 1,
                        INDEX(_tryLowOrderChar, 1, 2) = "H", 2,
                        INDEX(_tryLowOrderChar, 1, 2) = "M", 3,
                        INDEX(_tryLowOrderChar, 1, 2) = "S", 4
                    ),
                    _precision, IF(_lowOrder < 4, 0,
                        LET(
                            _tryPrecisionChar, FIND_NTH_CHAR(Options, "0123456789", 1, 0, 1),
                            IF(INDEX(_tryPrecisionChar, 1, 1) = 0, 0,
                                VALUE(INDEX(_tryPrecisionChar, 1, 2))
                            )
                        )
                    ),

                    _sTZO, IFERROR(FORMAT_ISO_TZO(TZOMinutes, Options), "#TZO!"),
                    
                    IFS(
                        _hasDate * _hasTime, LET(
                            _rDateTime, LET(
                                _dt, HSTACK(YearCE, Month, Day, Time),
                                IFS(
                                    MAX(N(ISERROR(_dt))), _dt,
                                    (_lowOrder > 1) * (Time = 1), _dt,
                                    TRUE, LET(
                                        _tryResolve, RESOLVE_DATETIME(YearCE, Month, Day, Time, _lowOrder, _precision, _truncate, JulianCalendar),
                                        IF(MAX(N(ISERROR(_tryResolve))), _dt, _tryResolve)
                                    )
                                )
                            ),
                            _sDate, IFERROR(
                                FORMAT_ISO_CALENDAR_DATE(
                                    INDEX(_rDateTime, 1, 1),
                                    INDEX(_rDateTime, 1, 2),
                                    INDEX(_rDateTime, 1, 3),
                                    _basic,
                                    JulianCalendar
                                ), "#DATE!"
                            ),
                            IF(_lowOrder = 1,
                                CONCAT(_sDate, "T", _sTZO),
                                LET(
                                    _sTime, IFERROR(FORMAT_ISO_TIME(INDEX(_rDateTime, 1, 4), Options), "T#TIME!"),
                                    CONCAT(_sDate, _sTime, _sTZO)
                                )
                            )
                        ),
                        _hasDate * NOT(_hasTime), FORMAT_ISO_CALENDAR_DATE(YearCE, Month, Day, _basic, JulianCalendar),
                        NOT(_hasDate) * _hasTime, LET(
                            _rTime, ROUND_TIMESPAN(Time, _lowOrder, _precision, _truncate),
                            _sTime, IFERROR(FORMAT_ISO_TIME(_rTime, Options), "T#TIME!"),
                            _sTime & _sTZO
                        )
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_LITERARY_YEAR

Returns a number representing the year relative to the common era from a given literary year.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | YearCE. Note that 1 BC = 0 CE, 2 BC = -1 CE

Parameters
----------------------------------------------------------------------------------------------------------------
LiteraryYear | text | Literary year
--------------------------------------------------------------------------------------------------------------*/
PARSE_LITERARY_YEAR = LAMBDA(LiteraryYear,
    IFS(
        IS_EMPTY(LiteraryYear), "",
        NOT(VALIDATE_CHARSET(LiteraryYear, " -+0123456789BCE" & UNICHAR(8722))), {#VALUE!},
        TRUE, LET(
            fnYearValue, LAMBDA(_text,
                LET(
                    _char1, LEFT(_text, 1),
                    _sign, IFS(
                        _char1 = "+", 1,
                        _char1 = "-", -1,
                        UNICODE(_char1) = 8722, -1,
                        TRUE, ""
                    ),
                    IF(_sign = "",
                        INT(VALUE(_text)),
                        _sign * INT(VALUE(RIGHT(_text, LEN(_text) -1)))
                    )
                )
            ),

            _litYear, SUBSTITUTE(SUBSTITUTE(LiteraryYear, ",", ""), " ", ""),
            _yearCE, IFS(
                RIGHT(_litYear, 3) = "BCE",
                    LET(
                        _sYear, LEFT(_litYear, LEN(_litYear) - 3),
                        1 - fnYearValue(_sYear)
                    ),
                RIGHT(_litYear, 2) = "CE",
                    LET(
                        _sYear, LEFT(_litYear, LEN(_litYear) - 2),
                        fnYearValue(_sYear)
                    ),
                TRUE, fnYearValue(_litYear)
            ),
            
            IFERROR(_yearCE, {#VALUE!})
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
FORMAT_LITERARY_YEAR

Returns a year formatted in literary style.

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | Literary year

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE          | integer | Note that 1 BC = 0 CE, 2 BC = -1 CE
[AlwaysShowEra] | switch  | Always apply BCE/CE suffix. If not used, only years less than 1000 show an era.
--------------------------------------------------------------------------------------------------------------*/
FORMAT_LITERARY_YEAR = LAMBDA(YearCE, [AlwaysShowEra],
    IF(IS_EMPTY(YearCE), "",
        LET(
            _yearCE, INT(YearCE),
            _isCE, _yearCE >= 1,
            _year, IF(_isCE, _yearCE, 1 - _yearCE),
            _suffix, IFS(NOT(_isCE), " BCE",
                _yearCE < 1000, " CE",
                N(AlwaysShowEra) <> 0, " CE",
                TRUE, ""
            ),
            _year & _suffix
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_LITERARY_DATE

Parses a literary date into respective parts of year, month, day and time of day.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day
 4 | decimal [0..1]  | Time

Parameters
----------------------------------------------------------------------------------------------------------------
LiteraryDate     | text   | Literary date and time
[JulianCalendar] | switch | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |        | proleptic calendar. 

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_LITERARY_DATE("Feb 25, 2014, 6:00")
Returns: {2014, 2, 25, 0.25}

PARSE_LITERARY_DATE("Dec 31, 2023, 24:00")
Returns: {2023, 12, 31, 1}

PARSE_LITERARY_DATE("Feb 25")
Returns: { , 2, 25, }
--------------------------------------------------------------------------------------------------------------*/
PARSE_LITERARY_DATE = LAMBDA(LiteraryDate, [JulianCalendar],
    IF(IS_EMPTY(LiteraryDate), {"", "", "", ""},
        LET(
            fnParseTime, LAMBDA(_timePart,
                LET(
                    _tryTime, DATEVALUE(_timePart) + TIMEVALUE(_timePart),
                    IFS(
                        ISERROR(_tryTime), "",
                        _tryTime > 1, {#NUM!},
                        TRUE, _tryTime
                    )
                )
            ),

            fnParseDay, LAMBDA(_dayPart, _year, _month,
                LET(
                    _day, INT(VALUE(_dayPart)),
                    IFS(
                        _day <= 0, {#NUM!},
                        _day <= DAYS_IN_MONTH(_month, _year, JulianCalendar), _day,
                        TRUE, {#NUM!}
                    )
                )
            ),

            _parts, TRIM(TEXTSPLIT(LiteraryDate, ",")),
            _cols, COLUMNS(_parts),
            IFS(_cols = 1,
                LET(
                    _part1, INDEX(_parts, 1, 1),
                    _spacePos, IFERROR(FIND(" ", _part1), 0),
                    IF(_spacePos = 0, {#VALUE!, "", "", ""},
                        LET(
                            _month, PARSE_MONTH(LEFT(_part1, _spacePos - 1)),
                            _daysInMonth, DAYS_IN_MONTH(_month, 2000),
                            _remain, MID(_part1, _spacePos + 1, LEN(_part1) - _spacePos),
                            _denotedYear, IFERROR(FIND("C", _remain), 0) > 0,
                            _val, IF(_denotedYear, PARSE_LITERARY_YEAR(_remain),
                                INT(VALUE(_remain))
                            ), 
                            _day, IFS(_denotedYear, "",
                                _val <= 0, "",
                                _val <= _daysInMonth, _val,
                                TRUE, ""
                            ),
                            _year, IFS(_denotedYear, _val,
                                _val <= 0, _val,
                                _val <= _daysInMonth, "",
                                TRUE, _val
                            ),
                            HSTACK(_year, _month, _day, "")
                        )
                    )
                ),
                _cols = 2,
                LET(
                    _p1, INDEX(_parts, 1, 1),
                    _spacePos, IFERROR(FIND(" ", _p1), 0),
                    IF(_spacePos = 0, {#VALUE!, "", "", ""},
                        LET(
                            _month, PARSE_MONTH(LEFT(_p1, _spacePos - 1)),
                            _p2, INDEX(_parts, 1, 2),
                            _time, fnParseTime(_p2),
                            _year, IF(NOT(ISNUMBER(_time)), PARSE_LITERARY_YEAR(_p2), ""),
                            _dayPart, MID(_p1, _spacePos + 1, LEN(_p1) - _spacePos),
                            _day, fnParseDay(_dayPart, _year, _month),
                            HSTACK(_year, _month, _day, _time)
                        )
                    )
                ),
                _cols = 3,
                LET(
                    _year, PARSE_LITERARY_YEAR(INDEX(_parts, 1, 2)),
                    _time, fnParseTime(INDEX(_parts, 1, 3)),
                    _p1, INDEX(_parts, 1, 1),
                    _spacePos, IFERROR(FIND(" ", _p1), 0),
                    IF(_spacePos = 0, {#VALUE!, "", "", ""},
                        LET(
                            _month, PARSE_MONTH(LEFT(_p1, _spacePos - 1)),
                            _dayPart, MID(_p1, _spacePos + 1, LEN(_p1) - _spacePos),
                            _day, fnParseDay(_dayPart, 2000, _month),
                            HSTACK(_year, _month, _day, _time)
                        )
                    )
                ),
                TRUE, {#VALUE!, "", "", ""}
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
FORMAT_LITERARY_DATE

Returns a date formatted in literary style.

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | Literary date

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE                 | integer         | Note that 1 BC = 0 CE, 2 BC = -1 CE
Month                  | integer [1..12] |
Day                    | integer [1..31] |
[Time]                 | decimal [0..1]  | Time of day as decimal fraction of a day.
[Options]              | text            | [S][I][E]
                       |                 |  S : Display short form months
                       |                 |  I : Use International English instead of local language set in Excel
                       |                 |  E : Always apply BCE/CE suffix. If not used, only years less than 1000
                       |                 |      show an era.
[JulianCalendar]       | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                       |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
FORMAT_LITERARY_DATE = LAMBDA(YearCE, Month, Day, [Time], [Options], [JulianCalendar],
    IFS(
        IS_EMPTY(YearCE) * IS_EMPTY(Month) * IS_EMPTY(Day), "",
        NOT(ISNUMBER(Month)) + (NOT(ISNUMBER(YearCE)) * NOT(ISNUMBER(Day))), {#VALUE!},
        TRUE, LET(
            _short, IFERROR(SEARCH("S", Options), 0) > 0,
            _intEnglish, IFERROR(SEARCH("I", Options), 0) > 0,
            _era, IFERROR(SEARCH("E", Options), 0) > 0,

            _sDate, LET(
                _nominalYear, IF(IS_EMPTY(YearCE), 2000, YearCE),
                _nominalDay, IF(ISNUMBER(Day), INT(Day), 1),
                IF(NOT(IS_VALID_DATE(_nominalYear, Month, _nominalDay, JulianCalendar)), "#DATE!",
                    LET(
                        _sMonth, MONTH_NAME(Month, _short, _intEnglish),
                        _sDay, IF(ISNUMBER(Day), " " & _nominalDay, ""),
                        _sYear, IF(ISNUMBER(YearCE), ", " & FORMAT_LITERARY_YEAR(YearCE, _era), ""),
                        CONCAT(_sMonth, _sDay, _sYear)
                    )
                )
            ),

            _sTime, IFS(
                IS_EMPTY(Time), "",
                NOT(ISNUMBER(Time)), "#TIME!",
                Time < 0, "#TIME!",
                Time > 1, "#TIME!",
                TRUE, LET(
                    _rTime, ROUND_TIMESPAN(Time, 3, 0, 1),
                    _fmt, IF(_rTime = 1, "[hh]:mm", "h:mm AM/PM"),
                    TEXT(_rTime, _fmt)
                )
            ),
            IF(_sTime = "", _sDate, _sDate & ", " & _sTime)
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_US_DATE

Parses a US formated date into respective parts of year, month, day and time of day.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day
 4 | decimal [0..1)  | Time

Parameters
----------------------------------------------------------------------------------------------------------------
USDate           | text   | Date in US format ie. MM/dd/yyyy hh:mm:ss
[JulianCalendar] | switch | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |        | proleptic calendar. 

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_US_DATE("1/25/2014 6:00")
Returns: {2014, 1, 25, 0.25}

PARSE_US_DATE("12/31/2023 24:00")
Returns: {2023, 12, 31, 1}
--------------------------------------------------------------------------------------------------------------*/
PARSE_US_DATE = LAMBDA(USDate, [JulianCalendar], 
    IFS(
        IS_EMPTY(USDate), {"", "", "", ""},
        NOT(VALIDATE_CHARSET(USDate, " ,-./0123456789:AMPTamp_" & UNICHAR(8722), 1)), {#VALUE!},
        TRUE, LET(
            _tryDate, DATEVALUE(USDate),
            _tryTime, TIMEVALUE(USDate),
            _isTimeOnly, IFS(
                ISERROR(_tryTime), FALSE,
                ISERROR(_tryDate), FALSE,
                TRUE, ISNUMBER(_tryTime) * (_tryDate = 0)
            ),
            IF(_isTimeOnly, HSTACK("", "", "", _tryTime),
                LET( 
                    fnYearValue, LAMBDA(_text,
                        LET(
                            _char1, LEFT(_text, 1),
                            _sign, IFS(
                                _char1 = "+", 1,
                                _char1 = "-", -1,
                                UNICODE(_char1) = 8722, -1,
                                TRUE, ""
                            ),
                            IF(_sign = "",
                                INT(VALUE(_text)),
                                _sign * INT(VALUE(RIGHT(_text, LEN(_text) - 1)))
                            )
                        )
                    ),

                    _pos1, FIND_NTH_CHAR(USDate, ",./-_", 1),
                    _pos2, FIND_NTH_CHAR(USDate, ",./-_", 2),
                    _pos3, IF(_pos2 = 0, 0, FIND_NTH_CHAR(USDate, ",./-_T ", 1, 1, 0, _pos2 + 2)),
                    _pos4, IF(_pos3 = 0, 0, FIND_NTH_CHAR(USDate, "0123456789", 1, 0, 0, MAX(_pos2, _pos3) + 1)),
                    _month, IF(_pos1 = 0, {#VALUE!},
                        INT(VALUE(LEFT(USDate, _pos1 - 1)))
                    ),
                    _year, IF(ISERROR(_month), {#VALUE!},
                        fnYearValue(
                            IF(_pos3 = 0,
                                RIGHT(USDate, LEN(USDate) - _pos2),
                                MID(USDate, _pos2 + 1, _pos3 - _pos2 - 1)
                            )
                        )
                    ),
                    _time, IF(_pos4 = 0, "",
                        LET(
                            _timePart, RIGHT(USDate, LEN(USDate) - _pos4 + 1),
                            _timeVal, DATEVALUE(_timePart) + TIMEVALUE(_timePart),
                            IF(_timeVal >= 1, {#NUM!}, _timeVal)
                        )
                    ),
                    _day, IF(_pos2 = 0, {#VALUE!},
                        LET(
                            _d, INT(VALUE(MID(USDate, _pos1 + 1, _pos2 - _pos1 - 1))),
                            IF(NOT(IFERROR(IS_VALID_DATE(_year, _month, _d, JulianCalendar), FALSE)), {#NUM!},
                                _d
                            )
                        )
                    ),
                    HSTACK(_year, _month, _day, _time)
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
FORMAT_US_DATE

Returns a date formatted in the US style.

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | US style date

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] |
Day              | integer [1..31] |
[Time]           | decimal [0..1)  | Time of day as decimal fraction of a day.
[Options]        | text            | String with elements: [<][LowOrder][DateSeparator][TimeSeparator]
                 |                 |      LowOrder : low order component to display
                 |                 |          Null : Defaults to minutes if time present, otherwise day
                 |                 |             D : Day
                 |                 |             H : Hour
                 |                 |             M : Minute
                 |                 |             S : Second
                 |                 |             T : Millisecond (ticks)
                 |                 |             < : Round by truncating components. Default is rounding to nearest.
                 |                 | DateSeparator : Character to separate date components. [,./-_]
                 |                 | TimeSeparator : Character to separate time components. [,.:-_]
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar. 
--------------------------------------------------------------------------------------------------------------*/
FORMAT_US_DATE = LAMBDA(YearCE, Month, Day, [Time], [Options], [JulianCalendar],
    IF(IS_EMPTY(YearCE) * IS_EMPTY(Month) * IS_EMPTY(Day) * IS_EMPTY(Time),  "",
       LET( 
            _hasTime, ISNUMBER(Time),
            _hasDate, ISNUMBER(YearCE) * ISNUMBER(Month) * ISNUMBER(Day),
            IF(NOT(_hasDate + _hasTime), {#VALUE!},
                LET(
                    fnFormatDate, LAMBDA(_separator, _yearCE, _month, _day,
                        IF(NOT(IS_VALID_DATE(_yearCE, _month, _day, JulianCalendar)), "#DATE!",
                            LET(
                                _sYear, TEXT(_yearCE, "0000;" & UNICHAR(8722) & "0000;0000"),
                                _sMonth, TEXT(_month, "0"),
                                _sDay, TEXT(_day, "0"),
                                CONCAT(_sMonth, _separator, _sDay, _separator, _sYear)
                            )
                        )
                    ),
                                        
                    fnFormatTime, LAMBDA(_separator, _lowOrder, _timeOfDay,
                        IFS(
                            IS_EMPTY(_timeOfDay), "",
                            _lowOrder = 1, "",
                            NOT(ISNUMBER(_timeOfDay)), "#TIME!",
                            _timeOfDay < 0, "#TIME!",
                            _timeOfDay > 1, "#TIME!",
                            TRUE, LET(
                                _fmt, IFS(
                                    _lowOrder = 1, "",
                                    _lowOrder = 2, "h AM/PM",
                                    _lowOrder = 3, "h\" & _separator & "mm AM/PM",
                                    _lowOrder = 4, "h\" & _separator & "mm\" & _separator & "ss AM/PM",
                                    _lowOrder = 5, "h\" & _separator & "mm\" & _separator & "ss.000 AM/PM"
                                ),
                                TEXT(_timeOfDay, _fmt)
                            )
                        )
                    ),

                    _truncate, IFERROR(FIND("<", Options), 0) > 0,
                    _lowOrder, IF(NOT(_hasTime), 1,
                        LET(
                            _tryLowOrderChar, FIND_NTH_CHAR(Options, "DHMST", 1, 0, 1),
                            IFS(
                                INDEX(_tryLowOrderChar, 1, 1) = 0, 3,
                                INDEX(_tryLowOrderChar, 1, 2) = "D", 1,
                                INDEX(_tryLowOrderChar, 1, 2) = "H", 2,
                                INDEX(_tryLowOrderChar, 1, 2) = "M", 3,
                                INDEX(_tryLowOrderChar, 1, 2) = "S", 4,
                                INDEX(_tryLowOrderChar, 1, 2) = "T", 5
                            )
                        )
                    ),
                    _useLowOrder, IF(_lowOrder = 5, 4, _lowOrder),
                    _precision, IF(_lowOrder = 5, 3, 0),
            
                    _tryDateSepChar, FIND_NTH_CHAR(Options, ",./-_", 1, 0, 1),
                    _dateSeparator, IF(INDEX(_tryDateSepChar, 1, 1) = 0, "/",
                        INDEX(_tryDateSepChar, 1, 2)
                    ),
                    _tryTimeSepChar, FIND_NTH_CHAR(Options, ",.:-_", 1, 0, 1, INDEX(_tryDateSepChar, 1, 1) + 1),
                    _timeSeparator, IF(INDEX(_tryTimeSepChar, 1, 1) = 0, ":",
                        INDEX(_tryTimeSepChar, 1, 2)
                    ),
                    
                    IFS(
                        _hasDate * _hasTime, LET(
                            _rDateTime, RESOLVE_DATETIME(YearCE, Month, INT(Day), Time, _useLowOrder, _precision, _truncate, JulianCalendar),
                            _sDate, fnFormatDate(_dateSeparator, INDEX(_rDateTime, 1, 1), INDEX(_rDateTime, 1, 2), INDEX(_rDateTime, 1, 3)),
                            _sTime, fnFormatTime(_timeSeparator, _lowOrder, INDEX(_rDateTime, 1, 4)),
                            IF(_sTime = "",
                                _sDate,
                                CONCAT(_sDate, " ", _sTime)
                            )
                        ),
                        _hasTime, LET(
                            // no date, time only
                            _rTimeOfDay, ROUND_TIMESPAN(Time, _useLowOrder, _precision, _truncate),
                            fnFormatTime(_timeSeparator, _lowOrder, _rTimeOfDay)
                        ),
                        TRUE, fnFormatDate(_dateSeparator, YearCE, Month, INT(Day)) // date only
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_MIL_DTG

Parses a date-time group in the format used by US Military message traffic, into respective parts of year,
month, day, time of day and time zone offset in minutes.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [1951..2050] | Year
 2 | integer [1..12]      | Month
 3 | integer [1..31]      | Day
 4 | decimal [0..1)       | Time
 5 | decimal [-900..900]  | Time zone offset minutes

Parameters
----------------------------------------------------------------------------------------------------------------
DTG | text | Date-time group in US Military format ie. ddHHmmssZmmmYY

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_MIL_DTG("12 15 30 45 B MAY 23")
Returns: {2023, 5, 12, 0.77118055, 120}

PARSE_MIL_DTG("05064515KJUN00")
Returns: {2000, 6, 5, 0.281423611, 600}

PARSE_MIL_DTG("150600Z")
Returns: { , , 15, 0.25, 0}
--------------------------------------------------------------------------------------------------------------*/
PARSE_MIL_DTG = LAMBDA(DTG,
    LET(
        _DTG, SUBSTITUTE(DTG, " ", ""),
        IFS(
            IS_EMPTY(_DTG), {"", "", "", "", ""},
            NOT(VALIDATE_CHARSET(_DTG, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ", 1)), {#VALUE!, "", "", "", ""},
            TRUE, LET(
                fnYear, LAMBDA(_sYear,
                    LET(
                        _yy, VALUE(_sYear),
                        IF(_yy < 51, 2000 + _yy, 1900 + _yy)
                    )
                ),

                fnTime, LAMBDA(_hour, _minute, _second,
                    IF(NOT(IS_VALID_TIME_OF_DAY(_hour, _minute, _second, 0)), {#NUM!},
                        TIMESPAN(
                            HSTACK(1, 0, _hour, _minute, _second)
                        )
                    )
                ),

                fnParseFull, LAMBDA(_DTG,
                    LET(
                        _day, VALUE(LEFT(_DTG, 2)),
                        _month, PARSE_MONTH(MID(_DTG, 10, 3)),
                        _year, fnYear(RIGHT(_DTG, 2)),
                        IF(NOT(IS_VALID_DATE(_year, _month, _day, 0)), {#VALUE!, "", "", "", ""},
                            LET(
                                _hour, VALUE(MID(_DTG, 3, 2)),
                                _minute, VALUE(MID(_DTG, 5, 2)),
                                _second, VALUE(MID(_DTG, 7, 2)),
                                _time, fnTime(_hour, _minute, _second),
                                _tz, IFNA(MILITARY_TZO(MID(_DTG, 9, 1)), ""),
                                HSTACK(
                                    _year,
                                    _month,
                                    _day,
                                    _time,
                                    _tz
                                )
                            )
                        )
                    )
                ),

                fnParseShort, LAMBDA(_DTG,
                    LET(
                        _day, VALUE(LEFT(_DTG, 2)),
                        _month, PARSE_MONTH(MID(_DTG, 8, 3)),
                        _year, fnYear(RIGHT(_DTG, 2)),
                        IF(NOT(IS_VALID_DATE(_year, _month, _day, 0)), {#VALUE!, "", "", "", ""},
                            LET(
                                _hour, VALUE(MID(_DTG, 3, 2)),
                                _minute, VALUE(MID(_DTG, 5, 2)),
                                _time, fnTime(_hour, _minute, 0),
                                _tz, IFNA(MILITARY_TZO(MID(_DTG, 7, 1)), ""),
                                HSTACK(
                                    _year,
                                    _month,
                                    _day,
                                    _time,
                                    _tz
                                )
                            )
                        )
                    )
                ),

                fnParsePlan, LAMBDA(_DTG,
                    LET(
                        _day, VALUE(LEFT(_DTG, 2)),
                        _hour, VALUE(MID(_DTG, 3, 2)),
                        _minute, VALUE(MID(_DTG, 5, 2)),
                        _time, fnTime(_hour, _minute, 0),
                        _tz, IFNA(MILITARY_TZO(MID(_DTG, 7, 1)), ""),
                        HSTACK(
                            "",
                            "",
                            _day,
                            _time,
                            _tz
                        )
                    )
                ),

                _len, LEN(_DTG),
                _fmt, IFS(_len = 14, "F", 
                    _len = 12, "S",
                    _len = 7, "P",
                    TRUE, #N/A
                ),
                IFS(
                    ISNA(_fmt), {#VALUE!, "", "", "", ""},
                    _fmt = "F", fnParseFull(_DTG),
                    _fmt = "S", fnParseShort(_DTG),
                    _fmt = "P", fnParsePlan(_DTG)
                )
            )
        )
    )
);

/*--------------------------------------------------------------------------------------------------------
FORMAT_MIL_DTG

Returns a date formatted in US Military message traffic style.

Output
----------------------------------------------------------------------------------------------------------
 1 | text | DTG formatted date

Parameters
----------------------------------------------------------------------------------------------------------
Year         | integer         |
             | [1951..2050]    |
Month        | integer [1..12] |
Day          | integer [1..31] |
Time         | decimal [0..1)  | Time of day as decimal fraction of a day.
[TZOMinutes] | decimal         | Time zone offset from UTC in minutes
             | [-900..900]     | Assumed to be UTC if ommitted. [-15:00..+15:00]
             |                 | Time will be converted if the offset does not align with military
             |                 | time zones.
[Options]    | text            | String with elements: [S][_][<]
             |                 |  S : Short format, ommits seconds
             |                 |  _ : Spacing between components
             |                 |  < : Round by truncating components. Default is rounding to nearest.

Examples
----------------------------------------------------------------------------------------------------------
FORMAT_MIL_DTG(2023, 2, 12, 0.75, 600, 1)
Returns: 121800KFEB23

FORMAT_MIL_DTG( , , 12, 0.25)
Returns: 120600J
--------------------------------------------------------------------------------------------------------*/
FORMAT_MIL_DTG = LAMBDA(Year, Month, Day, Time, [TZOMinutes], [Options],
    IFS(
        IS_EMPTY(Year) * IS_EMPTY(Month) * IS_EMPTY(Day) * IS_EMPTY(Time), "",
        NOT(IS_NUMERIC_NULL(Year)), {#VALUE!},
        NOT(IS_NUMERIC_NULL(Month)), {#VALUE!},
        NOT(IS_NUMERIC_NULL(Day)), {#VALUE!},
        NOT(IS_EMPTY(Month)) * NOT(IS_VALID_DATE(Year, Month, Day, 0)), "#DATE!",
        TRUE, LET(
            _tzo, N(TZOMinutes),
            _short, IFERROR(SEARCH("S", Options), 0) > 0,
            _spacing, IFERROR(FIND("_", Options), 0) > 0,
            _truncate, IFERROR(FIND("<", Options), 0) > 0,
            
            fnFmtTime, LAMBDA(_time,
                LET(
                    _timeFmt, IFS(
                        _short * _spacing, "hh mm",
                        _short * NOT(_spacing), "hhmm",
                        NOT(_short) * _spacing, "hh mm ss",
                        TRUE, "hhmmss"
                    ),
                    TEXT(_time, _timeFmt)
                )
            ),

            _day, INT(Day),
            _nominalYear, IF(IS_EMPTY(Year), 2001, Year),
            _nominalMonth, IF(IS_EMPTY(Year), 3, Month),
            _militaryTZ, TZO_TO_MILITARY(TZOMinutes),
            _nominalTime, N(Time) + INDEX(_militaryTZ, 1, 3),
            _rDateTime, RESOLVE_DATETIME(_nominalYear, _nominalMonth, _day, _nominalTime, 4 - N(_short), _truncate, 0),
            _sDay, TEXT(INDEX(_rDateTime, 3), "00"),
            _sTime, fnFmtTime(INDEX(_rDateTime, 4)),
            _sTZ, INDEX(_militaryTZ, 1, 1),
            _spc, IF(_spacing, " ", ""),
            IF(IS_EMPTY(Year),
                CONCAT(_sDay, _spc, _sTime, _spc, _sTZ),
                IF((INDEX(_rDateTime, 1) < 1951) + (INDEX(_rDateTime, 1) > 2050), "#RANGE!",
                    LET(
                        _sMonth, UPPER(MONTH_NAME(INDEX(_rDateTime, 2), 1, 1)),
                        _sYY, TEXT(MOD(INDEX(_rDateTime, 1), 100), "00"),
                        CONCAT(_sDay, _spc, _sTime, _spc, _sTZ, _spc, _sMonth, _spc, _sYY)
                    )
                )
            )
        )
    )
);















/*##############################################################################################################
# ORDINAL DATES                                                                                                #
##############################################################################################################*/


/*--------------------------------------------------------------------------------------------------------------
IS_VALID_ORDINAL_DATE

Tests if an ordinal date is valid for the given calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE           | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
OrdinalDay       | decimal [1..367) | Day of year
[JulianCalendar] | switch           | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                  | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
IS_VALID_ORDINAL_DATE = LAMBDA(YearCE, OrdinalDay, [JulianCalendar],
    IFS(
        NOT(ISNUMBER(YearCE)) + NOT(ISNUMBER(OrdinalDay)), FALSE, // cannot ommit year or ordinal day
        NOT(IS_INTEGER(YearCE)), FALSE, // year cannot be fractional
        TRUE, LET(
            _ordinalDay, INT(OrdinalDay),
            IF(_ordinalDay < 1, FALSE,
                LET(
                    _daysInYear, DAYS_IN_YEAR(YearCE, JulianCalendar),
                    _ordinalDay <= _daysInYear
                )
            )
        )
    )
);

/*--------------------------------------------------------------------------------------------------------------
PARSE_ISO_ORDINAL_DATE

Parses an ISO formatted ordinal date into respective parts of year, and ordinal day.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer          | YearCE
 2 | integer [1..366] | Ordinal day

Parameters
----------------------------------------------------------------------------------------------------------------
ISOOrdinalDate   | text   | Date in ISO format ie. yyyy-ddd
[JulianCalendar] | switch | Validate in the Julian proleptic calendar. Default is Gregorian
                 |        | proleptic calendar.

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_ISO_ORDINAL_DATE("2023-223")
Returns: {2023, 223}

PARSE_ISO_ORDINAL_DATE("1900-366", 1)
Returns: {2023, 366} i.e. 1900 was a leap year in the Julian calendar
--------------------------------------------------------------------------------------------------------------*/
PARSE_ISO_ORDINAL_DATE = LAMBDA(ISOOrdinalDate, [JulianCalendar],
    IFS(
        IS_EMPTY(ISOOrdinalDate), {"", ""},
        NOT(VALIDATE_CHARSET(ISOOrdinalDate, "+-0123456789" & UNICHAR(8722))), {#VALUE!, ""},
        TRUE, LET(
            _firstChar, LEFT(ISOOrdinalDate, 1),
            _isSigned, IFS(
                _firstChar = "+", TRUE,
                _firstChar = "-", TRUE,
                _firstChar = UNICHAR(8722), TRUE,
                TRUE, FALSE
            ),
            _sign, IFS(
                NOT(_isSigned), 1,
                _firstChar = "-", -1,
                _firstChar = UNICHAR(8722), -1,
                TRUE, 1
            ),
            _unSigned, IF(_isSigned,
                RIGHT(ISOOrdinalDate, LEN(ISOOrdinalDate) - 1),
                ISOOrdinalDate
            ),
            _len, LEN(_unSigned),
            _pattern, REPLACE_CHARS(_unSigned, "0123456789", "_"),
            _tryParse, IFS(
                _len >= 8, IF(
                    _pattern = RIGHT("_______________-___", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 4)),
                        VALUE(RIGHT(_unSigned, 3))
                    ),
                    ""
                ),
                _len = 7, IF(
                    _pattern = "_______",
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 3)),
                        VALUE(RIGHT(_unSigned, 3))
                    ),
                    ""
                ),
                (_len >= 4) * (_len <= 5), IF(
                    _pattern = RIGHT("_____", _len),
                    HSTACK(
                        VALUE(_unSigned),
                        ""
                    ),
                    ""
                ),
                TRUE, #N/A
            ),

            IF(ISERROR(INDEX(_tryParse, 1, 1)), {#VALUE!, ""},
                LET(
                    _year, _sign * INDEX(_tryParse, 1, 1),
                    _ordinalDay, INDEX(_tryParse, 1, 2),
                    IFS(
                        _ordinalDay = "", HSTACK(_year, ""),
                        IS_VALID_ORDINAL_DATE(_year, _ordinalDay, JulianCalendar),
                            HSTACK(_year, _ordinalDay),
                        TRUE,
                            HSTACK(_year, {#NUM!})
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
FORMAT_ISO_ORDINAL_DATE

Returns an ordinal date as text in ISO format.

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | ISO formatted ordinal date

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE           | integer          | Note that 1 BC = 0 CE, 2 BC = -1 CE
OrdinalDay       | integer [1..366] |
[Basic]          | switch           | Display in basic format eg yyyyddd.
                 |                  | Invalid when OrdinalDay provided and YearCE outside of range -9999..9999
                 |                  | due to collision with yyyyMMdd ISO format.
[JulianCalendar] | switch           | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                  | proleptic calendar. 
--------------------------------------------------------------------------------------------------------------*/
FORMAT_ISO_ORDINAL_DATE = LAMBDA(YearCE, OrdinalDay, [Basic], [JulianCalendar],
    IFS(
        IS_EMPTY(YearCE) * IS_EMPTY(OrdinalDay), "",
        NOT(ISNUMBER(YearCE)), {#VALUE!},
        NOT(IS_NUMERIC_NULL(OrdinalDay)), {#VALUE!},
        IS_EMPTY(OrdinalDay), FORMAT_ISO_Year(YearCE),
        TRUE, LET(
            _basic, N(Basic) <> 0,
            IF(_basic * (ABS(YearCE) > 9999), {#VALUE!},
                LET(
                    _delim, IF(_basic, "", "-"),
                    IF(NOT(IS_VALID_ORDINAL_DATE(YearCE, OrdinalDay, JulianCalendar)), {#NUM!},
                        CONCAT(
                            FORMAT_ISO_Year(YearCE),
                            _delim, TEXT(OrdinalDay, "000")
                        )
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
ORDINAL_DATE_TO_MJDATE

Converts an ordinal date and time in the specified calendar to a Modified Julian Date (MJDATE).

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Modified Julian Date

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE           | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
OrdinalDay       | integer [1..366] | Day of year, carries if range exceeded
[Time]           | decimal [0..1)   | Time of day
[JulianCalendar] | switch           | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                  | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
ORDINAL_DATE_TO_MJDATE = LAMBDA(YearCE, OrdinalDay, [Time], [JulianCalendar],
    IFS(
        (YearCE = "") * (OrdinalDay = "") * (Time = ""), "",
        NOT(ISNUMBER(YearCE)) + NOT(ISNUMBER(OrdinalDay)), {#VALUE!},
        TRUE, LET(
            _ordinalDay, INT(OrdinalDay),
            _MJDNYear, MODIFIED_JULIAN_DAY_NUMBER(YearCE, 1, 1, JulianCalendar) - 1,
            _MJDNYear + _ordinalDay + N(Time)
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
MJDATE_TO_ORDINAL_DATE

Converts a Modified Julian Date (MJDATE) to an ordinal date and time in the specified calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer           | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..366]  | Ordinal day
 3 | decimal [0..1)    | Time of day
 4 | integer [365,366] | Days in year

Parameters
----------------------------------------------------------------------------------------------------------------
MJDate           | decimal | Modified Julian Date
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
MJDATE_TO_ORDINAL_DATE = LAMBDA(MJDate, [JulianCalendar],
    IFS(
        MJDate = "", {"", "", "", ""},
        NOT(ISNUMBER(MJDate)), {#VALUE!, "", "", ""},
        TRUE, LET(
            _cDate, MJDATE_TO_CALENDAR_DATE(MJDate, JulianCalendar),
            _yearCE, INDEX(_cDate, 1, 1),
            _MJDNYear, MODIFIED_JULIAN_DAY_NUMBER(_yearCE, 1, 1, JulianCalendar) - 1,
            _ordinalDay, INT(MJDate - _MJDNYear),
            _daysInYear, DAYS_IN_YEAR(_yearCE, JulianCalendar),
            HSTACK(
                _yearCE,
                _ordinalDay,
                INDEX(_cDate, 1, 4),
                _daysInYear
            )
        )
    )
);












/*##############################################################################################################
# WEEKS                                                                                                        #
##############################################################################################################*/


/*--------------------------------------------------------------------------------------------------------------
CONVERT_WEEKDAY_NUMBER

Returns an integer for the day of the week from the traditonal numbering scheme to the ISO definition, or
vice versa.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Weekday number
   | [1..7]  |    | ISO       | Traditioal
   |         | ---------------------------
   |         |  1 | Monday    | Sunday 
   |         |  2 | Tuesday   | Monday 
   |         |  3 | Wednesday | Tuesday
   |         |  4 | Thursday  | Wednesday
   |         |  5 | Friday    | Thursday
   |         |  6 | Saturday  | Friday
   |         |  7 | Sunday    | Saturday

Parameters
----------------------------------------------------------------------------------------------------------------
DayOfWeek          | integer [1..7] | Day of week number
[ISOtoTraditional] | switch         | Return day of week using traditional numbering scheme, assuming 
                   |                | DayOfWeek was provided according to ISO definition.
                   |                | Default is to return in ISO definition, assuming DayOfWeek was
                   |                | provided according to the traditional numbering scheme.
--------------------------------------------------------------------------------------------------------------*/
CONVERT_WEEKDAY_NUMBER = LAMBDA(DayOfWeek, [ISOtoTraditional],
    IFS(
        DayOfWeek = "", "",
        NOT(ISNUMBER(DayOfWeek)), {#VALUE!},
        TRUE, LET(
            _givenDoW, INT(N(DayOfWeek)),
            _fromISO, N(ISOtoTraditional) <> 0, 
            _shiftDoW, _givenDow + IF(_fromISO, 0, -2),
            MOD(_shiftDow, 7) + 1
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_WEEKDAY

Returns a number representing the day of the week from a given text weekday name.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Weekday number
   | [1..7]  |    | ISO       | Traditioal
   |         | ---------------------------
   |         |  1 | Monday    | Sunday 
   |         |  2 | Tuesday   | Monday 
   |         |  3 | Wednesday | Tuesday
   |         |  4 | Thursday  | Wednesday
   |         |  5 | Friday    | Thursday
   |         |  6 | Saturday  | Friday
   |         |  7 | Sunday    | Saturday

Parameters
----------------------------------------------------------------------------------------------------------------
DayOfWeekText | text   | Day of week name
[Traditional] | switch | Return day of week using traditional numbering scheme.

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_WEEKDAY("Saturday")
Returns: 6

PARSE_WEEKDAY("Mon", 1)
Returns: 2

PARSE_WEEKDAY("Thurs")
Returns: #VALUE!

PARSE_WEEKDAY("Ven")
Returns: 5 (Friday, if local language is set to Italian)
--------------------------------------------------------------------------------------------------------------*/
PARSE_WEEKDAY = LAMBDA(DayOfWeekText, [Traditional],
    IF(DayOfWeekText = "", "",
        LET(
            fnMatchIntEng, LAMBDA(DoW,
                LET(
                    _dow, IF(LEN(DayOfWeekText) = 3,
                        XMATCH(
                            DayOfWeekText,
                            {
                                "Mon";
                                "Tue";
                                "Wed";
                                "Thu";
                                "Fri";
                                "Sat";
                                "Sun"
                            }
                        ),
                        XMATCH(
                            DayOfWeekText,
                            {
                                "Monday";
                                "Tuesday";
                                "Wednesday";
                                "Thursday";
                                "Friday";
                                "Saturday";
                                "Sunday"
                            }
                        )
                    ),
                    IFNA(_dow, 0)
                )
            ),
            fnMatchLocalLang, LAMBDA(DoW,
                LET(
                    _days, SEQUENCE(7, 1, 36528),
                    _dow, IF(LEN(DayOfWeekText) = 3,
                        XMATCH(DayOfWeekText, TEXT(_days, "ddd")),
                        XMATCH(DayOfWeekText, TEXT(_days, "dddd"))
                    ),
                    IFNA(_dow, 0)
                )
            ),
            _ISOWeekday, LET(
                _idx, fnMatchIntEng(DayOfWeekText),
                IF(_idx > 0, _idx, fnMatchLocalLang(DayOfWeekText))
            ),
            IFS(_ISOWeekday = 0, {#VALUE!},
                N(Traditional) = 0, _ISOWeekday,
                TRUE, MOD(_ISOWeekday, 7) + 1
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
WEEKDAY_NAME

Returns name of an ISO day of week number as text.

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | Weekday

Parameters
----------------------------------------------------------------------------------------------------------------
ISOWeekDay             | integer [1..7] | ISO day of week number
[Short]                | switch         | Return short format Mon..Sun
[InternationalEnglish] | switch         | International English instead of local language set in Excel
--------------------------------------------------------------------------------------------------------------*/
WEEKDAY_NAME = LAMBDA(ISOWeekDay, [Short], [InternationalEnglish],
    IFS(
        ISOWeekDay = "", "",
        NOT(ISNUMBER(ISOWeekDay)), {#VALUE!},
        TRUE, LET(
            _useShort, N(Short) <> 0,
            _useLocalLang, N(InternationalEnglish) = 0,
            _isoDoW, MOD(INT(ISOWeekDay) - 1, 7) + 1, 
            IF(_useLocalLang,
                LET(
                    _y2krefDay, 36527 + _isoDoW,
                    _fmt, IF(_useShort, "ddd", "dddd"),
                    TEXT(_y2krefDay, _fmt)
                ),
                IF(
                    _useShort,
                    CHOOSE(_isoDoW,
                        "Mon",
                        "Tue",
                        "Wed",
                        "Thu",
                        "Fri",
                        "Sat",
                        "Sun"
                    ),
                    CHOOSE(_isoDoW,
                        "Monday",
                        "Tuesday",
                        "Wednesday",
                        "Thursday",
                        "Friday",
                        "Saturday",
                        "Sunday"
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
DAY_OF_WEEK

Returns an integer for the day of the week for a given Modified Julian Date.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [1..7] | ISO day of week number
   |                | Monday..Sunday

Parameters
----------------------------------------------------------------------------------------------------------------
MJDate | decimal | Modified Julian Date
--------------------------------------------------------------------------------------------------------------*/
DAY_OF_WEEK = LAMBDA(MJDate,
    IFS(
        MJDate = "", "",
        NOT(ISNUMBER(MJDate)), {#VALUE!},
        TRUE, LET(
            _MJDN, INT(MJDate),
            MOD(_MJDN + 2, 7) + 1
        )
    )
);




/*--------------------------------------------------------------------------------------------------------------
WEEKDAY_OF_MONTH

Returns a Modified Julian Date for a given day of week, relative week for the month, year and time of day
of the specified calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Modified Julian Date

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] | Month of the year
WeekOfMonth      | integer [-4..5] | Week in the month.
                 |                 | Note if the reference exceeds the bounds of the month, another month
                 |                 | will be returned.
                 |                 |  0 - last week of previous month
                 |                 |  1 - first week
                 |                 |  2 - second week
                 |                 |  3 - third week
                 |                 |  4 - fourth week
                 |                 |  5 - fifth week
                 |                 | -1 - last week
                 |                 | -2 - second to last week
                 |                 | -3 - third to last week
                 |                 | -4 - fourth to last week
ISOWeekDay       | integer [1..7]  | ISO day of week number Monday..Sunday
[Time]           | decimal [0..1)  | Time of day
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
    
Examples
----------------------------------------------------------------------------------------------------------------
WEEKDAY_OF_MONTH(2023, 6, 0, 7)
Returns: MJDate 60120.0 (25/06/2023) ie. the last Sunday of June 2023

WEEKDAY_OF_MONTH(2023, 1, 2, 2, 0.5)
Returns: MJDate 59954.5 (10/01/2023 12pm) ie. midday of the second Tuesday of January 2023
--------------------------------------------------------------------------------------------------------------*/
WEEKDAY_OF_MONTH = LAMBDA(YearCE, Month, WeekOfMonth, ISOWeekDay, [Time], [JulianCalendar],
    IFS(
        (YearCE = "") * (Month = "") * (WeekOfMonth = "") * (ISOWeekDay = ""), "",
        NOT(ISNUMBER(YearCE)) + NOT(ISNUMBER(Month)) + NOT(ISNUMBER(WeekOfMonth)) + NOT(ISNUMBER(ISOWeekDay)), {#VALUE!},
        NOT(IS_INTEGER(YearCE) * IS_INTEGER(Month) * IS_INTEGER(WeekOfMonth) * IS_INTEGER(ISOWeekDay)), {#NUM!},
        (WeekOfMonth < -4) + (WeekOfMonth > 5), {#NUM!},
        TRUE, LET(
            _month, Month + N(WeekOfMonth < 0),
            _weekOffset, WeekOfMonth - N(WeekOfMonth >= 0),
            _isoDoW, MOD(ISOWeekDay - 1, 7) + 1,
            _firstOfMonth, MODIFIED_JULIAN_DATE(YearCE, _month, 1, 0, JulianCalendar),
            _firstDoW, DAY_OF_WEEK(_firstOfMonth),
            _firstOfMonth + (_weekOffset * 7) + MOD(_isoDow - _firstDoW, 7) + N(Time)
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
IS_VALID_WEEK_DATE

Tests if a week date is valid for the given calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
ISOWeek          | integer [1..53] | ISO defined week number of the year
[ISOWeekDay]     | integer [1..7]  | ISO defined day of week Monday..Sunday
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
IS_VALID_WEEK_DATE = LAMBDA(YearCE, ISOWeek, [ISOWeekDay], [JulianCalendar],
    IFS(
        NOT(ISNUMBER(YearCE)) + NOT(ISNUMBER(ISOWeek)), FALSE, // cannot ommit year or week
        NOT(IS_INTEGER(YearCE) * IS_INTEGER(ISOWeek)), FALSE, // year and week cannot be fractional
        TRUE, LET(
            _validWeek, IFS(
                ISOWeek < 1, FALSE,
                ISOWeek <= 52, TRUE,
                ISOWeek = 53, (WEEKS_IN_YEAR(YearCE, JulianCalendar) = 53),
                TRUE, FALSE
            ),
            IF(NOT(_validWeek), FALSE,
                IF(NOT(ISNUMBER(ISOWeekDay)), TRUE,
                    LET(
                        _weekDay, INT(ISOWeekDay),
                        (_weekDay >= 1) * (_weekDay <= 7) <> 0
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
WEEKS_IN_YEAR

Returns the count of ISO defined weeks in a given year of the specified calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [52,53]

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE           | integer | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
WEEKS_IN_YEAR = LAMBDA(YearCE, [JulianCalendar],
    IFS(
        YearCE = "", "",
        NOT(ISNUMBER(YearCE)), {#VALUE!},
        TRUE, LET(
            _gregorian, N(JulianCalendar) = 0,
            fnLastWeekDayOfYear, LAMBDA(_yearCE,
                LET(
                    _dayPrecession, IF(_gregorian,
                        _yearCE + INT(_yearCE / 4) - INT(_yearCE / 100) + INT(_yearCE / 400) + 6,
                        _yearCE + INT(_yearCE / 4) + 4
                    ),
                    MOD(_dayPrecession, 7) + 1
                )
            ),

            _yearCE, INT(YearCE),
            _dowLastDay, fnLastWeekDayOfYear(_yearCE),
            IF(
                _dowLastDay = 4,
                // if last day of year is a Thursday, then has an extra week
                53,
                LET(
                    _dowLastDayPrev, fnLastWeekDayOfYear(_yearCE - 1) ,
                    IF(
                        _dowLastDayPrev = 3,
                        // if last day of previous year is a Wednesday, then has an extra week
                        53,
                        // otherwise
                        52
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_ISO_WEEK_DATE

Parses an ISO formatted week date into respective parts of year, week and weekday.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | YearCE
 2 | integer | ISO week
 3 | integer | ISO week day

Parameters
----------------------------------------------------------------------------------------------------------------
ISOWeekDate      | text   | Week date in ISO format ie. yyyy-Www-d
[JulianCalendar] | switch | Validate in the Julian proleptic calendar. Default is Gregorian
                 |        | proleptic calendar.

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_ISO_WEEK_DATE("2023-W05-1")
Returns: {2023, 5, 1}
--------------------------------------------------------------------------------------------------------------*/
PARSE_ISO_WEEK_DATE = LAMBDA(ISOWeekDate, [JulianCalendar],
    IFS(
        IS_EMPTY(ISOWeekDate), {"", "", ""},
        NOT(VALIDATE_CHARSET(ISOWeekDate, "+-0123456789W" & UNICHAR(8722), 1)), {#VALUE!, "", ""},
        TRUE, LET(
            _firstChar, LEFT(ISOWeekDate, 1),
            _isSigned, IFS(
                _firstChar = "+", TRUE,
                _firstChar = "-", TRUE,
                _firstChar = UNICHAR(8722), TRUE,
                TRUE, FALSE
            ),
            _sign, IFS(
                NOT(_isSigned), 1,
                _firstChar = "-", -1,
                _firstChar = UNICHAR(8722), -1,
                TRUE, 1
            ),
            _unSigned, IF(_isSigned,
                RIGHT(ISOWeekDate, LEN(ISOWeekDate) - 1),
                ISOWeekDate
            ),
            _len, LEN(_unSigned),
            _pattern, REPLACE_CHARS(_unSigned, "0123456789", "_"),
            _tryParse, IFS(
                _len >= 10, IFS(
                    _pattern = RIGHT("_______________-W__-_", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 6)),
                        VALUE(MID(_unSigned, _len - 3, 2)),
                        VALUE(RIGHT(_unSigned, 1))
                    ),
                    _pattern = RIGHT("_______________-W__", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 4)),
                        VALUE(RIGHT(_unSigned, 2)),
                        ""
                    ),
                    _pattern = RIGHT("_______________W___", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 4)),
                        VALUE(MID(_unSigned, _len - 2, 2)),
                        VALUE(RIGHT(_unSigned, 1))
                    ),
                    _pattern = RIGHT("_______________W__", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 3)),
                        VALUE(RIGHT(_unSigned, 2)),
                        ""
                    ),
                    TRUE, ""
                ),
                _len >= 8, IFS(
                    _pattern = RIGHT("_____-W__", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 4)),
                        VALUE(RIGHT(_unSigned, 2)),
                        ""
                    ),
                    _pattern = RIGHT("_____W___", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 4)),
                        VALUE(MID(_unSigned, _len - 2, 2)),
                        VALUE(RIGHT(_unSigned, 1))
                    ),
                    _pattern = RIGHT("______W__", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 3)),
                        VALUE(RIGHT(_unSigned, 2)),
                        ""
                    ),
                    TRUE, ""
                ),
                _len = 7, IF(
                    _pattern = "____W__",
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 3)),
                        VALUE(RIGHT(_unSigned, 2)),
                        ""
                    ),
                    ""
                ),
                (_len >= 4) * (_len <= 5), IF(
                    _pattern = RIGHT("_____", _len),
                    HSTACK(
                        VALUE(_unSigned),
                        "",
                        ""
                    ),
                    ""
                ),
                TRUE, #N/A
            ),

            IF(ISERROR(INDEX(_tryParse, 1, 1)), {#VALUE!, "", ""},
                LET(
                    _year, _sign * INDEX(_tryParse, 1, 1),
                    _week, INDEX(_tryParse, 1, 2),
                    IF(_week = "", HSTACK(_year, "", ""),
                        LET(
                            _invalidWeek, IFS(
                                _week < 1, TRUE,
                                _week <= 52, FALSE,
                                _week > 53, TRUE,
                                TRUE, WEEKS_IN_YEAR(_year, JulianCalendar) < 53
                            ),
                            IF(_invalidWeek, HSTACK(_year, {#NUM!}, ""),
                                LET(
                                    _day, INDEX(_tryParse, 1, 3),
                                    IF(_day = "", HSTACK(_year, _week, ""),
                                        IF((_day >= 1) * (_day <= 7),
                                            HSTACK(_year, _week, _day),
                                            HSTACK(_year, _week, {#NUM!})
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
FORMAT_ISO_WEEK_DATE

Returns a week date as text in ISO format.

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | ISO formatted week date

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Note that 1 BC = 0 CE, 2 BC = -1 CE
ISOWeek          | integer [1..53] | Note most years have 52 ISO weeks
[ISOWeekDay]     | integer [1..7]  | ISO day of week Monday..Sunday
[Basic]          | switch          | Display in basic format eg yyyyWwwd
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar. 
--------------------------------------------------------------------------------------------------------------*/
FORMAT_ISO_WEEK_DATE = LAMBDA(YearCE, ISOWeek, [ISOWeekDay], [Basic], [JulianCalendar],
    IFS(
        IS_EMPTY(YearCE) * IS_EMPTY(ISOWeek) * IS_EMPTY(ISOWeekDay), "",
        NOT(ISNUMBER(YearCE)), {#VALUE!},
        NOT(IS_NUMERIC_NULL(ISOWeek)) + NOT(IS_NUMERIC_NULL(ISOWeekDay)), {#VALUE!},
        NOT(ISNUMBER(ISOWeek)) * ISNUMBER(ISOWeekDay), {#VALUE!},
        TRUE, LET(
            _delim, IF(N(Basic) = 0, "-", ""),
            IFS(
                IS_EMPTY(ISOWeek), FORMAT_ISO_Year(YearCE),
                NOT(IS_VALID_WEEK_DATE(YearCE, ISOWeek, ISOWeekDay, JulianCalendar)), {#NUM!},
                IS_EMPTY(ISOWeekDay), CONCAT(
                    FORMAT_ISO_Year(YearCE),
                    _delim, "W", TEXT(ISOWeek, "00")
                ),
                TRUE, CONCAT(
                    FORMAT_ISO_Year(YearCE),
                    _delim, "W", TEXT(ISOWeek, "00"),
                    _delim, TEXT(ISOWeekDay, "0")
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
WEEK_DATE_TO_MJDATE

Converts a week date of year, ISO defined week number, ISO weekday, and time in the specified calendar to a
Modified Julian Date (MJDATE).

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Modified Julian Date

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
ISOWeek          | integer [1..53] | ISO defined week number of the year
ISOWeekDay       | integer [1..7]  | ISO defined day of week Monday..Sunday
[Time]           | decimal [0..1)  | Time of day
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
WEEK_DATE_TO_MJDATE = LAMBDA(YearCE, ISOWeek, ISOWeekDay, [Time], [JulianCalendar],
    IFS(
        (YearCE = "") * (ISOWeek = "") * (ISOWeekDay = ""), "",
        NOT(ISNUMBER(YearCE)) + NOT(ISNUMBER(ISOWeek)) + NOT(ISNUMBER(ISOWeekDay)), {#VALUE!},
        TRUE, LET(
            _invalid, IFS(
                NOT(IS_INTEGER(YearCE)), TRUE,
                NOT(IS_INTEGER(ISOWeek)), TRUE,
                ISOWeek < 1, TRUE,
                ISOWeek > 53, TRUE,
                ISOWeek = 53, (WEEKS_IN_YEAR(YearCE, JulianCalendar) < 53),
                TRUE, FALSE
            ),
            IF(_invalid, {#NUM!},
                LET(
                    _shiftByWeeks, (ISOWeek - 1) * 7,
                    _shiftDayOfWeek, MOD(INT(ISOWeekDay) - 1, 7),
                    _firstDayYear, MODIFIED_JULIAN_DAY_NUMBER(YearCE, 1, 1, JulianCalendar),
                    _firstWeekDay, DAY_OF_WEEK(_firstDayYear),
                    _yearCorrection, MOD(4 - _firstWeekDay, 7) - 3,
                    _firstDayYear + _yearCorrection + _shiftByWeeks + _shiftDayOfWeek + N(Time) 
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
MJDATE_TO_WEEK_DATE

Converts a Modified Julian Date (MJDATE) to the year, ISO defined week number, ISO weekday, time, and weeks
in the year in the specified calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer         | YearCE
 2 | integer [1..53] | ISO week number
 3 | integer [1..7]  | ISO day of week Monday..Sunday
 4 | decimal [0..1)  | Time of day
 5 | integer [52,53] | ISO weeks in year

Parameters
----------------------------------------------------------------------------------------------------------------
MJDate           | decimal | Modified Julian Date
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
MJDATE_TO_WEEK_DATE = LAMBDA(MJDate, [JulianCalendar],
    IFS(
        MJDate = "", {"", "", "", "", ""},
        NOT(ISNUMBER(MJDate)), {#VALUE!, "", "", "", ""},
        TRUE, LET(
            _cDate, MJDATE_TO_CALENDAR_DATE(MJDate, JulianCalendar),
            _yearCE, INDEX(_cDate, 1, 1),
            _dayOfWeek, DAY_OF_WEEK(MJDate),
            _MJDNYear, MODIFIED_JULIAN_DAY_NUMBER(_yearCE, 1, 1, JulianCalendar) - 1,
            _dayOfYear, INT(MJDate - _MJDNYear),
            _nominalWeek, INT((_dayOfYear - _dayOfWeek + 10) / 7),
            IFS(
                // last week of previous year
                _nominalWeek = 0, LET(
                    _weeksInYear, WEEKS_IN_YEAR(_yearCE - 1, JulianCalendar), 
                    HSTACK(
                        _yearCE - 1,
                        _weeksInYear,
                        _dayOfWeek,
                        INDEX(_cDate, 1, 4),
                        _weeksInYear
                    )
                ),
                
                // auxiliary week
                _nominalWeek = 53, IF(WEEKS_IN_YEAR(_yearCE, JulianCalendar) = 53,
                    HSTACK(
                        _yearCE,
                        53,
                        _dayOfWeek,
                        INDEX(_cDate, 1, 4),
                        53
                    ),
                    // if this year does not have 53 weeks, then is the first week of following year
                    LET(
                        _weeksInYear, WEEKS_IN_YEAR(_yearCE + 1, JulianCalendar),
                        HSTACK(
                            _yearCE + 1,
                            1,
                            _dayOfWeek,
                            INDEX(_cDate, 1, 4),
                            _weeksInYear
                        )
                    )
                ),
                
                // any other week in the year
                TRUE, LET(
                    _weeksInYear, WEEKS_IN_YEAR(_yearCE, JulianCalendar),
                    HSTACK(
                        _yearCE,
                        _nominalWeek,
                        _dayOfWeek,
                        INDEX(_cDate, 1, 4),
                        _weeksInYear
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
WEEK_NUMBER

Returns the ISO defined week number for a given Modified Julian Date in the specified calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [1..53] | ISO week number

Parameters
----------------------------------------------------------------------------------------------------------------
MJDate           | decimal | Modified Julian Date
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
WEEK_NUMBER = LAMBDA(MJDate, [JulianCalendar],
    IFS(
        MJDate = "", "",
        NOT(ISNUMBER(MJDate)), {#VALUE!},
        TRUE, LET(
            _weekDate, MJDATE_TO_WEEK_DATE(MJDate, JulianCalendar),
            CHOOSECOLS(_weekDate, 2)
        )
    )
);











/*##############################################################################################################
# QUARTERS                                                                                                     #
##############################################################################################################*/


/*--------------------------------------------------------------------------------------------------------------
DAYS_IN_QUARTER

Returns the count of days in a quarter of a given year of the specified calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [89..92]

Parameters
----------------------------------------------------------------------------------------------------------------
Quarter          | integer [1..4]  | Quarter of the year 1..4, transitive, exceeding range will carry to year.
[FiscalYearCE]   | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
                 |                 | When month offset is non-zero the fiscal year spans calendar years and
                 |                 | is defined as the year where June falls.
[MonthOffset]    | integer [-6..3] | Quarter month offset from Januaray
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.

Examples
----------------------------------------------------------------------------------------------------------------
DAYS_IN_QUARTER(3, 2020, -6)
Returns: 91
i.e. 3rd quarter starting from July 2019, namely Jan, Feb, Mar 2020 with 31, 29, 31 days respectively
--------------------------------------------------------------------------------------------------------------*/
DAYS_IN_QUARTER = LAMBDA(Quarter, [FiscalYearCE], [MonthOffset], [JulianCalendar],
    IFS(
        Quarter = "", "",
        NOT(ISNUMBER(Quarter)), {#VALUE!},
        NOT(IS_INTEGER(Quarter)), {#NUM!},
        TRUE, LET(
            _monthOffset, ROUND(N(MonthOffset), 0),
            IF((_monthOffset < -6) + (_monthOffset > 3), {#NUM!},
                LET(
                    _quarter, MOD(INT(Quarter) - 1, 4), // 0..3
                    _daysInQuarterCyclical, {90,89,92,91,92,92,92,92,91,92,92,90},
                    _quarterWithFeb, INT(MOD(1 - _monthOffset, 12) / 3),  // 0..3
                    _quarterPrecession, MOD(_monthOffset + (_quarter * 3), 12) + 1,
                    _nominalDaysInQuarter, INDEX(_daysInQuarterCyclical, 1, _quarterPrecession),
                    _leapDay, IF(ISNUMBER(FiscalYearCE) * (_quarterWithFeb = _quarter),
                        LET(
                            _yearOfFeb, INT(FiscalYearCE) + N(_quarter = 3),
                            N(IS_LEAP_YEAR(_yearOfFeb, JulianCalendar))
                        ),
                        0
                    ),
                    _nominalDaysInQuarter + _leapDay
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
QUARTER_DATE_TO_MJDATE

Converts a date expressed as fiscal year, quarter, day of quarter and time in the specified calendar to a
Modified Julian Date (MJDATE).

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Modified Julian Date

Parameters
----------------------------------------------------------------------------------------------------------------
FiscalYearCE     | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
                 |                 | When month offset is non-zero the fiscal year spans calendar years and
                 |                 | is defined as the year where June falls.
Quarter          | integer [1..4]  | Quarter of the year 1..4, transitive, exceeding range will carry to year.
DayOfQuarter     | integer [1..92] | Ordinal day of the quarter, exceeding range will carry
[Time]           | decimal [0..1)  | Time of day
[MonthOffset]    | integer [-6..3] | Quarter month offset from January
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
QUARTER_DATE_TO_MJDATE = LAMBDA(FiscalYearCE, Quarter, DayOfQuarter, [Time], [MonthOffset], [JulianCalendar],
    IFS(
        (FiscalYearCE = "") * (Quarter = "") * (DayOfQuarter = ""), "",
        NOT(ISNUMBER(FiscalYearCE)), {#VALUE!},
        NOT(ISNUMBER(Quarter)), {#VALUE!},
        NOT(ISNUMBER(DayOfQuarter)), {#VALUE!},
        NOT(IS_INTEGER(Quarter)), {#NUM!},
        TRUE, LET(
            _monthOffset, ROUND(N(MonthOffset), 0),
            IF((_monthOffset < -6) + (_monthOffset > 3), {#NUM!},
                LET(
                    _fiscalYearCE, INT(FiscalYearCE),
                    _quarter, INT(Quarter),
                    _shiftMonth, (_quarter - 1) * 3 + _monthOffset,
                    _yearCE, _fiscalYearCE + INT(_shiftMonth / 12),
                    _month, MOD(_shiftMonth, 12) + 1,
                    _MJDNQuarter, MODIFIED_JULIAN_DAY_NUMBER(_yearCE, _month, 1, JulianCalendar) - 1,
                    _MJDNQuarter + INT(DayOfQuarter) + N(Time)
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
MJDATE_TO_QUARTER_DATE

Converts Modified Julian Date (MJDATE) to a date expressed as fiscal year, quarter, day of quarter and time
in the specified calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer          | FiscalYearCE
   |                  | When month offset is non-zero the fiscal year spans calendar years and
   |                  | is defined as the year where June falls.
 2 | integer [1..4]   | Quarter
 3 | integer [1..92]  | Day of quarter
 4 | decimal [0..1)   | Time of day
 5 | integer [89..92] | Days in quarter

Parameters
----------------------------------------------------------------------------------------------------------------
MJDate           | decimal         | Modified Julian Date
[MonthOffset]    | integer [-6..3] | Quarter month offset from January
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
MJDATE_TO_QUARTER_DATE = LAMBDA(MJDate, [MonthOffset], [JulianCalendar],
    IFS(
        MJDate = "", {"", "", "", "", ""},
        NOT(ISNUMBER(MJDate)), {#VALUE!, "", "", "", ""},
        TRUE, LET(
            _monthOffset, ROUND(N(MonthOffset), 0),
            IFS(
                _monthOffset < -6, {#NUM!, "", "", "", ""},
                _monthOffset > 3, {#NUM!, "", "", "", ""},
                TRUE, LET(
                    _cDate, MJDATE_TO_CALENDAR_DATE(MJDate, JulianCalendar),
                    _shiftMonth, INDEX(_cDate, 1, 2) - 1 - _monthOffset,
                    _fiscalYear, INDEX(_cDate, 1, 1) + INT(_shiftMonth / 12),
                    _zeroBasedFiscalMonth, MOD(_shiftMonth, 12),
                    _quarter, INT(_zeroBasedFiscalMonth / 3) + 1,
                    _MJDNQuarter, QUARTER_DATE_TO_MJDATE(_fiscalYear, _quarter, 1, 0, _monthOffset, JulianCalendar) - 1,
                    _dayOfQuarter, INT(MJDate - _MJDNQuarter),
                    _daysInQuarter, DAYS_IN_QUARTER(_quarter, _fiscalYear, _monthOffset, JulianCalendar),
                    HSTACK(
                        _fiscalYear,
                        _quarter,
                        _dayOfQuarter,
                        INDEX(_cDate, 1, 4),
                        _daysInQuarter
                    )
                )
            )
        )
    )
);













/*##############################################################################################################
# DELTAS                                                                                                       #
##############################################################################################################*/


/*--------------------------------------------------------------------------------------------------------------
DELTA_HOURS

Returns the timespan difference between Modified Julian Dates in hours.
Can also accept standard Julian Dates, provided types are not mixed.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Difference in hours

Parameters
----------------------------------------------------------------------------------------------------------------
MJDateStart | decimal | Starting Modified Julian Date 
MJDateEnd   | decimal | Ending Modified Julian Date
--------------------------------------------------------------------------------------------------------------*/
DELTA_HOURS = LAMBDA(MJDateStart, MJDateEnd,
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), "",
        NOT(ISNUMBER(MJDateStart)), {#VALUE!},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
        TRUE, (MJDateEnd - MJDateStart) * 24
    )
);


/*--------------------------------------------------------------------------------------------------------------
DELTA_MINUTES

Returns the timespan difference between Modified Julian Dates in minutes.
Can also accept standard Julian Dates, provided types are not mixed.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Difference in minutes

Parameters
----------------------------------------------------------------------------------------------------------------
MJDateStart | decimal | Starting Modified Julian Date 
MJDateEnd   | decimal | Ending Modified Julian Date
--------------------------------------------------------------------------------------------------------------*/
DELTA_MINUTES = LAMBDA(MJDateStart, MJDateEnd,
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), "",
        NOT(ISNUMBER(MJDateStart)), {#VALUE!},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
        TRUE, (MJDateEnd - MJDateStart) * 1440
    )
);


/*--------------------------------------------------------------------------------------------------------------
DELTA_SECONDS

Returns the timespan difference between Modified Julian Dates in seconds.
Can also accept standard Julian Dates, provided types are not mixed.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Difference in seconds

Parameters
----------------------------------------------------------------------------------------------------------------
MJDateStart | decimal | Starting Modified Julian Date 
MJDateEnd   | decimal | Ending Modified Julian Date
--------------------------------------------------------------------------------------------------------------*/
DELTA_SECONDS = LAMBDA(MJDateStart, MJDateEnd,
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), "",
        NOT(ISNUMBER(MJDateStart)), {#VALUE!},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
        TRUE, (MJDateEnd - MJDateStart) * 86400
    )
);


/*--------------------------------------------------------------------------------------------------------------
DELTA_DHMS

Returns the sexagesimal difference between Modified Julian Dates with the given lowest order component rounded
to the specified precision.
Can also accept standard Julian Dates, provided types are not mixed.

Output - LowOrder = 4 (default)
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Days
 3 | integer [0..23]  | Hours
 4 | integer [0..59]  | Minutes
 5 | decimal [0..60)  | Seconds

Output - LowOrder = 3
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Days
 3 | integer [0..23]  | Hours
 4 | decimal [0..60)  | Minutes

Output - LowOrder = 2
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Days
 3 | decimal [0..24)  | Hours

Output - LowOrder = 1
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | decimal [0..]    | Days

Parameters
----------------------------------------------------------------------------------------------------------------
MJDateStart   | decimal | Starting Modified Julian Date 
MJDateEnd     | decimal | Ending Modified Julian Date
[HighOrder]   | integer | Highest-order component. Defaults to Day.
              | [1..4]  |  1 - Day
              |         |  2 - Hour
              |         |  3 - Minute
              |         |  4 - Second
[LowOrder]    | integer | Lowest-order component. Defaults to Second.
              | [1..4]  |  1 - Day
              |         |  2 - Hour
              |         |  3 - Minute
              |         |  4 - Second
[Precision]   | integer | Select precision level
              | [0..9]  | Null - Floating
[Truncate]    | switch  | Round to precision by truncating components. Default is rounding to nearest.
--------------------------------------------------------------------------------------------------------------*/
DELTA_DHMS = LAMBDA(MJDateStart, MJDateEnd, [HighOrder], [LowOrder], [Precision], [Truncate],
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), {"","","",""},
        NOT(ISNUMBER(MJDateStart)), {#VALUE!, "", "", ""},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!, "", "", ""},
        TRUE, RESOLVE_TIMESPAN(MJDateEnd - MJDateStart, HighOrder, LowOrder, Precision, Truncate)
    )
);


/*--------------------------------------------------------------------------------------------------------------
DELTA_TIMESPAN

Returns the timespan difference between Modified Julian Dates.
Can also accept standard Julian Dates, provided types are not mixed.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Timespan difference, day = 1

Parameters
----------------------------------------------------------------------------------------------------------------
MJDateStart | decimal | Starting Modified Julian Date 
MJDateEnd   | decimal | Ending Modified Julian Date
--------------------------------------------------------------------------------------------------------------*/
DELTA_TIMESPAN = LAMBDA(MJDateStart, MJDateEnd,
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), "",
        NOT(ISNUMBER(MJDateStart)), {#VALUE!},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
        TRUE, (MJDateEnd - MJDateStart)
    )
);


/*--------------------------------------------------------------------------------------------------------------
DELTA_WEEKS

Returns the timespan difference between Modified Julian Dates in weeks.
Can also accept standard Julian Dates, provided types are not mixed.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Difference in weeks

Parameters
----------------------------------------------------------------------------------------------------------------
MJDateStart | decimal | Starting Modified Julian Date 
MJDateEnd   | decimal | Ending Modified Julian Date
--------------------------------------------------------------------------------------------------------------*/
DELTA_WEEKS = LAMBDA(MJDateStart, MJDateEnd,
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), "",
        NOT(ISNUMBER(MJDateStart)), {#VALUE!},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
        TRUE, (MJDateEnd - MJDateStart) / 7
    )
);


/*--------------------------------------------------------------------------------------------------------------
DELTA_MONTHS

Returns the timespan difference between Modified Julian Dates in months.
Where the difference includes partial months, the fraction is calculated on the basis of days in the month
of the calendar. If the Modified Julian Dates are expressed in UTC rather than local time then a small margin
of error will be introduced due to the bounds of calendar days.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Difference in months

Parameters
----------------------------------------------------------------------------------------------------------------
MJDateStart      | decimal | Starting Modified Julian Date 
MJDateEnd        | decimal | Ending Modified Julian Date
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
DELTA_MONTHS = LAMBDA(MJDateStart, MJDateEnd, [JulianCalendar],
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), "",
        NOT(ISNUMBER(MJDateStart)), {#VALUE!},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
        TRUE, IF(MJDateStart = MJDateEnd, 0,
            LET(
                _sign, IF(MJDateEnd >= MJDateStart, 1, -1),
                _date_A, MJDATE_TO_CALENDAR_DATE(
                    IF(_sign = 1, MJDateStart, MJDateEnd),
                    JulianCalendar
                ),
                _date_B, MJDATE_TO_CALENDAR_DATE(
                    IF(_sign = 1, MJDateEnd, MJDateStart),
                    JulianCalendar
                ),
                _deltaYear, INDEX(_date_B, 1, 1) - INDEX(_date_A, 1, 1),
                _deltaMonth, INDEX(_date_B, 1, 2) - INDEX(_date_A, 1, 2),
                _diffMonths, (_deltaYear * 12) + _deltaMonth,
                _daysMonth_A, DAYS_IN_MONTH(INDEX(_date_A, 1, 2), INDEX(_date_A, 1, 1), JulianCalendar),
                _daysMonth_B, DAYS_IN_MONTH(INDEX(_date_B, 1, 2), INDEX(_date_B, 1, 1), JulianCalendar),
                _partialMonth_A, (INDEX(_date_A, 1, 3) - 1 + INDEX(_date_A, 1, 4)) / _daysMonth_A,
                _partialMonth_B, (INDEX(_date_B, 1, 3) - 1 + INDEX(_date_B, 1, 4)) / _daysMonth_B,
                _sign * (_diffMonths - _partialMonth_A + _partialMonth_B)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
DELTA_QUARTERS

Returns the timespan difference between Modified Julian Dates in quarters.
Where the difference includes partial quarters, the fraction is calculated on the basis of days in the
quarter of the calendar. If the Modified Julian Dates are expressed in UTC rather than local time then a
small margin of error will be introduced due to the bounds of calendar days.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Difference in quarters

Parameters
----------------------------------------------------------------------------------------------------------------
MJDateStart      | decimal         | Starting Modified Julian Date 
MJDateEnd        | decimal         | Ending Modified Julian Date
[MonthOffset]    | integer [-6..3] | Quarter month offset from January.
[JulianCalendar] | switch          | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
DELTA_QUARTERS = LAMBDA(MJDateStart, MJDateEnd, [MonthOffset], [JulianCalendar],
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), "",
        NOT(ISNUMBER(MJDateStart)), {#VALUE!},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
        TRUE, LET(
            _monthOffset, ROUND(N(MonthOffset), 0),
            IFS(
                _monthOffset < -6, {#NUM!},
                _monthOffset > 3, {#NUM!},
                MJDateStart = MJDateEnd, 0,
                TRUE, LET(
                    _sign, IF(MJDateEnd >= MJDateStart, 1, -1),
                    _quarterDate_A, MJDATE_TO_QUARTER_DATE(
                        IF(_sign = 1, MJDateStart, MJDateEnd),
                        _monthOffset, JulianCalendar
                    ),
                    _quarterDate_B, MJDATE_TO_QUARTER_DATE(
                        IF(_sign = 1, MJDateEnd, MJDateStart),
                        _monthOffset, JulianCalendar
                    ),
                    _deltaYear, INDEX(_quarterDate_B, 1, 1) - INDEX(_quarterDate_A, 1, 1),
                    _deltaQuarter, INDEX(_quarterDate_B, 1, 2) - INDEX(_quarterDate_A, 1, 2),
                    _diffQuarters, (_deltaYear * 4) + _deltaQuarter,
                    _partialQuarter_A, (INDEX(_quarterDate_A, 1, 3) - 1 + INDEX(_quarterDate_A, 1, 4)) / INDEX(_quarterDate_A, 1, 5),
                    _partialQuarter_B, (INDEX(_quarterDate_B, 1, 3) - 1 + INDEX(_quarterDate_B, 1, 4)) / INDEX(_quarterDate_B, 1, 5),
                    _sign * (_diffQuarters - _partialQuarter_A + _partialQuarter_B)
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
DELTA_YEARS

Returns the timespan difference between Modified Julian Dates in years.
Where the difference includes partial years, the fraction is calculated on the basis of days in the
year of the calendar. If the Modified Julian Dates are expressed in UTC rather than local time then a
small margin of error will be introduced due to the bounds of calendar days.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Difference in years

Parameters
----------------------------------------------------------------------------------------------------------------
MJDateStart      | decimal | Starting Modified Julian Date 
MJDateEnd        | decimal | Ending Modified Julian Date
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
DELTA_YEARS = LAMBDA(MJDateStart, MJDateEnd, [JulianCalendar],
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), "",
        NOT(ISNUMBER(MJDateStart)), {#VALUE!},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
        MJDateStart = MJDateEnd, 0,
        TRUE, LET(
            _sign, IF(MJDateEnd >= MJDateStart, 1, -1),
            _ordinalDate_A, MJDATE_TO_ORDINAL_DATE(
                IF(_sign = 1, MJDateStart, MJDateEnd),
                JulianCalendar
            ),
            _ordinalDate_B, MJDATE_TO_ORDINAL_DATE(
                IF(_sign = 1, MJDateEnd, MJDateStart),
                JulianCalendar
            ),
            _deltaYear, INDEX(_ordinalDate_B, 1, 1) - INDEX(_ordinalDate_A, 1, 1),
            _partialYear_A, (INDEX(_ordinalDate_A, 1, 2) - 1 + INDEX(_ordinalDate_A, 1, 3)) / INDEX(_ordinalDate_A, 1, 4),
            _partialYear_B, (INDEX(_ordinalDate_B, 1, 2) - 1 + INDEX(_ordinalDate_B, 1, 3)) / INDEX(_ordinalDate_B, 1, 4),
            _sign * (_deltaYear - _partialYear_A + _partialYear_B)
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
DELTA_WEEK_DAYS

Returns the timespan difference between Modified Julian Dates in weeks and days.
Can also accept standard Julian Dates, provided types are not mixed.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Delta weeks 
 3 | integer [0..6]   | Delta days
 4 | decimal [0..1)   | Delta time

Parameters
----------------------------------------------------------------------------------------------------------------
MJDateStart | decimal | Starting Modified Julian Date 
MJDateEnd   | decimal | Ending Modified Julian Date
--------------------------------------------------------------------------------------------------------------*/
DELTA_WEEK_DAYS = LAMBDA(MJDateStart, MJDateEnd,
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), {"", "", "", ""},
        NOT(ISNUMBER(MJDateStart)), {#VALUE!, "", "", ""},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!, "", "", ""},
        TRUE, LET(
            _diffDays, (MJDateEnd - MJDateStart),
            IF(_diffDays = 0, {0, 0, 0, 0},
                LET(
                    _sign, IF(_diffDays >= 0, 1, -1),
                    _absDiffDays, _sign * _diffDays,
                    _deltaWeek, INT(_absDiffDays / 7),
                    _remDays, _absDiffDays - _deltaWeek * 7,
                    _deltaDay, INT(_remDays),
                    _deltaTime, _remDays - _deltaDay,
                    HSTACK(
                        _sign,
                        _deltaWeek,
                        _deltaDay,
                        _deltaTime
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
DELTA_YEAR_WEEK_DAYS

Returns the timespan difference between Modified Julian Dates in years, weeks, and days.
Note the number of weeks per year can vary between 52 and 53. If an absolute number of weeks is being sought
then use either DELTA_WEEK_DAYS or DELTA_WEEKS functions. If the Modified Julian Dates are expressed in UTC
rather than local time then a small margin of error will be introduced due to the bounds of calendar days.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Delta years
 3 | integer [0..52]  | Delta weeks 
 4 | decimal [0..6]   | Delta days
 5 | decimal [0..1)   | Delta time

Parameters
----------------------------------------------------------------------------------------------------------------
MJDateStart      | decimal | Starting Modified Julian Date 
MJDateEnd        | decimal | Ending Modified Julian Date
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
DELTA_YEAR_WEEK_DAYS = LAMBDA(MJDateStart, MJDateEnd, [JulianCalendar],
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), {"", "", "", "", ""},
        NOT(ISNUMBER(MJDateStart)), {#VALUE!, "", "", "", ""},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!, "", "", "", ""},
        MJDateStart = MJDateEnd, {0, 0, 0, 0, 0},
        TRUE, LET(
            _sign, IF(MJDateEnd >= MJDateStart, 1, -1),
            _weekDate_A, MJDATE_TO_WEEK_DATE(
                IF(_sign = 1, MJDateStart, MJDateEnd),
                JulianCalendar
            ),
            _weekDate_B, MJDATE_TO_WEEK_DATE(
                IF(_sign = 1, MJDateEnd, MJDateStart),
                JulianCalendar
            ),
            _deltaYear, INDEX(_weekDate_B, 1, 1) - INDEX(_weekDate_A, 1, 1),
            _deltaWeek, INDEX(_weekDate_B, 1, 2) - INDEX(_weekDate_A, 1, 2),
            _diffDays, INDEX(_weekDate_B, 1, 3) - INDEX(_weekDate_A, 1, 3)
                + INDEX(_weekDate_B, 1, 4) - INDEX(_weekDate_A, 1, 4),
            _carryWeek, INT(_diffDays / 7),
            _remDays, _diffDays - _carryWeek * 7,
            _deltaWeek2, _deltaWeek + _carryWeek,
            _deltaDay, INT(_remDays),
            _deltaTime, _remDays - _deltaDay,
            IF(_deltaWeek2 >= 0,
                HSTACK(
                    _sign,
                    _deltaYear,
                    _deltaWeek2,
                    _deltaDay,
                    _deltaTime
                ),
                HSTACK(
                    _sign,
                    _deltaYear - 1,
                    _deltaWeek2 + INDEX(_weekDate_A, 1, 5),
                    _deltaDay,
                    _deltaTime
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
DELTA_MONTH_DAYS

Returns the timespan difference between Modified Julian Dates in months and days.
If the Modified Julian Dates are expressed in UTC rather than local time then a small margin of error will
be introduced due to the bounds of calendar days.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Delta months
 3 | integer [0..30]  | Delta days
 4 | decimal [0..1)   | Delta time

Parameters
----------------------------------------------------------------------------------------------------------------
MJDateStart      | decimal | Starting Modified Julian Date 
MJDateEnd        | decimal | Ending Modified Julian Date
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
DELTA_MONTH_DAYS = LAMBDA(MJDateStart, MJDateEnd, [JulianCalendar],
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), {"", "", "", ""},
        NOT(ISNUMBER(MJDateStart)), {#VALUE!, "", "", ""},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!, "", "", ""},
        MJDateStart = MJDateEnd, {0, 0, 0, 0},
        TRUE, LET(
            _sign, IF(MJDateEnd >= MJDateStart, 1, -1),
            _date_A, MJDATE_TO_CALENDAR_DATE(
                IF(_sign = 1, MJDateStart, MJDateEnd),
                JulianCalendar
            ),
            _date_B, MJDATE_TO_CALENDAR_DATE(
                IF(_sign = 1, MJDateEnd, MJDateStart),
                JulianCalendar
            ),
            _deltaYear, INDEX(_date_B, 1, 1) - INDEX(_date_A, 1, 1),
            _deltaMonth, INDEX(_date_B, 1, 2) - INDEX(_date_A, 1, 2),
            _diffMonths, (_deltaYear * 12) + _deltaMonth,
            _diffDays, INDEX(_date_B, 1, 3) - INDEX(_date_A, 1, 3)
                + INDEX(_date_B, 1, 4) - INDEX(_date_A, 1, 4),
            IF(_diffDays >= 0,
                LET(
                    _deltaDay, INT(_diffDays),
                    _deltaTime, _diffDays - _deltaDay,
                    HSTACK(
                        _sign,
                        _diffMonths,
                        _deltaDay,
                        _deltaTime
                    )
                ),
                LET(
                    _daysMonth_A, DAYS_IN_MONTH(INDEX(_date_A, 1, 2), INDEX(_date_A, 1, 1), JulianCalendar),
                    _diffDays2, _diffDays + _daysMonth_A,  
                    _deltaDay, INT(_diffDays2),
                    _deltaTime, _diffDays2 - _deltaDay,
                    HSTACK(
                        _sign,
                        _diffMonths - 1,
                        _deltaDay,
                        _deltaTime
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
DELTA_QUARTER_DAYS

Returns the timespan difference between Modified Julian Dates in quarters and days.
If the Modified Julian Dates are expressed in UTC rather than local time then a small margin of error will
be introduced due to the bounds of calendar days.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Delta quarters
 3 | decimal [0..92)  | Delta days

Parameters
----------------------------------------------------------------------------------------------------------------
MJDateStart      | decimal         | Starting Modified Julian Date 
MJDateEnd        | decimal         | Ending Modified Julian Date
[MonthOffset]    | integer [-6..3] | Quarter month offset from January.
[JulianCalendar] | switch          | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
DELTA_QUARTER_DAYS = LAMBDA(MJDateStart, MJDateEnd, [MonthOffset], [JulianCalendar],
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), {"", "", "", ""},
        NOT(ISNUMBER(MJDateStart)), {#VALUE!, "", "", ""},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!, "", "", ""},
        TRUE, LET(
            _monthOffset, ROUND(N(MonthOffset), 0),
            IFS(
                _monthOffset < -6, {#NUM!, "", "", ""},
                _monthOffset > 3, {#NUM!, "", "", ""},
                MJDateStart = MJDateEnd, {0, 0, 0, 0},
                TRUE, LET(
                    _sign, IF(MJDateEnd >= MJDateStart, 1, -1),
                    _quarterDate_A, MJDATE_TO_QUARTER_DATE(
                        IF(_sign = 1, MJDateStart, MJDateEnd),
                        _monthOffset, JulianCalendar
                    ),
                    _quarterDate_B, MJDATE_TO_QUARTER_DATE(
                        IF(_sign = 1, MJDateEnd, MJDateStart),
                        _monthOffset, JulianCalendar
                    ),
                    _deltaYear, INDEX(_quarterDate_B, 1, 1) - INDEX(_quarterDate_A, 1, 1),
                    _deltaQuarter, INDEX(_quarterDate_B, 1, 2) - INDEX(_quarterDate_A, 1, 2),
                    _diffQuarters, (_deltaYear * 4) + _deltaQuarter,
                    _diffDays, INDEX(_quarterDate_B, 1, 3) - INDEX(_quarterDate_A, 1, 3)
                        + INDEX(_quarterDate_B, 1, 4) - INDEX(_quarterDate_A, 1, 4),
                    IF(_diffDays >= 0,
                        LET(
                            _deltaDay, INT(_diffDays),
                            _deltaTime, _diffDays - _deltaDay,
                            HSTACK(
                                _sign,
                                _diffQuarters,
                                _deltaDay,
                                _deltaTime
                            )
                        ),
                        LET(
                            _diffDays2, _diffDays + INDEX(_quarterDate_A, 1, 5),
                            _deltaDay, INT(_diffDays2),
                            _deltaTime, _diffDays2 - _deltaDay,
                            HSTACK(
                                _sign,
                                _diffQuarters - 1,
                                _deltaDay,
                                _deltaTime
                            )
                        )
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
DELTA_INTERVAL

Returns the timespan difference between Modified Julian Dates in the specified units.

Output where Units = H, N, S, D, W, M, Q, Y
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Delta units decimal

Output where Units = HMS
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Delta hours
 3 | integer [0..59]  | Delta minutes
 4 | decimal [0..60)  | Delta seconds

Output where Units = DHMS
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Delta days
 3 | integer [0..23]  | Delta hours
 4 | integer [0..59]  | Delta minutes
 5 | decimal [0..60)  | Delta seconds

Output where Units = WD, MD, QD
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1]     | Sign
 2 | integer [0..]        | Delta weeks/months/quarters
 3 | integer [0..6/30/91] | Delta days
 4 | decimal [0..1)       | Delta time

Output where Units = YWD, YMD, YQD
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1]     | Sign
 2 | integer [0..]        | Delta years
 3 | integer [0..52/12/4] | Delta weeks/months/quarters
 4 | integer [0..6/30/91] | Delta days
 5 | decimal [0..1)       | Delta time

Output where Units = YMDHMS
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Delta years
 3 | integer [0..12]  | Delta months
 4 | integer [0..30]  | Delta days
 5 | integer [0..23]  | Delta hours
 6 | integer [0..59]  | Delta minutes
 7 | decimal [0..60)  | Delta seconds

Parameters
----------------------------------------------------------------------------------------------------------------
Units            | text            |      H - hours decimal
                 |                 |      N - minutes decimal
                 |                 |      S - seconds decimal
                 |                 |      T - timespan decimal
                 |                 |      W - weeks decimal
                 |                 |      M - months decimal
                 |                 |      Q - quarters decimal
                 |                 |      Y - years decimal
                 |                 |    HMS - hours, minutes, seconds
                 |                 |   DHMS - days, hours, minutes, seconds
                 |                 |     WD - weeks and days
                 |                 |     MD - months and days
                 |                 |     QD - quarters and days
                 |                 |    YWD - years, weeks, days
                 |                 |    YMD - years, months, days
                 |                 |    YQD - years, quarters, days
                 |                 | YMDHMS - years, months, days, hours, minutes, seconds
MJDateStart      | decimal         | Starting Modified Julian Date 
MJDateEnd        | decimal         | Ending Modified Julian Date
[MonthOffset]    | integer [-6..3] | Quarter month offset from January.
[JulianCalendar] | switch          | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
DELTA_INTERVAL = LAMBDA(Units, MJDateStart, MJDateEnd, [MonthOffset], [JulianCalendar],
    IFS(
        Units = "", {#VALUE!},
        Units = "H", DELTA_HOURS(MJDateStart, MJDateEnd),
        Units = "N", DELTA_MINUTES(MJDateStart, MJDateEnd),
        Units = "S", DELTA_SECONDS(MJDateStart, MJDateEnd),
        Units = "DHMS", DELTA_DHMS(MJDateStart, MJDateEnd, 4),
        Units = "T", DELTA_TIMESPAN(MJDateStart, MJDateEnd),
        Units = "W", DELTA_WEEKS(MJDateStart, MJDateEnd),
        Units = "M", DELTA_MONTHS(MJDateStart, MJDateEnd, JulianCalendar),
        Units = "Q", DELTA_QUARTERS(MJDateStart, MJDateEnd, MonthOffset, JulianCalendar),
        Units = "Y", DELTA_YEARS(MJDateStart, MJDateEnd, JulianCalendar),
        Units = "WD", DELTA_WEEK_DAYS(MJDateStart, MJDateEnd),
        Units = "YWD", DELTA_YEAR_WEEK_DAYS(MJDateStart, MJDateEnd, JulianCalendar),
        Units = "MD", DELTA_MONTH_DAYS(MJDateStart, MJDateEnd, JulianCalendar),
        Units = "QD", DELTA_QUARTER_DAYS(MJDateStart, MJDateEnd, MonthOffset, JulianCalendar),
        Units = "HMS", LET(
                _dhms, DELTA_DHMS(MJDateStart, MJDateEnd, 4),
                _hours, INDEX(_dhms, 1, 3) + (24 * INDEX(_dhms, 1, 2)),
                HSTACK(
                    INDEX(_dhms, 1, 1),
                    _hours,
                    INDEX(_dhms, 1, 4),
                    INDEX(_dhms, 1, 5)
                )
            ),
        Units = "YMD", LET(
                _monthDays, DELTA_MONTH_DAYS(MJDateStart, MJDateEnd, JulianCalendar),
                _years, INT(INDEX(_monthDays, 1, 2) / 12),
                _months, INDEX(_monthDays, 1, 2) - _years * 12,
                HSTACK(
                    INDEX(_monthDays, 1, 1),
                    _years,
                    _months,
                    INDEX(_monthDays, 1, 3),
                    INDEX(_monthDays, 1, 4)
                )
            ),
        Units = "YQD", LET(
                _quarterDays, DELTA_QUARTER_DAYS(MJDateStart, MJDateEnd, MonthOffset, JulianCalendar),
                _years, INT(INDEX(_quarterDays, 1, 2) / 4),
                _quarters, INDEX(_quarterDays, 1, 2) - _years * 4,
                HSTACK(
                    INDEX(_quarterDays, 1, 1),
                    _years,
                    _quarters,
                    INDEX(_quarterDays, 1, 3),
                    INDEX(_quarterDays, 1, 4)
                )
            ),
        Units = "YMDHMS", LET(
                _monthDays, DELTA_MONTH_DAYS(MJDateStart, MJDateEnd, JulianCalendar),
                _years, INT(INDEX(_monthDays, 1, 2) / 12),
                _months, INDEX(_monthDays, 1, 2) - _years * 12,
                _hms, RESOLVE_TIMESPAN(INDEX(_monthDays, 1, 4), 1, 4, 0, 1),
                _carryDay, INDEX(_hms, 1, 2),
                HSTACK(
                    INDEX(_monthDays, 1, 1),
                    _years,
                    _months,
                    INDEX(_monthDays, 1, 3) + _carryDay,
                    CHOOSECOLS(_hms, {3,4,5})
                )
            ),
        TRUE, {#VALUE!}
    )
);













/*##############################################################################################################
# EXTENTS                                                                                                      #
##############################################################################################################*/


/*--------------------------------------------------------------------------------------------------------------
EXTENT_OF_DAYS

Returns the inclusive extent of days spanned by two Modified Julian Dates expressed in local time.
If the Modified Julian Dates are expressed in UTC rather than local time then inconsistent results may be
produced due to the bounds of calendar days.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Extent of days

Parameters
----------------------------------------------------------------------------------------------------------------
LocalMJDateStart | decimal | Starting Modified Julian Date in local time 
LocalMJDateEnd   | decimal | Ending Modified Julian Date in local time

Examples
----------------------------------------------------------------------------------------------------------------
EXTENT_DAYS(MODIFIED_JULIAN_DATE(2023,1,1,TIME(23,59,55)), MODIFIED_JULIAN_DATE(2023,1,2,TIME(0,0,5)))
= 2  i.e. 2 days because the 10 second timespan crosses the day boundary
--------------------------------------------------------------------------------------------------------------*/
EXTENT_OF_DAYS = LAMBDA(LocalMJDateStart, LocalMJDateEnd,
    IFS(
        IS_EMPTY(LocalMJDateStart) * IS_EMPTY(LocalMJDateEnd), "",
        NOT(ISNUMBER(LocalMJDateStart)), {#VALUE!},
        NOT(ISNUMBER(LocalMJDateEnd)), {#VALUE!},
        TRUE, LET(
            _sign, IF(LocalMJDateEnd >= LocalMJDateStart, 1, -1),
            _deltaDay, INT(LocalMJDateEnd) - INT(LocalMJDateStart),
            _sign * (ABS(_deltaDay) + 1)
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
EXTENT_OF_WEEKS

Returns the inclusive extent of weeks spanned by two Modified Julian Dates expressed in local time.
If the Modified Julian Dates are expressed in UTC rather than local time then inconsistent results may be
produced due to the bounds of calendar days.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Extent of weeks

Parameters
----------------------------------------------------------------------------------------------------------------
LocalMJDateStart | decimal | Starting Modified Julian Date in local time 
LocalMJDateEnd   | decimal | Ending Modified Julian Date in local time

Examples
----------------------------------------------------------------------------------------------------------------
EXTENT_WEEKS(MODIFIED_JULIAN_DATE(2023,6,4,TIME(23,59,55)), MODIFIED_JULIAN_DATE(2023,6,5,TIME(0,0,5)))
= 2  i.e. 2 weeks because the 10 second timespan crosses the week boundary
--------------------------------------------------------------------------------------------------------------*/
EXTENT_OF_WEEKS = LAMBDA(LocalMJDateStart, LocalMJDateEnd,
    IFS(
        IS_EMPTY(LocalMJDateStart) * IS_EMPTY(LocalMJDateEnd), "",
        NOT(ISNUMBER(LocalMJDateStart)), {#VALUE!},
        NOT(ISNUMBER(LocalMJDateEnd)), {#VALUE!},
        TRUE, LET(
            _sign, IF(LocalMJDateEnd >= LocalMJDateStart, 1, -1),
            _startMonday, INT(LocalMJDateStart) + 1 - DAY_OF_WEEK(LocalMJDateStart),
            _endMonday, INT(LocalMJDateEnd) + 1 - DAY_OF_WEEK(LocalMJDateEnd),
            _sign * (INT(ABS(_endMonday - _startMonday) / 7) + 1)
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
EXTENT_OF_MONTHS

Returns the inclusive extent of months spanned by two Modified Julian Dates expressed in local time.
If the Modified Julian Dates are expressed in UTC rather than local time then inconsistent results may be
produced due to the bounds of calendar days.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Extent of months

Parameters
----------------------------------------------------------------------------------------------------------------
LocalMJDateStart | decimal | Starting Modified Julian Date in local time 
LocalMJDateEnd   | decimal | Ending Modified Julian Date in local time
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
EXTENT_OF_MONTHS = LAMBDA(LocalMJDateStart, LocalMJDateEnd, [JulianCalendar],
    IFS(
        IS_EMPTY(LocalMJDateStart) * IS_EMPTY(LocalMJDateEnd), "",
        NOT(ISNUMBER(LocalMJDateStart)), {#VALUE!},
        NOT(ISNUMBER(LocalMJDateEnd)), {#VALUE!},
        TRUE, LET(
            _sign, IF(LocalMJDateEnd >= LocalMJDateStart, 1, -1),
            _date_A, MJDATE_TO_CALENDAR_DATE(
                IF(_sign = 1, LocalMJDateStart, LocalMJDateEnd),
                JulianCalendar
            ),
            _date_B, MJDATE_TO_CALENDAR_DATE(
                IF(_sign = 1, LocalMJDateEnd, LocalMJDateStart),
                JulianCalendar
            ),
            _deltaYear, INDEX(_date_B, 1, 1) - INDEX(_date_A, 1, 1),
            _deltaMonth, INDEX(_date_B, 1, 2) - INDEX(_date_A, 1, 2),
            _diffMonths, (_deltaYear * 12) + _deltaMonth,
            _sign * (_diffMonths + 1)
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
EXTENT_OF_QUARTERS

Returns the inclusive extent of quarters spanned by two Modified Julian Dates expressed in local time.
If the Modified Julian Dates are expressed in UTC rather than local time then inconsistent results may be
produced due to the bounds of calendar days.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Extent of quarters

Parameters
----------------------------------------------------------------------------------------------------------------
LocalMJDateStart | decimal         | Starting Modified Julian Date in local time 
LocalMJDateEnd   | decimal         | Ending Modified Julian Date in local time
[MonthOffset]    | integer [-6..3] | Quarter month offset from January.
[JulianCalendar] | switch          | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
EXTENT_OF_QUARTERS = LAMBDA(LocalMJDateStart, LocalMJDateEnd, [MonthOffset], [JulianCalendar],
    IFS(
        IS_EMPTY(LocalMJDateStart) * IS_EMPTY(LocalMJDateEnd), "",
        NOT(ISNUMBER(LocalMJDateStart)), {#VALUE!},
        NOT(ISNUMBER(LocalMJDateEnd)), {#VALUE!},
        TRUE, LET(
            _monthOffset, ROUND(N(MonthOffset), 0),
            IFS(
                _monthOffset < -6, {#NUM!},
                _monthOffset > 3, {#NUM!},
                TRUE, LET(
                    _sign, IF(LocalMJDateEnd >= LocalMJDateStart, 1, -1),
                    _quarterDate_A, MJDATE_TO_QUARTER_DATE(
                        IF(_sign = 1, LocalMJDateStart, LocalMJDateEnd),
                        _monthOffset, JulianCalendar
                    ),
                    _quarterDate_B, MJDATE_TO_QUARTER_DATE(
                        IF(_sign = 1, LocalMJDateEnd, LocalMJDateStart),
                        _monthOffset, JulianCalendar
                    ),
                    _deltaYear, INDEX(_quarterDate_B, 1, 1) - INDEX(_quarterDate_A, 1, 1),
                    _deltaQuarter, INDEX(_quarterDate_B, 1, 2) - INDEX(_quarterDate_A, 1, 2),
                    _diffQuarters, (_deltaYear * 4) + _deltaQuarter,
                    _sign * (_diffQuarters + 1)
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
EXTENT_OF_YEARS

Returns the inclusive extent of years spanned by two Modified Julian Dates expressed in local time.
If the Modified Julian Dates are expressed in UTC rather than local time then inconsistent results may be
produced due to the bounds of calendar days.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Extent of quarters

Parameters
----------------------------------------------------------------------------------------------------------------
LocalMJDateStart | decimal | Starting Modified Julian Date in local time 
LocalMJDateEnd   | decimal | Ending Modified Julian Date in local time
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
EXTENT_OF_YEARS = LAMBDA(LocalMJDateStart, LocalMJDateEnd, [JulianCalendar],
    IFS(
        IS_EMPTY(LocalMJDateStart) * IS_EMPTY(LocalMJDateEnd), "",
        NOT(ISNUMBER(LocalMJDateStart)), {#VALUE!},
        NOT(ISNUMBER(LocalMJDateEnd)), {#VALUE!},
        TRUE, LET(
            _sign, IF(LocalMJDateEnd >= LocalMJDateStart, 1, -1),
            _date_A, MJDATE_TO_CALENDAR_DATE(
                IF(_sign = 1, LocalMJDateStart, LocalMJDateEnd),
                JulianCalendar
            ),
            _date_B, MJDATE_TO_CALENDAR_DATE(
                IF(_sign = 1, LocalMJDateEnd, LocalMJDateStart),
                JulianCalendar
            ),
            _deltaYear, INDEX(_date_B, 1, 1) - INDEX(_date_A, 1, 1),
            _sign * (_deltaYear + 1)
        )
    )
);















/*##############################################################################################################
# CONVERSIONS                                                                                                  #
##############################################################################################################*/


/*--------------------------------------------------------------------------------------------------------------
TIMESPAN_TO_EXCELTIME

Converts a TimeSpan to an Excel Date/Time.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1]     | Sign
 2 | decimal [0..2958466) | Excel Date/Time.

Parameters
----------------------------------------------------------------------------------------------------------------
TimeSpan | decimal |
--------------------------------------------------------------------------------------------------------------*/
TIMESPAN_TO_EXCELTIME = LAMBDA(TimeSpan,
    IFS(
        IS_EMPTY(TimeSpan), {"", ""},
        NOT(ISNUMBER(TimeSpan)), {#VALUE!, ""},
        TRUE, LET(
            _absTimeSpan, ABS(TimeSpan),
            _sign, SIGN(TimeSpan),
            IF(_absTimeSpan >= 2958466,
                HSTACK(_sign, {#NUM!}),
                HSTACK(_sign, _absTimeSpan)
            )
        )
    )
);

/*--------------------------------------------------------------------------------------------------------------
EXCELTIME_TO_TIMESPAN

Converts an Excel Date/Time to a TimeSpan.

Output
----------------------------------------------------------------------------------------------------------------
 1 | TimeSpan | decimal |

Parameters
----------------------------------------------------------------------------------------------------------------
Sign      | integer [-1,0,1]     |
ExcelTime | decimal [0..2958466) | Excel Date/Time.
--------------------------------------------------------------------------------------------------------------*/
EXCELTIME_TO_TIMESPAN = LAMBDA(Sign, ExcelTime,
    IFS(
        IS_EMPTY(ExcelTime), "",
        NOT(ISNUMBER(ExcelTime)), {#VALUE!},
        TRUE, LET(
            _sign, IFS(
                NOT(ISNUMBER(Sign)), 1,
                Sign < 0, -1, 
                TRUE, 1
            ),
            _sign * ExcelTime
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
MJDATE_TO_EXCELDATE

Converts a Modified Julian Date to an Excel Date/Time.
Note Excel Date/Time uses the Gregorian calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal         | Excel Date/Time.
   | [1..2958466)    | 1900-01-01..9999-12-31

Parameters
----------------------------------------------------------------------------------------------------------------
MJDate  | decimal          | Modified Julian Date
        | [15019..2973484) |
--------------------------------------------------------------------------------------------------------------*/
MJDATE_TO_EXCELDATE = LAMBDA(MJDate,
    IFS(
        IS_EMPTY(MJDate), "",
        NOT(ISNUMBER(MJDate)), {#VALUE!},
        MJDate < 15019, {#NUM!},
        MJDate >= 2973484, {#NUM!}, 
        TRUE, MJDate - 15018
    )
);


/*--------------------------------------------------------------------------------------------------------------
EXCELDATE_TO_MJDATE

Converts an Excel Date/Time to a Modified Julian Date.
Note Excel Date/Time uses the Gregorian calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal          | Modified Julian Date.
   | [15019..2973484) |

Parameters
----------------------------------------------------------------------------------------------------------------
ExcelDate | decimal      | Excel Date/Time
          | [1..2958466) | 1900-01-01..9999-12-31
--------------------------------------------------------------------------------------------------------------*/
EXCELDATE_TO_MJDATE = LAMBDA(ExcelDate,
    IFS(
        IS_EMPTY(ExcelDate), "", 
        NOT(ISNUMBER(ExcelDate)), {#VALUE!},
        TRUE, ExcelDate + 15018
    )
);


/*--------------------------------------------------------------------------------------------------------------
USDATE_TO_EXCELDATE

Converts a US format date to an Excel Date/Time.
Note Excel Date/Time uses the Gregorian calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Excel Date/Time.

Parameters
----------------------------------------------------------------------------------------------------------------
USDate | text | Date in US format ie. MM/dd/yyyy hh:mm:ss
--------------------------------------------------------------------------------------------------------------*/
USDATE_TO_EXCELDATE = LAMBDA(USDate,
    IF(IS_EMPTY(USDate), "",
        LET(
            _USDate, PARSE_US_DATE(USDate),
            _time, N(INDEX(_USDate, 1, 4)),
            _year, INDEX(_USDate, 1, 1),
            _excelDate, IF(IS_EMPTY(_year), 0,
                DATE(_year, INDEX(_USDate, 1, 2), INDEX(_USDate, 1, 3))
            ),
            _excelDate + _time
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
EXCELDATE_TO_USDATE

Converts an Excel Date/Time to a US format date.
Note Excel Date/Time uses the Gregorian calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | US format date and time

Parameters
----------------------------------------------------------------------------------------------------------------
ExcelDate | decimal | Excel Date/Time.
[Options] | text    | String with elements: [<][LowOrder][DateSeparator][TimeSeparator]
          |         |      LowOrder : low order component to display
          |         |          Null : Defaults to minutes if time present, otherwise day
          |         |             D : Day
          |         |             H : Hour
          |         |             M : Minute
          |         |             S : Second
          |         |             T : Millisecond (ticks)
          |         |             < : Round by truncating components. Default is rounding to nearest.
          |         | DateSeparator : Character to separate date components. [,./-_]
          |         | TimeSeparator : Character to separate time components. [,.:-_]
--------------------------------------------------------------------------------------------------------------*/
EXCELDATE_TO_USDATE = LAMBDA(ExcelDate, [Options],
    IFS(
        IS_EMPTY(ExcelDate), "",
        NOT(ISNUMBER(ExcelDate)), {#VALUE!},
        ExcelDate <= 1, FORMAT_US_DATE("", "", "", ExcelDate, Options, 0),
        TRUE, LET(
            _yearCE, YEAR(ExcelDate),
            _month, MONTH(ExcelDate),
            _day, DAY(ExcelDate),
            _time, ExcelDate - INT(ExcelDate),
            FORMAT_US_DATE(_yearCE, _month, _day, _time, Options, 0)
        )
    )
);



/*--------------------------------------------------------------------------------------------------------------
ISO_DATETIME_TO_EXCELDATE

Converts an ISO formatted date and time to an Excel Date/Time and time zone offset.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal         | Excel Date/Time.
 2 | decimal         | Time zone offset from UTC as decimal fraction of a day.
   | [-0.625..0.625] | -15:00..+15:00

Parameters
----------------------------------------------------------------------------------------------------------------
ISODateTime        | text   | Date, time and time zone offset in ISO format
[AllowMixedStyles] | switch | Relax validation for no mixing of basic and extended formats. eg. yyyyMMddThh:mm
--------------------------------------------------------------------------------------------------------------*/
ISO_DATETIME_TO_EXCELDATE = LAMBDA(ISODateTime, [AllowMixedStyles],
    IF(IS_EMPTY(ISODateTime), {"", ""},
        LET(
            _isoDateTime, PARSE_ISO_DATETIME(ISODateTime, AllowMixedStyles),
            IFS(
                ISERROR(INDEX(_isoDateTime, 1, 1)), HSTACK({#VALUE!}, INDEX(_isoDateTime, 1, 5)),
                ISERROR(INDEX(_isoDateTime, 1, 4)), HSTACK({#VALUE!}, INDEX(_isoDateTime, 1, 5)),
                IS_EMPTY(INDEX(_isoDateTime, 1, 1)), HSTACK(INDEX(_isoDateTime, 1, 4), INDEX(_isoDateTime, 1, 5)),
                TRUE, LET(
                    _date, DATE(
                        INDEX(_isoDateTime, 1, 1),
                        INDEX(_isoDateTime, 1, 2),
                        INDEX(_isoDateTime, 1, 3)
                    ),
                    HSTACK(_date + N(INDEX(_isoDateTime, 1, 4)), INDEX(_isoDateTime, 1, 5))
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
EXCELDATE_TO_ISO_DATETIME

Converts an Excel Date/Time and time zone offset to an ISO formatted date and time.

Output
----------------------------------------------------------------------------------------------------------------
 1 | text  | ISO formated date and time

Parameters
----------------------------------------------------------------------------------------------------------------
ExcelDate    | decimal     | Excel Date/Time.
[TZOMinutes] | decimal     | Time zone offset from UTC in minutes
             | [-900..900] | Assumed to be UTC if ommitted. [-15:00..+15:00]
[Options]    | text        | String with elements: [B][<][LowOrder][Precision][Z]
             |             |        B : Display in basic format eg T0000
             |             |        < : Round by truncating components. Default is rounding to nearest.
             |             | LowOrder : low order component to display
             |             |     Null : Defaults to seconds if time present, otherwise day
             |             |        D : Day
             |             |        H : Hour
             |             |        M : Minute
             |             |        S : Second
             |             | Precision: [0-9] Only has an effect when low order component is seconds.
             |             |        Z : Display 'Z' for Zulu time zone +00:00
--------------------------------------------------------------------------------------------------------------*/
EXCELDATE_TO_ISO_DATETIME = LAMBDA(ExcelDate, [TZOMinutes], [Options],
    IFS(
        IS_EMPTY(ExcelDate), "",
        NOT(ISNUMBER(ExcelDate)), {#VALUE!},
        ExcelDate <= 1, FORMAT_ISO_DATETIME("", "", "", ExcelDate, TZOMinutes, Options),
        TRUE, LET(
            _yearCE, YEAR(ExcelDate),
            _month, MONTH(ExcelDate),
            _day, DAY(ExcelDate),
            _time, ExcelDate - INT(ExcelDate),
            FORMAT_ISO_DATETIME(_yearCE, _month, _day, _time, TZOMinutes, Options)
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
ISO_DATETIME_TO_MJDATE

Converts an ISO formatted date and time to a Modified Julian Date and time zone offset.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal         | Local Modifed Julian Date
 2 | decimal         | Time zone offset from UTC as decimal fraction of a day.
   | [-0.625..0.625] | -15:00..+15:00

Parameters
----------------------------------------------------------------------------------------------------------------
ISODateTime        | text   | Date, time and time zone offset in ISO format
[AllowMixedStyles] | switch | Relax validation for no mixing of basic and extended formats. eg. yyyyMMddThh:mm
[JulianCalendar]   | switch | Calculate for the Julian proleptic calendar. Default is Gregorian
                   |        | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
ISO_DATETIME_TO_MJDATE = LAMBDA(ISODateTime, [AllowMixedStyles], [JulianCalendar],
    IF(IS_EMPTY(ISODateTime), {"", ""},
        LET(
            _isoDateTime, PARSE_ISO_DATETIME(ISODateTime, AllowMixedStyles),
            IFS(
                ISERROR(INDEX(_isoDateTime, 1, 1)), HSTACK({#VALUE!}, INDEX(_isoDateTime, 1, 5)),
                NOT(IS_NUMERIC_NULL(INDEX(_isoDateTime, 1, 4))), HSTACK({#VALUE!}, INDEX(_isoDateTime, 1, 5)),
                IS_EMPTY(INDEX(_isoDateTime, 1, 1)), HSTACK({#VALUE!}, INDEX(_isoDateTime, 1, 5)),
                TRUE, LET(
                    _MJDate, MODIFIED_JULIAN_DATE(
                        INDEX(_isoDateTime, 1, 1),
                        INDEX(_isoDateTime, 1, 2),
                        INDEX(_isoDateTime, 1, 3),
                        INDEX(_isoDateTime, 1, 4),
                        JulianCalendar
                    ),
                    HSTACK(_MJDate, INDEX(_isoDateTime, 1, 5))
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
MJDATE_TO_ISO_DATETIME

Converts a Modified Julian Date and time zone offset to an ISO formatted date and time.

Output
----------------------------------------------------------------------------------------------------------------
 1 | text  | ISO formated date and time

Parameters
----------------------------------------------------------------------------------------------------------------
MJDate           | decimal     | Modified Julian Date
[TZOMinutes]     | decimal     | Time zone offset from UTC in minutes
                 | [-900..900] | Assumed to be UTC if ommitted. [-15:00..+15:00]
[Options]        | text        | String with elements: [B][<][LowOrder][Precision][Z]
                 |             |        B : Display in basic format eg T0000
                 |             |        < : Round by truncating components. Default is rounding to nearest.
                 |             | LowOrder : low order component to display
                 |             |     Null : Defaults to seconds if time present, otherwise day
                 |             |        D : Day
                 |             |        H : Hour
                 |             |        M : Minute
                 |             |        S : Second
                 |             | Precision: [0-9] Only has an effect when low order component is seconds.
                 |             |        Z : Display 'Z' for Zulu time zone +00:00
[JulianCalendar] | switch      | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |             | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
MJDATE_TO_ISO_DATETIME = LAMBDA(MJDate, [TZOMinutes], [Options], [JulianCalendar],
    IFS(
        IS_EMPTY(MJDate), "",
        NOT(ISNUMBER(MJDate)), {#VALUE!},
        TRUE, LET(
            _cDate, MJDATE_TO_CALENDAR_DATE(MJDate, JulianCalendar),
            FORMAT_ISO_DATETIME(
                INDEX(_cDate, 1, 1),
                INDEX(_cDate, 1, 2),
                INDEX(_cDate, 1, 3),
                INDEX(_cDate, 1, 4),
                TZOMinutes,
                Options,
                JulianCalendar
            )
        )
    )
);


/*##############################################################################################################
# END CALENDAR                                                                                                 #
##############################################################################################################*/
