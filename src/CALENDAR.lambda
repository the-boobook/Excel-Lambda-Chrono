/*##############################################################################################################
# CALENDAR v3.0                                                                                                #
#                                                                                                              #
# Module for working with dates in the Gregorian and Julian calendars outside the range of the Excel Date/Time #
# type.                                                                                                        #
#                                                                                                              #
# Module Dependencies: None                                                                                    #
#                                                                                                              #
# GENERAL                                                                                                      #
# ------------------------------------------------------------------------------------------------------------ #
# IS_EMPTY                   Tests if the parameter has an empty value. Errors return FALSE.                   #
# IS_NUMERIC_NULL            Tests if the parameter has a numeric value or is empty. Errors return FALSE.      #
# IS_INTEGER                 Tests if a number is an integer or very close to an integer. Use in place of      #
#                            MOD(N, 0) > 0 where N can be within a large range of magnitudes.                  #
# NULLIFY                    Ensures an empty cell reference is not resolved to zero.                          #
# DECIMALS                   Returns the number of decimal places for a rational number.                       #
# VALIDATE_CHARSET           Validates that the given text only contains characters in the specified character #
#                            set. Matching is case-insensitive by default.                                     #
# REPLACE_CHARS              Replaces each instance of a set of characters within text with another character. #
#                            Matching is case-insensitive by default. Note can be used to remove characters by #
#                            supplying an empty CharReplaceWith.                                               #
# SUBSTITUTE_I               Case-insensitive substitution of text. Similar to SUBSTITUTE function which is    #
#                            case-sensitive.                                                                   #
# FIND_NTH_CHAR              Locates the position of the Nth count of any one of a set of characters within    #
#                            the given text. The search is case-insensitive by default.                        #
# SPLIT                      Splits text into columns at a given delimiter up to the specified limit. Matching #
#                            is case-insensitive by default.                                                   #
# SPLIT_FOR_CHARS            Splits text at any character not in the given set. First element returned is the  #
#                            count number of substrings, then second element is the sequence of unmatched      #
#                            characters, followed by each substring. Matching is case-insensitive by default.  #
# SIFT_FOR_CHARS             Returns the characters found in a text string found from a given set of           #
#                            characters. An upper limit can be set on the number of times any character can be #
#                            matched. Matching is case-insensitive by default.                                 #
#                                                                                                              #
# TIMESPAN                                                                                                     #
# ------------------------------------------------------------------------------------------------------------ #
# VALIDATE_TIMESPAN          Validate each element of a sexagesimal representation of a timespan. A component  #
#                            can exceed its modulus if no higher order component is provided.                  #
# IS_VALID_TIMESPAN          Tests if sexagesimal representation of a timespan is valid. A component can       #
#                            exceed its modulus if no higher order element is provided.                        #
# TIMESPAN                   Returns a decimal timespan as a fraction of a day from a sexagesimal              #
#                            representation of time. Note components exceeding their modulus will carry.       #
# ROUND_TIMESPAN             Returns a decimal timespan value rounded to the specified low order component and #
#                            precision level.                                                                  #
# NORMALISE_TIMESPAN         Returns a normalised sexagesimal representation of a timespan where each          #
#                            component is within its modulus.                                                  #
# RESOLVE_TIMESPAN           Returns the sexagesimal representation of a timespan value expressed from the     #
#                            specified high order component and the given lowest order component rounded to    #
#                            the specified precision.                                                          #
# PARSE_TIMESPAN             Parses an ISO formatted time of day into either time of day expressed as decimal  #
#                            value or sexagesimal complication.                                                #
# FORMAT_TIMESPAN            Returns a timespan as text in the specified format from a given decimal timespan. #
#                                                                                                              #
# CALENDAR DATE                                                                                                #
# ------------------------------------------------------------------------------------------------------------ #
# YEAR_BCE_TO_CE             Converts to year value relative to the Common Era for a given year Before Common  #
#                            Era. Function is symmetrical, can also be used for CE to BCE conversion.          #
# PARSE_MONTH                Returns a number representing the month of year from a given month name.          #
# MONTH_NAME                 Returns name of month.                                                            #
# IS_LEAP_YEAR               Tests if a year includes a leap day in the given calendar.                        #
# DAYS_IN_YEAR               Returns number of days in the given year of the specified calendar.               #
# DAYS_IN_MONTH              Returns number of days in the given month and year of the specified calendar.     #
# VALIDATE_DATE              Validate a year, month and day representation of a date of the specified calendar.#
# IS_VALID_DATE              Tests if a month and day representation of a date is valid for the specified      #
#                            calendar.                                                                         #
# NORMALISE_CALENDAR_DATE    Returns a normalised YMD representation of a date where each component is within  #
#                            its valid range.                                                                  #
# PARSE_ISO_CALENDAR_DATE    Parses an ISO formatted calendar date into respective parts of year, month and    #
#                            day.                                                                              #
# FORMAT_ISO_CALENDAR_DATE   Returns a calendar date as text in ISO format.                                    #
# JULIAN_DAY_NUMBER          Returns the Julian Day Number (JDN) of the provided date in the specified         #
#                            calendar. Note the Julian Day Number is an integer type and is an ordinal day     #
#                            number referenced from January 1, 4713 BC in the proleptic Julian calendar. It    #
#                            does not include any value for time of day.                                       #
# MODIFIED_JULIAN_DAY_NUMBER Returns the Modified Julian Day Number (MJDN) of the provided date in the         #
#                            specified calendar. Note the Modified Julian Day Number is an integer type and    #
#                            is an ordinal day number referenced from November 17, 1858 in the proleptic       #
#                            Gregorian calendar. It does not include any value for time of day.                #
# JDN_TO_MODIFIED            Converts a Julian Day Number (JDN) to a Modified Julian Day Number (MJDN).        #
# MODIFIED_TO_JDN            Converts a Modified Julian Day Number (MJDN) to a Julian Day Number (JDN).        #
# JDN_TO_CALENDAR_DATE       Converts a Julian Day Number (JDN) to a date in the specified calendar.           #
# MJDN_TO_CALENDAR_DATE      Converts a Modified Julian Day Number (MJDN) to a date in the specified calendar. #
# GREGORIAN_TO_JULIAN        Translates a date in the Gregorian proleptic calendar to the Julian proleptic     #
#                            calendar.                                                                         #
# JULIAN_TO_GREGORIAN        Translates a date in the Julian proleptic calendar to the Gregorian proleptic     #
#                            calendar.                                                                         #
# SECULAR_DIFFERENCE         Returns the number of days the Gregorian proleptic calendar is ahead of the       #
#                            Julian proleptic calendar for a given date.                                       #
#                                                                                                              #
# TIME OF DAY                                                                                                  #
# ------------------------------------------------------------------------------------------------------------ #
# VALIDATE_TIME_OF_DAY       Validate each element of a sexagesimal representation of a time of day.           #
# IS_VALID_TIME_OF_DAY       Tests if sexagesimal representation of time is valid for a 24 hour day.           #
# PARSE_TIME_OF_DAY          Parses a formatted time of day into either decimal time of day or time            #
#                            complication.                                                                     #
# FORMAT_TIME_OF_DAY         Returns a formatted sexagesimal representation of time of day from a given        #
#                            decimal fraction of a 24 hour day.                                                #
#                                                                                                              #
# TIME ZONE                                                                                                    #
# ------------------------------------------------------------------------------------------------------------ #
# IS_VALID_TZO               Tests if a time zone offset in minutes is within the range -900..+900             #
# TIMESPAN_TO_TZO            Converts a deimal timespan into time zone offset minutes.                         #
# TZO_TO_TIMESPAN            Converts time zone offset minutes into a decimal timespan.                        #
# PARSE_ISO_TZO              Parses an ISO formatted time zone offset into a decimal timespan.                 #
# FORMAT_ISO_TZO             Returns a time zone offset as text in ISO format.                                 #
# MILITARY_TZO               Returns the time zone offset in minutes of a military time zone designator.       #
# TZO_TO_MILITARY            Returns the closest military time zone designator, its offset in minutes and the  #
#                            time adjustment to that time zone for the provided time zone offset in minutes.   #
# SHIFT_TIMEZONE             Translates a Modified Julian Date from one time zone to another. If a time zone   #
#                            is omitted it is assumed to be UTC.                                               #
#                                                                                                              #
# DATETIME                                                                                                     #
# ------------------------------------------------------------------------------------------------------------ #
# JULIAN_DATE                Returns the Julian Date of the provided date and time of day in the specified     #
#                            calendar. Note that the decimal time component of Julian Date is based from       #
#                            midday.                                                                           #
# MODIFIED_JULIAN_DATE       Returns the Modified Julian Date of the provided date and time of day in the      #
#                            specified calendar. Note that the time component of Modified Julian Date is       #
#                            based from midnight.                                                              #
# JDATE_TO_MODIFIED          Converts a Julian Date (JDATE) to a Modified Julian Date (MJDATE). Note that the  #
#                            decimal time component of MJDATE is based from midnight.                          #
# MODIFIED_TO_JDATE          Converts a Modified Julian Date (MJDATE) to a Julian Date (JDATE). Note that the  #
#                            decimal time component of JDATE is based from midday.                             #
# JDATE_TO_YMDT              Converts a Julian Date to a date and time in the specified calendar.              #
# MJDATE_TO_YMDT             Converts a Modified Julian Date to a date and time in the specified calendar.     #
# NORMALISE_YMDT             Returns a normalised YMDT representation of a date and time where each component  #
#                            is within its valid range.                                                        #
# RESOLVE_YMDT               Returns the resolved date and time from the provided components to a low order    #
#                            component rounded to the specified precision.                                     #
# ROUND_MJDATE               Returns the decimal MJdate value rounded to the specified low order component and #
#                            precision level.                                                                  #
# RESOLVE_MJDATE             Returns the date and sexagesimal representation of the time value with the given  #
#                            lowest order component rounded to the specified precision.                        #
# MJDATE_ADDITION            Returns the addition of a timespan complication to a given Modified Julian Date.  #
#                            Note if date components of years, quarters or months are added for a MJDate       #
#                            expressed in UTC rather than local time, then results may be inconsistent due to  #
#                            the bounds of calendar days.                                                      #
# PARSE_ISO_DATETIME         Parses an ISO formatted date and time into respective date parts, time, and time  #
#                            zone offset from UTC. Providing a time zone offset on its own is invalid for      #
#                            this function.                                                                    #
# FORMAT_ISO_DATETIME        Returns a date, time and time zone offset as text in ISO format.                  #
# PARSE_LITERARY_YEAR        Returns a number representing the year relative to the common era from a given    #
#                            literary year.                                                                    #
# FORMAT_LITERARY_YEAR       Returns a year formatted in literary style.                                       #
# PARSE_LITERARY_DATETIME    Parses a literary date into respective parts of year, month, day and time of day. #
# FORMAT_LITERARY_DATETIME   Returns a date formatted in literary style.                                       #
# PARSE_US_DATETIME          Parses a US formatted date into respective parts of year, month, day and time of  #
#                            day.                                                                              #
# FORMAT_US_DATETIME         Returns a date formatted in the US style.                                         #
# PARSE_MIL_DTG              Parses a date-time group in the format used by US Military message traffic, into  #
#                            respective parts of year, month, day, time of day and time zone offset in         #
#                            minutes from UTC.                                                                 #
# FORMAT_MIL_DTG             Returns a date-time group formatted in US Military message traffic style.         #
#                                                                                                              #
# ORDINAL DATES                                                                                                #
# ------------------------------------------------------------------------------------------------------------ #
# IS_VALID_ORDINAL_DATE      Tests if an ordinal date is valid for the given calendar.                         #
# PARSE_ISO_ORDINAL_DATE     Parses an ISO formatted ordinal date into respective parts of year, and ordinal   #
#                            day.                                                                              #
# FORMAT_ISO_ORDINAL_DATE    Returns an ordinal date as text in ISO format.                                    #
# ORDINAL_DATE_TO_MJDATE     Converts an ordinal date and time in the specified calendar to a Modified Julian  #
#                            Date.                                                                             #
# MJDATE_TO_ORDINAL_DATE     Converts a Modified Julian Date (MJDATE) to an ordinal date and time in the       #
#                            specified calendar.                                                               #
#                                                                                                              #
# WEEKS                                                                                                        #
# ------------------------------------------------------------------------------------------------------------ #
# CONVERT_WEEKDAY_NUMBER     Returns an integer for the day of the week from the traditonal numbering scheme   #
#                            to the ISO definition, or vice versa.                                             #
# PARSE_WEEKDAY              Returns a number representing the day of the week from a given text weekday name. #
# WEEKDAY_NAME               Returns name of an ISO day of week number as text.                                #
# DAY_OF_WEEK                Returns an integer for the day of the week for a given Modified Julian Date.      #
# WEEKDAY_OF_MONTH           Returns a Modified Julian Date for a given day of week, relative week for the     #
#                            month, year and time of day of the specified calendar.                            #
# IS_VALID_WEEK_DATE         Tests if a week date is valid for the given calendar.                             #
# WEEKS_IN_YEAR              Returns the count of ISO defined weeks in a given year of the specified calendar. #
# PARSE_ISO_WEEK_DATE        Parses an ISO formatted week date into respective parts of year, week and         #
#                            weekday.                                                                          #
# FORMAT_ISO_WEEK_DATE       Returns a week date as text in ISO format.                                        #
# WEEK_DATE_TO_MJDATE        Converts a week date of year, ISO defined week number, ISO weekday, and time in   #
#                            the specified calendar to a Modified Julian Date (MJDATE).                        #
# MJDATE_TO_WEEK_DATE        Converts a Modified Julian Date (MJDATE) to the year, ISO defined week number,    #
#                            ISO weekday, time, and weeks in the year in the specified calendar.               #
# WEEK_NUMBER                Returns the ISO defined week number for a given Modified Julian Date in the       #
#                            specified calendar.                                                               #
#                                                                                                              #
# QUARTERS                                                                                                     #
# ------------------------------------------------------------------------------------------------------------ #
# DAYS_IN_QUARTER            Returns the count of days in a quarter of a given year of the specified calendar. #
# QUARTER_DATE_TO_MJDATE     Converts a date expressed as fiscal year, quarter, day of quarter and time in     #
#                            the specified calendar to a Modified Julian Date (MJDATE).                        #
# MJDATE_TO_QUARTER_DATE     Converts a Modified Julian Date (MJDATE) to a date expressed as fiscal year,      #
#                            quarter, day of quarter and time in the specified calendar.                       #
#                                                                                                              #
# DELTAS                                                                                                       #
# ------------------------------------------------------------------------------------------------------------ #
# DELTA_INTERVAL             Returns the timespan difference between Modified Julian Dates in the specified    #
#                            units.                                                                            #
# DELTA_HOURS                Returns the timespan difference between Modified Julian Dates in hours.           #
# DELTA_MINUTES              Returns the timespan difference between Modified Julian Dates in minutes.         #
# DELTA_SECONDS              Returns the timespan difference between Modified Julian Dates in seconds.         #
# DELTA_DHMS                 Returns the sexagesimal difference between Modified Julian Dates with the given   #
#                            lowest order component rounded to the specified precision.                        #
# DELTA_TIMESPAN             Returns the timespan difference between Modified Julian Dates.                    #
# DELTA_WEEKS                Returns the timespan difference between Modified Julian Dates in weeks.           #
# DELTA_MONTHS               Returns the timespan difference between Modified Julian Dates in months. Where    #
#                            the difference includes partial months, the fraction is calculated on the basis   #
#                            of days in the month of the calendar. If the Modified Julian Dates are expressed  #
#                            in UTC rather than local time then a small margin of error will be introduced due #
#                            to the bounds of calendar days.                                                   #
# DELTA_QUARTERS             Returns the timespan difference between Modified Julian Dates in quarters. Where  #
#                            the difference includes partial quarters, the fraction is calculated on the basis #
#                            of days in the quarter of the calendar. If the Modified Julian Dates are          #
#                            expressed in UTC rather than local time then a small margin of error will be      #
#                            introduced due to the bounds of calendar days.                                    #
# DELTA_YEARS                Returns the timespan difference between Modified Julian Dates in years. Where the #
#                            difference includes partial years, the fraction is calculated on the basis of     #
#                            days in the year of the calendar. If the Modified Julian Dates are expressed in   #
#                            UTC rather than local time then a small margin of error will be introduced due to #
#                            the bounds of calendar days.                                                      #
# DELTA_WEEK_DAYS            Returns the timespan difference between Modified Julian Dates in weeks and days.  #
# DELTA_YEAR_WEEK_DAYS       Returns the timespan difference between Modified Julian Dates in years, weeks,    #
#                            and days. Note the number of weeks per year can vary between 52 and 53. If an     #
#                            absolute number of weeks is being sought then use either DELTA_WEEK_DAYS or       #
#                            DELTA_WEEKS functions. If the Modified Julian Dates are expressed in UTC rather   #
#                            than local time then a small margin of error will be introduced due to the bounds #
#                            of calendar days.                                                                 #
# DELTA_MONTH_DAYS           Returns the timespan difference between Modified Julian Dates in months and days. #
#                            If the Modified Julian Dates are expressed in UTC rather than local time then a   #
#                            small margin of error will be introduced due to the bounds of calendar days.      #
# DELTA_QUARTER_DAYS         Returns the timespan difference between Modified Julian Dates in quarters and     #
#                            days. If the Modified Julian Dates are expressed in UTC rather than local time    #
#                            then a small margin of error will be introduced due to the bounds of calendar     #
#                            days.                                                                             #
#                                                                                                              #
# EXTENTS                                                                                                      #
# ------------------------------------------------------------------------------------------------------------ #
# EXTENT_OF_DAYS             Returns the inclusive extent of days spanned by two Modified Julian Dates         #
#                            expressed in local time. If the Modified Julian Dates are expressed in UTC rather #
#                            than local time then inconsistent results may be produced due to the bounds of    #
#                            calendar days.                                                                    #
# EXTENT_OF_WEEKS            Returns the inclusive extent of weeks spanned by two Modified Julian Dates        #
#                            expressed in local time. If the Modified Julian Dates are expressed in UTC rather #
#                            than local time then inconsistent results may be produced due to the bounds of    #
#                            calendar days.                                                                    #
# EXTENT_OF_MONTHS           Returns the inclusive extent of months spanned by two Modified Julian Dates       #
#                            expressed in local time. If the Modified Julian Dates are expressed in UTC rather #
#                            than local time then inconsistent results may be produced due to the bounds of    #
#                            calendar days.                                                                    #
# EXTENT_OF_QUARTERS         Returns the inclusive extent of quarters spanned by two Modified Julian Dates     #
#                            expressed in local time. If the Modified Julian Dates are expressed in UTC rather #
#                            than local time then inconsistent results may be produced due to the bounds of    #
#                            calendar days.                                                                    #
# EXTENT_OF_YEARS            Returns the inclusive extent of years spanned by two Modified Julian Dates        #
#                            expressed in local time. If the Modified Julian Dates are expressed in UTC rather #
#                            than local time then inconsistent results may be produced due to the bounds of    #
#                            calendar days.                                                                    #
#                                                                                                              #
# CONVERSIONS                                                                                                  #
# ------------------------------------------------------------------------------------------------------------ #
# TIMESPAN_TO_EXCELTIME      Converts a TimeSpan to an Excel Date/Time.                                        #
# EXCELTIME_TO_TIMESPAN      Converts an Excel Date/Time to a TimeSpan.                                        #
# MJDATE_TO_EXCELDATE        Converts a Modified Julian Date to an Excel Date/Time.                            #
# EXCELDATE_TO_MJDATE        Converts an Excel Date/Time to a Modified Julian Date.                            #
# USDATE_TO_EXCELDATE        Converts a US format date to an Excel Date/Time.                                  #
# EXCELDATE_TO_USDATE        Converts an Excel Date/Time to a US format date.                                  #
# ISO_DATETIME_TO_EXCELDATE  Converts an ISO formatted date and time to an Excel Date/Time and time zone       #
#                            offset.                                                                           #
# EXCELDATE_TO_ISO_DATETIME  Converts an Excel Date/Time and time zone offset to an ISO formatted date and     #
#                            time.                                                                             #
# ISO_DATETIME_TO_MJDATE     Converts an ISO formatted date and time to a Modified Julian Date and time zone   #
#                            offset.                                                                           #
# MJDATE_TO_ISO_DATETIME     Converts a Modified Julian Date and time zone offset to an ISO formatted date and #
#                            time.                                                                             #
#                                                                                                              #
##############################################################################################################*/


/*##############################################################################################################
# GENERAL                                                                                                      #
##############################################################################################################*/


/*--------------------------------------------------------------------------------------------------------------
IS_EMPTY

Tests if the parameter has an empty value. Errors return FALSE.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean | 

Parameters
----------------------------------------------------------------------------------------------------------------
Value | variant |

Examples
----------------------------------------------------------------------------------------------------------------
IS_EMPTY("")
Returns TRUE

IS_EMPTY(1)
Returns FALSE

IS_EMPTY(#N/A)
Returns FALSE
--------------------------------------------------------------------------------------------------------------*/
IS_EMPTY = LAMBDA(Value,
    IF(ISERROR(Value), FALSE,
        Value = ""
    )
);


/*--------------------------------------------------------------------------------------------------------------
IS_NUMERIC_NULL

Tests if the parameter has a numeric value or is empty. Errors return FALSE.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean | 

Parameters
----------------------------------------------------------------------------------------------------------------
Value | variant |

Examples
----------------------------------------------------------------------------------------------------------------
IS_NUMERIC_NULL(1)
Returns TRUE

IS_NUMERIC_NULL("")
Returns TRUE

IS_NUMERIC_NULL("X")
Returns FALSE

IS_NUMERIC_NULL(#VALUE!)
Returns FALSE
--------------------------------------------------------------------------------------------------------------*/
IS_NUMERIC_NULL = LAMBDA(Value,
    IFS(
        ISERROR(Value), FALSE,
        Value = "", TRUE,
        ISNUMBER(Value), TRUE,
        TRUE, FALSE
    )    
);


/*--------------------------------------------------------------------------------------------------------------
IS_INTEGER

Tests if a number is an integer or very close to an integer. Use in place of MOD(N, 0) > 0 where N
can be within a large range of magnitudes.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean | 

Parameters
----------------------------------------------------------------------------------------------------------------
N | decimal | 

Examples
----------------------------------------------------------------------------------------------------------------
IS_INTEGER(1)
Returns TRUE

IS_INTEGER(0.5)
Returns FALSE

IS_INTEGER("3")
Returns #VALUE!
--------------------------------------------------------------------------------------------------------------*/
IS_INTEGER = LAMBDA(N,
    IF(NOT(ISNUMBER(N)), {#VALUE!},
        LET(
            _integer, INT(N),
            ROUNDDOWN(N - _integer, 15) = 0
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
NULLIFY

Ensures an empty cell reference is not resolved to zero.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | variant | 

Parameters
----------------------------------------------------------------------------------------------------------------
Value | variant |

Examples
----------------------------------------------------------------------------------------------------------------
NULLIFY(A1), where A1 is empty
Returns ""
--------------------------------------------------------------------------------------------------------------*/
NULLIFY = LAMBDA(Value,
    IF(ISBLANK(Value), "", Value)
);


/*--------------------------------------------------------------------------------------------------------------
DECIMALS

Returns the number of decimal places for a rational number.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [0..] | max value 15 for values > 1

Parameters
----------------------------------------------------------------------------------------------------------------
N | decimal | 
--------------------------------------------------------------------------------------------------------------*/
DECIMALS = LAMBDA(N,
    IFS(
        N = "", "",
        NOT(ISNumber(N)), {#VALUE!},
        N = 0, 0,
        TRUE, LET(
            // IEEE 754 floating point arithmetic introduces errors in the mathematical algorithm:
            // num -> frac = MOD(num, 1); smallest n where frac * 10^n = INT(frac * 10^n)
            // MOD involves subraction, which for a numbers >> 1 with a small decimal part produces
            // an error margin that results in a much larger n 
            // eg num = 10^12 + 0.1 ; MOD(num, 1) - 0.1 = -0.000244...
            // n should = 1, however the algorithm results in a run-away n
            // Using Excel string formatting instead
            _num1, ABS(N),
            _frac1, _num1 - INT(_num1),
            _shift, IFERROR(CEILING(-LOG10(_frac1), 1) - 1, 0),
            _num2, _num1 * POWER(10, _shift),
            _sNum2, TEXT(_num2,"0.000000000000000"),
            _sFrac, RIGHT(_sNum2, 15),
            IF(_sFrac = "000000000000000", 0,
                LET(
                    _last, REDUCE("", SEQUENCE(15,,15, -1),
                        LAMBDA(_acc, _curr,
                            IF(_acc <> "", _acc,
                                IF(MID(_sFrac, _curr, 1) = "0", "", _curr)
                            )
                        )
                    ),
                    _last + _shift
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
VALIDATE_CHARSET

Validates that the given text only contains characters in the specified character set.
Matching is case-insensitive by default.

Array compatible: Text parameter only

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
----------------------------------------------------------------------------------------------------------------
Text              | text    | Text to validate
CharSet           | text    | Valid characters
[CaseInsensitive] | boolean | Ignore case when matching
--------------------------------------------------------------------------------------------------------------*/
VALIDATE_CHARSET = LAMBDA(Text, CharSet, [CaseSensitive],
    IFS(
        CharSet = "", FALSE,
        Text = "", FALSE,
        TRUE, LET(
            _ignoreCase, N(CaseSensitive) = 0,
            _text, IF(_ignoreCase, UPPER(Text), Text),
            _chars, IF(_ignoreCase, UPPER(CharSet), CharSet),
            _escapeText, SUBSTITUTE(SUBSTITUTE(_text, "&", "&amp;"), "<", "&lt;"),
            _xml, CONCAT("<xml><s>", _escapeText, "</s></xml>"),
            _xpath, CONCAT("//s[translate(.,'", _chars, "','')='']"),
            NOT(ISERROR(FILTERXML(_xml, _xpath)))
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
REPLACE_CHARS

Replaces each instance of a set of characters within text with another character.
Matching is case-insensitive by default. Note can be used to remove characters by supplying an empty CharReplaceWith.

Array compatible: Text parameter only

Output
----------------------------------------------------------------------------------------------------------------
 1 | text |

Parameters
----------------------------------------------------------------------------------------------------------------
Text            | text    | Text within which to replace characters
CharSet         | text    | Set of characters to be replaced
CharReplaceWith | text    | Target character with which to replace each character in CharSet
[CaseSensitive] | boolean | Match on letter case

Examples
----------------------------------------------------------------------------------------------------------------
REPLACE_CHARS("abc:def/g/h", ":/", "")
Returns: abcdefgh

REPLACE_CHARS("abc:def/g/h", ":/", "_")
Returns: abc_def_g_h
--------------------------------------------------------------------------------------------------------------*/
REPLACE_CHARS = LAMBDA(Text, CharSet, CharReplaceWith, [CaseSensitive],
    LET(
        _charNew, LEFT(CharReplaceWith),
        _ignoreCase, N(CaseSensitive) = 0,
        MAP(Text,
            LAMBDA(_text,
                IFS(
                    CharSet = "", _text,
                    _text = "", "",
                    _ignoreCase,
                        REDUCE(_text, SEQUENCE(LEN(CharSet)),
                            LAMBDA(acc, curr,
                                LET(
                                    _charL, LOWER(MID(CharSet, curr, 1)),
                                    _textL, SUBSTITUTE(acc, _charL, _charNew),
                                    SUBSTITUTE(_textL, UPPER(_charL), _charNew)
                                )
                            )
                        ),
                    TRUE, REDUCE(_text, SEQUENCE(LEN(CharSet)),
                        LAMBDA(acc, curr,
                            SUBSTITUTE(acc, MID(CharSet, curr, 1), _charNew)
                        )
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
SUBSTITUTE_I

Case-insensitive substitution of text. Similar to SUBSTITUTE function which is case-sensitive.

Array compatible: Text parameter only

Output
----------------------------------------------------------------------------------------------------------------
 1 | text |

Parameters
----------------------------------------------------------------------------------------------------------------
Text          | text    | Text within which to replace matched text
OldText       | text    | Text to be replaced
NewText       | text    | Text with which to replace OldText
[InstanceNum] | integer | Specifiy which occurance to replace. If omitted or 0 then all occurances are replaced.
              |         | Negative instance matches from end.

Examples
----------------------------------------------------------------------------------------------------------------
SUBSTITUTE_I("abc:def:ghi:jkl", ":", "")
Returns: abcdefghijkl

SUBSTITUTE_I("abc:def:ghi:jkl", ":", "-", 2)
Returns: abc:def-ghi:jkl
--------------------------------------------------------------------------------------------------------------*/
SUBSTITUTE_I = LAMBDA(Text, OldText, NewText, [InstanceNum],
    IF(OldText = "", NULLIFY(Text),
        LET(
            _oldLen, LEN(OldText),
            _lenDiff, LEN(NewText) - _oldLen,
            _instance, N(InstanceNum),
            MAP(Text,
                LAMBDA(_text,
                    IF(_text = "", "",
                        LET(
                            _maxInstance, INT(LEN(_text) / _oldLen),
                            _pos, SCAN(0, SEQUENCE(1, _maxInstance),
                                LAMBDA(_acc, _curr,
                                    IF(_acc = "", "", IFERROR(SEARCH(OldText, _text, _acc + 1), ""))
                                )
                            ),
                            _count, COUNT(_pos),
                            IFS(
                                _count = 0, _text,
                                ABS(_instance) > _count, _text,
                                _instance > 0, REPLACE(_text, INDEX(_pos, 1, _instance), _oldLen, NewText),
                                _instance < 0, REPLACE(_text, INDEX(_pos, 1, _count + _instance + 1), _oldLen, NewText),
                                TRUE, LET(
                                    _nPos, TAKE(_pos, 1, _count) + SEQUENCE(1, _count, 0, _lenDiff),
                                    REDUCE(_text, _nPos,
                                        LAMBDA(_acc, _curr,
                                            REPLACE(_acc, _curr, _oldLen, NewText)
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
FIND_NTH_CHAR

Locates the position of the Nth count of any one of a set of characters within the given text.
Search is case-insensitive by default.

Array compatible: Text parameter as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Character position in text.
 2 | char    | Character found. Returned if ReturnChar is set

Parameters
----------------------------------------------------------------------------------------------------------------
Text            | text             | Text to search within
Chars           | text             | Characters to search for
[N]             | integer          | Nth count of any of the characters. Defaults to 1st.
                |                  | Negative values will perform a reverse search from the end of the text.
[CaseSensitive] | switch           | Search is case-sensitive.           
[ReturnChar]    | switch           | Also return the character found
[LowerPos]      | integer          | Position to start the search from.
                | [1..LEN(Text)]   | Negative values are relative to the end of the text.
                | [-LEN(Text)..-1] | Defaults to beginning of the text.
[UpperPos]      | integer          | Position limit of the search.
                | [1..LEN(Text)]   | Negative values are relative to the end of the text.
                | [-LEN(Text)..-1] | Defaults to end of the text.

Examples
----------------------------------------------------------------------------------------------------------------
FIND_NTH_CHAR("1234_A_B_A_0", "AB")
Returns: 6 i.e. 1st A or B is at position 6

FIND_NTH_CHAR("1234_A_b_a_0", "ab", 2, 1)
Returns: 10 i.e. 2nd a or b, case-sensitive is at position 10

FIND_NTH_CHAR("1234_A_B_A_0", "ab", 2, 0, 1, 7)
Returns: {10, A} i.e. 2nd a or b, case-insensitive is at position 10, searching from position 7. A was found.

FIND_NTH_CHAR("1234_A_B_A_0", "AB", -2, 1, 1, -4)
Returns: {6, A} i.e. 2nd A or B, case-sensitive is at position 6, using reverse search from 4 characters from end.
         A was found
--------------------------------------------------------------------------------------------------------------*/
FIND_NTH_CHAR = LAMBDA(Text, Chars, [N], [CaseSensitive], [ReturnChar], [LowerPos], [UpperPos],
    LET(
        _ignoreCase, N(CaseSensitive) = 0,
        _outChar, N(ReturnChar) <> 0,
        _n, IF(ISOMITTED(N), 1, INT(N(N))),
        _returnNone, IF(_outChar, {0, ""}, 0),
        _lowPos, IF(N(LowerPos) = 0, 1, INT(LowerPos)),
        
        fnNthChar, LAMBDA(_text,
            IFS(
                ISERROR(_text), IF(_outChar, HSTACK(_text, ""), _text),
                IS_EMPTY(Chars), _returnNone,
                _n = 0, _returnNone,
                TRUE, LET(
                    _len, LEN(_text),
                    _startPos, IF(_lowPos < 1, _len + _lowPos + 1, _lowPos),
                    _endPos, IFS(
                        NOT(ISNUMBER(UpperPos)), _len,
                        UpperPos > 0, UpperPos,
                        UpperPos < 0, _len + UpperPos + 1,
                        TRUE, 0
                    ),
                    IFS(
                        _startPos > _len, _returnNone,
                        _startPos > _endPos, _returnNone,
                        TRUE, LET(
                            _searchText, MID(_text, _startPos, _endPos - _startPos + 1),
                            _casedText, IF(_ignoreCase, UPPER(_searchText), _searchText),
                            _searchLen, LEN(_casedText),
                            _charArray, MID(
                                IF(_ignoreCase, UPPER(Chars), Chars),
                                SEQUENCE(LEN(Chars)),
                                1
                            ),
                            _findCount, LET(
                                _removed, REDUCE(_casedText, _charArray,
                                    LAMBDA(_acc, _curr,
                                        SUBSTITUTE(_acc, _curr, "")
                                    )
                                ),
                                _searchLen - LEN(_removed)
                            ),
                            IF(_findCount < ABS(_n), _returnNone,
                                LET(
                                    // nth can count from end backwards
                                    _nth, IF(_n > 0, _n, _findCount + _n + 1),
                                    _nthPos, REDUCE(0, SEQUENCE(_nth),
                                        LAMBDA(_acc, _curr,
                                            IF(_acc < 0, -1,
                                                LET(
                                                    _nextPosChars, IFERROR(FIND(_charArray, _casedText, _acc + 1), 0),
                                                    _nextPos, MIN(FILTER(_nextPosChars, _nextPosChars > 0, 0)),
                                                    IF(_nextPos = 0, -1, _nextPos)
                                                )
                                            )
                                        )
                                    ),
                                    _outPos, _nthPos + _startPos - 1,
                                    IF(_outPos < 1, _returnNone,
                                        IF(_outChar,
                                            HSTACK(_outPos, MID(_searchText, _nthPos, 1)),
                                            _outPos
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ),

        _rowCount, ROWS(Text),
        DROP(
            REDUCE(0, SEQUENCE(_rowCount),
                LAMBDA(_acc, _curr,
                    VSTACK(
                        _acc,
                        fnNthChar(NULLIFY(INDEX(Text, _curr, 1)))
                    )
                )
            ), 1
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
SPLIT

Splits text into columns at a given delimiter up to the specified limit. Matching is case-insensitive by default.

Array compatible: Text parameter as column

Output C[1..]
----------------------------------------------------------------------------------------------------------------
Array of substrings [1..n]

Parameters
----------------------------------------------------------------------------------------------------------------
Text            | text    | Text to split
ColumnDelimiter | text    | Substring to split at
[SplitLimit]    | integer | Limit at which to stop splitting. Defaults to 0 for no limit.
[CaseSensitive] | boolean | Match letter case
[IgnoreEmpty]   | boolean | Skip empty elements
[PadWith]       | text    | Pad fill empty elements in array

Examples
----------------------------------------------------------------------------------------------------------------
SPLIT("ABC|DEF||G", "|", , TRUE)
Returns: {"ABC", "DEF", "G"}

SPLIT("123abc456ABC789", "abc", , , TRUE)
Returns: {"123", "456ABC789"}
--------------------------------------------------------------------------------------------------------------*/
SPLIT = LAMBDA(Text, ColumnDelimiter, [SplitLimit], [CaseSensitive], [IgnoreEmpty], [PadWith],
    LET(
        _limit, MAX(INT(N(SplitLimit)), 0),
        IFS(
            ColumnDelimiter = "", NULLIFY(Text),
            _limit = 1, NULLIFY(Text),
            TRUE, LET(
                _caseSensitive, N(CaseSensitive) <> 0,
                _ignoreEmpty, N(IgnoreEmpty) <> 0,
                
                fnSplit, LAMBDA(_text,
                    IFS(
                        ISERROR(_text), HSTACK(_text),
                        _text = "", HSTACK(""),
                        TRUE, _SplitRecursive(_text, ColumnDelimiter, _limit, _caseSensitive, _ignoreEmpty, 1, "")
                    )
                ),
            
                _rows, ROWS(Text),
                _arrayRaw, DROP(
                    REDUCE("", SEQUENCE(_rows),
                        LAMBDA(_acc, _curr,
                            VSTACK(
                                _acc,
                                fnSplit(NULLIFY(INDEX(Text, _curr, 1)))
                            )
                        )
                    ), 1
                ),
                
                IF(ISOMITTED(PadWith),
                    _arrayRaw,
                    IFNA(_arrayRaw, PadWith)
                )
            )
        )
    )
);

_SplitRecursive = LAMBDA(Text, ColumnDelimiter, SplitLimit, CaseSensitive, IgnoreEmpty, StartPos, Columns,
    LET(
        fnRemainder, LAMBDA(
            LET(
                _element, RIGHT(Text, LEN(Text) - StartPos + 1),
                _cols, IF((_element = "") * IgnoreEmpty,
                    Columns,
                    HSTACK(Columns, _element)
                ),
                IF(COLUMNS(_cols) = 1, _cols, DROP(_cols, , 1))
            )
        ),
    
        IF(COLUMNS(Columns) = SplitLimit, fnRemainder(),
            LET(
                _pos, IF(CaseSensitive,
                    IFERROR(FIND(ColumnDelimiter, Text, StartPos), 0),
                    IFERROR(SEARCH(ColumnDelimiter, Text, StartPos), 0)
                ),
                IF(_pos = 0, fnRemainder(),
                    LET(
                        _element, MID(Text, StartPos, _pos - StartPos),
                        _cols, IF((_element = "") * IgnoreEmpty,
                            Columns,
                            HSTACK(Columns, _element)
                        ),
                        _SplitRecursive(Text, ColumnDelimiter, SplitLimit, CaseSensitive, IgnoreEmpty, _pos + LEN(ColumnDelimiter), _cols)
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
SPLIT_FOR_CHARS

Splits text at any character not in the given set. First element returned is the count of substrings, then second
element is the sequence of unmatched characters, followed by each substring. Matching is case-insensitive by default.

Array compatible: Text parameter as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Number of substrings (n)
 2 | text    | Unmatched characters
 3 | text    | Array of substrings [1..n]

Parameters
----------------------------------------------------------------------------------------------------------------
Text            | text    | Text to split
CharSet         | text    | Valid characters for each substring
[SplitLimit]    | integer | Limit at which to stop splitting
[CaseSensitive] | boolean | Match letter case

Examples
----------------------------------------------------------------------------------------------------------------
SPLIT_FOR_CHARS("A12b34B56", "123456")
Returns: {4, "AbB", , 12, 34, 56}
--------------------------------------------------------------------------------------------------------------*/
SPLIT_FOR_CHARS = LAMBDA(Text, CharSet, [SplitLimit], [CaseSensitive],
    IF(IS_EMPTY(CharSet), HSTACK(0, NULLIFY(Text)),
        LET(
            _limit, MAX(INT(N(SplitLimit)), 0),
            _ignoreCase, N(CaseSensitive) = 0,
            _chars, MID(CharSet, SEQUENCE(LEN(CharSet)), 1),
            fnMatchChar, LAMBDA(_c,
                LET(
                    _charMatches, IF(_ignoreCase,
                        _c = _chars,
                        CODE(_c) = CODE(_chars)
                    ),
                    N(MAX(N(_charMatches)) > 0)
                ) 
            ),
            fnSplitAround, LAMBDA(_rowText,
                LET(
                    _len, LEN(_rowText),
                    IFS(
                        _len = 0, HSTACK(0, ""),
                        _len = 1, IF(fnMatchChar(_rowText),
                            HSTACK(1, "", _rowText),
                            HSTACK(0, _rowText)
                        ),
                        TRUE, LET(
                            _firstChar, LEFT(_rowText),
                            _init, IF(fnMatchChar(_firstChar),
                                HSTACK("", _firstChar, 1),
                                HSTACK(_firstChar, "", 0)
                            ),
                            _split, REDUCE(_init, SEQUENCE(1, _len - 1, 2),
                                LAMBDA(_acc, _curr,
                                    LET(
                                        _accLastCol, COLUMNS(_acc),
                                        _currChar, MID(_rowText, _curr, 1),
                                        IF((_limit > 1) * (_accLastCol - 2 = _limit),
                                            HSTACK(
                                                TAKE(_acc, 1, _accLastCol - 2),
                                                CONCAT(INDEX(_acc, 1, _accLastCol - 1), _currChar),
                                                1
                                            ),
                                            LET(
                                                _lastMatch, INDEX(_acc, 1, _accLastCol),
                                                _thisMatch, fnMatchChar(_currChar),
                                                IF(_thisMatch,
                                                    IF(_lastMatch,
                                                        HSTACK(
                                                            TAKE(_acc, 1, _accLastCol - 2),
                                                            CONCAT(INDEX(_acc, 1, _accLastCol - 1), _currChar),
                                                            1
                                                        ),
                                                        HSTACK(TAKE(_acc, 1, _accLastCol - 1), _currChar, 1)
                                                    ),
                                                    HSTACK(CONCAT(INDEX(_acc, 1, 1), _currChar), DROP(TAKE(_acc, 1, _accLastCol - 1),, 1), 0)
                                                )
                                            )
                                        )
                                    )
                                )
                            ),
                            _splitLastCol, COLUMNS(_split),
                            IFS(
                                (_splitLastCol = 3) * (INDEX(_split, 1, 2) = "") * (INDEX(_split, 1, 3) = 0),
                                    HSTACK(0, INDEX(_split, 1, 1)),
                                INDEX(_split, 1, _splitLastCol) = 0,
                                    HSTACK(_splitLastCol - 1, DROP(_split, , -1), ""),
                                TRUE,
                                    HSTACK(_splitLastCol - 2, DROP(_split, , -1))
                            )
                        )
                    )
                )
            ),

            _rowCount, ROWS(Text),
            DROP(
                REDUCE(0, SEQUENCE(_rowCount),
                    LAMBDA(_acc, _curr,
                        VSTACK(
                            _acc,
                            fnSplitAround(NULLIFY(INDEX(Text, _curr, 1)))
                        )
                    )
                ), 1
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
SIFT_FOR_CHARS

Returns the characters found in a text string found from a given set of characters. An upper limit can be set
on the number of instances any character can be matched. Matching is case-insensitive by default.

Array compatible: Text parameter only

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | Matched characters, sorted

Parameters
----------------------------------------------------------------------------------------------------------------
Text            | text    | Text to sift
Chars           | text    | Characters to match
[InstanceLimit] | integer | Upper limit on instances for each character match
                |         | 0 for no limit
                |         | Defaults to 1
[CaseSensitive] | switch  | Match letter case
[Sort]          | switch  | Sort matched characters

Examples
----------------------------------------------------------------------------------------------------------------
SIFT_FOR_CHARS("CDA_b_B", "abc")
Returns: "CAb"

SIFT_FOR_CHARS("CDA_b_B_CDA_b_B", "AB", 0, 1, 1)
Returns: "AABB"
--------------------------------------------------------------------------------------------------------------*/
SIFT_FOR_CHARS = LAMBDA(Text, Chars, [InstanceLimit], [CaseSensitive], [Sort],
    IF((Text = "") + (Chars = ""), "",
        LET(
            _limit, IF(ISNUMBER(InstanceLimit), MAX(INT(InstanceLimit), 0), 1),
            _ignoreCase, N(CaseSensitive) = 0,
            _sort, N(Sort) <> 0,
            _targetChars, LET(
                _charArray, MID(Chars, SEQUENCE(LEN(Chars)), 1),
                IF(_ignoreCase, UNIQUE(_charArray),
                    UNIQUE(CODE(_charArray))
                 )
            ),

            fnMatchChar, LAMBDA(_refChars,
                BYROW(_refChars,
                    LAMBDA(_c,
                        LET(
                            _charMatches, IF(_ignoreCase,
                                _c = _targetChars,
                                CODE(_c) = _targetChars
                            ),
                            N(MAX(N(_charMatches)) <> 0)
                        )
                    )
                ) 
            ),

            fnTextJoin, LAMBDA(_textCol,
                LET(
                    _rowCount, ROWS(_textCol),
                    REDUCE("",  SEQUENCE(_rowCount),
                        LAMBDA(_acc, _curr,
                            CONCAT(_acc, INDEX(_textCol, _curr, 1))
                        )
                    )
                )
            ),

            fnSiftChars, LAMBDA(_text,
                LET(
                    _charList, MID(_text, SEQUENCE(LEN(_text)), 1),
                    _charFiltered, FILTER(_charList, fnMatchChar(_charList), {#N/A}),
                    _charCount, ROWS(_charFiltered),
                    IFS(
                        (_charCount = 1) * ISNA(INDEX(_charFiltered, 1, 1)), "",
                        (_limit = 0) * NOT(_sort), fnTextJoin(_charFiltered),
                        TRUE, LET(
                            _charIndexed, MAKEARRAY(_charCount, 2,
                                LAMBDA(_row, _col,
                                    IF(_col = 2, _row, INDEX(_charFiltered, _row, 1))
                                )
                            ),
                            _charSorted, IF(_ignoreCase,
                                SORTBY(_charIndexed, CHOOSECOLS(_charIndexed, 1), 1, CHOOSECOLS(_charIndexed, 2), 1),
                                SORTBY(_charIndexed, CHOOSECOLS(_charIndexed, 1), 1, IFERROR(CODE(CHOOSECOLS(_charIndexed, 1)), 0), 1, CHOOSECOLS(_charIndexed, 2), 1)
                            ),
                            _charResult, IF(_limit = 0, _charSorted,
                                LET(
                                    _instances, SCAN(0, SEQUENCE(_charCount),
                                        LAMBDA(_acc, _curr,
                                            IFS(
                                                _acc = 0, 1,
                                                _ignoreCase, IF(INDEX(_charSorted, _curr, 1) = INDEX(_charSorted, _curr - 1, 1), _acc + 1, 1),
                                                TRUE, IF(CODE(INDEX(_charSorted, _curr, 1)) = CODE(INDEX(_charSorted, _curr - 1, 1)), _acc + 1, 1)
                                            )
                                        )
                                    ),
                                    _charLimited, FILTER(_charSorted, _instances <= _limit),
                                    IF(_sort, _charLimited,
                                        SORTBY(_charLimited, CHOOSECOLS(_charLimited, 2), 1)
                                    ) 
                                )
                            ),
                            fnTextJoin(CHOOSECOLS(_charResult, 1))
                        )
                    )
                )
            ),

            MAP(Text,
                LAMBDA(_element,
                    fnSiftChars(NULLIFY(_element))
                )
            )
        )
    )
); 


/*##############################################################################################################
# TIMESPAN                                                                                                     #
##############################################################################################################*/


/*--------------------------------------------------------------------------------------------------------------
VALIDATE_TIMESPAN

Validate each element of a sexagesimal representation of a timespan.
A component can exceed its modulus if no higher order component is provided.

Array compatible: As columns

Output C[5]
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | decimal [0..]    | Days
 3 | decimal [0..24)  | Hours
 4 | decimal [0..60)  | Minutes
 5 | decimal [0..60)  | Seconds

Parameters
----------------------------------------------------------------------------------------------------------------
TimeSpan_C5 | array   C[2..5]  |
   Sign     | integer [-1,0,1] |
   Days     | decimal [0..]    | Fractional allowed if hours, minutes and seconds empty.
   Hours    | decimal [0..24)  | Fractional allowed if minutes and seconds empty.
   Minutes  | decimal [0..60)  | Fractional allowed if seconds empty.
   Seconds  | decimal [0..60)  | Fractional allowed
--------------------------------------------------------------------------------------------------------------*/
VALIDATE_TIMESPAN = LAMBDA(TimeSpan_C5,
    LET(
        fnValidateTimeSpan, LAMBDA(_timeSpan,
            LET(
                _colCount, COLUMNS(TimeSpan_C5),
                _colReturn, MIN(_colCount, 5),
                IFS(
                    (_colCount > 5) + (_colCount < 2), ({#REF!} * SEQUENCE(1, _colReturn)),
                    MAX(N(NOT(IS_EMPTY(_timeSpan)))) = 0, TAKE({"","","","",""}, 1, _colReturn),
                    TRUE, LET(
                        _sign, LET(
                            _s, INDEX(_timeSpan, 1, 1),
                            IFS(
                                ISERROR(_s), HSTACK(_s),
                                NOT(ISNUMBER(_s)), {#VALUE!},
                                MAX(N(_s = {-1,0,1})) = 0, {#NUM!},
                                TRUE, _s
                            )
                        ),
                        _isZeroed, IFERROR(_sign, 1) = 0,
                        _high, IFS(
                            NOT(IS_EMPTY(IFERROR(INDEX(_timeSpan, 1, 2), ""))), 1,
                            NOT(IS_EMPTY(IFERROR(INDEX(_timeSpan, 1, 3), ""))), 2,
                            NOT(IS_EMPTY(IFERROR(INDEX(_timeSpan, 1, 4), ""))), 3,
                            NOT(IS_EMPTY(IFERROR(INDEX(_timeSpan, 1, 5), ""))), 4,
                            TRUE, 0
                        ),
                        IF(_high = 0, HSTACK(_sign, ({#VALUE!} * SEQUENCE(1, _colCount-1))),
                            LET(
                                _low, IFS(
                                    NOT(IS_EMPTY(IFERROR(INDEX(_timeSpan, 1, 5),""))), 4,
                                    NOT(IS_EMPTY(IFERROR(INDEX(_timeSpan, 1, 4),""))), 3,
                                    NOT(IS_EMPTY(IFERROR(INDEX(_timeSpan, 1, 3),""))), 2,
                                    NOT(IS_EMPTY(IFERROR(INDEX(_timeSpan, 1, 2),""))), 1,
                                    TRUE, 0
                                ),
                                fnValidateComponentValue, LAMBDA(_idx, _modulus,
                                    IF((_high > _idx) + (_low < _idx), "",
                                        LET(
                                            _comp, INDEX(_timeSpan, 1, _idx + 1),
                                            IFS(
                                                ISERROR(_comp), HSTACK(_comp),
                                                NOT(ISNUMBER(_comp)), {#VALUE!},
                                                _comp < 0, {#NUM!},
                                                _isZeroed * (_comp > 0), {#NUM!},
                                                (_high < _idx) * (_comp >= _modulus), {#NUM!},
                                                (_low > _idx) * NOT(IS_INTEGER(_comp)), {#NUM!},
                                                TRUE, _comp
                                            )
                                        )
                                    )
                                ),
                                _days, fnValidateComponentValue(1, 0),
                                _hours, fnValidateComponentValue(2, 24),
                                _minutes, fnValidateComponentValue(3, 60),
                                _seconds, fnValidateComponentValue(4, 60),
                                TAKE(
                                    HSTACK(_sign, _days, _hours, _minutes, _seconds),
                                    1, _colCount
                                )
                            )
                        )
                    )
                )
            )
        ),

        _rowCount, ROWS(TimeSpan_C5),
        DROP(
            REDUCE("", SEQUENCE(_rowCount),
                LAMBDA(_acc, _curr,
                    VSTACK(
                        _acc,
                        fnValidateTimeSpan(NULLIFY(CHOOSEROWS(TimeSpan_C5, _curr)))
                    )
                )
            ), 1
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
IS_VALID_TIMESPAN

Tests if sexagesimal representation of a timespan is valid.
A component can exceed its modulus if no higher order component is provided.

Array compatible: As columns

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
----------------------------------------------------------------------------------------------------------------
TimeSpan_C5 | array   C[2..5]  |
   Sign     | integer [-1,0,1] |
   Days     | decimal [0..]    | Fractional allowed if hours, minutes and seconds empty.
   Hours    | decimal [0..24)  | Fractional allowed if minutes and seconds empty.
   Minutes  | decimal [0..60)  | Fractional allowed if seconds empty.
   Seconds  | decimal [0..60)  | Fractional allowed
--------------------------------------------------------------------------------------------------------------*/
IS_VALID_TIMESPAN = LAMBDA(TimeSpan_C5,
    BYROW(TimeSpan_C5,
        LAMBDA(_timeSpan,
            IF(MAX(N(NOT(IS_EMPTY(_timeSpan)))) = 0, FALSE,
                LET(
                    _validateTimeSpan, VALIDATE_TIMESPAN(_timeSpan),
                    MAX(N(ISERROR(_validateTimeSpan))) = 0
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
TIMESPAN

Returns a decimal timespan as a fraction of a day from a sexagesimal representation of time.
Note components exceeding their modulus will carry.

Array compatible: As columns

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Timespan as fraction of a day. Implicitly converts to Excel Date/Time type for non-negative
   |         | values.

Parameters
----------------------------------------------------------------------------------------------------------------
TimeSpan_C5 | array   C[2..5]  |
   Sign     | integer [-1,0,1] |
   Days     | decimal [0..]    | Fractional allowed if hours, minutes and seconds empty.
   Hours    | decimal [0..24)  | Fractional allowed if minutes and seconds empty.
   Minutes  | decimal [0..60)  | Fractional allowed if seconds empty.
   Seconds  | decimal [0..60)  | Fractional allowed
--------------------------------------------------------------------------------------------------------------*/
TIMESPAN = LAMBDA(TimeSpan_C5,
    BYROW(TimeSpan_C5,
        LAMBDA(_timeSpan,
            LET(
                _colCount, COLUMNS(_timeSpan),
                IFS(
                    (_colCount > 5) + (_colCount < 2), {#REF!},
                    MAX(N(ISERROR(_timeSpan))) = 1, {#VALUE!},
                    MAX(N(NOT(IS_EMPTY(_timeSpan)))) = 0, "",
                    TRUE, LET(
                        _sign, INDEX(_timeSpan, 1, 1),
                        _days, N(INDEX(_timeSpan, 1, 2)),
                        _hours, IF(_colCount < 3, 0, N(INDEX(_timeSpan, 1, 3))),
                        _minutes, IF(_colCount < 4, 0, N(INDEX(_timeSpan, 1, 4))),
                        _seconds, IF(_colCount < 5, 0, N(INDEX(_timeSpan, 1, 5))),
                        IFS(
                            NOT(ISNUMBER(_sign)), {#VALUE!},
                            MAX(N(_sign = {-1,0,1})) = 0, {#VALUE!},
                            _sign = 0, 0,
                            TRUE, _sign * (_days + (_hours / 24) + (_minutes / 1440) + (_seconds / 86400))
                        )
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
ROUND_TIMESPAN

Returns a decimal timespan value rounded to the specified low order component and precision level.

Array compatible: TimeSpan_D as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | TimeSpan

Parameters
----------------------------------------------------------------------------------------------------------------
TimeSpan_D  | decimal | Decimal timespan where a day = 1
[LowOrder]  | integer | Lowest-order component to round at. Defaults to Second.
            | [1..4]  |  1 - Day
            |         |  2 - Hour
            |         |  3 - Minute
            |         |  4 - Second
[Precision] | integer | Select precision level
            | [0..9]  | Defaults to 0
[Truncate]  | switch  | Round to precision by truncating components. Default is rounding to nearest.
--------------------------------------------------------------------------------------------------------------*/
ROUND_TIMESPAN = LAMBDA(TimeSpan_D, [LowOrder], [Precision], [Truncate],
    LET(
        _maxPrecision, 9,
        _lowOrder, IFS(
            NOT(ISNUMBER(LowOrder)), 4,
            LowOrder < 1, 1,
            LowOrder > 4, 4,
            TRUE, INT(LowOrder)
        ),
        _precision, IFS(
            NOT(ISNUMBER(Precision)), 0,
            Precision < 0, 0,
            Precision > _maxPrecision, _maxPrecision,
            TRUE, INT(Precision)
        ),
        _truncate, N(Truncate) <> 0,
        MAP(TimeSpan_D, 
            LAMBDA(_timeSpan,
                IFS(
                    ISERROR(_timeSpan), _timeSpan,
                    _timeSpan = "", "",
                    NOT(ISNUMBER(_timeSpan)), {#VALUE!},
                    _timeSpan = 0, 0,
                    _truncate, IFS(
                        _lowOrder = 1, ROUNDDOWN(_timeSpan, _precision),
                        _lowOrder = 2, ROUNDDOWN(_timeSpan * 24, _precision) / 24,
                        _lowOrder = 3, ROUNDDOWN(_timeSpan * 1440, _precision) / 1440,
                        _lowOrder = 4, ROUNDDOWN(_timeSpan * 86400, _precision) / 86400
                    ),
                    TRUE, IFS(
                        _lowOrder = 1, ROUND(_timeSpan, _precision),
                        _lowOrder = 2, ROUND(_timeSpan * 24, _precision) / 24,
                        _lowOrder = 3, ROUND(_timeSpan * 1440, _precision) / 1440,
                        _lowOrder = 4, ROUND(_timeSpan * 86400, _precision) / 86400
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
NORMALISE_TIMESPAN

Returns a normalised sexagesimal representation of a timespan where each component is within its modulus.

Array compatible: TimeSpan_C5 as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Days
 3 | integer [0..23]  | Hours
 4 | integer [0..59]  | Minutes
 5 | decimal [0..60)  | Seconds

Parameters
----------------------------------------------------------------------------------------------------------------
TimeSpan_C5 | array   C[2..5]  |
   Sign     | integer [-1,0,1] |
   Days     | decimal [0..]    |
   Hours    | decimal [0..]    |
   Minutes  | decimal [0..]    |
   Seconds  | decimal [0..]    |
--------------------------------------------------------------------------------------------------------------*/
NORMALISE_TIMESPAN = LAMBDA(TimeSpan_C5,
    LET(
        _maxPrecision, 9,
        
        fnNormalise, LAMBDA(_timeSpan_C5,
            LET(
                _timeSpan_D, TIMESPAN(_timeSpan_C5),
                RESOLVE_TIMESPAN(_timeSpan_D, 1, 4, _maxPrecision)
            )
        ),
        
        _rowCount, ROWS(TimeSpan_C5),
        DROP(
            REDUCE("", SEQUENCE(_rowCount),
                LAMBDA(_acc, _curr,
                    VSTACK(
                        _acc,
                        fnNormalise(NULLIFY(CHOOSEROWS(TimeSpan_C5, _curr)))
                    )
                )
            ), 1
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
RESOLVE_TIMESPAN

Returns the sexagesimal representation of a timespan value expressed from the specified high order component
and the given lowest order component rounded to the specified precision.

Array compatible: TimeSpan_D as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Days
 3 | integer [0..23]  | Hours
 4 | integer [0..59]  | Minutes
 5 | decimal [0..60)  | Seconds

Parameters
----------------------------------------------------------------------------------------------------------------
TimeSpan_D    | decimal | Decimal timespan where a day = 1
[HighOrder]   | integer | Highest-order component. Defaults to Day.
              | [1..4]  |  1 - Day
              |         |  2 - Hour
              |         |  3 - Minute
              |         |  4 - Second
[LowOrder]    | integer | Lowest-order component. Defaults to Second.
              | [1..4]  |  1 - Day
              |         |  2 - Hour
              |         |  3 - Minute
              |         |  4 - Second
[Precision]   | integer | Select precision level
              | [0..9]  | Null - Floating
[Truncate]    | switch  | Round to precision by truncating components. Default is rounding to nearest.
--------------------------------------------------------------------------------------------------------------*/
RESOLVE_TIMESPAN = LAMBDA(TimeSpan_D, [HighOrder], [LowOrder], [Precision], [Truncate],
    LET(
        _maxPrecision, 9,
        
        _lowOrder, IFS(
            NOT(ISNUMBER(LowOrder)), 4,
            LowOrder < 1, 4,
            LowOrder > 4, 4,
            TRUE, INT(LowOrder)
        ),
        
        _highOrder, LET(
            _high, IFS(
                NOT(ISNUMBER(HighOrder)), 1,
                HighOrder < 1, 1,
                HighOrder > 4, 4,
                TRUE, INT(HighOrder)
            ),
            IF(_high > _lowOrder, _lowOrder, _high)
        ),
        
        _float, NOT(ISNUMBER(Precision)),
        _truncate, ISNUMBER(Precision) * (N(Truncate) <> 0),
        _precision, IFS(
            _float, "",
            Precision < 0, 0,
            Precision > _maxPrecision, _maxPrecision,
            TRUE, INT(Precision)
        ),
        
        fnRoundLastComponent, LAMBDA(_number,
            IFS(
                _float, _number,
                _truncate, ROUNDDOWN(_number, _precision),
                TRUE, ROUND(_number, _precision)
            )
        ),

        fnCheckSign, LAMBDA(_sign, _d, _h, _m, _s,
            IFS(
                _s > 0, _sign,
                _m > 0, _sign,
                _h > 0, _sign,
                _d > 0, _sign,
                TRUE, 0
            )
        ),
           
        fnResolveTimeSpan, LAMBDA(_timeSpan,
            IFS(
                _timeSpan = "", {"", "", "", "", ""},
                NOT(ISNUMBER(_timeSpan)), {#VALUE!, "", "", "", ""},
                _timeSpan = 0, MAP(SEQUENCE(1,5),
                    LAMBDA(_n,
                        IFS(
                            _n = 1, 0,
                            _n - 1 < _highOrder, "",
                            _n - 1 > _lowOrder, "",
                            TRUE, 0
                        )
                    )
                ),
                TRUE, LET(
                    _absTimeSpan, ABS(_timeSpan),
                    _sign, SIGN(_timeSpan),
                    IFS(
                        _highOrder = 1, IFS(
                            _lowOrder = 4, LET(
                                _rDay, INT(_absTimeSpan),
                                _hours, MOD(_absTimeSpan, 1) * 24,
                                _rHour, INT(_hours),
                                _minutes, MOD(_hours, 1) * 60,
                                _rMinute, INT(_minutes),
                                _seconds, MOD(_minutes, 1) * 60,
                                // Round second last because arithmetic rounding of the timespan decimal value
                                // can bring in floating point errors.
                                // Sign checked for rounding down to zero.
                                // Second checked for rounding up to minute.
                                _rSecond, fnRoundLastComponent(_seconds),
                                _rSign, fnCheckSign(_sign, _rDay, _rHour, _rMinute, _rSecond),
                                IFS(
                                    _rSecond < 60, HSTACK(_rSign, _rDay, _rHour, _rMinute, _rSecond),
                                    _rMinute <= 58, HSTACK(_rSign, _rDay, _rHour, _rMinute + 1, 0),
                                    _rHour <= 22, HSTACK(_rSign, _rDay, _rHour + 1, 0, 0),
                                    TRUE, HSTACK(_rSign, _rDay + 1, 0, 0, 0)
                                )
                            ),
                        
                            _lowOrder = 3, LET(
                                _rDay, INT(_absTimeSpan),
                                _hours, MOD(_absTimeSpan, 1) * 24,
                                _rHour, INT(_hours),
                                _minutes, MOD(_hours, 1) * 60,
                                // Round minute last because arithmetic rounding of the timespan decimal value
                                // can bring in floating point errors.
                                // Sign checked for rounding down to zero.
                                // Minute checked for rounding up to hour.
                                _rMinute, fnRoundLastComponent(_minutes),
                                _rSign, fnCheckSign(_sign, _rDay, _rHour, _rMinute, 0),
                                IFS(
                                    _rMinute < 60, HSTACK(_rSign, _rDay, _rHour, _rMinute, ""),
                                    _rHour <= 22, HSTACK(_rSign, _rDay, _rHour + 1, 0, ""),
                                    TRUE, HSTACK(_rSign, _rDay + 1, 0, 0, "")
                                )
                            ),
                            _lowOrder = 2, LET(
                                _rDay, INT(_absTimeSpan),
                                _hours, MOD(_absTimeSpan, 1) * 24,
                                // Round hour last because arithmetic rounding of the timespan decimal value
                                // can bring in floating point errors.
                                // Sign checked for rounding down to zero.
                                // Hour checked for rounding up to day.
                                _rHour, fnRoundLastComponent(_hours),
                                _rSign, fnCheckSign(_sign, _rDay, _rHour, 0, 0),
                                IFS(
                                    _rHour < 24, HSTACK(_rSign, _rDay, _rHour, "", ""),
                                    TRUE, HSTACK(_rSign, _rDay + 1, 0, "", "")
                                )
                            ),
                            _lowOrder = 1, LET(
                                _rDay, fnRoundLastComponent(_absTimeSpan),
                                _rSign, fnCheckSign(_sign, _rDay, 0, 0, 0),
                                HSTACK(_rSign, _rDay, "", "", "")
                            )
                        ),

                        _highOrder = 2, IFS(
                            _lowOrder = 4, LET(
                                _hours, _absTimeSpan * 24,
                                _rHour, INT(_hours),
                                _minutes, MOD(_hours, 1) * 60,
                                _rMinute, INT(_minutes),
                                _seconds, MOD(_minutes, 1) * 60,
                                // Round second last because arithmetic rounding of the timespan decimal value
                                // can bring in floating point errors.
                                // Sign checked for rounding down to zero.
                                // Second checked for rounding up to minute.
                                _rSecond, fnRoundLastComponent(_seconds),
                                _rSign, fnCheckSign(_sign, 0, _rHour, _rMinute, _rSecond),
                                IFS(
                                    _rSecond < 60, HSTACK(_rSign, "", _rHour, _rMinute, _rSecond),
                                    _rMinute <= 58, HSTACK(_rSign, "", _rHour, _rMinute + 1, 0),
                                    TRUE, HSTACK(_rSign, "", _rHour + 1, 0, 0)
                                )
                            ),
                        
                            _lowOrder = 3, LET(
                                _hours, _absTimeSpan * 24,
                                _rHour, INT(_hours),
                                _minutes, MOD(_hours, 1) * 60,
                                // Round minute last because arithmetic rounding of the timespan decimal value
                                // can bring in floating point errors.
                                // Sign checked for rounding down to zero.
                                // Minute checked for rounding up to hour.
                                _rMinute, fnRoundLastComponent(_minutes),
                                _rSign, fnCheckSign(_sign, 0, _rHour, _rMinute, 0),
                                IF(_rMinute < 60,
                                    HSTACK(_rSign, "", _rHour, _rMinute, ""),
                                    HSTACK(_rSign, "", _rHour + 1, 0, "")
                                )
                            ),
                            _lowOrder = 2, LET(
                                _hours, _absTimeSpan * 24,
                                // Round hour last because arithmetic rounding of the timespan decimal value
                                // can bring in floating point errors.
                                // Sign checked for rounding down to zero.
                                // Hour checked for rounding up to day.
                                _rHour, fnRoundLastComponent(_hours),
                                _rSign, fnCheckSign(_sign, 0, _rHour, 0, 0),
                                HSTACK(_rSign, "", _rHour, "", "")
                            )
                        ),

                        _highOrder = 3, IFS(
                            _lowOrder = 4, LET(
                                _minutes, _absTimeSpan * 1440,
                                _rMinute, INT(_minutes),
                                _seconds, MOD(_minutes, 1) * 60,
                                // Round second last because arithmetic rounding of the timespan decimal value
                                // can bring in floating point errors.
                                // Sign checked for rounding down to zero.
                                // Second checked for rounding up to minute.
                                _rSecond, fnRoundLastComponent(_seconds),
                                _rSign, fnCheckSign(_sign, 0, 0, _rMinute, _rSecond),
                                IF(_rSecond < 60,
                                    HSTACK(_rSign, "", "", _rMinute, _rSecond),
                                    HSTACK(_rSign, "", "", _rMinute + 1, 0)
                                )
                            ),
                        
                            _lowOrder = 3, LET(
                                _minutes, _absTimeSpan * 1440,
                                // Round minute last because arithmetic rounding of the timespan decimal value
                                // can bring in floating point errors.
                                // Sign checked for rounding down to zero.
                                // Minute checked for rounding up to hour.
                                _rMinute, fnRoundLastComponent(_minutes),
                                _rSign, fnCheckSign(_sign, 0, 0, _rMinute, 0),
                                HSTACK(_rSign, "", "", _rMinute, "")
                            )
                        ),

                        _highOrder = 4, IFS(
                            _lowOrder = 4, LET(
                                _seconds, _absTimeSpan * 86400,
                                // Round second last because arithmetic rounding of the timespan decimal value
                                // can bring in floating point errors.
                                // Sign checked for rounding down to zero.
                                // Second checked for rounding up to minute.
                                _rSecond, fnRoundLastComponent(_seconds),
                                _rSign, fnCheckSign(_sign, 0, 0, 0, _seconds),
                                HSTACK(_rSign, "", "", "", _rSecond)
                            )
                        )
                    )
                )
            )
        ),

        _rowCount, ROWS(TimeSpan_D),
        DROP(
            REDUCE("", SEQUENCE(_rowCount),
                LAMBDA(_acc, _curr,
                    VSTACK(
                        _acc,
                        fnResolveTimeSpan(NULLIFY(INDEX(TimeSpan_D, _curr, 1)))
                    )
                )
            ), 1
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_TIMESPAN

Parses a text timespan expression into either decimal time or sexagesimal components.

Array compatible: TimeSpanText as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal [0..1] | Time of day as decimal fraction of a day.

Output when AsSexagesimal switch set
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Days
 3 | integer [0..23]  | Hours
 4 | integer [0..59]  | Minutes
 5 | decimal [0..60)  | Seconds

Parameters
----------------------------------------------------------------------------------------------------------------
TimeSpanText    | text   | Formatted TimeSpan
[AsSexagesimal] | switch | Output sexagesimal component parts

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_TIMESPAN("12:00")
Returns: 0.5

PARSE_TIMESPAN("24:00:01")
Returns: #NUM!  i.e. range is 0 to 24 hours 
--------------------------------------------------------------------------------------------------------------*/
PARSE_TIMESPAN = LAMBDA(TimeSpanText, [AsSexagesimal],
    LET(
        _asValue, N(AsSexagesimal) = 0,
        _logicTable, {
            // terms, pattern, high, low, skipLastCol, hasDecimal
            5, ".::.", 1, 4, FALSE, TRUE;   // d.hh:mm:ss.000
            4, ".::", 1, 4, FALSE, FALSE;   // d.hh:mm:ss
            4, "::.", 2, 4, FALSE, TRUE;    // h:mm:ss.000
            3, ".:", 1, 3, FALSE, FALSE;    // d.hh:mm
            3, "::", 2, 4, FALSE, FALSE;    // h:mm:ss
            3, ":.", 3, 4, FALSE, TRUE;     // m:ss.000
            2, ":", 2, 3, FALSE, FALSE;     // h:mm
            2, ".", 1, 1, FALSE, TRUE;      // d.000
            1, "", 1, 1, FALSE, FALSE;      // d
            6, "dhm.s", 1, 4, TRUE, TRUE;   // 0d 0h 0m 0.000s
            5, "dhms", 1, 4, TRUE, FALSE;   // 0d 0h 0m 0s
            5, "dh.m", 1, 3, TRUE, TRUE;    // 0d 0h 0.000m
            5, "hm.s", 2, 4, TRUE, TRUE;    // 0h 0m 0.000s
            4, "dhm", 1, 3, TRUE, FALSE;    // 0d 0h 0m
            4, "hms", 2, 4, TRUE, FALSE;    // 0h 0m 0s
            4, "d.h", 1, 2, TRUE, TRUE;     // 0d 0.000h
            4, "h.m", 2, 3, TRUE, TRUE;     // 0h 0.000m
            4, "m.s", 3, 4, TRUE, TRUE;     // 0m 0.000s
            3, "dh", 1, 2, TRUE, FALSE;     // 0d 0h
            3, "hm", 2, 3, TRUE, FALSE;     // 0h 0m
            3, "ms", 3, 4, TRUE, FALSE;     // 0m 0s
            3, ".d", 1, 1, TRUE, TRUE;      // 0.000d
            3, ".h", 2, 2, TRUE, TRUE;      // 0.000h
            3, ".m", 3, 3, TRUE, TRUE;      // 0.000m
            3, ".s", 4, 4, TRUE, TRUE;      // 0.000s
            2, "d", 1, 1, TRUE, FALSE;      // 0d
            2, "h", 2, 2, TRUE, FALSE;      // 0h
            2, "m", 3, 3, TRUE, FALSE;      // 0m
            2, "s", 4, 4, TRUE, FALSE;      // 0s
            6, "dh'.""", 1, 4, TRUE, TRUE;  // 0d 0h 0' 0.000"
            5, "dh'""", 1, 4, TRUE, FALSE;  // 0d 0h 0' 0"
            5, "dh.'", 1, 3, TRUE, TRUE;    // 0d 0h 0.000'
            5, "h'.""", 2, 4, TRUE, TRUE;   // 0h 0' 0.000"
            4, "dh'", 1, 3, TRUE, FALSE;    // 0d 0h 0'
            4, "h'""", 2, 4, TRUE, FALSE;   // 0h 0' 0"
            4, "h.'", 2, 3, TRUE, TRUE;     // 0h 0.000'
            4, "'.""", 3, 4, TRUE, TRUE;    // 0' 0.000"
            3, "h'", 2, 3, TRUE, FALSE;     // 0h 0'
            3, "'""", 3, 4, TRUE, FALSE;    // 0' 0"
            3, ".'", 3, 3, TRUE, TRUE;      // 0.000'
            3, ".""", 4, 4, TRUE, TRUE;     // 0.000"
            2, "'", 3, 3, TRUE, FALSE;      // 0'
            2, """", 4, 4, TRUE, FALSE      // 0"
        },

        fnParseSexagesimal, LAMBDA(_timeSpanText,
            LET(
                _timeSpanText1, IF(IFERROR(FIND(" ", _timeSpanText), 0) = 0,
                    _timeSpanText,
                    IF(FIND_NTH_CHAR(_timeSpanText, "dh'""") > 0,
                        SUBSTITUTE(_timeSpanText, " ", ""),
                        {#VALUE!}
                    )
                ),
                _firstChar, LEFT(_timeSpanText1),
                _hasSign, IFS(
                    _firstChar = "+", TRUE,
                    _firstChar = "-", TRUE,
                    _firstChar = "", TRUE, //  UNICHAR(8722)
                    TRUE, FALSE
                ),
                _nominalSign, IFS(
                    _firstChar = "-", -1,
                    _firstChar = "", -1, //  UNICHAR(8722)
                    TRUE, 1
                ),
                _uTimeSpan, IF(_hasSign, MID(_timeSpanText1, 2, LEN(_timeSpanText1) - 1), _timeSpanText1),
                _split, SPLIT_FOR_CHARS(_uTimeSpan, "0123456789"),
                _terms, INDEX(_split, 1, 1), 
                _pattern, INDEX(_split, 1, 2),
                _match, FILTER(_logicTable, (CHOOSECOLS(_logicTable, 1) = _terms) * (CHOOSECOLS(_logicTable, 2) = _pattern), ""),
                IF(COLUMNS(_match) = 1, {#VALUE!},
                    LET( 
                        _high, INDEX(_match, 1, 3),
                        _low, INDEX(_match, 1, 4),
                        _nCols, _terms - N(INDEX(_match, 1, 5)),
                        _lastCol, 2 + _nCols,
                        _hasDecimals, INDEX(_match, 1, 6),
                        _expressedTerms, if(_hasDecimals,
                            LET(
                                _decimals, MIN(LEN(INDEX(_split, 1, _lastCol)), 9),
                                IFS(
                                    _nCols > 2,
                                        HSTACK(
                                            VALUE(DROP(TAKE(_split, 1, _lastCol - 2),, 2)),
                                            VALUE(INDEX(_split, 1, _lastCol - 1)) + (VALUE(LEFT(INDEX(_split, 1, _lastCol), _decimals)) / (10 ^ _decimals))
                                        ),
                                    _nCols = 2,
                                        HSTACK(
                                            VALUE(INDEX(_split, 1, _lastCol - 1)) + (VALUE(LEFT(INDEX(_split, 1, _lastCol), _decimals)) / (10 ^ _decimals))
                                        ),
                                    TRUE, {#VALUE!}
                                )
                            ),
                            HSTACK(
                                VALUE(DROP(TAKE(_split, 1, _lastCol),, 2))
                            )
                        ),
                        _trueSign, IF(MAX(N(_expressedTerms > 0)) = 0, 0, _nominalSign), 
                        IFS(
                            (_high = 1) * (_low = 4),
                                HSTACK(
                                    _trueSign,   
                                    _expressedTerms
                                ),
                            (_high > 1) * (_low = 4),
                                HSTACK(
                                    _trueSign,
                                    TAKE({"","",""}, 1, _high - 1),
                                    _expressedTerms
                                ),
                            (_high = 1) * (_low < 4),
                                HSTACK(
                                    _trueSign,
                                    _expressedTerms,
                                    TAKE({"","",""}, 1, 4 - _low)
                                ),
                            TRUE,
                                HSTACK(
                                    _trueSign,
                                    TAKE({"","",""}, 1, _high - 1),
                                    _expressedTerms,
                                    TAKE({"","",""}, 1, 4 - _low)
                                )
                        )
                    )
                )
            )
        ),
        
        _rowCount, ROWS(TimeSpanText),
        DROP(
            REDUCE("", SEQUENCE(_rowCount),
                LAMBDA(_acc, _curr,
                    LET(
                        _ts, NULLIFY(CHOOSEROWS(TimeSpanText, _curr)),
                        _out, IF(_asValue,
                            IFS(
                                _ts = "", "",
                                ISNUMBER(_ts), _ts,
                                TRUE, LET(
                                    _sexagesimal, fnParseSexagesimal(_ts),
                                    IF(ISERROR(INDEX(_sexagesimal, 1, 1)),
                                        {#VALUE!},
                                        TIMESPAN(_sexagesimal)
                                    )
                                )
                            ),
                            IF(
                                _ts = "", {"", "", "", "", ""},
                                fnParseSexagesimal(_ts)
                            )
                        ),
                        VSTACK(
                            _acc,
                            _out
                        )
                    )
                )
            ), 1
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
FORMAT_TIMESPAN

Returns a timespan as text in the specified format from a given decimal timespan.

Array compatible: TimeSpan_D as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | text    | Formatted timespan d.HH:mm:ss.000

Parameters
----------------------------------------------------------------------------------------------------------------
TimeSpan_D     | decimal | Decimal timespan where a day = 1
[Options]      | text    | String with elements: [T|E|B][+][P][_][HighOrder][LowOrder][~|<][Precision]
               |         |   T, E, B : Traditional, European or Basic style. Modern style when not present.
               |         |             Modern:      0.00:00:00.000
               |         |             Traditional: 0d 0h 0m 0.000s
               |         |             European:    0d 0h 0' 0.000"
               |         |             Basic:       000000.000 (hhmmss.000) Has a maximum magnitude < 100 hours
               |         |         + : Display positive sign for non-negative values
               |         |         P : Modern style: pad leading value with zero.
               |         |             Traditional and European styles: pad all values except first with zero.
               |         |             Basic style: not applicable, all components are fixed at double digits.
               |         |         _ : Insert spacing. Not applicable to modern and basic styles.
               |         | HighOrder : High order component. Upper case to set explicitly. Lower case allows floating
               |         |             from expressing in the given component up to days as needed.
               |         | LowOrder  : Low order component. Upper case to set explicitly. Lower case allows floating
               |         |             from expressing in the given component down to seconds as needed.
               |         | If only a single option is given, it is assumed to be LowOrder.
               |         | Both elements take the following:
               |         |      D, d : Day
               |         |      H, h : Hour
               |         |      M, m : Minute
               |         |      S, s : Second
               |         |      ~, < : Force rounding method of low order component: ~ round nearest, < round down
               |         |             If neither specified then defaults to behaviour of the style.
               |         |             Modern and Basic styles: Round down for days, hours and minutes; round to nearest for seconds.
               |         |             Traditional and European styles: When no precision specified round down for days,
               |         |             hours and minutes; round to nearest for seconds.
               |         | Precision : [0-9]
               |         |             Decimal places to display.
               |         |             Modern style: Only applies to seconds.
               |         |             Traditional and European styles: Applies to low order component.
               |         |             Basic style: not applicable.
Examples
----------------------------------------------------------------------------------------------------------------
FORMAT_TIMESPAN(1.7865, "")
Returns: 1.18:52:33.6

FORMAT_TIMESPAN(1.7865, "HS3")
Returns: 42:52:33.600

FORMAT_TIMESPAN(1.7865, "T+_HS")
Returns: + 42h 52m 33s"

FORMAT_TIMESPAN(1.7865, "ES")
Returns: 1h18h52'34"
--------------------------------------------------------------------------------------------------------------*/
FORMAT_TIMESPAN = LAMBDA(TimeSpan_D, [Options],
    LET(
        _options, IF(ISOMITTED(Options), "", Options),
        _style, LEFT(SIFT_FOR_CHARS(_options, "BET")),
        _signPositive, IFERROR(FIND("+", _options), 0) > 0,
        _padding, IFERROR(SEARCH("P", _options), 0) > 0,
        _spacing, IFERROR(FIND("_", _options), 0) > 0,
        _rounding, IFS(
            IFERROR(FIND("~", _options), 0) > 0, 1,
            IFERROR(FIND("<", _options), 0) > 0, -1,
            TRUE, 0
        ),

        // precision (max 9 decimals for nanoseconds)
        _precision, LET(
            _p, LEFT(SIFT_FOR_CHARS(_options, "0123456789")),
            IF(_p = "", "", VALUE(_p))
        ),

        _orderSpec, SIFT_FOR_CHARS(_options, "DHMS", 2),
        _high, IFS(
            _orderSpec = "", {0; 0},
            LEN(_orderSpec) = 1, {0; 0},
            TRUE, LET(
                _h, LEFT(_orderSpec),
                VSTACK(
                    N(CODE(_h) < 100),
                    XMATCH(_h, {"D", "H", "M", "S"}, 0)
                )
            )
        ),
        _hardHigh, INDEX(_high, 1),
        _highOrder, INDEX(_high, 2),

        _low, IF(_orderSpec = "", {0; 0},
            LET(
                _h, RIGHT(_orderSpec),
                VSTACK(
                    N(CODE(_h) < 100),
                    XMATCH(_h, {"D", "H", "M", "S"}, 0)
                )
            )
        ),
        _hardLow, INDEX(_low, 1),
        _lowOrder, INDEX(_low, 2),
        _sError, "#TIMESPAN!",

        fnCompose, LAMBDA(_provider,
            IF(NOT(ISNUMBER(INDEX(_provider, 1, 1))), _sError,
                LET(
                    _count, INDEX(_provider, 1, 2) - INDEX(_provider, 1, 1) + 1,
                    _designator, IF(INDEX(_provider, 3, 1) = "", "",
                        CONCAT(
                            INDEX(_provider, 3, 1),
                            IF(INDEX(_provider, 1, 6), " ", "")
                        )
                    ),
                    
                    REDUCE(_designator, SEQUENCE(_count),
                        LAMBDA(_acc, _n,
                            LET(
                                _fmt, IFS(
                                    _n = _count, INDEX(_provider, 1, 5),
                                    _n = 1, INDEX(_provider, 1, 3),
                                    TRUE, INDEX(_provider, 1, 4)
                                ),
                                _col, INDEX(_provider, 1, 1) + _n,
                                _part, TEXT(INDEX(_provider, 2, _col), _fmt),
                                _delim, INDEX(_provider, 3, _col),
                                _spc, IF(INDEX(_provider, 1, 6) * (_n < _count), " ", ""),
                                CONCAT(_acc, _part, _delim, _spc)
                            )
                        )
                    )
                )
            )
        ),

        fnFormatTimeSpan, LAMBDA(_timeSpan,
            IFS(
                IS_EMPTY(_timeSpan), "",
                NOT(ISNUMBER(_timeSpan)), {#VALUE!},
                TRUE, LET(
                    _provider, IFS(
                        _style = "T", _FORMAT_PROVIDER_SEXAGESIMAL_TRADITIONAL(_timeSpan, _signPositive, _padding, _spacing, _hardHigh, _highOrder, _hardLow, _lowOrder, _rounding, _precision),
                        _style = "E", _FORMAT_PROVIDER_SEXAGESIMAL_EUROPEAN(_timeSpan, _signPositive, _padding, _spacing, _hardHigh, _highOrder, _hardLow, _lowOrder, _rounding, _precision),
                        _style = "B", _FORMAT_PROVIDER_SEXAGESIMAL_BASIC(_timeSpan, _signPositive, _hardLow, _lowOrder, _rounding, _precision),
                        TRUE,         _FORMAT_PROVIDER_SEXAGESIMAL_MODERN(_timeSpan, _signPositive, _padding, _hardHigh, _highOrder, _hardLow, _lowOrder, _rounding,  _precision)
                        
                    ),

                    fnCompose(_provider)
                )
            )
        ),

        MAP(TimeSpan_D,
            LAMBDA(_element,
                fnFormatTimeSpan(_element)
            )
        )
    )
);


_FORMAT_PROVIDER_SEXAGESIMAL_MODERN = LAMBDA(TimeSpan_D, SignPositive, Padding, HardHigh, HighOrder, HardLow, LowOrder, Rounding, Precision,
    // Rounding: -1 always round down (truncate = 1)
    //            1 always round to nearest (truncate = 0)
    //            0 default: Days, Hours, Minutes round down
    //                       Seconds round to nearest
    
    LET(
        fnExpressedOrder, LAMBDA(_timeSpan, _direction,
            // _direction = -1 : low end
            //               1 : high end
            LET(
                _sign, INDEX(_timeSpan, 1, 1),
                IF(_sign = 0, {#N/A},
                    LET(
                        _nonZero, N((0 + IFERROR(DROP(_timeSpan, , 1), 1)) <> 0),
                        XMATCH(1, _nonZero, 0, _direction)
                    )
                )
            )
        ),

        _maxPrecision, 9,

        _resolveUsingSeconds, IFS(
            HardLow = 0, TRUE,
            LowOrder = 4, TRUE,
            TRUE, FALSE
        ),

        _resolvePrecision, IFS(
            NOT(_resolveUsingSeconds), 0,
            ISNUMBER(Precision), Precision,
            HardLow = 1, 0,
            TRUE, _maxPrecision
        ),
        
        _resolveTruncate, IFS(
            Rounding = 1, FALSE,
            Rounding = -1, TRUE,
            TRUE, NOT(_resolveUsingSeconds)
        ),

        _resolveHighOrder, IFS(
            HardHigh = 0, 1,
            // high order days or hours
            HighOrder <= 2, HighOrder,
            // modern style high order can only be minutes when seconds explicitly expressed with decimals
            (HighOrder = 3) * (HardLow = 1) * (LowOrder = 4) * (N(Precision) > 0), 3, 
            // otherwise high order is hours
            TRUE, 2
        ),

        _resolveLowOrder, IFS(
            HardLow = 0, 4,
            // modern style low order can only be minutes or seconds
            LowOrder >= 3, LowOrder,
            // otherwise low order is minutes
            TRUE, 3
        ),
        
        _resolveTimeSpan, RESOLVE_TIMESPAN(TimeSpan_D, _resolveHighOrder, _resolveLowOrder, _resolvePrecision, _resolveTruncate),

        _showLowOrder, IF(HardLow, _resolveLowOrder,
            // floating
            LET(
                // modern style low order can only be minutes or seconds
                _minLowOrder, IF(LowOrder = 4, 4, 3),
                _hasLowOrder, IFNA(fnExpressedOrder(_resolveTimeSpan, -1), _minLowOrder),
                MAX(_minLowOrder, _hasLowOrder)
            )
        ),

        _maxFractionalDigits, IFS(
            ISNUMBER(Precision), Precision,
            HardLow = 1, 0,
            TRUE, _maxPrecision
        ),

        _showFractionalDigits, IFS(
            NOT(_resolveUsingSeconds), 0,
            HardLow = 1, _maxFractionalDigits,
            TRUE, MIN(DECIMALS(INDEX(_resolveTimeSpan, 1, 5)), _maxFractionalDigits)
        ),

        _showHighOrder, IF(HardHigh, _resolveHighOrder,
            // floating    
            LET(
                // modern style floating high order can only be days or hours
                _maxHighOrder, IF(HighOrder = 1, 1, 2),
                _hasHighOrder, IFNA(fnExpressedOrder(_resolveTimeSpan, 1), _maxHighOrder),
                MIN(_maxHighOrder, _hasHighOrder)
            )
        ),
        
        _leadFmt, IF(Padding, "00", "0"),
        _midFmt, "00",
        _lastFmt, IF(_showFractionalDigits = 0, _midFmt,
            CONCAT(_midFmt, LEFT(".000000000", _showFractionalDigits + 1))
        ),
        
        _designator, IFS(
            INDEX(_resolveTimeSpan, 1, 1) < 0, "", //  UNICHAR(8722)
            SignPositive, "+",
            TRUE, ""
        ),

        _delims, IF(_showLowOrder = 4,
            {".", ":", ":", ""},
            {".", ":", "", ""}
        ),
        
        VSTACK(
            HSTACK(_showHighOrder, _showLowOrder, _leadFmt, _midFmt, _lastFmt, FALSE),
            _resolveTimeSpan,
            HSTACK(_designator, _delims, _showFractionalDigits)
        )
    )
);


_FORMAT_PROVIDER_SEXAGESIMAL_TRADITIONAL = LAMBDA(TimeSpan_D, SignPositive, Padding, Spacing, HardHigh, HighOrder, HardLow, LowOrder, Rounding, Precision,
    // Rounding: -1 always round down (truncate = 1)
    //            1 always round to nearest (truncate = 0)
    //            0 default: Always round to nearest when specifying Precision
    //                       Otherwise Days, Hours and Minutes round down
    //                       Seconds round to nearest
    
    LET(
        fnExpressedOrder, LAMBDA(_timeSpan, _direction,
            // _direction = -1 : low end
            //               1 : high end
            LET(
                _sign, INDEX(_timeSpan, 1, 1),
                IF(_sign = 0, {#N/A},
                    LET(
                        _nonZero, N((0 + IFERROR(DROP(_timeSpan, , 1), 1)) <> 0),
                        XMATCH(1, _nonZero, 0, _direction)
                    )
                )
            )
        ),

        _maxPrecision, 9,

        _setPrecision, ISNUMBER(Precision),
        _resolvePrecision, IFS(
            _setPrecision, Precision,
            HardLow = 1, 0,
            TRUE, _maxPrecision
        ),
        
        _resolveHighOrder, IF(HardHigh = 0, 1, HighOrder),
        _resolveLowOrder, IF(HardLow = 0, 4, LowOrder),

        _resolveTruncate, IFS(
            Rounding = 1, FALSE,
            Rounding = -1, TRUE,
            _resolveLowOrder = 4, FALSE,
            TRUE, (_resolvePrecision = 0)
        ),
        
        _resolveTimeSpan, RESOLVE_TIMESPAN(TimeSpan_D, _resolveHighOrder, _resolveLowOrder, _resolvePrecision, _resolveTruncate),

        _showLowOrder, IF(HardLow, _resolveLowOrder,
            // floating
            LET(
                _hasLowOrder, IFNA(fnExpressedOrder(_resolveTimeSpan, -1), IF(LowOrder = 0, 4, LowOrder)),
                MAX(LowOrder, _hasLowOrder)
            )
        ),

        _showFractionalDigits, IF(HardLow = 1, _resolvePrecision,
            MIN(DECIMALS(INDEX(_resolveTimeSpan, 1, _showLowOrder + 1)), _resolvePrecision)
        ),

        _showHighOrder, IF(HardHigh, _resolveHighOrder,
            // floating
            LET(
                _hasHighOrder, IFNA(fnExpressedOrder(_resolveTimeSpan, 1), _showLowOrder),
                IF(HighOrder = 0, _hasHighOrder, 
                    MIN(HighOrder, _hasHighOrder)
                )
            )
        ),
        
        _leadFmt, "0",
        _midFmt, IF(Padding, "00", "0"),
        _lastFmt, IF(_showFractionalDigits = 0, _midFmt,
            CONCAT(_midFmt, LEFT(".000000000", _showFractionalDigits + 1))
        ),
        
        _designator, IFS(
            INDEX(_resolveTimeSpan, 1, 1) < 0, "", //  UNICHAR(8722)
            SignPositive, "+",
            TRUE, ""
        ),

        _delims, {"d", "h", "m", "s"},
        
        VSTACK(
            HSTACK(_showHighOrder, _showLowOrder, _leadFmt, _midFmt, _lastFmt, Spacing),
            _resolveTimeSpan,
            HSTACK(_designator, _delims, _showFractionalDigits)
        )
    )
);


_FORMAT_PROVIDER_SEXAGESIMAL_EUROPEAN = LAMBDA(TimeSpan_D, SignPositive, Padding, Spacing, HardHigh, HighOrder, HardLow, LowOrder, Rounding, Precision,
    // Rounding: -1 always round down (truncate = 1)
    //            1 always round to nearest (truncate = 0)
    //            0 default: Always round to nearest when specifying Precision
    //                       Otherwise Days, Hours and Minutes round down
    //                       Seconds round to nearest

    LET(
        _provider, _FORMAT_PROVIDER_SEXAGESIMAL_TRADITIONAL(TimeSpan_D, SignPositive, Padding, Spacing, HardHigh, HighOrder, HardLow, LowOrder, Rounding, Precision),
        IF(NOT(ISNUMBER(INDEX(_provider, 1, 1))), INDEX(_provider, 1, 1),
            LET(
                _designator, INDEX(_provider, 3, 1),
                _showFractionalDigits, INDEX(_provider, 3, 6),
                _delims, {"d", "h", "'", """"},
                VSTACK(
                    CHOOSEROWS(_provider, 1, 2),
                    HSTACK(_designator, _delims, _showFractionalDigits)
                )
            )
        )
    )
);


_FORMAT_PROVIDER_SEXAGESIMAL_BASIC = LAMBDA(TimeSpan_D, SignPositive, HardLow, LowOrder, Rounding, Precision,
    // Rounding: -1 always round down (truncate = 1)
    //            1 always round to nearest (truncate = 0)
    //            0 default: Days, Hours, Minutes round down
    //                       Seconds round to nearest

    LET(
        _padding, 1,
        _hardHigh, 1,
        _highOrder, 2,
        _provider, _FORMAT_PROVIDER_SEXAGESIMAL_MODERN(TimeSpan_D, SignPositive, _padding, _hardHigh, _highOrder, HardLow, LowOrder, Rounding, Precision),
        _maxHours, 100,
        _outOfRange, INDEX(_provider, 2, 3) >= _maxHours,
        IF(_outOfRange, {#NUM!},
            LET(
                _designator, INDEX(_provider, 3, 1),
                _showFractionalDigits, INDEX(_provider, 3, 6),
                _delims, {"", "", "", ""},
                VSTACK(
                    CHOOSEROWS(_provider, {1, 2}),
                    HSTACK(_designator, _delims, _showFractionalDigits)
                )
            )
        )
    )
);






/*##############################################################################################################
# CALENDAR DATE                                                                                                #
##############################################################################################################*/


/*--------------------------------------------------------------------------------------------------------------
YEAR_BCE_TO_CE

Converts to year value relative to the Common Era for a given year Before Common Era.
Function is symmetrical, can also be used for CE to BCE conversion.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | 1 BCE = 0, 2 BCE = -1

Parameters
----------------------------------------------------------------------------------------------------------------
Year  | integer | Where 1 is first year Before Common Era
--------------------------------------------------------------------------------------------------------------*/
YEAR_BCE_TO_CE = LAMBDA(Year,
    IFS(
        ISERROR(Year), Year,
        Year = "", "",
        NOT(ISNUMBER(Year)), {#VALUE!},
        TRUE, 1 - INT(Year)
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_MONTH

Returns a number representing the month of year from a given text month name.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [1..12] | Month

Parameters
----------------------------------------------------------------------------------------------------------------
MonthText | text | Month name

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_MONTH("Feb")
Returns: 2

PARSE_MONTH("January")
Returns: 1

PARSE_MONTH("J")
Returns: #VALUE!

PARSE_MONTH("Marzo")
Returns: 3 (if local language is set to Italian)
--------------------------------------------------------------------------------------------------------------*/
PARSE_MONTH = LAMBDA(MonthText,
    IF(MonthText = "", "",
        MONTH(DATEVALUE(CONCAT(MonthText, " 2000")))
    )
);


/*--------------------------------------------------------------------------------------------------------------
MONTH_NAME

Returns a month as text.

Array compatible: Month only

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | Month name

Parameters
----------------------------------------------------------------------------------------------------------------
Month                  | integer [1..12] | Month. For values outside of range modulus is taken.
[Short]                | switch          | Return short format Jan..Dec
[InternationalEnglish] | switch          | International English instead of local language set in Excel
--------------------------------------------------------------------------------------------------------------*/
MONTH_NAME = LAMBDA(Month, [Short], [InternationalEnglish],
    LET(
        _useShort, N(Short) <> 0,
        _fmt, IF(_useShort, "MMM", "MMMM"),
        _useLocalLang, N(InternationalEnglish) = 0,
        fnMonthName, LAMBDA(_m,
            IFS(
                _m = "", {""},
                NOT(ISNUMBER(_m)), {#VALUE!},
                TRUE, LET(
                    _month, MOD(INT(_m) - 1, 12) + 1,
                    IF(_useLocalLang,
                        LET(
                            _dayOfMonth, DATE(2000, _month, 1),
                            TEXT(_dayOfMonth, _fmt)
                        ),
                        IF(_useShort,
                            INDEX(
                                {
                                    "Jan";
                                    "Feb";
                                    "Mar";
                                    "Apr";
                                    "May";
                                    "Jun";
                                    "Jul";
                                    "Aug";
                                    "Sep";
                                    "Oct";
                                    "Nov";
                                    "Dec"
                                },
                                _month
                            ),
                            INDEX(
                                {
                                    "January";
                                    "February";
                                    "March";
                                    "April";
                                    "May";
                                    "June";
                                    "July";
                                    "August";
                                    "September";
                                    "October";
                                    "November";
                                    "December"
                                },
                                _month
                            )
                        )
                    )
                )
            )
        ),

        MAP(Month,
            LAMBDA(_element, fnMonthName(_element))
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
IS_LEAP_YEAR

Tests if a year includes a leap day in the given calendar.

Array compatible: YearCE only

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean | null if empty

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE           | decimal | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
IS_LEAP_YEAR = LAMBDA(YearCE, [JulianCalendar],
    LET(
        _gregorian, N(JulianCalendar) = 0,
        fnIsLeapYear, LAMBDA(_yearCE,
            IFS(
                _yearCE = "", "",
                NOT(ISNUMBER(_yearCE)), {#VALUE!},
                TRUE, LET(
                    _iYear, INT(_yearCE),
                    IF(_gregorian,
                        IFS(
                            MOD(_iYear, 400) = 0, TRUE,
                            MOD(_iYear, 100) = 0, FALSE,
                            TRUE, MOD(_iYear, 4) = 0
                        ),
                        MOD(_iYear, 4) = 0
                    )
                )
            )
        ),

        MAP(YearCE,
            LAMBDA(_element, fnIsLeapYear(_element))
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
DAYS_IN_YEAR

Returns number of days in the given year of the specified calendar.

Array compatible: YearCE only

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [365,366]

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE           | integer | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian proleptic
                 |         | calendar.
--------------------------------------------------------------------------------------------------------------*/
DAYS_IN_YEAR = LAMBDA(YearCE, [JulianCalendar],
    LET(
        _julianCalendar, N(JulianCalendar) <> 0,
        
        MAP(YearCE,
            LAMBDA(_yearCE,
                IFS(
                    _yearCE = "", {""},
                    IS_LEAP_YEAR(_yearCE, _julianCalendar), 366,
                    TRUE, 365
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
DAYS_IN_MONTH

Returns number of days in the given month and year of the specified calendar.

Array compatible: Month, YearCE as columns

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [1..31]

Parameters
----------------------------------------------------------------------------------------------------------------
Month            | integer [1..12] | Month of year
[YearCE]         | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
DAYS_IN_MONTH = LAMBDA(Month, [YearCE], [JulianCalendar],
    LET(
        _julianCalendar, N(JulianCalendar) <> 0,
        _rowCount, ROWS(Month),
        BYROW(SEQUENCE(_rowCount),
            LAMBDA(_row,
                LET(
                    _m, INDEX(Month, _row, 1),
                    IFS(
                        _m = "", {""},
                        NOT(ISNUMBER(_m)), {#VALUE!},
                        TRUE, LET(
                            _iMonth, INT(_m),
                            IFS(
                                _iMonth < 1, {#NUM!},
                                _iMonth > 12, {#NUM!},

                                // February
                                _iMonth = 2, LET(
                                    _y, INDEX(YearCE, _row, 1),
                                    _leapDay, IFERROR(N(IS_LEAP_YEAR(_y, _julianCalendar)), 0),
                                    28 + _leapDay
                                ),

                                // Jan, Mar, Apr, May, Jun, Jul
                                _iMonth <= 7, 30 + MOD(_iMonth, 2),
                                
                                // Aug, Sep, Oct, Nov, Dec
                                TRUE, 31 - MOD(_iMonth, 2)
                            )
                        )
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
VALIDATE_CALENDAR_DATE

Validate a year, month and day representation of a date in a given calendar.

Array compatible: Date_YMD as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer          | YearCE
 2 | integer [1..12]  | Month
 3 | integer [1..366] | Day

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YMD         | array   C[1..3]  |
   YearCE        | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
   [Month]       | integer [1..12]  | Month of year. Can be empty.
   [Day]         | decimal [0..367) | Day. Ordinal day of year if month empty. Can be empty.
[JulianCalendar] | switch           | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                  | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
VALIDATE_CALENDAR_DATE = LAMBDA(Date_YMD, [JulianCalendar],
    LET(
        _julianCalendar, N(JulianCalendar) <> 0,
        fnValidateDate, LAMBDA(_ymd,
            IF(COLUMNS(_ymd) > 3, {#REF!, "", ""},
                LET(
                    _ymd1, IFNA(_ymd, ""),
                    IF(MAX(N(NOT(CALENDAR.IS_EMPTY(_ymd)))) = 0, {"", "", ""},
                        LET(
                            _y, INDEX(_ymd1, 1, 1),
                            _m, INDEX(_ymd1, 1, 2),
                            _d, INDEX(_ymd1, 1, 3),
                            
                            _yearIsInt, IS_INTEGER(_y),
                            _year, IFS(
                                ISERROR(_yearIsInt), {#VALUE!},
                                NOT(_yearIsInt), {#NUM!},
                                TRUE, _y
                            ),
                            
                            _monthIsInt, IS_INTEGER(_m),
                            _month, IFS(
                                IFNA(ERROR.TYPE(_m), 0) = 4, "",
                                _m = "", "",
                                ISERROR(_monthIsInt), {#VALUE!},
                                NOT(_monthIsInt), {#NUM!},
                                _m < 1, {#NUM!},
                                _m > 12, {#NUM!},
                                TRUE, _m
                            ),
                            
                            _day, IFS(
                                IFNA(ERROR.TYPE(_d), 0) = 4, "",
                                _d = "", "",
                                NOT(ISNUMBER(_d)), {#VALUE!},
                                TRUE, LET(
                                    _iDay, INT(_d),
                                    IFS(
                                        _iDay < 1, {#NUM!},
                                        _month = "", IFS(
                                            _iDay <= 365, _iDay,
                                            _iDay > 366, {#NUM!},
                                            IFERROR(IS_LEAP_YEAR(_year, _julianCalendar), FALSE), 366,
                                            TRUE, {#NUM!}
                                        ),
                                        _iDay <= DAYS_IN_MONTH(_month, _year, _julianCalendar), _iDay,
                                        TRUE, {#NUM!}
                                    )
                                )
                            ),
                            
                            HSTACK(_year, _month, _day)
                        )
                    )
                )
            )
        ),

        _rowCount, ROWS(Date_YMD),
        DROP(
            REDUCE("", SEQUENCE(_rowCount),
                LAMBDA(_acc, _curr,
                    LET(
                        _ymd, NULLIFY(CHOOSEROWS(Date_YMD, _curr)),
                        _validateDate_YMD, fnValidateDate(_ymd),
                        VSTACK(
                            _acc,
                            _validateDate_YMD
                        )
                    )
                )
            ), 1
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
IS_VALID_CALENDAR_DATE

Tests if a month and day representation of a date is valid for the specified calendar.

Array compatible: Date_YMD as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YMD         | array   C[1..3]  |
   YearCE        | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
   [Month]       | integer [1..12]  | Month of year. Can be empty.
   [Day]         | decimal [0..367) | Day. Ordinal day of year if month empty. Can be empty.
[JulianCalendar] | switch           | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                  | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
IS_VALID_CALENDAR_DATE = LAMBDA(Date_YMD, [JulianCalendar],
    LET(
        _julianCalendar, N(JulianCalendar) <> 0,
        BYROW(Date_YMD,
            LAMBDA(_date_YMD,
                IF(MAX(N(NOT(IS_EMPTY(_date_YMD)))) = 0, FALSE,
                    LET(
                        _validateDate, VALIDATE_CALENDAR_DATE(_date_YMD, _julianCalendar),
                        MAX(N(ISERROR(_validateDate))) = 0
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
NORMALISE_CALENDAR_DATE

Returns a normalised YMD representation of a date where each component is within its valid range.

Array compatible: Date_YMD as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day of month

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YMD         | array   C[1..3]  |
   YearCE        | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
   [Month]       | integer          | Month of year. Can be empty.
   [Day]         | decimal          | Day. Ordinal day of year if month empty. Can be empty.
[JulianCalendar] | switch           | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                  | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
NORMALISE_CALENDAR_DATE = LAMBDA(Date_YMD, [JulianCalendar],
    LET(
        _julianCalendar, N(JulianCalendar) <> 0,
       
        fnNormaliseDate, LAMBDA(_date_YMD,
            LET(
                _colCount, COLUMNS(_date_YMD),
                IFS(
                    _colCount > 3, {#REF!, "", ""},
                    MAX(N(NOT(IS_EMPTY(_date_YMD)))) = 0, {"", "", ""},
                    TRUE, LET(
                        _validateDate, VALIDATE_CALENDAR_DATE(_date_YMD, _julianCalendar),
                        _hasNonNumError, LET(
                            _errors, N(IFNA(ERROR.TYPE(_validateDate), 0)),
                            MAX((_errors > 0) * (_errors <> 6)) > 0
                        ),
                        IFS(
                            // year must be valid
                            ISERROR(INDEX(_validateDate, 1, 1)), _validateDate,
                            // #NUM! error for month or day can be normalised
                            _hasNonNumError, _validateDate,
                            // return if date is already valid and fully expressed
                            MAX(N(NOT(ISNUMBER(_validateDate)))) = 0, _validateDate,
                            TRUE, LET(
                                _hasMonth, IF(_colCount < 2, FALSE,
                                    NOT(IS_EMPTY(INDEX(_date_YMD, 1, 2)))
                                ),
                                _hasDay, IF(_colCount < 3, FALSE,
                                    NOT(IS_EMPTY(INDEX(_date_YMD, 1, 3)))
                                ),
                                _month0, IF(_hasMonth,
                                    INT(INDEX(_date_YMD, 1, 2)) - 1,
                                    ""
                                ),
                                _year, INT(INDEX(_date_YMD, 1, 1)) + IF(_hasMonth,
                                    INT(_month0 / 12),
                                    0
                                ),
                                _month, IF(_hasMonth,
                                    MOD(_month0, 12) + 1,
                                    1
                                ),
                                _day0, IF(_hasDay, 
                                    INT(INDEX(_date_YMD, 1, 3)) - 1,
                                    0
                                ),
                                _JDN_FirstOfMonth, _JULIAN_DAY_NUMBER(_year, _month, 1, _julianCalendar),
                                _JDN, _JDN_FirstOfMonth + _day0,
                                JDN_TO_CALENDAR_DATE(_JDN, _julianCalendar)
                            )
                        )
                    )
                )
            )
        ),

        _rowCount, ROWS(Date_YMD),
        DROP(
            REDUCE("", SEQUENCE(_rowCount),
                LAMBDA(_acc, _curr,
                    LET(
                        _ymd, NULLIFY(CHOOSEROWS(Date_YMD, _curr)),
                        _normalise_YMD, fnNormaliseDate(_ymd),
                        VSTACK(
                            _acc,
                            _normalise_YMD
                        )
                    )
                )
            ), 1
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_ISO_CALENDAR_DATE

Parses an ISO formatted calendar date into respective parts of year, month and day.

Array compatible: ISOCalendarDate as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | YearCE
 2 | integer | Month
 3 | integer | Day

Parameters
----------------------------------------------------------------------------------------------------------------
ISOCalendarDate  | text   | Date in ISO format ie. yyyy-MM-dd
[JulianCalendar] | switch | Validate in the Julian proleptic calendar. Default is Gregorian
                 |        | proleptic calendar.

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_ISO_CALENDAR_DATE("2023-05-23")
Returns: {2023, 5, 23}

PARSE_ISO_CALENDAR_DATE("1900-02-29", 1)
Returns: {2023, 2, 29} i.e. Feb 29, 1900 is valid in the Julian calendar
--------------------------------------------------------------------------------------------------------------*/
PARSE_ISO_CALENDAR_DATE = LAMBDA(ISOCalendarDate, [JulianCalendar],
    LET(
        _julianCalendar, N(JulianCalendar) <> 0,
        _validCharSet, "0123456789-+", //  UNICHAR(8722)

        fnParseISOCalendarDate, LAMBDA(_ISOCalendarDate,
            IFS(
                _ISOCalendarDate = "", {"", "", ""},
                NOT(VALIDATE_CHARSET(_ISOCalendarDate, _validCharSet)), {#VALUE!, "", ""},
                TRUE, LET(
                    _firstChar, LEFT(_ISOCalendarDate),
                    _isSigned, IFS(
                        _firstChar = "+", TRUE,
                        _firstChar = "-", TRUE,
                        _firstChar = "", TRUE, //  UNICHAR(8722)
                        TRUE, FALSE
                    ),
                    _sign, IFS(
                        NOT(_isSigned), 1,
                        _firstChar = "-", -1,
                        _firstChar = "", -1, //  UNICHAR(8722)
                        TRUE, 1
                    ),
                    _unSigned, IF(_isSigned,
                        RIGHT(_ISOCalendarDate, LEN(_ISOCalendarDate) - 1),
                        _ISOCalendarDate
                    ),
                    _len, LEN(_unSigned),
                    _pattern, REPLACE_CHARS(_unSigned, "0123456789", "_"),
                    _tryParse, IFS(
                        _len >= 10, IFS(
                            _pattern = RIGHT("_______________-__-__", _len),
                            HSTACK(
                                _sign * VALUE(LEFT(_unSigned, _len - 6)),
                                VALUE(MID(_unSigned, _len - 4, 2)),
                                VALUE(RIGHT(_unSigned, 2))
                            ),
                            _pattern = RIGHT("_______________-__", _len),
                            HSTACK(
                                _sign * VALUE(LEFT(_unSigned, _len - 3)),
                                VALUE(RIGHT(_unSigned, 2)),
                                ""
                            ),
                            _pattern = RIGHT("___________________", _len),
                            HSTACK(
                                _sign * VALUE(LEFT(_unSigned, _len - 4)),
                                VALUE(MID(_unSigned, _len - 3, 2)),
                                VALUE(RIGHT(_unSigned, 2))
                            ),
                            TRUE, ""
                        ),
                        _len >= 8, IFS(
                            _pattern = RIGHT("______-__", _len),
                            HSTACK(
                                _sign * VALUE(LEFT(_unSigned, _len - 3)),
                                VALUE(RIGHT(_unSigned, 2)),
                                ""
                            ),
                            _pattern = RIGHT("_________", _len),
                            HSTACK(
                                _sign * VALUE(LEFT(_unSigned, _len - 4)),
                                VALUE(MID(_unSigned, _len - 3, 2)),
                                VALUE(RIGHT(_unSigned, 2))
                            ),
                            TRUE, ""
                        ),
                        _len = 7, IF(
                            _pattern = "____-__",
                            HSTACK(
                                _sign * VALUE(LEFT(_unSigned, 4)),
                                VALUE(RIGHT(_unSigned, 2)),
                                ""
                            ),
                            ""
                        ),
                        (_len >= 4) * (_len <= 5),  IF(
                            _pattern = RIGHT("_____", _len),
                            HSTACK(
                                _sign * VALUE(_unSigned),
                                "",
                                ""
                            ),
                            ""
                        ),
                        TRUE, ""
                    ),

                    IF(INDEX(_tryParse, 1, 1) = "", {#VALUE!, #VALUE!, #VALUE!},
                        VALIDATE_CALENDAR_DATE(_tryParse, _julianCalendar)
                    )
                )
            )
        ),

        _rowCount, ROWS(ISOCalendarDate),
        DROP(
            REDUCE("", SEQUENCE(_rowCount),
                LAMBDA(_acc, _curr,
                    VSTACK(
                        _acc,
                        fnParseISOCalendarDate(NULLIFY(CHOOSEROWS(ISOCalendarDate, _curr)))
                    )
                )
            ), 1
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
FORMAT_ISO_CALENDAR_DATE

Returns a calendar date as text in ISO format.

Array compatible: Date_YMD as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | ISO formatted date

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YMD         | array   C[2..3]  |
   YearCE        | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
   [Month]       | integer [1..12]  | Month of year. Can be empty.
   [Day]         | decimal [0..367) | Day. Ordinal day of year if month empty. Can be empty.
[JulianCalendar] | switch           | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                  | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
FORMAT_ISO_CALENDAR_DATE = LAMBDA(Date_YMD, [Basic], [JulianCalendar],
    LET(
        _julianCalendar, N(JulianCalendar) <> 0,
        _basic, N(Basic) <> 0,
        _delim, IF(_basic, "", "-"),
        _sError, "#DATE!",

        fnFormatISOCalendarDate, LAMBDA(_date_YMD,
            IF(MAX(N(NOT(IS_EMPTY(_date_YMD)))) = 0, "",
                LET(
                    _validateDate, VALIDATE_CALENDAR_DATE(_date_YMD, JulianCalendar),
                    IFS(
                        MAX(N(ISERROR(_validateDate))) > 0, _sError,
                        _basic * (ABS(INDEX(_validateDate, 1, 1)) > 9999), _sError,
                        TRUE, LET(
                            _sYear, _FORMAT_ISO_YEAR(INDEX(_validateDate, 1, 1)), 
                            IF(INDEX(_validateDate, 1, 2) = "",
                                IF(INDEX(_validateDate, 1, 3) = "",
                                    _sYear,
                                    CONCAT(_sYear, _delim, TEXT(INDEX(_validateDate, 1, 3), "000"))
                                ),
                                LET(
                                    _sMonth, TEXT(INDEX(_validateDate, 1, 2), "00"),
                                    IF(INDEX(_validateDate, 1, 3) = "",
                                        IF(_basic, _sError,
                                            CONCAT(_sYear, _delim, _sMonth)
                                        ),
                                        CONCAT(_sYear, _delim, _sMonth, _delim, TEXT(INDEX(_validateDate, 1, 3), "00"))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ),

        BYROW(Date_YMD,
            LAMBDA(_date_YMD, fnFormatISOCalendarDate(_date_YMD))
        )
    )
);

_FORMAT_ISO_YEAR = LAMBDA(YearCE,
    LET(
        _sError, "#YEAR!",
        IFS(
            ISERROR(YearCE), _sError,
            YearCE = "", "",
            NOT(ISNUMBER(YearCE)), _sError,
            NOT(IS_INTEGER(YearCE)), _sError,
            TRUE, LET(
                _yearFmt, IF((YearCE >= 1000) * (YearCE <= 9999),
                    "0000;0000",
                    "+0000;0000" //  UNICHAR(8722)
                ),
                TEXT(YearCE, _yearFmt)
            )
        )
    )
);

_JULIAN_DAY_NUMBER = LAMBDA(YearCE, Month, Day, JulianCalendar,
    LET(
        _YEAR4801BCE, -4800,
        _G4801BCE_JD, -32045,
        _J4801BCE_JD, -32083,
        _DaysIn5MonthsFromMarch, 153,
        _month, INT(Month),
        _MarchShiftYear, INT((14 - _month) / 12),
        _years, INT(YearCE) - _YEAR4801BCE - _MarchShiftYear,
        _MarchShiftMonth, _month + (12 * _MarchShiftYear) - 3,
        _days, 365 * _years + INT(_years / 4) + INT((_DaysIn5MonthsFromMarch * _MarchShiftMonth + 2) / 5) + INT(Day),
        _days + IF(JulianCalendar,
            _J4801BCE_JD,
            _G4801BCE_JD - INT(_years / 100) + INT(_years / 400)
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
JULIAN_DAY_NUMBER

Returns the Julian Day Number (JDN) of the provided date in the specified calendar.
Note the Julian Day Number is an integer type and is an ordinal day number referenced from January 1,
4713 BC in the proleptic Julian calendar. It does not include any value for time of day.
If month and day are empty then returns JDN for January 1st of the year.

Array compatible: Date_YMD as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Julian Day Number

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YMD         | array   C[2..3]  |
   YearCE        | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
   [Month]       | integer [1..12]  | Month of year. Can be empty.
   [Day]         | decimal [0..367) | Day. Ordinal day of year if month empty. Can be empty.
[JulianCalendar] | switch           | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                  | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
JULIAN_DAY_NUMBER = LAMBDA(Date_YMD, [JulianCalendar],
    LET(
        _julianCalendar, N(JulianCalendar) <> 0,
            
        fnResolveJDN, LAMBDA(_date_YMD,
            IF(MAX(N(NOT(IS_EMPTY(_date_YMD)))) = 0, "",
                LET(
                    _validateDate, VALIDATE_CALENDAR_DATE(_date_YMD, _julianCalendar),
                    _firstError, TAKE(FILTER(_validateDate, ISERROR(_validateDate), ""), 1, 1),
                    IF(ISERROR(_firstError), _firstError,
                        LET(
                            _y, INDEX(_validateDate, 1, 1),
                            _m, INDEX(_validateDate, 1, 2),
                            _d, INDEX(_validateDate, 1, 3),
                            IF(_m = "",
                                LET(
                                    _JDN_JAN0, _JULIAN_DAY_NUMBER(_y, 1, 0, _julianCalendar),
                                    _JDN_JAN0 + IF(_d = "", 1, _d)
                                ),
                                IF(_d = "", 
                                    _JULIAN_DAY_NUMBER(_y, _m, 1, _julianCalendar),
                                    _JULIAN_DAY_NUMBER(_y, _m, _d, _julianCalendar)
                                )
                            )
                        )
                    )
                )
            )
        ),
                        
        BYROW(Date_YMD,
            LAMBDA(_date_YMD, fnResolveJDN(_date_YMD))
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
MODIFIED_JULIAN_DAY_NUMBER

Returns the Modified Julian Day Number (MJDN) of the provided date in the specified calendar.
Note the Modified Julian Day Number is an integer type and is an ordinal day number referenced from November 17,
1858 in the proleptic Gregorian calendar. It does not include any value for time of day.
If month and day are empty then returns MJDN for January 1st of the year.

Array compatible: Date_YMD as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Modified Julian Day Number

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YMD         | array   C[2..3]  |
   YearCE        | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
   [Month]       | integer [1..12]  | Month of year. Can be empty.
   [Day]         | decimal [0..367) | Day. Ordinal day of year if month empty. Can be empty.
[JulianCalendar] | switch           | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                  | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
MODIFIED_JULIAN_DAY_NUMBER = LAMBDA(Date_YMD, [JulianCalendar],
    LET(
        _JDN, JULIAN_DAY_NUMBER(Date_YMD, JulianCalendar),
        IF(NOT(ISNUMBER(_JDN)), _JDN,
            JDN_TO_MODIFIED(_JDN)
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
JDN_TO_MODIFIED

Converts a Julian Day Number (JDN) to a Modified Julian Day Number (MJDN).

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Modified Julian Day Number

Parameters
----------------------------------------------------------------------------------------------------------------
JDN | integer | Julian Day Number
--------------------------------------------------------------------------------------------------------------*/
JDN_TO_MODIFIED = LAMBDA(JDN,
    IFS(
        ISERROR(JDN), JDN,
        JDN = "", "",
        NOT(ISNUMBER(JDN)), {#VALUE!},
        TRUE, INT(JDN) - 2400001
    )
);


/*--------------------------------------------------------------------------------------------------------------
MODIFIED_TO_JDN

Converts a Modified Julian Day Number (MJDN) to a Julian Day Number (JDN).

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Julian Day Number

Parameters
----------------------------------------------------------------------------------------------------------------
MJDN | integer | Modified Julian Day Number
--------------------------------------------------------------------------------------------------------------*/
MODIFIED_TO_JDN = LAMBDA(MJDN,
    IFS(
        ISERROR(MJDN), MJDN,
        MJDN = "", "",
        NOT(ISNUMBER(MJDN)), {#VALUE!},
        TRUE, INT(MJDN) + 2400001
    )
);


/*--------------------------------------------------------------------------------------------------------------
JDN_TO_CALENDAR_DATE

Converts a Julian Day Number to a date in the specified calendar.

Array compatible: JDN as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day of month

Parameters
----------------------------------------------------------------------------------------------------------------
JDN              | integer | Julian Day Number
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
JDN_TO_CALENDAR_DATE = LAMBDA(JDN, [JulianCalendar],
    LET(
        _julianCalendar, N(JulianCalendar) <> 0,

        fnJDNtoCalendarDate, LAMBDA(_JDN,
            IFS(
                ISERROR(_JDN), HSTACK(_JDN, "", ""),
                _JDN = "", {"", "", ""},
                NOT(ISNUMBER(_JDN)), {#VALUE!, "", ""},
                TRUE, LET(
                    _YEAR4801BCE, -4800,
                    _DaysIn4Year, 1461,
                    _DaysInYear, 365,
                    _MonthCorrectionDays, 308,
                    _DaysIn4Months, 122,
                    _DaysIn5MonthsFromMarch, 153,
                    IF(_julianCalendar,
                        LET(
                            _J4801BCE_JD0, -32083,
                            _days0, INT(_JDN) - _J4801BCE_JD0 - 1,
                            _quadYr, INT(_days0 / _DaysIn4Year),
                            _days1, _days0 - _quadYr * _DaysIn4Year,
                            _remYr, INT((INT(_days1 / _DaysInYear) + 1) * 0.75),
                            _days2, _days1 - _remYr * _DaysInYear,
                            _y, _quadYr * 4 + _remYr,
                            _m, INT((_days2 * 5 + _MonthCorrectionDays) / _DaysIn5MonthsFromMarch) - 2,
                            _day, _days2 - INT((_m + 4) * _DaysIn5MonthsFromMarch / 5) +
                                _DaysIn4Months + 1,
                            _year, _YEAR4801BCE + _y + INT((_m + 2) / 12),
                            _month, MOD(_m + 2, 12) + 1,
                            HSTACK(_year, _month, _day)
                        ),
                        LET(
                            _G4801BCE_JD0, -32045,
                            _GregDaysIn400Year, 146097,
                            _GregDaysIn100Year, 36524,
                            _days0, INT(_JDN) - _G4801BCE_JD0 - 1,
                            _quadCent, INT(_days0 / _GregDaysIn400Year),
                            _days1, _days0 - _quadCent * _GregDaysIn400Year,
                            _remCent, INT((INT(_days1 / _GregDaysIn100Year) + 1) * 0.75),
                            _days2, _days1 - _remCent * _GregDaysIn100Year,
                            _quadYr, INT(_days2 / _DaysIn4Year),
                            _days3, _days2 - _quadYr * _DaysIn4Year,
                            _remYr, INT((INT(_days3 / _DaysInYear) + 1) * 0.75),
                            _days4, _days3 - _remYr * _DaysInYear,
                            _y, _quadCent * 400 + _remCent * 100 + _quadYr * 4 + _remYr,
                            _m, INT((_days4 * 5 + _MonthCorrectionDays) / _DaysIn5MonthsFromMarch) - 2,
                            _day, _days4 - INT((_m + 4) * _DaysIn5MonthsFromMarch / 5) +
                                _DaysIn4Months + 1,
                            _year, _YEAR4801BCE + _y + INT((_m + 2) / 12),
                            _month, MOD(_m + 2, 12) + 1,
                            HSTACK(_year, _month, _day)
                        )
                    )
                )
            )
        ),

        _rowCount, ROWS(JDN),
        DROP(
            REDUCE("", SEQUENCE(_rowCount),
                LAMBDA(_acc, _curr,
                    VSTACK(
                        _acc,
                        fnJDNtoCalendarDate(NULLIFY(INDEX(JDN, _curr, 1)))
                    )
                )
            ), 1
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
MJDN_TO_CALENDAR_DATE

Converts a Modified Julian Day Number (MJDN) to a date in the specified calendar.

Array compatible: MJDN as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day of month

Parameters
----------------------------------------------------------------------------------------------------------------
MJDN             | integer | Modified Julian Day Number
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
MJDN_TO_CALENDAR_DATE = LAMBDA(MJDN, [JulianCalendar],
    LET(
        _JDN, MODIFIED_TO_JDN(MJDN),
        JDN_TO_CALENDAR_DATE(_JDN, JulianCalendar)
    )
);


/*--------------------------------------------------------------------------------------------------------------
GREGORIAN_TO_JULIAN

Translates a date in the Gregorian proleptic calendar to the Julian proleptic calendar.

Array compatible: Date_YMD as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YMD         | array   C[2..3]  |
   YearCE        | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
   [Month]       | integer [1..12]  | Month of year. Can be empty.
   [Day]         | decimal [0..367) | Day. Ordinal day of year if month empty. Can be empty.
--------------------------------------------------------------------------------------------------------------*/
GREGORIAN_TO_JULIAN = LAMBDA(Date_YMD,
    LET(
        _JDN, JULIAN_DAY_NUMBER(Date_YMD, 0),
        JDN_TO_CALENDAR_DATE(_JDN, 1)
    )
);


/*--------------------------------------------------------------------------------------------------------------
JULIAN_TO_GREGORIAN

Translates a date in the Julian proleptic calendar to the Gregorian proleptic calendar.

Array compatible: Date_YMD as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YMD         | array   C[2..3]  |
   YearCE        | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
   [Month]       | integer [1..12]  | Month of year. Can be empty.
   [Day]         | decimal [0..367) | Day. Ordinal day of year if month empty. Can be empty.
--------------------------------------------------------------------------------------------------------------*/
JULIAN_TO_GREGORIAN = LAMBDA(Date_YMD,
    LET(
        _JDN, JULIAN_DAY_NUMBER(Date_YMD, 1),
        JDN_TO_CALENDAR_DATE(_JDN, 0)
    )
);


/*--------------------------------------------------------------------------------------------------------------
SECULAR_DIFFERENCE

Returns the number of days the Gregorian proleptic calendar is ahead of the Julian proleptic calendar for
a given date.

Array compatible: Date_YMD as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Days difference. Negative values are when the Julian proleptic calender is ahead.

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YMD             | array   C[2..3]  |
   YearCE            | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
   [Month]           | integer [1..12]  | Month of year. Can be empty.
   [Day]             | decimal [0..367) | Day. Ordinal day of year if month empty. Can be empty.
[FromJulianCalendar] | switch           | Provided date is in Julian calendar.
                     |                  | Default is the Gregorian calendar.
--------------------------------------------------------------------------------------------------------------*/
SECULAR_DIFFERENCE = LAMBDA(Date_YMD, [FromJulianCalendar],
    LET(
        _fromJulianCalendar, N(FromJulianCalendar) <> 0,
        
        fnFromGregorian, LAMBDA(_date_YMD,
            LET(
                _JDN_G, JULIAN_DAY_NUMBER(_date_YMD, 0),
                IFS(
                    ISERROR(_JDN_G), _JDN_G,
                    _JDN_G = "", "",
                    TRUE, LET(
                        _year, INDEX(_date_YMD, 1, 1),
                        _month, IFERROR(INDEX(_date_YMD, 1, 2), 1),
                        _day, IFERROR(INDEX(_date_YMD, 1, 3), 1),
                        _JDN_J, IF((_month = 2) * (_day = 29) * NOT(IS_LEAP_YEAR(_year, 1)),
                            JULIAN_DAY_NUMBER(HSTACK(_year, 2, 28), 1),
                            JULIAN_DAY_NUMBER(_date_YMD, 1)
                        ),
                        _JDN_J - _JDN_G
                    )
                )
            )
        ),
        
        fnFromJulian, LAMBDA(_date_YMD,
            LET(
                _date_G, JULIAN_TO_GREGORIAN(_date_YMD),
                IFS(
                    ISERROR(INDEX(_date_G, 1, 1)), INDEX(_date_G, 1, 1),
                    INDEX(_date_G, 1, 1) = "", "",
                    TRUE, fnFromGregorian(_date_G)
                )
            )
        ),

        IF(_fromJulianCalendar,
            BYROW(Date_YMD,
                LAMBDA(_date_YMD, fnFromJulian(_date_YMD))
            ),
            BYROW(Date_YMD,
                LAMBDA(_date_YMD, fnFromGregorian(_date_YMD))
            )
        )
    )
);






/*##############################################################################################################
# TIME OF DAY                                                                                                  #
##############################################################################################################*/


/*--------------------------------------------------------------------------------------------------------------
VALIDATE_TIME_OF_DAY

Validate each element of a sexagesimal representation of a time of day.

Array compatible: Time_HMS as columns

Output C[3]
----------------------------------------------------------------------------------------------------------------
 1 | integer [0..24]  | Hour
 2 | integer [0..59]  | Minute
 3 | decimal [0..60)  | Second

Parameters
----------------------------------------------------------------------------------------------------------------
Time_HMS       | array   C[3]    |
   Hour        | integer [0..24] |
   Minute      | integer [0..59] |
   Second      | decimal [0..60) | Fractional less than 60
[Accept24Hour] | switch          | Accept time of 24:00:00 to represent midnight next day.
--------------------------------------------------------------------------------------------------------------*/
VALIDATE_TIME_OF_DAY = LAMBDA(Time_HMS, [Accept24Hour],
    LET(
        _accept24hr, N(Accept24Hour) <> 0,
        
        fnValidateToD, LAMBDA(_time_HMS,
            LET(
                _colCount, COLUMNS(_time_HMS),
                IFS(
                    _colCount <> 3, {#REF!, "", ""},
                    MAX(N(NOT(IS_EMPTY(_time_HMS)))) = 0, {"", "", ""},
                    TRUE, LET(
                        _minute, LET(
                            _m, INDEX(_time_HMS, 1, 2),
                            IFS(
                                ISERROR(_m), HSTACK(_m),
                                NOT(ISNUMBER(_m)), {#VALUE!},
                                _m < 0, {#NUM!},
                                _m > 59, {#NUM!},
                                NOT(IS_INTEGER(_m)), {#NUM!},
                                TRUE, _m
                            )
                        ),
                        _second, LET(
                            _s, INDEX(_time_HMS, 1, 3),
                            IFS(
                                ISERROR(_s), HSTACK(_s),
                                NOT(ISNUMBER(_s)), {#VALUE!},
                                _s < 0, {#NUM!},
                                _s >= 60, {#NUM!},
                                TRUE, _s
                            )
                        ),
                        _hour, LET(
                            _h, INDEX(_time_HMS, 1, 1),
                            IFS(
                                ISERROR(_h), HSTACK(_h),
                                NOT(ISNUMBER(_h)), {#VALUE!},
                                _h < 0, {#NUM!},
                                _h > 24, {#NUM!},
                                NOT(IS_INTEGER(_h)), {#NUM!},
                                _h = 24, IFS(
                                    NOT(_accept24hr), {#NUM!},
                                    _minute > 0, {#NUM!},
                                    _second > 0, {#NUM!},
                                    TRUE, _h
                                ),
                                TRUE, _h
                            )
                        ),
                        HSTACK(_hour, _minute, _second)
                    )
                )
            )
        ),

        _rowCount, ROWS(Time_HMS),
        DROP(
            REDUCE("", SEQUENCE(_rowCount),
                LAMBDA(_acc, _curr,
                    VSTACK(
                        _acc,
                        fnValidateToD(NULLIFY(CHOOSEROWS(Time_HMS, _curr)))
                    )
                )
            ), 1
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
IS_VALID_TIME_OF_DAY

Tests if sexagesimal representation of time is valid for a 24 hour day.

Array compatible: As columns

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
----------------------------------------------------------------------------------------------------------------
Time_HMS       | array   C[3]    |
   Hour        | integer [0..24] |
   Minute      | integer [0..59] |
   Second      | decimal [0..60) | Fractional less than 60
[Accept24Hour] | switch          | Accept time of 24:00:00 to represent midnight next day.
--------------------------------------------------------------------------------------------------------------*/
IS_VALID_TIME_OF_DAY = LAMBDA(Time_HMS, [Accept24Hour],
    LET(
        _accept24hour, N(Accept24Hour) <> 0,
        BYROW(Time_HMS,
            LAMBDA(_time_HMS,
                IF(MAX(N(NOT(IS_EMPTY(_time_HMS)))) = 0, FALSE,
                    LET(
                        _validateToD, VALIDATE_TIME_OF_DAY(_time_HMS, _accept24hour),
                        MAX(N(ISERROR(_validateToD))) = 0
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_TIME_OF_DAY

Parses a formatted time of day into either decimal time of day or time complication.

Array compatible: TimeOfDay as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal [0..1] | Time of day as decimal fraction of a day. Implicitly equivalent to Excel Time value.

Output when AsSexagesimal switch set
----------------------------------------------------------------------------------------------------------------
 1 | integer [0..24]  | Hour
 2 | integer [0..59]  | Minute
 3 | decimal [0..60)  | Second

Parameters
----------------------------------------------------------------------------------------------------------------
TimeOfDay        | text   | Time in general format ie. h:mm:ss.000 AM/PM
[AsSexagesimal]  | switch | Output sexagesimal component parts
[RequireISO8601] | switch | Require TimeOfDay is explicitly in ISO8601 format.

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_TIME_OF_DAY("12:00")
Returns: 0.5

PARSE_TIME_OF_DAY("6 pm")
Returns: 0.75

PARSE_TIME_OF_DAY("24:00:01")
Returns: #NUM!  i.e. range is 0 to 24 hours 
--------------------------------------------------------------------------------------------------------------*/
PARSE_TIME_OF_DAY = LAMBDA(TimeOfDay, [AsSexagesimal], [RequireISO8601],
    LET(
        _asValue, N(AsSexagesimal) = 0,
        _strictISO, N(RequireISO8601) <> 0,
        _accept24hr, TRUE,
        _returnValErr, IF(_asValue, {#VALUE!}, {#VALUE!, "", ""}),
        _returnNumErr, IF(_asValue, {#NUM!}, {#NUM!, "", ""}),
        _returnEmpty, IF(_asValue, "", {"", "", ""}),
        _validCharsGeneral, "0123456789AMP :.",
        _validCharsISO, "0123456789:.",
        
        _generalLogicTable, {
            // terms, pattern, 24hr, hasDecimal, am/pm
            5, "::. am", FALSE, TRUE,  1;  // h:mm:ss.000 am
            5, "::.am",  FALSE, TRUE,  1;  // h:mm:ss.000am
            5, "::. pm", FALSE, TRUE,  2;  // h:mm:ss.000 pm
            5, "::.pm",  FALSE, TRUE,  2;  // h:mm:ss.000pm
            4, "::.",    TRUE,  TRUE,  0;  // H:mm:ss.000
            4, ":: am",  FALSE, FALSE, 1;  // h:mm:ss am 
            4, "::am",   FALSE, FALSE, 1;  // h:mm:ssam 
            4, ":: pm",  FALSE, FALSE, 2;  // h:mm:ss pm
            4, "::pm",   FALSE, FALSE, 2;  // h:mm:sspm
            3, "::",     TRUE,  FALSE, 0;  // H:mm:ss
            3, ": am",   FALSE, FALSE, 1;  // h:mm am
            3, ":am",    FALSE, FALSE, 1;  // h:mmam
            3, ": pm",   FALSE, FALSE, 2;  // h:mm pm
            3, ":pm",    FALSE, FALSE, 2;  // h:mmpm
            2, ":",      TRUE,  FALSE, 0;  // H:mm
            2, " am",    FALSE, FALSE, 1;  // h am
            2, "am",     FALSE, FALSE, 1;  // ham
            2, " pm",    FALSE, FALSE, 2;  // h pm
            2, "pm",     FALSE, FALSE, 2;  // hpm
            1, "",       TRUE,  FALSE, 0   // H
        },

        fnParseISO, LAMBDA(_timeOfDay,
            IF(CODE(_timeOfDay) <> 84, _returnValErr, // firstChar must be "T"
                LET(
                    _ISOtime, RIGHT(_timeOfDay, LEN(_timeOfDay) - 1),
                    IF(NOT(VALIDATE_CHARSET(_ISOtime, _validCharsISO)), _returnValErr,
                        LET(
                            _pattern, REPLACE_CHARS(_ISOtime, "0123456789", "0"),
                            _dotPos, IFERROR(FIND(".", _pattern), 0),
                            _lenDecimal, LEN(_pattern) - _dotPos,
                            _decPartError, IFS(
                                _dotPos = 0, FALSE,
                                _dotPos = 1, TRUE,
                                _dotPos = LEN(_pattern), TRUE,
                                TRUE, RIGHT(_pattern, _lenDecimal) <> REPT("0", _lenDecimal)
                            ),
                            IF(_decPartError, _returnValErr,
                                LET(
                                    _hmsPattern, IF(_dotPos = 0, _pattern,
                                        LEFT(_pattern, _dotPos - 1)
                                    ),
                                    _hms, IFS(
                                        _hmsPattern = "00:00:00",
                                            VALUE(MID(_ISOtime, {1, 4, 7}, 2)),
                                        _hmsPattern = "00:00",
                                            HSTACK(VALUE(MID(_ISOtime, {1, 4}, 2)), 0),
                                        _hmsPattern = "000000",
                                            VALUE(MID(_ISOtime, {1, 3, 5}, 2)),
                                        _hmsPattern = "0000",
                                            HSTACK(VALUE(MID(_ISOtime, {1, 3}, 2)), 0),
                                        _hmsPattern = "00",
                                            HSTACK(VALUE(MID(_ISOtime, 1, 2)), 0, 0),
                                        TRUE, {#VALUE!}
                                    ),
                                    IF(ISERROR(INDEX(_hms, 1, 1)), _returnValErr,
                                        LET(
                                            _fracSeconds, IF(_dotPos = 0, 0,
                                                LET(
                                                    _decimals, MIN(_lenDecimal, 9),
                                                    VALUE(MID(_ISOtime, _dotPos + 1, _decimals)) / (10 ^ _decimals)
                                                )
                                            ),
                                            _hmsf, HSTACK(DROP(_hms, , -1), INDEX(_hms, 1, 3) + _fracSeconds),
                                            _hmsf
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ),
        
        fnParseGeneral, LAMBDA(_timeOfDay,
            IF(NOT(VALIDATE_CHARSET(_timeOfDay, _validCharsGeneral)), _returnValErr,
                LET(
                    _split, SPLIT_FOR_CHARS(_timeOfDay, "0123456789"),
                    _countTerms, INDEX(_split, 1, 1),
                    IF(_countTerms = 0, _returnValErr,
                        IF(_countTerms > 5, _returnValErr,
                            LET(
                                _hint24hr, NULLIFY(INDEX(_split, 1, _countTerms + 2)) <> "",
                                _pattern, INDEX(_split, 1, 2),
                                _match, DROP(FILTER(_generalLogicTable, (CHOOSECOLS(_generalLogicTable, 1) = _countTerms) * (CHOOSECOLS(_generalLogicTable, 2) = _pattern) * (CHOOSECOLS(_generalLogicTable, 3) = _hint24hr), #N/A), , 3),
                                IF(ISNA(INDEX(_match, 1, 1)), _returnValErr,
                                    LET(
                                        _hasDecimal, INDEX(_match, 1, 1),
                                        _ampm, INDEX(_match, 1, 2),
                                        _terms, IF(_hint24hr,
                                            DROP(_split, , 2),
                                            DROP(DROP(_split, , 2), , -1)
                                        ),
                                        _hms, IF(_hasDecimal,
                                            HSTACK(
                                                DROP(_terms, , -2),
                                                CONCAT(CHOOSECOLS(_terms, -2), ".", LEFT(CHOOSECOLS(_terms, -1), 9))
                                            ),
                                            _terms
                                        ),
                                        _lowOrder, COLUMNS(_hms),
                                        _hms3, TAKE(HSTACK(VALUE(_hms), 0, 0), 1, 3),
                                        _hms24, IF(_ampm = 0, _hms3,
                                            LET(
                                                _h, INDEX(_hms3, 1, 1),
                                                _resolveH, IFS(
                                                    _h = 0, {#NUM!},
                                                    _h > 12, {#NUM!},
                                                    (_ampm = 1) * (_h = 12), 0,
                                                    (_ampm = 2) * (_h < 12), _h + 12,
                                                    TRUE, _h
                                                ),
                                                HSTACK(_resolveH, DROP(_hms3, , 1))
                                            )
                                        ),
                                        _hms24
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ),
        
        fnParseTimeOfDay, LAMBDA(_timeOfDay,
            IF(ISERROR(_timeOfDay), _returnValErr,
                LET(
                    _trimToD, TRIM(_timeOfDay),
                    IF(_trimToD = "", _returnEmpty,
                        LET(
                            _parsedTimeOfDay, IF(_strictISO, fnParseISO(_timeOfDay),
                                LET(
                                    _firstChar, LEFT(_timeOfDay),
                                    _detectStyle, IFS(
                                        CODE(_firstChar) = 84, "I", // firstChar = "T" => ISO Style
                                        NOT(ISERROR(VALUE(_firstChar))), "G", // firstChar => General style
                                        TRUE, ""
                                    ),
                                    IF(_detectStyle = "I", fnParseISO(_timeOfDay),
                                        IF(_detectStyle = "G", fnParseGeneral(_trimToD),
                                            _returnValErr
                                        )
                                    )
                                )
                            ),

                            IF(ISERROR(INDEX(_parsedTimeOfDay, 1, 1)), _parsedTimeOfDay, 
                                LET(
                                    _validToD, VALIDATE_TIME_OF_DAY(_parsedTimeOfDay, _accept24hr),
                                    IF(_asValue, 
                                        TIMESPAN(HSTACK(1, 0, _validToD)),
                                        _validToD
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ),

        _rowCount, ROWS(TimeOfDay),
        DROP(
            REDUCE("", SEQUENCE(_rowCount),
                LAMBDA(_acc, _curr,
                    VSTACK(
                        _acc,
                        fnParseTimeOfDay(NULLIFY(INDEX(TimeOfDay, _curr, 1)))
                    )
                )
            ), 1
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
FORMAT_TIME_OF_DAY

Returns a formatted sexagesimal representation of time of day from a given decimal fraction of a 24 hour day.

Array compatible: TimeOfDay

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | Formatted sexagesimal representation of time of day

Parameters
----------------------------------------------------------------------------------------------------------------
TimeOfDay        | decimal [0..1] | Time of day as decimal fraction of a day. Implicity equivalent to Excel Time.
[Options]        | text           | String with elements: [C|I|B][P][^][LowOrder][~|<][Precision][\][L]
                 |                |  C, I, B : Civil, ISO8601 or Basic style. 24 hour style when not present.
                 |                |            24 Hour: H:mm:ss.00    
                 |                |            Civil:   h:mm:ss.000 AM/PM
                 |                |            ISO:     THH:mm:ss.000
                 |                |            Basic:   THHmmss.000
                 |                |        P : Pad hours with leading zero for 24 Hour and Civil styles.
                 |                |            ISO8601 and Basic styles always pad with leading zero.
                 |                |        ^ : Accept time of 24:00 to represent midnight next day.
                 |                |            Not applicable to Civil style.    
                 |                | LowOrder : Low order component. Defaults to minute.
                 |                |            H : Hour
                 |                |            M : Minute
                 |                |            S : Second
                 |                |     ~, < : Force rounding method of low order component: ~ round nearest, < round down
                 |                |            If unspecified then behaviour is round down for hours and minutes;
                 |                |            round to nearest for seconds.
                 |                | Precision: [0-9] Only applicable to low order component of seconds.
                 |                |        \ : No space preceding AM/PM. Applicable to Civil style, where default is spaced.
                 |                |        L : Lower case AM/PM. Applicable to Civil style, where default is upper case.

Examples
----------------------------------------------------------------------------------------------------------------
FORMAT_TIME_OF_DAY(0.25)
Returns: 6:00

FORMAT_TIME_OF_DAY(0.75, "CPL")
Returns: 06:00 pm

FORMAT_TIME_OF_DAY(0.6747, "I<M")
Returns: T16:11
--------------------------------------------------------------------------------------------------------------*/
FORMAT_TIME_OF_DAY = LAMBDA(TimeOfDay, [Options],
    LET(
        _options, IF(ISOMITTED(Options), "", Options),
        _style, LEFT(SIFT_FOR_CHARS(_options, "CIB")),
        _padding, IFERROR(SEARCH("P", _options), 0) > 0,
        _accept24hr, IFERROR(FIND("^", _options), 0) > 0,
        _low, LEFT(SIFT_FOR_CHARS(_options, "HMS")),
        _lowOrder, IFS(
            _low = "H", 2,
            _low = "M", 3,
            _low = "S", 4,
            TRUE, 3
        ),
        _rounding, IFS(
            IFERROR(FIND("~", _options), 0) > 0, 1,
            IFERROR(FIND("<", _options), 0) > 0, -1,
            TRUE, 0
        ),
        _precision, IF(_lowOrder < 4, 0,
            VALUE(LEFT(SIFT_FOR_CHARS(_options, "0123456789")))
        ),
        _nospc, IFERROR(FIND("\", _options), 0) > 0,
        _lampm, IFERROR(SEARCH("L", _options), 0) > 0,
        _sError, "#TIME!",

        fnCompose, LAMBDA(_provider,
            IF(NOT(ISNUMBER(INDEX(_provider, 1, 1))), _sError,
                LET(
                    _count, INDEX(_provider, 1, 2) - INDEX(_provider, 1, 1) + 1,
                    REDUCE(INDEX(_provider, 3, 1), SEQUENCE(_count),
                        LAMBDA(_acc, _n,
                            LET(
                                _fmt, IFS(
                                    _n = _count, INDEX(_provider, 1, 5),
                                    _n = 1, INDEX(_provider, 1, 3),
                                    TRUE, INDEX(_provider, 1, 4)
                                ),
                                _col, INDEX(_provider, 1, 1) + _n,
                                _part, TEXT(INDEX(_provider, 2, _col), _fmt),
                                _delim, INDEX(_provider, 3, _col),
                                CONCAT(_acc, _part, _delim)
                            )
                        )
                    )
                )
            )
        ),

        fnFormatTimeOfDay, LAMBDA(_timeOfDay,
            IF(IS_EMPTY(_timeOfDay), "",
                LET(
                    _provider, IFS(
                        NOT(ISNUMBER(_timeOfDay)), {#VALUE!},
                        _style = "C", _FORMAT_PROVIDER_TIME_OF_DAY_CIVIL(_timeOfDay, _padding, _lowOrder, _rounding, _precision, _nospc, _lampm),
                        _style = "I", _FORMAT_PROVIDER_TIME_OF_DAY_ISO(_timeOfDay, _lowOrder, _rounding, _precision, _accept24hr, 0),
                        _style = "B", _FORMAT_PROVIDER_TIME_OF_DAY_ISO(_timeOfDay, _lowOrder, _rounding, _precision, _accept24hr, 1),
                        TRUE,         _FORMAT_PROVIDER_TIME_OF_DAY_24HR(_timeOfDay, _padding, _lowOrder, _rounding, _precision, _accept24hr)
                    ),
                    fnCompose(_provider)
                )
            )
        ),

        MAP(TimeOfDay,
            LAMBDA(_element,
                fnFormatTimeOfDay(NULLIFY(_element))
            )
        )
    )
);

_FORMAT_PROVIDER_TIME_OF_DAY_24HR = LAMBDA(TimeOfDay, Padding, LowOrder, Rounding, Precision, Accept24hr,
    LET(
        _signPositive, 0,
        _hardHigh, 1,
        _highOrder, 2,
        _hardLow, 1,
        _provider, _FORMAT_PROVIDER_SEXAGESIMAL_MODERN(TimeOfDay, _signPositive, Padding, _hardHigh, _highOrder, _hardLow, LowOrder, Rounding, Precision),
        IF(NOT(ISNUMBER(INDEX(_provider, 1, 1))), INDEX(_provider, 1, 1),
            LET(
                _h, N(INDEX(_provider, 2, 3)),
                _outOfRange, IFS(
                    NOT(ISNUMBER(INDEX(_provider, 1, 1))), TRUE,
                    INDEX(_provider, 2, 1) < 0, TRUE,
                    _h < 24, FALSE,
                    _h > 24, TRUE,
                    NOT(Accept24hr), TRUE,
                    TRUE, MAX(N(INDEX(_provider, 2, {3, 5})) > 0)
                ),
                IF(_outOfRange, {#NUM!}, _provider)
            )
        )
    )
);

_FORMAT_PROVIDER_TIME_OF_DAY_CIVIL = LAMBDA(TimeOfDay, Padding, LowOrder, Rounding, Precision, NoSpace, LowerAMPM,
    LET(
        _accept24hr, 0,
        _provider, _FORMAT_PROVIDER_TIME_OF_DAY_24HR(TimeOfDay, Padding, LowOrder, Rounding, Precision, _accept24hr),
        IF(NOT(ISNUMBER(INDEX(_provider, 1, 1))), INDEX(_provider, 1, 1),
            LET(
                _colCount, INDEX(_provider, 1, 2) - INDEX(_provider, 1, 1) + 1,
                _h, N(INDEX(_provider, 2, 3)),
                _ampm, CONCAT(
                    IF(NoSpace, "", " "),
                    IF(LowerAMPM,
                        IF(_h < 12, "am", "pm"),
                        IF(_h < 12, "AM", "PM")
                    )
                ),
                _civilH, MOD(_h - 1, 12) + 1,
                _cols, HSTACK(INDEX(_provider, 2, {1, 2}), _civilH, INDEX(_provider, 2, {4, 5})), 
                _delims, HSTACK(TAKE(_provider, -1, _colCount + 1), _ampm, DROP(CHOOSEROWS(_provider, 3), , _colCount + 2)),
                VSTACK(
                    CHOOSEROWS(_provider, 1),
                    _cols,
                    _delims
                )
            )
        )
    )
);

_FORMAT_PROVIDER_TIME_OF_DAY_ISO = LAMBDA(TimeOfDay, LowOrder, Rounding, Precision, Accept24hr, Basic,
    LET(
        _padding, 1,
        _provider, _FORMAT_PROVIDER_TIME_OF_DAY_24HR(TimeOfDay, _padding, LowOrder, Rounding, Precision, Accept24hr),
        IF(NOT(ISNUMBER(INDEX(_provider, 1, 1))), INDEX(_provider, 1, 1),
            LET(
                _colCount, INDEX(_provider, 1, 2) - INDEX(_provider, 1, 1) + 1,
                _delims, IF(Basic,
                    HSTACK("T", "", "", "", "", INDEX(_provider, 3, 6)),
                    HSTACK("T", DROP(CHOOSEROWS(_provider, 3), , 1))
                ),
                VSTACK(
                    CHOOSEROWS(_provider, {1, 2}),
                    _delims
                )
            )
        )
    )
);






/*##############################################################################################################
# TIME ZONE                                                                                                    #
##############################################################################################################*/


/*--------------------------------------------------------------------------------------------------------------
IS_VALID_TZO

Tests if a time zone offset in minutes is within the range -15:00..+15:00

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
----------------------------------------------------------------------------------------------------------------
TZOMinutes | decimal [-900..900] | Fractional allowed if minute and second empty.
--------------------------------------------------------------------------------------------------------------*/
IS_VALID_TZO = LAMBDA(TZOMinutes,
    IFS(
        IS_EMPTY(TZOMinutes), FALSE,
        NOT(ISNUMBER(TZOMinutes)), FALSE,
        ABS(TZOMinutes) > 900, FALSE,
        TRUE, TRUE
    )
);


/*--------------------------------------------------------------------------------------------------------------
TIMESPAN_TO_TZO

Converts a deimal timespan into time zone offset minutes.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
----------------------------------------------------------------------------------------------------------------
TZOTimeSpan | decimal [-0.625..0.625] |
--------------------------------------------------------------------------------------------------------------*/
TIMESPAN_TO_TZO = LAMBDA(TZOTimeSpan,
    IFS(
        ISERROR(TZOTimeSpan), TZOTimeSpan,
        NOT(ISNUMBER(TZOTimeSpan)), {#VALUE!},
        TZOTimeSpan = "", "",
        TRUE, LET(
            _tzo, TZOTimeSpan * 1440,
            IF(IS_VALID_TZO(_tzo), _tzo, {#NUM!})
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
TZO_TO_TIMESPAN

Converts time zone offset minutes into a decimal timespan.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean | Time Zone Offset expressed as a TimeSpan 

Parameters
----------------------------------------------------------------------------------------------------------------
TZOTimeSpan | decimal [-0.625..0.625] |
--------------------------------------------------------------------------------------------------------------*/
TZO_TO_TIMESPAN = LAMBDA(TZOMinutes,
    IFS(
        ISERROR(TZOMinutes), TZOMinutes,
        TZOMinutes = "", "",
        NOT(ISNUMBER(TZOMinutes)), {#VALUE!},
        NOT(IS_VALID_TZO(TZOMinutes)), {#NUM!},
        TRUE, TZOMinutes / 1440
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_ISO_TZO

Parses an ISO formatted time zone offset into time zone offset minutes.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal [-900..900] | Time zone offset in minutes

Parameters
----------------------------------------------------------------------------------------------------------------
ISOTimeZoneOffset | text | Time zone offset in ISO format ie. hh:mm

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_ISO_TZO("Z")
Returns: 0 i.e. UTC time zone (Zulu)

PARSE_ISO_TIME("06:00")
Returns: -360

PARSE_ISO_TIME("+16:00")
Returns: #NUM! i.e. range is 15:00 to +15:00
--------------------------------------------------------------------------------------------------------------*/
PARSE_ISO_TZO = LAMBDA(ISOTimeZoneOffset,
    LET(
        fnParseTZO, LAMBDA(_TZO,
            IFS(
                IS_EMPTY(_TZO), "",
                (LEN(_TZO) = 1) * (CODE(_TZO) = 90), 0,
                TRUE, LET(
                    _sChar, LEFT(_TZO),
                    _sign, IFS(
                        _sChar = "+", 1,
                        _sChar = "-", -1,
                        UNICODE(_sChar) = 8722, -1,
                        TRUE, 0
                    ),
                    IF(_sign = 0, {#VALUE!},
                        LET(
                            _tz, MID(_TZO, 2, LEN(_TZO) - 1),
                            _pattern, REPLACE_CHARS(_tz, "0123456789", "_"),
                            _tryParse, IFS(
                                _pattern = "__:__:__",
                                    HSTACK(
                                        VALUE(LEFT(_tz, 2)),
                                        VALUE(MID(_tz, 4, 2)),
                                        VALUE(RIGHT(_tz, 2))
                                    ),
                                _pattern = "__:__",
                                    HSTACK(
                                        VALUE(LEFT(_tz, 2)),
                                        VALUE(RIGHT(_tz, 2)),
                                        0
                                    ),
                                _pattern = "______",
                                    HSTACK(
                                        VALUE(LEFT(_tz, 2)),
                                        VALUE(MID(_tz, 3, 2)),
                                        VALUE(RIGHT(_tz, 2))
                                    ),
                                _pattern = "____",
                                    HSTACK(
                                        VALUE(LEFT(_tz, 2)),
                                        VALUE(RIGHT(_tz, 2)),
                                        0
                                    ),
                                _pattern = "__",
                                    HSTACK(VALUE(_tz), 0, 0),
                                TRUE, {#VALUE!}
                            ),
                            
                            IFS(
                                ISERROR(INDEX(_tryParse, 1, 1)), {#VALUE!},
                                NOT(IS_VALID_TIME_OF_DAY(_tryParse)), {#NUM!},
                                TRUE, TIMESPAN_TO_TZO(TIMESPAN(HSTACK(_sign, 0, _tryParse)))
                            )
                        )
                    )
                )
            )
        ),

        MAP(ISOTimeZoneOffset,
            LAMBDA(_TZO, fnParseTZO(_TZO))
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
FORMAT_ISO_TZO

Returns a time zone offset as text in ISO format.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | ISO formatted time zone offset

Parameters
----------------------------------------------------------------------------------------------------------------
TZOMinutes | decimal     | Time zone offset from UTC in minutes.
           | [-900..900] | Assumed to be UTC if omitted. [-15:00..+15:00]
[Options]  | text        | String with elements: [B][Z][H|M|S]
           |             |       B : Display in basic format eg +0000
           |             |       Z : Display 'Z' for Zulu time zone +00:00
           |             | H, M, S : Force low order component. If omitted auto adjusts to minutes or seconds.
--------------------------------------------------------------------------------------------------------------*/
FORMAT_ISO_TZO = LAMBDA(TZOMinutes, [Options],
    LET(
        _options, IF(ISOMITTED(Options), "", Options),
        _basic, IFERROR(SEARCH("B", _options), 0) > 0,
        _zulu, IFERROR(SEARCH("Z", _options), 0) > 0,
        _lowOrder, LEFT(SIFT_FOR_CHARS(_options, "HMS")),
        
        _fmt, IFS(
            _lowOrder = "", IF(_basic, "B+m", "+PHm0"),
            _lowOrder = "H", IF(_basic, "B+H", "B+H"),
            _lowOrder = "M", IF(_basic, "B+M", "+PHM0"),
            _lowOrder = "S", IF(_basic, "B+S", "+PHS0")
        ),
        
        fnFormatTZO, LAMBDA(_TZOMinutes,
            IFS(
                IS_EMPTY(_TZOMinutes), "",
                NOT(ISNUMBER(_TZOMinutes)), {#VALUE!},
                NOT(IS_VALID_TZO(_TZOMinutes)), {#NUM!},
                (_TZOMinutes = 0) * _zulu, "Z",
                TRUE, FORMAT_TIMESPAN(_TZOMinutes/1440, _fmt)
            )
        ),

        MAP(TZOMinutes,
            LAMBDA(_TZOMinutes, fnFormatTZO(_TZOMinutes))
        )
    )
);


/*--------------------------------------------------------------------------------------------------------
MILITARY_TZO

Returns the time zone offset in minutes of a military time zone designator.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------
 1 | decimal     | Time zone offset in minutes
   | [-720..720] | [-12:00..+12:00]

Parameters
----------------------------------------------------------------------------------------------------------
Designator | text | Military time zone designator 
           |      | [ABCDEFGHIJKLMNOPQRSTUVWXYZ]

Examples
----------------------------------------------------------------------------------------------------------
MILITARY_TZO("A")
Returns: 60

FORMAT_MIL_DTG("J")
Returns: #N/A (local time zone)
--------------------------------------------------------------------------------------------------------*/
MILITARY_TZO = LAMBDA(Designator,
    IF(IS_EMPTY(Designator), "",
        LET(
            _code, CODE(Designator) - 64,
            IFS(
                _code <= 0, {#VALUE!},
                _code > 26, {#VALUE!},
                _code = 10, {#N/A}, // J = Local Time
                _code = 26, 0, // Z = UTC
                _code <= 9, _code * 60, // ABCDEFGHI -> +1..+9
                _code <= 13, (_code - 1) * 60,  // KLM -> +10..+12
                _code <= 25, (13 - _code) * 60 // NOPQRSTUVWXY -> -1..-12
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------
TZO_TO_MILITARY

Returns the closest military time zone designator, its offset in minutes and the time adjustment to that
time zone for the provided time zone offset in minutes.

Array compatible: TZOMinutes as column

Output
----------------------------------------------------------------------------------------------------------
 1 | text            |  Military time zone designator
   |                 | [ABCDEFGHIJKLMNOPQRSTUVWXYZ]
 2 | integer         | Time zone offset in minutes
   | [-720..720]     | [-12:00..+12:00]
 3 | decimal         | Time adjustment
   | [-0.125..0.125] | [-3:00..+3:00]

Parameters
----------------------------------------------------------------------------------------------------------
[TZOMinutes] | decimal     | Time zone offset from UTC in minutes
             | [-900..900] | Assumed to be UTC if omitted. [-15:00..+15:00]

Examples
----------------------------------------------------------------------------------------------------------
TZO_TO_MILITARY(60)
Returns: {A, 60, 0}

TZO_TO_MILITARY(#N/A)
Returns: {J, ,0} (local time zone)

TZO_TO_MILITARY(570)
Returns: {K, 600, 0.020833}

TZO_TO_MILITARY(840)
Returns: {M, 720, -0.08333}
--------------------------------------------------------------------------------------------------------*/
TZO_TO_MILITARY = LAMBDA(TZOMinutes,
    LET(
        fnTZOMilitary, LAMBDA(_TZOMinutes,
            IFS(
                IS_EMPTY(_TZOMinutes), {"", "", ""},
                ISNA(_TZOMinutes), {"J", "", 0},
                NOT(IS_VALID_TZO(_TZOMinutes)), {#VALUE!, "", ""},
                TRUE, IFS(
                    _TZOMinutes = 0, HSTACK("Z", 0, 0),
                    _TZOMinutes > 720, HSTACK("M", 720, (720 - _TZOMinutes) / 1440),
                    _TZOMinutes < -720, HSTACK("Y", -720, (-720 - _TZOMinutes) / 1440),
                    TRUE, LET(
                        _militaryTZO, SIGN(_TZOMinutes) * MROUND(ABS(_TZOMinutes), 60),
                        _idx, INT(_militaryTZO / 60) + 13,
                        _militaryTZ, CHOOSE(_idx, "Y", "X", "W", "V", "U", "T", "S", "R", "Q", "P", "O", "N", "Z", "A", "B", "C", "D", "E", "F", "G", "H", "I", "K", "L", "M"),
                        HSTACK(_militaryTZ, _militaryTZO, (_militaryTZO - _TZOMinutes) / 1440)
                    )
                )
            )
        ),

        _rowCount, ROWS(TZOMinutes),
        DROP(
            REDUCE("", SEQUENCE(_rowCount),
                LAMBDA(_acc, _curr,
                    VSTACK(
                        _acc,
                        fnTZOMilitary(NULLIFY(INDEX(TZOMinutes, _curr, 1)))
                    )
                )
            ), 1
        )
    )
);


/*--------------------------------------------------------------------------------------------------------
SHIFT_TIMEZONE

Translates a Modified Julian Date from one time zone to another. If a time zone is omitted it is assumed
to be UTC.

Array compatible: MJDate

Output
----------------------------------------------------------------------------------------------------------
 1 | decimal | MJDate

Parameters
----------------------------------------------------------------------------------------------------------
MJDate                | decimal     | Modified Julian Date
[ReferenceTZOMinutes] | decimal     | Time zone offset referenced by the MJDate
                      | [-900..900] | Assumed to be UTC if omitted. [-15:00..+15:00]
[TranslateTZOMinutes] | decimal     | Time zone offset to translate the MJDate to.
                      | [-900..900] | Assumed to be UTC if omitted. [-15:00..+15:00]
--------------------------------------------------------------------------------------------------------*/
SHIFT_TIMEZONE = LAMBDA(MJDate, [ReferenceTZOMinutes], [TranslateTZOMinutes],
    IFS(
        IS_EMPTY(MJDate), "",
        NOT(ISNUMBER(MJDate)), {#VALUE!},
        TRUE, LET(
            _referenceTZ, N(ReferenceTZOMinutes),
            _translateTZ, N(TranslateTZOMinutes),
            _difference, (_translateTZ - _referenceTZ) / 1440,
            MJDate + _difference
        )
    )
);





/*##############################################################################################################
# DATE AND TIME                                                                                                #
##############################################################################################################*/




/*--------------------------------------------------------------------------------------------------------------
JULIAN_DATE

Returns the Julian Date of the provided date and time of day in the specified calendar.
Note that the decimal time component of Julian Date is based from midday.

Array compatible: Date_YMDT as columns

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Julian Date

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YMDT        | array   C[2..4]  |
   YearCE        | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
   [Month]       | integer [1..12]  | Month of year. Can be empty.
   [Day]         | decimal [0..367) | Day. Ordinal day of year if month empty. Can be empty. If time is not omitted
                 |                  | any decimal part is ignored.
   [Time]        | decimal [0..1)   | Time of day. If omitted then decimal part of day is taken.
[JulianCalendar] | switch           | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                  | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
JULIAN_DATE = LAMBDA(Date_YMDT, [JulianCalendar],
    LET(
        _julianCalendar, N(JulianCalendar) <> 0,
        
        fnJulianDate, LAMBDA(_date_YMDT,
            LET(
                _colCount, COLUMNS(_date_YMDT),
                IF(_colCount > 4, {#REF!},
                    LET(
                        _date, TAKE(_date_YMDT, 1, 3),
                        _JDN, JULIAN_DAY_NUMBER(_date, _julianCalendar),
                        IF(NOT(ISNUMBER(_JDN)), _JDN,
                            LET(
                                _time, IFS(
                                    _colCount = 4, IF(IS_EMPTY(INDEX(_date_YMDT, 1, 4)),
                                        MOD(N(INDEX(_date_YMDT, 1, 3)), 1),
                                        INDEX(_date_YMDT, 1, 4)
                                    ),
                                    _colCount = 3, MOD(N(INDEX(_date_YMDT, 1, 3)), 1),
                                    TRUE,  0
                                ),
                                IF(NOT(ISNUMBER(_time)), {#VALUE!},
                                    LET(
                                        _timeAfterMidday, _time - 0.5,
                                        _JDN + _timeAfterMidday
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ),
        
        BYROW(Date_YMDT,
            LAMBDA(_date_YMDT, fnJulianDate(_date_YMDT))
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
MODIFIED_JULIAN_DATE

Returns the Modified Julian Date of the provided date and time of day in the specified calendar.
Note that the time component of Modified Julian Date is based from midnight.

Array compatible: Date_YMDT as columns

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Modified Julian Date

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YMDT        | array   C[2..4]  |
   YearCE        | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
   [Month]       | integer [1..12]  | Month of year. Can be empty.
   [Day]         | decimal [0..367) | Day. Ordinal day of year if month empty. Can be empty. If time is not omitted
                 |                  | any decimal part is ignored.
   [Time]        | decimal [0..1)   | Time of day. If omitted then decimal part of day is taken.
[JulianCalendar] | switch           | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                  | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
MODIFIED_JULIAN_DATE = LAMBDA(Date_YMDT, [JulianCalendar],
    LET(
        _julianCalendar, N(JulianCalendar) <> 0,
        
        fnModifiedJulianDate, LAMBDA(_date_YMDT,
            LET(
                _colCount, COLUMNS(_date_YMDT),
                IF(_colCount > 4, {#REF!},
                    LET(
                        _date, TAKE(_date_YMDT, 1, 3),
                        _MJDN, MODIFIED_JULIAN_DAY_NUMBER(_date, _julianCalendar),
                        IF(NOT(ISNUMBER(_MJDN)), _MJDN,
                            LET(
                                _time, IFS(
                                    _colCount = 4, IF(IS_EMPTY(INDEX(_date_YMDT, 1, 4)),
                                        MOD(N(INDEX(_date_YMDT, 1, 3)), 1),
                                        INDEX(_date_YMDT, 1, 4)
                                    ),
                                    _colCount = 3, MOD(N(INDEX(_date_YMDT, 1, 3)), 1),
                                    TRUE,  0
                                ),
                                IF(NOT(ISNUMBER(_time)), {#VALUE!},
                                    _MJDN + _time
                                )
                            )
                        )
                    )
                )
            )
        ),
        
        BYROW(Date_YMDT,
            LAMBDA(_date_YMDT, fnModifiedJulianDate(_date_YMDT))
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
JDATE_TO_MODIFIED

Converts a Julian Date (JDATE) to a Modified Julian Date (MJDATE).
Note that the decimal time component of MJDATE is based from midnight.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Modified Julian Date

Parameters
----------------------------------------------------------------------------------------------------------------
JDate | decimal | Julian Date
--------------------------------------------------------------------------------------------------------------*/
JDATE_TO_MODIFIED = LAMBDA(JDate,
    IF(JDate = "", "",
        JDate - 2400000.5
    )
);


/*--------------------------------------------------------------------------------------------------------------
MODIFIED_TO_JDATE

Converts a Modified Julian Date (MJDATE) to a Julian Date (JDATE).
Note that the decimal time component of JDATE is based from midday.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Julian Date

Parameters
----------------------------------------------------------------------------------------------------------------
MJDate | decimal | Modified Julian Date
--------------------------------------------------------------------------------------------------------------*/
MODIFIED_TO_JDATE = LAMBDA(MJDate,
    IF(MJDate = "", "",
        MJDate + 2400000.5
    )
);


/*--------------------------------------------------------------------------------------------------------------
JDATE_TO_YMDT

Converts a Julian Date to a date and time in the specified calendar.

Array compatible: JDate as column

Output C[4]
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day of month
 4 | decimal [0..1)  | Time of day

Parameters
----------------------------------------------------------------------------------------------------------------
JDate            | decimal | Julian Date
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
JDATE_TO_YMDT = LAMBDA(JDate, [JulianCalendar],
    LET(
        _julianCalendar, N(JulianCalendar) <> 0,

        fnJDateToYMDT, LAMBDA(_JDate,
            IFS(
                _JDate = "", {"", "", "", ""},
                NOT(ISNUMBER(_JDate)), {#VALUE!, "", "", ""},
                TRUE, LET(
                    _JDN, INT(_JDate + 0.5),
                    _timeOfDay, _JDate - _JDN + 0.5,
                    _cDate, JDN_TO_CALENDAR_DATE(_JDN, _julianCalendar),
                    HSTACK(_cDate, _timeOfDay)
                )
            )
        ),

        _rowCount, ROWS(JDate),
        DROP(
            REDUCE("", SEQUENCE(_rowCount),
                LAMBDA(_acc, _curr,
                    VSTACK(
                        _acc,
                        fnJDateToYMDT(NULLIFY(CHOOSEROWS(JDate, _curr)))
                    )
                )
            ), 1
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
MJDATE_TO_YMDT

Converts a Modified Julian Date to a date and time in the specified calendar.

Array compatible: MJDate as column

Output C[4]
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day of month
 4 | decimal [0..1)  | Time of day

Parameters
----------------------------------------------------------------------------------------------------------------
MJDate           | decimal | Modified Julian Date
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
MJDATE_TO_YMDT = LAMBDA(MJDate, [JulianCalendar],
    LET(
        _JDate, MODIFIED_TO_JDATE(MJDate),
        IFS(
            _JDate = "", {"", "", "", ""},
            NOT(ISNUMBER(_JDate)), {#VALUE!, "", "", ""},
            TRUE, JDATE_TO_YMDT(_JDate, JulianCalendar)
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
NORMALISE_YMDT

Returns a normalised YMDT representation of a date and time where each component is within its valid range.

Array compatible: Date_YMDT as column

Output C[4]
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day of month
 4 | decimal [0..1)  | Time of day

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YMDT        | array   C[1..4]  |
   YearCE        | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
   [Month]       | integer [1..12]  | Month of year. Can be empty.
   [Day]         | decimal [0..367) | Day. Ordinal day of year if month empty. Can be empty. If time is not omitted
                 |                  | any decimal part is ignored.
   [Time]        | decimal [0..1)   | Time of day. If omitted then decimal part of day is taken.
[JulianCalendar] | switch           | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                  | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
NORMALISE_YMDT = LAMBDA(Date_YMDT, [JulianCalendar],
    LET(
        _julianCalendar, N(JulianCalendar) <> 0,

        fnNormaliseYMDT, LAMBDA(_date_YMDT,
            LET(
                _colCount, COLUMNS(_date_YMDT),
                IFS(
                    _colCount > 4, {#REF!, "", "", ""},
                    MAX(N(NOT(IS_EMPTY(_date_YMDT)))) = 0, {"", "", "", ""},
                    TRUE, LET(
                        _year, LET(
                            _y, INDEX(_date_YMDT, 1, 1),
                            IFS(
                                ISERROR(_y), {#VALUE!},
                                NOT(ISNUMBER(_y)), {#VALUE!},
                                NOT(IS_INTEGER(_y)), {#NUM!},
                                TRUE, _y
                            )
                        ),
                        _month, IF(_colCount < 2, 1,
                            LET(
                                _m, INDEX(_date_YMDT, 1, 2),
                                IFS(
                                    ISERROR(_m), {#VALUE!},
                                    _m = "", 1,
                                    NOT(ISNUMBER(_m)), {#VALUE!},
                                    NOT(IS_INTEGER(_m)), {#NUM!},
                                    TRUE, _m
                                )
                            )
                        ),
                        _day, IF(_colCount < 3, 1,
                            LET(
                                _d, INDEX(_date_YMDT, 1, 3),
                                _allowDecimal, IF(_colCount < 4, TRUE, IS_EMPTY(INDEX(_date_YMDT, 1, 4))), 
                                IFS(
                                    ISERROR(_d), {#VALUE!},
                                    _d = "", 1,
                                    NOT(ISNUMBER(_d)), {#VALUE!},
                                    IF(_allowDecimal, FALSE, NOT(IS_INTEGER(_d))), {#NUM!},
                                    TRUE, _d
                                )
                            )
                        ),
                        _time, IF(_colCount < 4, "",
                            LET(
                                _t, INDEX(_date_YMDT, 1, 4),
                                IFS(
                                    ISERROR(_t), {#VALUE!},
                                    _t = "", "",
                                    NOT(ISNUMBER(_t)), {#VALUE!},
                                    TRUE, _t
                                )
                            )
                        ),
                        
                        IF(N(ISERROR(_year)) + N(ISERROR(_month)) + N(ISERROR(_day)) + N(ISERROR(_time)) > 0,
                            HSTACK(_year, _month, _day, _time),
                            LET(
                                _fractionalDay, NOT(IS_INTEGER(_day)),
                                _normTimeOfDay, IFS(
                                    _fractionalDay, MOD(_day, 1),
                                    _time = "", "",
                                    TRUE, MOD(_time, 1)
                                ),
                                _nominalDay, IFS(
                                    _fractionalDay, INT(_day),
                                    _time = "", _day,
                                    TRUE, _day + INT(_time)
                                ),
                                _normMonth, MOD(_month - 1, 12) + 1,
                                _normYear, _year + INT((_month - 1) / 12),
                                IF((_nominalDay >= 1) * (_nominalDay <= 28),
                                    HSTACK(_normYear, _normMonth, _nominalDay, _normTimeOfDay),
                                    LET(
                                        _JDN_FirstOfMonth, _JULIAN_DAY_NUMBER(_normYear, _normMonth, 1, _julianCalendar),
                                        _JDN, _JDN_FirstOfMonth + _nominalDay - 1,
                                        _normDate, JDN_TO_CALENDAR_DATE(_JDN, _julianCalendar),
                                        HSTACK(_normDate, _normTimeOfDay)
                                    )
                                )
                            )
                        )
                    )
                )
            )
        ),

        _rowCount, ROWS(Date_YMDT),
        DROP(
            REDUCE("", SEQUENCE(_rowCount),
                LAMBDA(_acc, _curr,
                    VSTACK(
                        _acc,
                        fnNormaliseYMDT(NULLIFY(CHOOSEROWS(Date_YMDT, _curr)))
                    )
                )
            ), 1
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
RESOLVE_YMDT

Returns the resolved date and time from the provided components to a low order component rounded to the
specified precision.

Array compatible: Date_YMDT as column

Output C[4]
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day of month
 4 | decimal [0..1)  | Time of day

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YMDT        | array   C[1..4]  |
   YearCE        | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
   [Month]       | integer [1..12]  | Month of year. Can be empty.
   [Day]         | decimal [0..367) | Day. Ordinal day of year if month empty. Can be empty. If time is not omitted
                 |                  | any decimal part is ignored.
   [Time]        | decimal [0..1)   | Time of day. If omitted then decimal part of day is taken.
[LowOrder]       | integer [1..4]   | Low-order component
                 |                  |  1 - Day
                 |                  |  2 - Hour
                 |                  |  3 - Minute
                 |                  |  4 - Second
[Precision]      | integer [0..9]   | Select precision level. Null for floating.
[Truncate]       | switch           | Round to precision by truncating components. Default is rounding to nearest.
[JulianCalendar] | switch           | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                  | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
RESOLVE_YMDT = LAMBDA(Date_YMDT, [LowOrder], [Precision], [Truncate], [JulianCalendar],
    LET(
        _maxPrecision, 9,
        _lowOrder, IFS(
            NOT(ISNUMBER(LowOrder)), 4,
            LowOrder < -1, -1,
            LowOrder > 4, 4,
            TRUE, INT(LowOrder)
        ),
        _precision, IFS(
            NOT(ISNUMBER(Precision)), "",
            Precision < 0, 0,
            Precision > _maxPrecision, _maxPrecision,
            TRUE, INT(Precision)
        ),
        _truncate, N(Truncate) <> 0,
        _julianCalendar, N(JulianCalendar) <> 0,

        fnResolveYMDT, LAMBDA(_date_YMDT,
            LET(
                _colCount, COLUMNS(_date_YMDT),
                IFS(
                    _colCount > 4, {#REF!, "", "", ""},
                    MAX(N(NOT(IS_EMPTY(_date_YMDT)))) = 0, {"", "", "", ""},
                    TRUE, LET(
                        _normalisedYMDT, NORMALISE_YMDT(_date_YMDT, _julianCalendar),
                        IF(IS_EMPTY(INDEX(_normalisedYMDT, 1, 4)), _normalisedYMDT,
                            LET(
                                _roundedTimeOfDay, ROUND_TIMESPAN(INDEX(_normalisedYMDT, 1, 4), _lowOrder, _precision, _truncate),
                                NORMALISE_YMDT(HSTACK(TAKE(_normalisedYMDT, 1, 3), _roundedTimeOfDay), _julianCalendar)
                            )
                        )
                    )
                )
            )
        ),

        _rowCount, ROWS(Date_YMDT),
        DROP(
            REDUCE("", SEQUENCE(_rowCount),
                LAMBDA(_acc, _curr,
                    VSTACK(
                        _acc,
                        fnResolveYMDT(NULLIFY(CHOOSEROWS(Date_YMDT, _curr)))
                    )
                )
            ), 1
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
ROUND_MJDATE

Returns the decimal MJdate value rounded to the specified low order component and precision level.

Array compatible: MJDate

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal     | Modified Julian Date

Parameters
----------------------------------------------------------------------------------------------------------------
MJDate           | decimal        | Modified Julian Date
[LowOrder]       | integer [1..4] | Low-order component
                 |                |  1 - Day
                 |                |  2 - Hour
                 |                |  3 - Minute
                 |                |  4 - Second
[Precision]      | integer [0..9] | Select precision level. Null for floating.
[Truncate]       | switch         | Round to precision by truncating components. Default is rounding to nearest.
--------------------------------------------------------------------------------------------------------------*/
ROUND_MJDATE = LAMBDA(MJDate, [LowOrder], [Precision], [Truncate],
    MAP(MJDate,
        LAMBDA(_MJDate,
            IFS(
                ISERROR(_MJDate), _MJDate,
                _MJDate = "", "",
                NOT(ISNUMBER(_MJDate)), {#VALUE!},
                TRUE, LET(
                    _MJDN, INT(_MJDate),
                    _timeOfDay, MOD(_MJDate, 1),
                    _roundedToD, ROUND_TIMESPAN(_timeOfDay, LowOrder, Precision, Truncate),
                    _MJDN + _roundedToD
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
RESOLVE_MJDATE

Returns the resolved date and time from the provided Modified Julian Date to a low order component rounded to the
specified precision.

Array compatible: MJDate as column

Output C[4]
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day of month
 4 | decimal [0..1)  | Time of day

Parameters
----------------------------------------------------------------------------------------------------------------
MJDate           | decimal        | Modified Julian Date
[LowOrder]       | integer [1..4] | Low-order component
                 |                |  1 - Day
                 |                |  2 - Hour
                 |                |  3 - Minute
                 |                |  4 - Second
[Precision]      | integer [0..9] | Select precision level. Null for floating.
[Truncate]       | switch         | Round to precision by truncating components. Default is rounding to nearest.
[JulianCalendar] | switch         | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
RESOLVE_MJDATE = LAMBDA(MJDate, [LowOrder], [Precision], [Truncate], [JulianCalendar],
    LET(
        _maxPrecision, 9,
        _lowOrder, IFS(
            NOT(ISNUMBER(LowOrder)), 4,
            LowOrder < -1, -1,
            LowOrder > 4, 4,
            TRUE, INT(LowOrder)
        ),
        _float, NOT(ISNUMBER(Precision)),
        _precision, IFS(
            _float, "",
            Precision < 0, 0,
            Precision > _maxPrecision, _maxPrecision,
            TRUE, INT(Precision)
        ),
        _truncate, N(Truncate) <> 0,
        _julianCalendar, N(JulianCalendar) <> 0,

        fnResolveMJDate, LAMBDA(_MJDate,
            IFS(
                COLUMNS(_MJDate) > 1, {#REF!, "", "", ""},
                IS_EMPTY(_MJDate), {"", "", "", ""},
                NOT(ISNUMBER(_MJDate)), {#VALUE!, "", "", ""},
                TRUE, LET(            
                    _MJDN, INT(_MJDate),
                    _roundedToD, ROUND_TIMESPAN(MOD(_MJDate, 1), _lowOrder, _precision, _truncate),
                    _carryDay, INT(_roundedToD),
                    _timeOfDay, MOD(_roundedToD, 1),
                    _date, MJDN_TO_CALENDAR_DATE(_MJDN + _carryDay, _julianCalendar),
                    HSTACK(_date, _timeOfDay)
                )
            )
        ),

        _rowCount, ROWS(MJDate),
        DROP(
            REDUCE("", SEQUENCE(_rowCount),
                LAMBDA(_acc, _curr,
                    VSTACK(
                        _acc,
                        fnResolveMJDate(NULLIFY(CHOOSEROWS(MJDate, _curr)))
                    )
                )
            ), 1
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
MJDATE_ADDITION

Returns the addition of a timespan complication to a given Modified Julian Date.
Note if date components of years, quarters or months are added for a MJDate expressed in UTC rather than
local time, then results may be inconsistent due to the bounds of calendar days.

Array compatible: LocalMJDate as column, AddValue as scalar or column

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Modified Julian Date

Parameters
----------------------------------------------------------------------------------------------------------------
LocalMJDate      | decimal | Modified Julian Date in local time zone
AddValue         | decimal | Add timespan expressed in the given Component.
[Component]      | text    | Component denomination of added value. Defaults to Days if omitted.
                 |         |    Y - Years. Fractional part will round to months and whole days.
                 |         |    Q - Quarters. Fractional part will round to months and whole days.
                 |         |    L - Months. Fractional part will round to months and whole days.
                 |         |    D - Days. Implicitly equivalent to Excel Time value.
                 |         |    H - Hours
                 |         |    M - Minutes
                 |         |    S - Seconds
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar. Only needed if Component is set to years, quarters or months.
--------------------------------------------------------------------------------------------------------------*/
MJDATE_ADDITION = LAMBDA(LocalMJDate, AddValue, [Component], [JulianCalendar],
    LET(
        _component, IFS(
            Component = "", "D",
            IFERROR(SEARCH(LEFT(Component), "YQLWDHMS"), 0) > 0, LEFT(Component),
            TRUE, "D"
        ),
        _julianCalendar, N(JulianCalendar) <> 0,
        
        fnMJDateAddition, LAMBDA(_localMJDate, _addValue,
            IFS(
                ISERROR(_localMJDate), _localMJDate,
                ISERROR(_addValue), _addValue,
                _localMJDate = "", "",
                _addValue = "", _localMJDate,
                NOT(ISNUMBER(_localMJDate)), {#VALUE!},
                NOT(ISNUMBER(_addValue)), {#VALUE!},
                _component = "W", _localMJDate + ROUND(_addValue * 7, 0),
                _component = "D", _localMJDate + _addValue,
                _component = "H", _localMJDate + (_addValue / 24),
                _component = "M", _localMJDate + (_addValue / 1440),
                _component = "S", _localMJDate + (_addValue / 86400),
                TRUE, LET(
                    _avgDaysMonth, IF(_julianCalendar, 30.4375, 30.436875),
                    _decAddMonths, _addValue * IFS(
                        _component = "Y", 12,
                        _component = "Q", 3,
                        _component = "L", 1
                    ),
                    _intAddMonths, INT(_decAddMonths),
                    _partialMonths, MOD(_decAddMonths, 1),
                    _localDate_YMDT, MJDATE_TO_YMDT(_localMJDate, _julianCalendar),
                    _addedDate_YMDT, _localDate_YMDT + HSTACK(
                        0,
                        _intAddMonths,
                        ROUND(_partialMonths * _avgDaysMonth, 0),
                        0
                    ),
                    _normalised_YMDT, NORMALISE_YMDT(_addedDate_YMDT, _julianCalendar),
                    MODIFIED_JULIAN_DATE(_normalised_YMDT, _julianCalendar)
                )
            )
        ),

        _rowCount, ROWS(LocalMJDate),
        _addCount, ROWS(AddValue),
        
        IF(_addCount = 1,
            LET(
                _addScalar, INDEX(AddValue, 1, 1),
                DROP(
                    REDUCE("", SEQUENCE(_rowCount),
                        LAMBDA(_acc, _curr,
                            VSTACK(
                                _acc,
                                fnMJDateAddition(NULLIFY(INDEX(LocalMJDate, _curr, 1)), _addScalar)
                            )
                        )
                    ), 1
                )
            ),
            DROP(
                REDUCE("", SEQUENCE(_rowCount),
                    LAMBDA(_acc, _curr,
                        LET(
                            _addValue, IF(_curr <= _addCount,
                                 NULLIFY(INDEX(AddValue, _curr, 1)),
                                 0
                            ),
                            VSTACK(
                                _acc,
                                fnMJDateAddition(NULLIFY(INDEX(LocalMJDate, _curr, 1)), _addValue)
                            )
                        )
                    )
                ), 1
            )
        )
    )
);






/*--------------------------------------------------------------------------------------------------------------
PARSE_ISO_DATETIME

Parses an ISO formatted date and time into respective date parts, time, and time zone offset from UTC.
Providing a time zone offset on its own is invalid.

Array compatible: ISODateTime

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year
 2 | integer         | Month
 3 | integer         | Day
 4 | decimal [0..1]  | Time
 5 | decimal         | Time zone offset from UTC
   | [-0.625..0.625] | 

Parameters
----------------------------------------------------------------------------------------------------------------
ISODateTime        | text   | Date time in ISO format ie. yyyy-MM-ddThh:mm:ss+hh:mm
[AllowMixedStyles] | switch | Relax validation for no mixing of basic and extended formats. eg. yyyyMMddThh:mm
[JulianCalendar]   | switch | Validate in the Julian proleptic calendar. Default is Gregorian
                   |        | proleptic calendar.

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_ISO_DATETIME("2023-05-23")
Returns: {2023, 5, 23, , }

PARSE_ISO_DATETIME("2023-05-23T06:00")
Returns: {2023, 5, 23, 0.25, }

PARSE_ISO_DATETIME("T12:00")
Returns: { , , , 0.5, }

PARSE_ISO_DATETIME("T12:0006:00")
Returns: { , , , 0.5, -360}

PARSE_ISO_DATETIME("2023-05-23T+09:00")
Returns: {2023, 5, 23, , 540}
--------------------------------------------------------------------------------------------------------------*/
PARSE_ISO_DATETIME = LAMBDA(ISODateTime, [AllowMixedStyles], [JulianCalendar],
    Let(
        _allowMixedStyles, N(AllowMixedStyles) <> 0,
        _julianCalendar, N(JulianCalendar) <> 0,
        _validCharSet, "0123456789TWZ:-+.,", //  UNICHAR(8722)
        _TZdelim, "Z-+", //  UNICHAR(8722)

        fnParseISODateTime, LAMBDA(_ISODateTime,
            IFS(
                ISERROR(_ISODateTime), HSTACK(_ISODateTime, "", "", "", ""),
                _ISODateTime = "", {"", "", "", "", ""},
                NOT(VALIDATE_CHARSET(_ISODateTime, _validCharSet, 1)), {#VALUE!, "", "", "", ""},
                TRUE, LET(
                    _Tpos, IFERROR(FIND("T", _ISODateTime), 0),
                    _parts, IF(_Tpos = 0,
                        HSTACK(_ISODateTime, "", ""),
                        LET(
                            _len, LEN(_ISODateTime),
                            _datePart, LEFT(_ISODateTime, _Tpos - 1),
                            _TZpos, FIND_NTH_CHAR(ISODateTime, _TZdelim, 1, 1, 0, _Tpos + 1),
                            IFS(
                                _TZpos = 0,
                                HSTACK(
                                    _datePart,
                                    RIGHT(ISODateTime, _len - _Tpos + 1),
                                    ""
                                ),
                                _TZpos = _Tpos + 1,
                                HSTACK(
                                    _datePart,
                                    "",
                                    RIGHT(ISODateTime, _len - _TZpos + 1)
                                ),
                                TRUE,
                                    HSTACK(
                                        _datePart,
                                        MID(ISODateTime, _Tpos, _TZPos - _Tpos),
                                        RIGHT(ISODateTime, _len - _TZpos + 1)
                                    )
                            )
                        )
                    ),
                    _failStyleCheck, IF(_allowMixedStyles, FALSE,
                        LET(
                            _fmtDate, IFS(
                                INDEX(_parts, 1, 1) = "", 3,
                                IFERROR(FIND("-", INDEX(_parts, 1, 1), 5), 0) > 0, 2,
                                TRUE, 1
                            ),
                            _fmtTime, IFS(
                                INDEX(_parts, 1, 2) = "", 3,
                                LEN(INDEX(_parts, 1, 2)) = 3, 3,
                                IFERROR(FIND(":", INDEX(_parts, 1, 2), 4), 0) > 0, 2,
                                TRUE, 1
                            ),
                            _fmtTZO, IFS(
                                INDEX(_parts, 1, 3) = "", 3,
                                CODE(INDEX(_parts, 1, 3)) = 90, 3,
                                LEN(INDEX(_parts, 1, 3)) = 3, 3,
                                IFERROR(FIND(":", INDEX(_parts, 1, 3), 4), 0) > 0, 2,
                                TRUE, 1
                            ),
                            IFS(
                                BITAND(_fmtDate, _fmtTime) = 0, TRUE,
                                BITAND(_fmtDate, _fmtTZO) = 0, TRUE,
                                BITAND(_fmtTime, _fmtTZO) = 0, TRUE,
                                TRUE, FALSE
                            )
                        )
                    ),
                    IF(_failStyleCheck, {#N/A, "", "", "", ""},
                        LET(
                            _time, PARSE_ISO_TIME_OF_DAY(INDEX(_parts, 1, 2)),
                            _tzo, PARSE_ISO_TZO(INDEX(_parts, 1, 3)),
                            IF(INDEX(_parts, 1, 1) = "",
                                IF(IS_EMPTY(_time),
                                    HSTACK("", "", "", {#VALUE!}, _tzo),
                                    HSTACK("", "", "", _time, _tzo)
                                ),
                                LET(
                                    _date, PARSE_ISO_CALENDAR_DATE(INDEX(_parts, 1, 1), JulianCalendar),
                                    HSTACK(_date, _time, _tzo)
                                )
                            )
                        )
                    )
                )
            )
        ),

        _rowCount, ROWS(ISODateTime),
        DROP(
            REDUCE("", SEQUENCE(_rowCount),
                LAMBDA(_acc, _curr,
                    VSTACK(
                        _acc,
                        fnParseISODateTime(NULLIFY(INDEX(ISODateTime, _curr, 1)))
                    )
                )
            ), 1
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
FORMAT_ISO_DATETIME

Returns a date, time and time zone offset as text in ISO format.

Array compatible: Date_YMDT as column

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | ISO formatted date, time and time zone offset

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YMDT        | array   C[1..4]  |
   YearCE        | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
   [Month]       | integer [1..12]  | Month of year. Can be empty.
   [Day]         | decimal [0..367) | Day. Ordinal day of year if month empty. Can be empty. If time is not omitted
                 |                  | any decimal part is ignored.
   [Time]        | decimal [0..1)   | Time of day. If omitted then decimal part of day is taken.
[TZOMinutes]     | decimal          | Time zone offset from UTC in minutes
                 | [-900..900]      | Assumed to be UTC if omitted. [-15:00..+15:00]
[Options]        | text             | String with elements: [B][<][LowOrder][Precision][Z]
                 |                  |        B : Display in basic format eg T0000
                 |                  |        < : Round by truncating components. Default is rounding to nearest.
                 |                  | LowOrder : low order component to display
                 |                  |     Null : Defaults to seconds if time present, otherwise day
                 |                  |        D : Day
                 |                  |        H : Hour
                 |                  |        M : Minute
                 |                  |        S : Second
                 |                  | Precision: [0-9] Only has an effect when low order component is seconds.
                 |                  |        Z : Display 'Z' for Zulu time zone +00:00
[JulianCalendar] | switch           | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                  | proleptic calendar. 
--------------------------------------------------------------------------------------------------------------*/
FORMAT_ISO_DATETIME = LAMBDA(Date_YMDT, [TZOMinutes], [Options], [JulianCalendar],
    LET(
        _options, IF(ISOMITTED(Options), "", Options),
        _julianCalendar, N(JulianCalendar) <> 0,
        _basic, IFERROR(SEARCH("B", _options), 0) > 0,
        _truncate, IFERROR(FIND("<", _options), 0) > 0,
        _lowOrder, LEFT(SIFT_FOR_CHARS(_options, "DHMS")),
        _precision, IF(_lowOrder < 4, 0,
            IFERROR(VALUE(LEFT(SIFT_FOR_CHARS(_options, "0123456789"))), 0)
        ),

        _TZoptions, LEFT(SIFT_FOR_CHARS(_options, "BZ")),
        _sTZO, IFERROR(FORMAT_ISO_TZO(N(TZOMinutes), _TZoptions), "#TZO!"),
        
        fnFormatISODate, LAMBDA(_date_YMDT,
            LET(
                _date, TAKE(_date_YMDT, 1, 3),
                _sDate, FORMAT_ISO_CALENDAR_DATE(_date, _basic, _julianCalendar),
                IFERROR(_sDate, "#DATE!")
            )
        ),

        fnFormatISOToD, LAMBDA(_timeOfDay,
            LET(
                _sTime, FORMAT_TIME_OF_DAY(_timeOfDay, CONCAT("I", _options)),
                IFERROR(_sTime, "T#TIME!")
            )
        ),
                                    
        fnFormatISODateTime, LAMBDA(_date_YMDT,
            LET(
                _colCount, COLUMNS(_date_YMDT), 
                IF(_colCount > 4, {#REF!},
                    LET(
                        _hasDateProvided, MAX(N(NOT(IS_EMPTY(TAKE(_date_YMDT, 1, 3))))) > 0,
                        _hasTimeProvided, IFS(
                            _colCount < 3, FALSE,
                            _colCount = 3, IF(NOT(ISNUMBER(INDEX(_date_YMDT, 1, 3))), FALSE,
                                NOT(IS_INTEGER(INDEX(_date_YMDT, 1, 3)))
                            ),
                            TRUE, NOT(IS_EMPTY(INDEX(_date_YMDT, 1, 4)))
                        ),
                        IFS(
                            NOT(_hasDateProvided) * NOT(_hasTimeProvided), "",
                            _hasDateProvided, LET(
                                _dateTime, TAKE(HSTACK(_date_YMDT, {"","",""}), 1, 4),
                                _normaliseDateTime, NORMALISE_YMDT(_dateTime, _julianCalendar), 
                                _resolveDateTime, RESOLVE_YMDT(_normaliseDateTime, _lowOrder, _precision, _truncate, _julianCalendar),
                                _sDate, fnFormatISODate(_resolveDateTime),
                                IFS(
                                    NOT(_hasTimeProvided), _sDate,
                                    _lowOrder = 1, CONCAT(_sDate, "T", _sTZO),
                                    TRUE, LET(
                                        _sTime, fnFormatISOToD(INDEX(_resolveDateTime, 1, 4)),
                                        CONCAT(_sDate, _sTime, _sTZO)
                                    )
                                )
                            ),
                            TRUE, LET(
                                _sTime, fnFormatISOToD(INDEX(_date_YMDT, 1, 4)),
                                CONCAT(_sTime, _sTZO)
                            )
                        )
                    )
                )
            )
        ),

        _rowCount, ROWS(Date_YMDT),
        DROP(
            REDUCE("", SEQUENCE(_rowCount),
                LAMBDA(_acc, _curr,
                    VSTACK(
                        _acc,
                        fnFormatISODateTime(NULLIFY(CHOOSEROWS(Date_YMDT, _curr)))
                    )
                )
            ), 1
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_LITERARY_YEAR

Returns a number representing the year relative to the common era from a given literary year.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | YearCE. Note that 1 BC = 0 CE, 2 BC = -1 CE

Parameters
----------------------------------------------------------------------------------------------------------------
LiteraryYear | text | Literary year
--------------------------------------------------------------------------------------------------------------*/
PARSE_LITERARY_YEAR = LAMBDA(LiteraryYear,
    LET(
        _validCharSet, "0123456789BCE -+", //  UNICHAR(8722)
        
        fnYearValue, LAMBDA(_sYear,
            LET(
                _char1, LEFT(_sYear),
                _sign, IFS(
                    _char1 = "+", 1,
                    _char1 = "-", -1,
                    UNICODE(_char1) = 8722, -1,
                    TRUE, ""
                ),
                IF(_sign = "",
                    INT(VALUE(_sYear)),
                    _sign * INT(VALUE(RIGHT(_sYear, LEN(_sYear) -1)))
                )
            )
        ),

        fnParseLiteraryYear, LAMBDA(_literaryYear,
            IFS(
                ISERROR(_literaryYear), _literaryYear,
                _literaryYear = "", "",
                NOT(VALIDATE_CHARSET(_literaryYear, _validCharSet)), {#VALUE!},
                TRUE, LET(
                    _litYear, REPLACE_CHARS(_literaryYear, ", ", ""),
                    IFS(
                        RIGHT(_litYear, 3) = "BCE", LET(
                            _sYear, LEFT(_litYear, LEN(_litYear) - 3),
                            1 - fnYearValue(_sYear)
                        ),
                        RIGHT(_litYear, 2) = "CE",
                        LET(
                            _sYear, LEFT(_litYear, LEN(_litYear) - 2),
                            fnYearValue(_sYear)
                        ),
                        TRUE, fnYearValue(_litYear)
                    )
                )
            )
        ),

        MAP(LiteraryYear,
            LAMBDA(_element,
                fnParseLiteraryYear(NULLIFY(_element))
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
FORMAT_LITERARY_YEAR

Returns a year formatted in literary style.

Array compatible: Yes

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | Literary year

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE          | integer | Note that 1 BC = 0 CE, 2 BC = -1 CE
[AlwaysShowEra] | switch  | Always apply BCE/CE suffix. If not used, only years less than 1000 show an era.
--------------------------------------------------------------------------------------------------------------*/
FORMAT_LITERARY_YEAR = LAMBDA(YearCE, [AlwaysShowEra],
    LET(
        _alwaysShowEra, N(AlwaysShowEra) <> 0,
        
        fnFormatLiteraryYear, LAMBDA(_yearCE,
            IFS(
                ISERROR(_yearCE), _yearCE,
                _yearCE = "", "",
                NOT(ISNUMBER(_yearCE)), {#VALUE!},
                NOT(IS_INTEGER(_yearCE)), {#NUM!},
                TRUE, LET(
                    _isCE, _yearCE >= 1,
                    _year, IF(_isCE, _yearCE, 1 - _yearCE),
                    _suffix, IFS(
                        NOT(_isCE), " BCE",
                        _yearCE < 1000, " CE",
                        _alwaysShowEra, " CE",
                        TRUE, ""
                    ),
                    CONCAT(TEXT(_year, "0"), _suffix)
                )
            )
        ),

        MAP(YearCE,
            LAMBDA(_element,
                fnFormatLiteraryYear(NULLIFY(_element))
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_LITERARY_DATE

Parses a literary date into respective parts of year, month, day and time of day.

Array compatible: LiteraryDate as column

Output C[4]
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day
 4 | decimal [0..1]  | Time

Parameters
----------------------------------------------------------------------------------------------------------------
LiteraryDate     | text   | Literary date and time
[JulianCalendar] | switch | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |        | proleptic calendar. 

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_LITERARY_DATE("Feb 25, 2014, 6:00")
Returns: {2014, 2, 25, 0.25}

PARSE_LITERARY_DATE("Dec 31, 2023, 24:00")
Returns: {2023, 12, 31, 1}

PARSE_LITERARY_DATE("Feb 25")
Returns: { , 2, 25, }
--------------------------------------------------------------------------------------------------------------*/
PARSE_LITERARY_DATE = LAMBDA(LiteraryDate, [JulianCalendar],
    LET(
        _julianCalendar, N(JulianCalendar) <> 0,

        fnParseDay, LAMBDA(_dayPart, _year, _month,
            LET(
                _day, INT(VALUE(_dayPart)),
                IFS(
                    _day <= 0, {#NUM!},
                    _day <= DAYS_IN_MONTH(_month, _year, _julianCalendar), _day,
                    TRUE, {#NUM!}
                )
            )
        ),

        fnParseTime, LAMBDA(_timePart,
            LET(
                _tryTime, DATEVALUE(_timePart) + TIMEVALUE(_timePart),
                IFS(
                    ISERROR(_tryTime), "",
                    _tryTime > 1, {#NUM!},
                    TRUE, _tryTime
                )
            )
        ),

        fnParseLiteraryDate, LAMBDA(_literaryDate,
            IF(ISERROR(_literaryDate), HSTACK(_literaryDate, "", "", ""),
                LET(
                    _tLitDate, TRIM(_literaryDate),
                    IF(_tLitDate = "", {"", "", "", ""},
                        LET(
                            _parts, SPLIT(_tLitDate, ","),
                            _cols, COLUMNS(_parts),
                            IFS(
                                _cols = 1, LET(
                                    _part1, INDEX(_parts, 1, 1),
                                    _spacePos, IFERROR(FIND(" ", _part1), 0),
                                    IF(_spacePos = 0, {#VALUE!, "", "", ""},
                                        LET(
                                            _month, PARSE_MONTH(LEFT(_part1, _spacePos - 1)),
                                            _daysInMonth, DAYS_IN_MONTH(_month, 2000),
                                            _remain, MID(_part1, _spacePos + 1, LEN(_part1) - _spacePos),
                                            _denotedYear, IFERROR(SEARCH("C", _remain), 0) > 0,
                                            _val, IF(_denotedYear, PARSE_LITERARY_YEAR(_remain), VALUE(_remain)),
                                            _day, IFS(
                                                _denotedYear, "",
                                                _val <= 0, "",
                                                _val <= _daysInMonth, _val,
                                                TRUE, ""
                                            ),
                                            _year, IFS(
                                                _denotedYear, _val,
                                                _val <= 0, _val,
                                                _val <= _daysInMonth, "",
                                                TRUE, _val
                                            ),
                                            HSTACK(_year, _month, _day, "")
                                        )
                                    )
                                ),
                                _cols = 2, LET(
                                    _p1, INDEX(_parts, 1, 1),
                                    _spacePos, IFERROR(FIND(" ", _p1), 0),
                                    IF(_spacePos = 0, {#VALUE!, "", "", ""},
                                        LET(
                                            _month, PARSE_MONTH(LEFT(_p1, _spacePos - 1)),
                                            _p2, INDEX(_parts, 1, 2),
                                            _time, fnParseTime(_p2),
                                            _year, IF(NOT(ISNUMBER(_time)), PARSE_LITERARY_YEAR(_p2), ""),
                                            _dayPart, MID(_p1, _spacePos + 1, LEN(_p1) - _spacePos),
                                            _day, fnParseDay(_dayPart, _year, _month),
                                            HSTACK(_year, _month, _day, _time)
                                        )
                                    )
                                ),
                                _cols = 3, LET(
                                    _year, PARSE_LITERARY_YEAR(INDEX(_parts, 1, 2)),
                                    _time, fnParseTime(INDEX(_parts, 1, 3)),
                                    _p1, INDEX(_parts, 1, 1),
                                    _spacePos, IFERROR(FIND(" ", _p1), 0),
                                    IF(_spacePos = 0, {#VALUE!, "", "", ""},
                                        LET(
                                            _month, PARSE_MONTH(LEFT(_p1, _spacePos - 1)),
                                            _dayPart, MID(_p1, _spacePos + 1, LEN(_p1) - _spacePos),
                                            _day, fnParseDay(_dayPart, 2000, _month),
                                            HSTACK(_year, _month, _day, _time)
                                        )
                                    )
                                ),
                                TRUE, {#VALUE!, "", "", ""}
                            )
                        )
                    )
                )
            )
        ),
        
        _rowCount, ROWS(LiteraryDate),
        DROP(
            REDUCE("", SEQUENCE(_rowCount),
                LAMBDA(_acc, _curr,
                    VSTACK(
                        _acc,
                        fnParseLiteraryDate(NULLIFY(INDEX(LiteraryDate, _curr, 1)))
                    )
                )
            ), 1
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
FORMAT_LITERARY_DATE

Returns a date formatted in literary style.

Array compatible: Date_YMDT as columns

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | Literary date

Parameters
----------------------------------------------------------------------------------------------------------------
Date_YMDT        | array   C[2..4]  |
   YearCE        | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
   [Month]       | integer [1..12]  | Month of year. Can be empty.
   [Day]         | decimal [0..367) | Day. Ordinal day of year if month empty. Can be empty. If time is not omitted
                 |                  | any decimal part is ignored.
   [Time]        | decimal [0..1)   | Time of day. If omitted then decimal part of day is taken.
[Options]        | text             | [S][I][E]
                 |                  |  S : Display short form months
                 |                  |  I : Use International English instead of local language set in Excel
                 |                  |  E : Always apply BCE/CE suffix. If not used, only years less than 1000
                 |                  |      show an era.
[JulianCalendar] | switch           | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                  | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
FORMAT_LITERARY_DATE = LAMBDA(Date_YMDT, [Options], [JulianCalendar],
    LET(
        _options, IF(ISOMITTED(Options), "", Options),
        _julianCalendar, N(JulianCalendar) <> 0,
        _short, IFERROR(SEARCH("S", _options), 0) > 0,
        _intEnglish, IFERROR(SEARCH("I", _options), 0) > 0,
        _era, IFERROR(SEARCH("E", _options), 0) > 0,

        fnFormatLiteraryDate, LAMBDA(_date_YMDT,
            IF(MAX(N(NOT(IS_EMPTY(_date_YMDT)))) = 0, "",
                LET(
                    _normaliseYMDT, NORMALISE_YMDT(_date_YMDT, _julianCalendar),
                    _yearProvided, ISNUMBER(INDEX(_normaliseYMDT, 1, 1)),
                    _nominalYMDT, IF(_yearProvided, _normaliseYMDT,
                        HSTACK(2000, DROP(_normaliseYMDT, , 1))
                    ),
                    _resolveYMDT, RESOLVE_YMDT(_nominalYMDT, 3, 0, 1, _julianCalendar),
                    _sDate, IF(MAX(N(ISERROR(TAKE(_date_YMDT, 1, 3)))) > 0, "#DATE!",
                        LET(
                            _sMonth, MONTH_NAME(INDEX(_resolveYMDT, 1, 2), _short, _intEnglish),
                            _sDay, IF(IS_EMPTY(INDEX(_date_YMDT, 1, 3)), "", TEXT(INDEX(_resolveYMDT, 1, 3), " 0")),
                            _sYear, IF(_yearProvided, CONCAT(", ", FORMAT_LITERARY_YEAR(INDEX(_resolveYMDT, 1, 1), _era)), ""),
                            CONCAT(_sMonth, _sDay, _sYear)
                        )
                    ),
                    _ToD, INDEX(_resolveYMDT, 1, 4),
                    _sTime, IFS(
                        ISERROR(_ToD), "#TIME!",
                        _ToD = "", "",
                        TRUE, TEXT(_ToD, "h:mm AM/PM")
                    ),
                    IF(_sTime = "", _sDate, CONCAT(_sDate, ", ", _sTime))
                )
            )
        ),
        
        BYROW(Date_YMDT,
            LAMBDA(_date_YMDT,
                fnFormatLiteraryDate(NULLIFY(_date_YMDT))
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_US_DATE

Parses a US formated date into respective parts of year, month, day and time of day.

Array compatible: USDate as column

Output C[4]
----------------------------------------------------------------------------------------------------------------
 1 | integer         | Year
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day
 4 | decimal [0..1)  | Time

Parameters
----------------------------------------------------------------------------------------------------------------
USDate           | text   | Date in US format ie. MM/dd/yyyy hh:mm:ss
[JulianCalendar] | switch | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |        | proleptic calendar. 

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_US_DATE("1/25/2014 6:00")
Returns: {2014, 1, 25, 0.25}

PARSE_US_DATE("12/31/2023 24:00")
Returns: {2023, 12, 31, 1}
--------------------------------------------------------------------------------------------------------------*/
PARSE_US_DATE = LAMBDA(USDate, [JulianCalendar], 
    LET(
        _julianCalendar, N(JulianCalendar) <> 0,
        _validCharSet, "0123456789AMPTamp :,-./_", //  UNICHAR(8722)

        fnYearValue, LAMBDA(_sYear,
            LET(
                _char1, LEFT(_sYear),
                _sign, IFS(
                    _char1 = "+", 1,
                    _char1 = "-", -1,
                    UNICODE(_char1) = 8722, -1,
                    TRUE, ""
                ),
                IF(_sign = "",
                    INT(VALUE(_sYear)),
                    _sign * INT(VALUE(RIGHT(_sYear, LEN(_sYear) - 1)))
                )
            )
        ),

        fnTimeValue, LAMBDA(_sTime,
            IFS(
                ISERROR(_sTime), _sTime,
                _sTime = "", "",
                TRUE, LET(
                    _eot, FIND_NTH_CHAR(_sTime, " AP"),
                    _tod, IF(_eot = 0, _sTime, LEFT(_sTime, _eot - 1)),
                    _pm, IF(_eot = 0, FALSE,
                        LET(
                            _sfx, TRIM(RIGHT(_sTime, LEN(_sTime) - _eot + 1)),
                            IFS(
                                _sfx = "PM", TRUE,
                                _sfx = "P", TRUE,
                                _sfx = "AM", FALSE,
                                _sfx = "A", FALSE,
                                TRUE, {#VALUE!}
                            )
                        )
                    ),
                    IF(ISERROR(_pm), {#VALUE!},
                        LET(
                            _tval, PARSE_TIMESPAN(_tod) + IF(_pm, 0.5, 0),
                            IF(_tval > 1, {#VALUE!}, _tval)
                        )
                    )
                )
            )
        ),

        fnParseUSDate, LAMBDA(_USDate,
            IF(ISERROR(_USDate), _USDate, //HSTACK(_USDate, "", "", ""),
                LET(
                    _trimUSDate, TRIM(_USDate),
                    IFS(
                        _trimUSDate = "", "", //{"", "", "", ""},
                        NOT(VALIDATE_CHARSET(_trimUSDate, _validCharSet, 1)), {#VALUE!}, //{#VALUE!, "", "", ""},
                        TRUE, LET(
                            _isTimeOnly, LEFT(SIFT_FOR_CHARS(_trimUSDate, "-./:")) = ":",
                            IF(_isTimeOnly, fnTimeValue(_trimUSDate), //HSTACK("", "", "", fnTimeValue(_trimUSDate)),
                                LET(
                                    _tPos1, FIND_NTH_CHAR(_trimUSDate, " T_,", 1, 1),
                                    _tPos2, IF(_tPos1 = 0, 0, FIND_NTH_CHAR(_trimUSDate, "0123456789", 1, 0, 0, _tPos1 + 1)),
                                    _datePart, IF(_tPos1 = 0, _trimUSDate, TRIM(LEFT(_trimUSDate, _tPos1 - 1))),
                                    _timePart, IF(_tPos2 = 0, "", TRIM(RIGHT(_trimUSDate, LEN(_trimUSDate) - _tPos2 + 1))),
                                    _timeOfDay, fnTimeValue(_timePart),
                                    _timePart
                                    /*_dateSplit, SPLIT_FOR_CHARS(_datePart, "0123456789" & UNICHAR(8722)),
                                    _datePattern, INDEX(_dateSplit, 1, 2), 
                                    _dateError, IFS(
                                        INDEX(_dateSplit, 1, 1) = 0, TRUE,
                                        _datePattern = "//", FALSE,
                                        _datePattern = "--", FALSE,
                                        _datePattern = "..", FALSE,
                                        TRUE, TRUE
                                    ),
                                    _ymd, IF(_dateError, {#VALUE!, #VALUE!, #VALUE!},
                                        VALIDATE_CALENDAR_DATE(
                                            HSTACK(
                                                fnYearValue(INDEX(_dateSplit, 1, 5)),
                                                VALUE(INDEX(_dateSplit, 1, {3, 4}))
                                            ), _julianCalendar
                                        )
                                    ),
                                    HSTACK(_ymd, _timeOfDay)
                                    //NORMALISE_YMDT(HSTACK(_ymd, _timeOfDay), _julianCalendar)*/
                                )
                            )
                        )
                    )
                )
            )
        ),
        
        _rowCount, ROWS(USDate),
        DROP(
            REDUCE("", SEQUENCE(_rowCount),
                LAMBDA(_acc, _curr,
                    VSTACK(
                        _acc,
                        fnParseUSDate(NULLIFY(INDEX(USDate, _curr, 1)))
                    )
                )
            ), 1
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
FORMAT_US_DATE

Returns a date formatted in the US style.

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | US style date

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] |
Day              | integer [1..31] |
[Time]           | decimal [0..1)  | Time of day as decimal fraction of a day.
[Options]        | text            | String with elements: [<][LowOrder][DateSeparator][TimeSeparator]
                 |                 |      LowOrder : low order component to display
                 |                 |          Null : Defaults to minutes if time present, otherwise day
                 |                 |             D : Day
                 |                 |             H : Hour
                 |                 |             M : Minute
                 |                 |             S : Second
                 |                 |             T : Millisecond (ticks)
                 |                 |             < : Round by truncating components. Default is rounding to nearest.
                 |                 | DateSeparator : Character to separate date components. [,./-_]
                 |                 | TimeSeparator : Character to separate time components. [,.:-_]
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar. 
--------------------------------------------------------------------------------------------------------------*/
/*FORMAT_US_DATE = LAMBDA(YearCE, Month, Day, [Time], [Options], [JulianCalendar],
    IF(IS_EMPTY(YearCE) * IS_EMPTY(Month) * IS_EMPTY(Day) * IS_EMPTY(Time),  "",
       LET(
            _options, IF(ISOMITTED(Options), "", Options), 
            _hasTime, ISNUMBER(Time),
            _hasDate, ISNUMBER(YearCE) * ISNUMBER(Month) * ISNUMBER(Day),
            IF(NOT(_hasDate + _hasTime), {#VALUE!},
                LET(
                    fnFormatDate, LAMBDA(_separator, _yearCE, _month, _day,
                        IF(NOT(IS_VALID_DATE(_yearCE, _month, _day, JulianCalendar)), "#DATE!",
                            LET(
                                _sYear, TEXT(_yearCE, "0000;" & UNICHAR(8722) & "0000;0000"),
                                _sMonth, TEXT(_month, "0"),
                                _sDay, TEXT(_day, "0"),
                                CONCAT(_sMonth, _separator, _sDay, _separator, _sYear)
                            )
                        )
                    ),
                                        
                    fnFormatTime, LAMBDA(_separator, _lowOrder, _timeOfDay,
                        IFS(
                            IS_EMPTY(_timeOfDay), "",
                            _lowOrder = 1, "",
                            NOT(ISNUMBER(_timeOfDay)), "#TIME!",
                            _timeOfDay < 0, "#TIME!",
                            _timeOfDay > 1, "#TIME!",
                            TRUE, LET(
                                _fmt, IFS(
                                    _lowOrder = 1, "",
                                    _lowOrder = 2, "h AM/PM",
                                    _lowOrder = 3, "h\" & _separator & "mm AM/PM",
                                    _lowOrder = 4, "h\" & _separator & "mm\" & _separator & "ss AM/PM",
                                    _lowOrder = 5, "h\" & _separator & "mm\" & _separator & "ss.000 AM/PM"
                                ),
                                TEXT(_timeOfDay, _fmt)
                            )
                        )
                    ),

                    _truncate, IFERROR(FIND("<", _options), 0) > 0,
                    _lowOrder, IF(NOT(_hasTime), 1,
                        LET(
                            _low, SIFT_FOR_CHARS(_options, "DHMST"),
                            IFS(
                                _low = "D", 1,
                                _low = "H", 2,
                                _low = "M", 3,
                                _low = "S", 4,
                                _low = "T", 5,
                                TRUE, 3
                            )
                        )
                    ),
                    _useLowOrder, IF(_lowOrder = 5, 4, _lowOrder),
                    _precision, IF(_lowOrder = 5, 3, 0),
            
                    _tryDateSepChar, FIND_NTH_CHAR(_options, ",./-_", 1, 0, 1),
                    _dateSeparator, IF(INDEX(_tryDateSepChar, 1, 1) = 0, "/",
                        INDEX(_tryDateSepChar, 1, 2)
                    ),
                    _tryTimeSepChar, FIND_NTH_CHAR(Options, ",.:-_", 1, 0, 1, INDEX(_tryDateSepChar, 1, 1) + 1),
                    _timeSeparator, IF(INDEX(_tryTimeSepChar, 1, 1) = 0, ":",
                        INDEX(_tryTimeSepChar, 1, 2)
                    ),
                    
                    IFS(
                        _hasDate * _hasTime, LET(
                            _rDateTime, RESOLVE_DATETIME(YearCE, Month, INT(Day), Time, _useLowOrder, _precision, _truncate, JulianCalendar),
                            _sDate, fnFormatDate(_dateSeparator, INDEX(_rDateTime, 1, 1), INDEX(_rDateTime, 1, 2), INDEX(_rDateTime, 1, 3)),
                            _sTime, fnFormatTime(_timeSeparator, _lowOrder, INDEX(_rDateTime, 1, 4)),
                            IF(_sTime = "",
                                _sDate,
                                CONCAT(_sDate, " ", _sTime)
                            )
                        ),
                        _hasTime, LET(
                            // no date, time only
                            _rTimeOfDay, ROUND_TIMESPAN(Time, _useLowOrder, _precision, _truncate),
                            fnFormatTime(_timeSeparator, _lowOrder, _rTimeOfDay)
                        ),
                        TRUE, fnFormatDate(_dateSeparator, YearCE, Month, INT(Day)) // date only
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_MIL_DTG

Parses a date-time group in the format used by US Military message traffic, into respective parts of year,
month, day, time of day and time zone offset in minutes.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [1951..2050] | Year
 2 | integer [1..12]      | Month
 3 | integer [1..31]      | Day
 4 | decimal [0..1)       | Time
 5 | decimal [-900..900]  | Time zone offset minutes

Parameters
----------------------------------------------------------------------------------------------------------------
DTG | text | Date-time group in US Military format ie. ddHHmmssZmmmYY

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_MIL_DTG("12 15 30 45 B MAY 23")
Returns: {2023, 5, 12, 0.77118055, 120}

PARSE_MIL_DTG("05064515KJUN00")
Returns: {2000, 6, 5, 0.281423611, 600}

PARSE_MIL_DTG("150600Z")
Returns: { , , 15, 0.25, 0}
--------------------------------------------------------------------------------------------------------------*/
/*PARSE_MIL_DTG = LAMBDA(DTG,
    LET(
        _DTG, SUBSTITUTE(DTG, " ", ""),
        IFS(
            IS_EMPTY(_DTG), {"", "", "", "", ""},
            NOT(VALIDATE_CHARSET(_DTG, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ", 1)), {#VALUE!, "", "", "", ""},
            TRUE, LET(
                fnYear, LAMBDA(_sYear,
                    LET(
                        _yy, VALUE(_sYear),
                        IF(_yy < 51, 2000 + _yy, 1900 + _yy)
                    )
                ),

                fnTime, LAMBDA(_hour, _minute, _second,
                    IF(NOT(IS_VALID_TIME_OF_DAY(_hour, _minute, _second, 0)), {#NUM!},
                        TIMESPAN(
                            HSTACK(1, 0, _hour, _minute, _second)
                        )
                    )
                ),

                fnParseFull, LAMBDA(_DTG,
                    LET(
                        _day, VALUE(LEFT(_DTG, 2)),
                        _month, PARSE_MONTH(MID(_DTG, 10, 3)),
                        _year, fnYear(RIGHT(_DTG, 2)),
                        IF(NOT(IS_VALID_DATE(_year, _month, _day, 0)), {#VALUE!, "", "", "", ""},
                            LET(
                                _hour, VALUE(MID(_DTG, 3, 2)),
                                _minute, VALUE(MID(_DTG, 5, 2)),
                                _second, VALUE(MID(_DTG, 7, 2)),
                                _time, fnTime(_hour, _minute, _second),
                                _tz, IFNA(MILITARY_TZO(MID(_DTG, 9, 1)), ""),
                                HSTACK(
                                    _year,
                                    _month,
                                    _day,
                                    _time,
                                    _tz
                                )
                            )
                        )
                    )
                ),

                fnParseShort, LAMBDA(_DTG,
                    LET(
                        _day, VALUE(LEFT(_DTG, 2)),
                        _month, PARSE_MONTH(MID(_DTG, 8, 3)),
                        _year, fnYear(RIGHT(_DTG, 2)),
                        IF(NOT(IS_VALID_DATE(_year, _month, _day, 0)), {#VALUE!, "", "", "", ""},
                            LET(
                                _hour, VALUE(MID(_DTG, 3, 2)),
                                _minute, VALUE(MID(_DTG, 5, 2)),
                                _time, fnTime(_hour, _minute, 0),
                                _tz, IFNA(MILITARY_TZO(MID(_DTG, 7, 1)), ""),
                                HSTACK(
                                    _year,
                                    _month,
                                    _day,
                                    _time,
                                    _tz
                                )
                            )
                        )
                    )
                ),

                fnParsePlan, LAMBDA(_DTG,
                    LET(
                        _day, VALUE(LEFT(_DTG, 2)),
                        _hour, VALUE(MID(_DTG, 3, 2)),
                        _minute, VALUE(MID(_DTG, 5, 2)),
                        _time, fnTime(_hour, _minute, 0),
                        _tz, IFNA(MILITARY_TZO(MID(_DTG, 7, 1)), ""),
                        HSTACK(
                            "",
                            "",
                            _day,
                            _time,
                            _tz
                        )
                    )
                ),

                _len, LEN(_DTG),
                _fmt, IFS(_len = 14, "F", 
                    _len = 12, "S",
                    _len = 7, "P",
                    TRUE, #N/A
                ),
                IFS(
                    ISNA(_fmt), {#VALUE!, "", "", "", ""},
                    _fmt = "F", fnParseFull(_DTG),
                    _fmt = "S", fnParseShort(_DTG),
                    _fmt = "P", fnParsePlan(_DTG)
                )
            )
        )
    )
);

/*--------------------------------------------------------------------------------------------------------
FORMAT_MIL_DTG

Returns a date formatted in US Military message traffic style.

Output
----------------------------------------------------------------------------------------------------------
 1 | text | DTG formatted date

Parameters
----------------------------------------------------------------------------------------------------------
Year         | integer         |
             | [1951..2050]    |
Month        | integer [1..12] |
Day          | integer [1..31] |
Time         | decimal [0..1)  | Time of day as decimal fraction of a day.
[TZOMinutes] | decimal         | Time zone offset from UTC in minutes
             | [-900..900]     | Assumed to be UTC if omitted. [-15:00..+15:00]
             |                 | Time will be converted if the offset does not align with military
             |                 | time zones.
[Options]    | text            | String with elements: [S][_][<]
             |                 |  S : Short format, omits seconds
             |                 |  _ : Spacing between components
             |                 |  < : Round by truncating components. Default is rounding to nearest.

Examples
----------------------------------------------------------------------------------------------------------
FORMAT_MIL_DTG(2023, 2, 12, 0.75, 600, 1)
Returns: 121800KFEB23

FORMAT_MIL_DTG( , , 12, 0.25)
Returns: 120600J
--------------------------------------------------------------------------------------------------------*/
/*FORMAT_MIL_DTG = LAMBDA(Year, Month, Day, Time, [TZOMinutes], [Options],
    IFS(
        IS_EMPTY(Year) * IS_EMPTY(Month) * IS_EMPTY(Day) * IS_EMPTY(Time), "",
        NOT(IS_NUMERIC_NULL(Year)), {#VALUE!},
        NOT(IS_NUMERIC_NULL(Month)), {#VALUE!},
        NOT(IS_NUMERIC_NULL(Day)), {#VALUE!},
        NOT(IS_EMPTY(Month)) * NOT(IS_VALID_DATE(Year, Month, Day, 0)), "#DATE!",
        TRUE, LET(
            _tzo, N(TZOMinutes),
            _short, IFERROR(SEARCH("S", Options), 0) > 0,
            _spacing, IFERROR(FIND("_", Options), 0) > 0,
            _truncate, IFERROR(FIND("<", Options), 0) > 0,
            
            fnFmtTime, LAMBDA(_time,
                LET(
                    _timeFmt, IFS(
                        _short * _spacing, "hh mm",
                        _short * NOT(_spacing), "hhmm",
                        NOT(_short) * _spacing, "hh mm ss",
                        TRUE, "hhmmss"
                    ),
                    TEXT(_time, _timeFmt)
                )
            ),

            _day, INT(Day),
            _nominalYear, IF(IS_EMPTY(Year), 2001, Year),
            _nominalMonth, IF(IS_EMPTY(Year), 3, Month),
            _militaryTZ, TZO_TO_MILITARY(TZOMinutes),
            _nominalTime, N(Time) + INDEX(_militaryTZ, 1, 3),
            _rDateTime, RESOLVE_DATETIME(_nominalYear, _nominalMonth, _day, _nominalTime, 4 - N(_short), _truncate, 0),
            _sDay, TEXT(INDEX(_rDateTime, 3), "00"),
            _sTime, fnFmtTime(INDEX(_rDateTime, 4)),
            _sTZ, INDEX(_militaryTZ, 1, 1),
            _spc, IF(_spacing, " ", ""),
            IF(IS_EMPTY(Year),
                CONCAT(_sDay, _spc, _sTime, _spc, _sTZ),
                IF((INDEX(_rDateTime, 1) < 1951) + (INDEX(_rDateTime, 1) > 2050), "#RANGE!",
                    LET(
                        _sMonth, UPPER(MONTH_NAME(INDEX(_rDateTime, 2), 1, 1)),
                        _sYY, TEXT(MOD(INDEX(_rDateTime, 1), 100), "00"),
                        CONCAT(_sDay, _spc, _sTime, _spc, _sTZ, _spc, _sMonth, _spc, _sYY)
                    )
                )
            )
        )
    )
);















/*##############################################################################################################
# ORDINAL DATES                                                                                                #
##############################################################################################################*/


/*--------------------------------------------------------------------------------------------------------------
IS_VALID_ORDINAL_DATE

Tests if an ordinal date is valid for the given calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE           | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
OrdinalDay       | decimal [1..367) | Day of year
[JulianCalendar] | switch           | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                  | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
IS_VALID_ORDINAL_DATE = LAMBDA(YearCE, OrdinalDay, [JulianCalendar],
    IFS(
        NOT(ISNUMBER(YearCE)) + NOT(ISNUMBER(OrdinalDay)), FALSE, // cannot omit year or ordinal day
        NOT(IS_INTEGER(YearCE)), FALSE, // year cannot be fractional
        TRUE, LET(
            _ordinalDay, INT(OrdinalDay),
            IF(_ordinalDay < 1, FALSE,
                LET(
                    _daysInYear, DAYS_IN_YEAR(YearCE, JulianCalendar),
                    _ordinalDay <= _daysInYear
                )
            )
        )
    )
);

/*--------------------------------------------------------------------------------------------------------------
PARSE_ISO_ORDINAL_DATE

Parses an ISO formatted ordinal date into respective parts of year, and ordinal day.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer          | YearCE
 2 | integer [1..366] | Ordinal day

Parameters
----------------------------------------------------------------------------------------------------------------
ISOOrdinalDate   | text   | Date in ISO format ie. yyyy-ddd
[JulianCalendar] | switch | Validate in the Julian proleptic calendar. Default is Gregorian
                 |        | proleptic calendar.

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_ISO_ORDINAL_DATE("2023-223")
Returns: {2023, 223}

PARSE_ISO_ORDINAL_DATE("1900-366", 1)
Returns: {2023, 366} i.e. 1900 was a leap year in the Julian calendar
--------------------------------------------------------------------------------------------------------------*/
/*PARSE_ISO_ORDINAL_DATE = LAMBDA(ISOOrdinalDate, [JulianCalendar],
    IFS(
        IS_EMPTY(ISOOrdinalDate), {"", ""},
        NOT(VALIDATE_CHARSET(ISOOrdinalDate, "+-0123456789" & UNICHAR(8722))), {#VALUE!, ""},
        TRUE, LET(
            _firstChar, LEFT(ISOOrdinalDate),
            _isSigned, IFS(
                _firstChar = "+", TRUE,
                _firstChar = "-", TRUE,
                _firstChar = UNICHAR(8722), TRUE,
                TRUE, FALSE
            ),
            _sign, IFS(
                NOT(_isSigned), 1,
                _firstChar = "-", -1,
                _firstChar = UNICHAR(8722), -1,
                TRUE, 1
            ),
            _unSigned, IF(_isSigned,
                RIGHT(ISOOrdinalDate, LEN(ISOOrdinalDate) - 1),
                ISOOrdinalDate
            ),
            _len, LEN(_unSigned),
            _pattern, REPLACE_CHARS(_unSigned, "0123456789", "_"),
            _tryParse, IFS(
                _len >= 8, IF(
                    _pattern = RIGHT("_______________-___", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 4)),
                        VALUE(RIGHT(_unSigned, 3))
                    ),
                    ""
                ),
                _len = 7, IF(
                    _pattern = "_______",
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 3)),
                        VALUE(RIGHT(_unSigned, 3))
                    ),
                    ""
                ),
                (_len >= 4) * (_len <= 5), IF(
                    _pattern = RIGHT("_____", _len),
                    HSTACK(
                        VALUE(_unSigned),
                        ""
                    ),
                    ""
                ),
                TRUE, #N/A
            ),

            IF(ISERROR(INDEX(_tryParse, 1, 1)), {#VALUE!, ""},
                LET(
                    _year, _sign * INDEX(_tryParse, 1, 1),
                    _ordinalDay, INDEX(_tryParse, 1, 2),
                    IFS(
                        _ordinalDay = "", HSTACK(_year, ""),
                        IS_VALID_ORDINAL_DATE(_year, _ordinalDay, JulianCalendar),
                            HSTACK(_year, _ordinalDay),
                        TRUE,
                            HSTACK(_year, {#NUM!})
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
FORMAT_ISO_ORDINAL_DATE

Returns an ordinal date as text in ISO format.

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | ISO formatted ordinal date

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE           | integer          | Note that 1 BC = 0 CE, 2 BC = -1 CE
OrdinalDay       | integer [1..366] |
[Basic]          | switch           | Display in basic format eg yyyyddd.
                 |                  | Invalid when OrdinalDay provided and YearCE outside of range -9999..9999
                 |                  | due to collision with yyyyMMdd ISO format.
[JulianCalendar] | switch           | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                  | proleptic calendar. 
--------------------------------------------------------------------------------------------------------------*/
/*FORMAT_ISO_ORDINAL_DATE = LAMBDA(YearCE, OrdinalDay, [Basic], [JulianCalendar],
    IFS(
        IS_EMPTY(YearCE) * IS_EMPTY(OrdinalDay), "",
        NOT(ISNUMBER(YearCE)), {#VALUE!},
        NOT(IS_NUMERIC_NULL(OrdinalDay)), {#VALUE!},
        IS_EMPTY(OrdinalDay), FORMAT_ISO_Year(YearCE),
        TRUE, LET(
            _basic, N(Basic) <> 0,
            IF(_basic * (ABS(YearCE) > 9999), {#VALUE!},
                LET(
                    _delim, IF(_basic, "", "-"),
                    IF(NOT(IS_VALID_ORDINAL_DATE(YearCE, OrdinalDay, JulianCalendar)), {#NUM!},
                        CONCAT(
                            FORMAT_ISO_Year(YearCE),
                            _delim, TEXT(OrdinalDay, "000")
                        )
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
ORDINAL_DATE_TO_MJDATE

Converts an ordinal date and time in the specified calendar to a Modified Julian Date (MJDATE).

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Modified Julian Date

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE           | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
OrdinalDay       | integer [1..366] | Day of year, carries if range exceeded
[Time]           | decimal [0..1)   | Time of day
[JulianCalendar] | switch           | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                  | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
/*ORDINAL_DATE_TO_MJDATE = LAMBDA(YearCE, OrdinalDay, [Time], [JulianCalendar],
    IFS(
        (YearCE = "") * (OrdinalDay = "") * (Time = ""), "",
        NOT(ISNUMBER(YearCE)) + NOT(ISNUMBER(OrdinalDay)), {#VALUE!},
        TRUE, LET(
            _ordinalDay, INT(OrdinalDay),
            _MJDNYear, MODIFIED_JULIAN_DAY_NUMBER(YearCE, 1, 1, JulianCalendar) - 1,
            _MJDNYear + _ordinalDay + N(Time)
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
MJDATE_TO_ORDINAL_DATE

Converts a Modified Julian Date (MJDATE) to an ordinal date and time in the specified calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer           | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..366]  | Ordinal day
 3 | decimal [0..1)    | Time of day
 4 | integer [365,366] | Days in year

Parameters
----------------------------------------------------------------------------------------------------------------
MJDate           | decimal | Modified Julian Date
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
/*MJDATE_TO_ORDINAL_DATE = LAMBDA(MJDate, [JulianCalendar],
    IFS(
        MJDate = "", {"", "", "", ""},
        NOT(ISNUMBER(MJDate)), {#VALUE!, "", "", ""},
        TRUE, LET(
            _cDate, MJDATE_TO_CALENDAR_DATE(MJDate, JulianCalendar),
            _yearCE, INDEX(_cDate, 1, 1),
            _MJDNYear, MODIFIED_JULIAN_DAY_NUMBER(_yearCE, 1, 1, JulianCalendar) - 1,
            _ordinalDay, INT(MJDate - _MJDNYear),
            _daysInYear, DAYS_IN_YEAR(_yearCE, JulianCalendar),
            HSTACK(
                _yearCE,
                _ordinalDay,
                INDEX(_cDate, 1, 4),
                _daysInYear
            )
        )
    )
);












/*##############################################################################################################
# WEEKS                                                                                                        #
##############################################################################################################*/


/*--------------------------------------------------------------------------------------------------------------
CONVERT_WEEKDAY_NUMBER

Returns an integer for the day of the week from the traditonal numbering scheme to the ISO definition, or
vice versa.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Weekday number
   | [1..7]  |    | ISO       | Traditioal
   |         | ---------------------------
   |         |  1 | Monday    | Sunday 
   |         |  2 | Tuesday   | Monday 
   |         |  3 | Wednesday | Tuesday
   |         |  4 | Thursday  | Wednesday
   |         |  5 | Friday    | Thursday
   |         |  6 | Saturday  | Friday
   |         |  7 | Sunday    | Saturday

Parameters
----------------------------------------------------------------------------------------------------------------
DayOfWeek          | integer [1..7] | Day of week number
[ISOtoTraditional] | switch         | Return day of week using traditional numbering scheme, assuming 
                   |                | DayOfWeek was provided according to ISO definition.
                   |                | Default is to return in ISO definition, assuming DayOfWeek was
                   |                | provided according to the traditional numbering scheme.
--------------------------------------------------------------------------------------------------------------*/
CONVERT_WEEKDAY_NUMBER = LAMBDA(DayOfWeek, [ISOtoTraditional],
    IFS(
        DayOfWeek = "", "",
        NOT(ISNUMBER(DayOfWeek)), {#VALUE!},
        TRUE, LET(
            _givenDoW, INT(N(DayOfWeek)),
            _fromISO, N(ISOtoTraditional) <> 0, 
            _shiftDoW, _givenDow + IF(_fromISO, 0, -2),
            MOD(_shiftDow, 7) + 1
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_WEEKDAY

Returns a number representing the day of the week from a given text weekday name.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Weekday number
   | [1..7]  |    | ISO       | Traditioal
   |         | ---------------------------
   |         |  1 | Monday    | Sunday 
   |         |  2 | Tuesday   | Monday 
   |         |  3 | Wednesday | Tuesday
   |         |  4 | Thursday  | Wednesday
   |         |  5 | Friday    | Thursday
   |         |  6 | Saturday  | Friday
   |         |  7 | Sunday    | Saturday

Parameters
----------------------------------------------------------------------------------------------------------------
DayOfWeekText | text   | Day of week name
[Traditional] | switch | Return day of week using traditional numbering scheme.

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_WEEKDAY("Saturday")
Returns: 6

PARSE_WEEKDAY("Mon", 1)
Returns: 2

PARSE_WEEKDAY("Thurs")
Returns: #VALUE!

PARSE_WEEKDAY("Ven")
Returns: 5 (Friday, if local language is set to Italian)
--------------------------------------------------------------------------------------------------------------*/
/*PARSE_WEEKDAY = LAMBDA(DayOfWeekText, [Traditional],
    IF(DayOfWeekText = "", "",
        LET(
            fnMatchIntEng, LAMBDA(DoW,
                LET(
                    _dow, IF(LEN(DayOfWeekText) = 3,
                        XMATCH(
                            DayOfWeekText,
                            {
                                "Mon";
                                "Tue";
                                "Wed";
                                "Thu";
                                "Fri";
                                "Sat";
                                "Sun"
                            }
                        ),
                        XMATCH(
                            DayOfWeekText,
                            {
                                "Monday";
                                "Tuesday";
                                "Wednesday";
                                "Thursday";
                                "Friday";
                                "Saturday";
                                "Sunday"
                            }
                        )
                    ),
                    IFNA(_dow, 0)
                )
            ),
            fnMatchLocalLang, LAMBDA(DoW,
                LET(
                    _days, SEQUENCE(7, 1, 36528),
                    _dow, IF(LEN(DayOfWeekText) = 3,
                        XMATCH(DayOfWeekText, TEXT(_days, "ddd")),
                        XMATCH(DayOfWeekText, TEXT(_days, "dddd"))
                    ),
                    IFNA(_dow, 0)
                )
            ),
            _ISOWeekday, LET(
                _idx, fnMatchIntEng(DayOfWeekText),
                IF(_idx > 0, _idx, fnMatchLocalLang(DayOfWeekText))
            ),
            IFS(_ISOWeekday = 0, {#VALUE!},
                N(Traditional) = 0, _ISOWeekday,
                TRUE, MOD(_ISOWeekday, 7) + 1
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
WEEKDAY_NAME

Returns name of an ISO day of week number as text.

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | Weekday

Parameters
----------------------------------------------------------------------------------------------------------------
ISOWeekDay             | integer [1..7] | ISO day of week number
[Short]                | switch         | Return short format Mon..Sun
[InternationalEnglish] | switch         | International English instead of local language set in Excel
--------------------------------------------------------------------------------------------------------------*/
/*WEEKDAY_NAME = LAMBDA(ISOWeekDay, [Short], [InternationalEnglish],
    IFS(
        ISOWeekDay = "", "",
        NOT(ISNUMBER(ISOWeekDay)), {#VALUE!},
        TRUE, LET(
            _useShort, N(Short) <> 0,
            _useLocalLang, N(InternationalEnglish) = 0,
            _isoDoW, MOD(INT(ISOWeekDay) - 1, 7) + 1, 
            IF(_useLocalLang,
                LET(
                    _y2krefDay, 36527 + _isoDoW,
                    _fmt, IF(_useShort, "ddd", "dddd"),
                    TEXT(_y2krefDay, _fmt)
                ),
                IF(
                    _useShort,
                    CHOOSE(_isoDoW,
                        "Mon",
                        "Tue",
                        "Wed",
                        "Thu",
                        "Fri",
                        "Sat",
                        "Sun"
                    ),
                    CHOOSE(_isoDoW,
                        "Monday",
                        "Tuesday",
                        "Wednesday",
                        "Thursday",
                        "Friday",
                        "Saturday",
                        "Sunday"
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
DAY_OF_WEEK

Returns an integer for the day of the week for a given Modified Julian Date.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [1..7] | ISO day of week number
   |                | Monday..Sunday

Parameters
----------------------------------------------------------------------------------------------------------------
MJDate | decimal | Modified Julian Date
--------------------------------------------------------------------------------------------------------------*/
/*DAY_OF_WEEK = LAMBDA(MJDate,
    IFS(
        MJDate = "", "",
        NOT(ISNUMBER(MJDate)), {#VALUE!},
        TRUE, LET(
            _MJDN, INT(MJDate),
            MOD(_MJDN + 2, 7) + 1
        )
    )
);




/*--------------------------------------------------------------------------------------------------------------
WEEKDAY_OF_MONTH

Returns a Modified Julian Date for a given day of week, relative week for the month, year and time of day
of the specified calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Modified Julian Date

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] | Month of the year
WeekOfMonth      | integer [-4..5] | Week in the month.
                 |                 | Note if the reference exceeds the bounds of the month, another month
                 |                 | will be returned.
                 |                 |  0 - last week of previous month
                 |                 |  1 - first week
                 |                 |  2 - second week
                 |                 |  3 - third week
                 |                 |  4 - fourth week
                 |                 |  5 - fifth week
                 |                 | -1 - last week
                 |                 | -2 - second to last week
                 |                 | -3 - third to last week
                 |                 | -4 - fourth to last week
ISOWeekDay       | integer [1..7]  | ISO day of week number Monday..Sunday
[Time]           | decimal [0..1)  | Time of day
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
    
Examples
----------------------------------------------------------------------------------------------------------------
WEEKDAY_OF_MONTH(2023, 6, 0, 7)
Returns: MJDate 60120.0 (25/06/2023) ie. the last Sunday of June 2023

WEEKDAY_OF_MONTH(2023, 1, 2, 2, 0.5)
Returns: MJDate 59954.5 (10/01/2023 12pm) ie. midday of the second Tuesday of January 2023
--------------------------------------------------------------------------------------------------------------*/
/*WEEKDAY_OF_MONTH = LAMBDA(YearCE, Month, WeekOfMonth, ISOWeekDay, [Time], [JulianCalendar],
    IFS(
        (YearCE = "") * (Month = "") * (WeekOfMonth = "") * (ISOWeekDay = ""), "",
        NOT(ISNUMBER(YearCE)) + NOT(ISNUMBER(Month)) + NOT(ISNUMBER(WeekOfMonth)) + NOT(ISNUMBER(ISOWeekDay)), {#VALUE!},
        NOT(IS_INTEGER(YearCE) * IS_INTEGER(Month) * IS_INTEGER(WeekOfMonth) * IS_INTEGER(ISOWeekDay)), {#NUM!},
        (WeekOfMonth < -4) + (WeekOfMonth > 5), {#NUM!},
        TRUE, LET(
            _month, Month + N(WeekOfMonth < 0),
            _weekOffset, WeekOfMonth - N(WeekOfMonth >= 0),
            _isoDoW, MOD(ISOWeekDay - 1, 7) + 1,
            _firstOfMonth, MODIFIED_JULIAN_DATE(YearCE, _month, 1, 0, JulianCalendar),
            _firstDoW, DAY_OF_WEEK(_firstOfMonth),
            _firstOfMonth + (_weekOffset * 7) + MOD(_isoDow - _firstDoW, 7) + N(Time)
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
IS_VALID_WEEK_DATE

Tests if a week date is valid for the given calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
ISOWeek          | integer [1..53] | ISO defined week number of the year
[ISOWeekDay]     | integer [1..7]  | ISO defined day of week Monday..Sunday
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
IS_VALID_WEEK_DATE = LAMBDA(YearCE, ISOWeek, [ISOWeekDay], [JulianCalendar],
    IFS(
        NOT(ISNUMBER(YearCE)) + NOT(ISNUMBER(ISOWeek)), FALSE, // cannot omit year or week
        NOT(IS_INTEGER(YearCE) * IS_INTEGER(ISOWeek)), FALSE, // year and week cannot be fractional
        TRUE, LET(
            _validWeek, IFS(
                ISOWeek < 1, FALSE,
                ISOWeek <= 52, TRUE,
                ISOWeek = 53, (WEEKS_IN_YEAR(YearCE, JulianCalendar) = 53),
                TRUE, FALSE
            ),
            IF(NOT(_validWeek), FALSE,
                IF(NOT(ISNUMBER(ISOWeekDay)), TRUE,
                    LET(
                        _weekDay, INT(ISOWeekDay),
                        (_weekDay >= 1) * (_weekDay <= 7) <> 0
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
WEEKS_IN_YEAR

Returns the count of ISO defined weeks in a given year of the specified calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [52,53]

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE           | integer | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
WEEKS_IN_YEAR = LAMBDA(YearCE, [JulianCalendar],
    IFS(
        YearCE = "", "",
        NOT(ISNUMBER(YearCE)), {#VALUE!},
        TRUE, LET(
            _gregorian, N(JulianCalendar) = 0,
            fnLastWeekDayOfYear, LAMBDA(_yearCE,
                LET(
                    _dayPrecession, IF(_gregorian,
                        _yearCE + INT(_yearCE / 4) - INT(_yearCE / 100) + INT(_yearCE / 400) + 6,
                        _yearCE + INT(_yearCE / 4) + 4
                    ),
                    MOD(_dayPrecession, 7) + 1
                )
            ),

            _yearCE, INT(YearCE),
            _dowLastDay, fnLastWeekDayOfYear(_yearCE),
            IF(
                _dowLastDay = 4,
                // if last day of year is a Thursday, then has an extra week
                53,
                LET(
                    _dowLastDayPrev, fnLastWeekDayOfYear(_yearCE - 1) ,
                    IF(
                        _dowLastDayPrev = 3,
                        // if last day of previous year is a Wednesday, then has an extra week
                        53,
                        // otherwise
                        52
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
PARSE_ISO_WEEK_DATE

Parses an ISO formatted week date into respective parts of year, week and weekday.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | YearCE
 2 | integer | ISO week
 3 | integer | ISO week day

Parameters
----------------------------------------------------------------------------------------------------------------
ISOWeekDate      | text   | Week date in ISO format ie. yyyy-Www-d
[JulianCalendar] | switch | Validate in the Julian proleptic calendar. Default is Gregorian
                 |        | proleptic calendar.

Examples
----------------------------------------------------------------------------------------------------------------
PARSE_ISO_WEEK_DATE("2023-W05-1")
Returns: {2023, 5, 1}
--------------------------------------------------------------------------------------------------------------*/
/*PARSE_ISO_WEEK_DATE = LAMBDA(ISOWeekDate, [JulianCalendar],
    IFS(
        IS_EMPTY(ISOWeekDate), {"", "", ""},
        NOT(VALIDATE_CHARSET(ISOWeekDate, "+-0123456789W" & UNICHAR(8722), 1)), {#VALUE!, "", ""},
        TRUE, LET(
            _firstChar, LEFT(ISOWeekDate),
            _isSigned, IFS(
                _firstChar = "+", TRUE,
                _firstChar = "-", TRUE,
                _firstChar = UNICHAR(8722), TRUE,
                TRUE, FALSE
            ),
            _sign, IFS(
                NOT(_isSigned), 1,
                _firstChar = "-", -1,
                _firstChar = UNICHAR(8722), -1,
                TRUE, 1
            ),
            _unSigned, IF(_isSigned,
                RIGHT(ISOWeekDate, LEN(ISOWeekDate) - 1),
                ISOWeekDate
            ),
            _len, LEN(_unSigned),
            _pattern, REPLACE_CHARS(_unSigned, "0123456789", "_"),
            _tryParse, IFS(
                _len >= 10, IFS(
                    _pattern = RIGHT("_______________-W__-_", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 6)),
                        VALUE(MID(_unSigned, _len - 3, 2)),
                        VALUE(RIGHT(_unSigned, 1))
                    ),
                    _pattern = RIGHT("_______________-W__", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 4)),
                        VALUE(RIGHT(_unSigned, 2)),
                        ""
                    ),
                    _pattern = RIGHT("_______________W___", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 4)),
                        VALUE(MID(_unSigned, _len - 2, 2)),
                        VALUE(RIGHT(_unSigned, 1))
                    ),
                    _pattern = RIGHT("_______________W__", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 3)),
                        VALUE(RIGHT(_unSigned, 2)),
                        ""
                    ),
                    TRUE, ""
                ),
                _len >= 8, IFS(
                    _pattern = RIGHT("_____-W__", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 4)),
                        VALUE(RIGHT(_unSigned, 2)),
                        ""
                    ),
                    _pattern = RIGHT("_____W___", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 4)),
                        VALUE(MID(_unSigned, _len - 2, 2)),
                        VALUE(RIGHT(_unSigned, 1))
                    ),
                    _pattern = RIGHT("______W__", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 3)),
                        VALUE(RIGHT(_unSigned, 2)),
                        ""
                    ),
                    TRUE, ""
                ),
                _len = 7, IF(
                    _pattern = "____W__",
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 3)),
                        VALUE(RIGHT(_unSigned, 2)),
                        ""
                    ),
                    ""
                ),
                (_len >= 4) * (_len <= 5), IF(
                    _pattern = RIGHT("_____", _len),
                    HSTACK(
                        VALUE(_unSigned),
                        "",
                        ""
                    ),
                    ""
                ),
                TRUE, #N/A
            ),

            IF(ISERROR(INDEX(_tryParse, 1, 1)), {#VALUE!, "", ""},
                LET(
                    _year, _sign * INDEX(_tryParse, 1, 1),
                    _week, INDEX(_tryParse, 1, 2),
                    IF(_week = "", HSTACK(_year, "", ""),
                        LET(
                            _invalidWeek, IFS(
                                _week < 1, TRUE,
                                _week <= 52, FALSE,
                                _week > 53, TRUE,
                                TRUE, WEEKS_IN_YEAR(_year, JulianCalendar) < 53
                            ),
                            IF(_invalidWeek, HSTACK(_year, {#NUM!}, ""),
                                LET(
                                    _day, INDEX(_tryParse, 1, 3),
                                    IF(_day = "", HSTACK(_year, _week, ""),
                                        IF((_day >= 1) * (_day <= 7),
                                            HSTACK(_year, _week, _day),
                                            HSTACK(_year, _week, {#NUM!})
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
FORMAT_ISO_WEEK_DATE

Returns a week date as text in ISO format.

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | ISO formatted week date

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Note that 1 BC = 0 CE, 2 BC = -1 CE
ISOWeek          | integer [1..53] | Note most years have 52 ISO weeks
[ISOWeekDay]     | integer [1..7]  | ISO day of week Monday..Sunday
[Basic]          | switch          | Display in basic format eg yyyyWwwd
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar. 
--------------------------------------------------------------------------------------------------------------*/
/*FORMAT_ISO_WEEK_DATE = LAMBDA(YearCE, ISOWeek, [ISOWeekDay], [Basic], [JulianCalendar],
    IFS(
        IS_EMPTY(YearCE) * IS_EMPTY(ISOWeek) * IS_EMPTY(ISOWeekDay), "",
        NOT(ISNUMBER(YearCE)), {#VALUE!},
        NOT(IS_NUMERIC_NULL(ISOWeek)) + NOT(IS_NUMERIC_NULL(ISOWeekDay)), {#VALUE!},
        NOT(ISNUMBER(ISOWeek)) * ISNUMBER(ISOWeekDay), {#VALUE!},
        TRUE, LET(
            _delim, IF(N(Basic) = 0, "-", ""),
            IFS(
                IS_EMPTY(ISOWeek), FORMAT_ISO_Year(YearCE),
                NOT(IS_VALID_WEEK_DATE(YearCE, ISOWeek, ISOWeekDay, JulianCalendar)), {#NUM!},
                IS_EMPTY(ISOWeekDay), CONCAT(
                    FORMAT_ISO_Year(YearCE),
                    _delim, "W", TEXT(ISOWeek, "00")
                ),
                TRUE, CONCAT(
                    FORMAT_ISO_Year(YearCE),
                    _delim, "W", TEXT(ISOWeek, "00"),
                    _delim, TEXT(ISOWeekDay, "0")
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
WEEK_DATE_TO_MJDATE

Converts a week date of year, ISO defined week number, ISO weekday, and time in the specified calendar to a
Modified Julian Date (MJDATE).

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Modified Julian Date

Parameters
----------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
ISOWeek          | integer [1..53] | ISO defined week number of the year
ISOWeekDay       | integer [1..7]  | ISO defined day of week Monday..Sunday
[Time]           | decimal [0..1)  | Time of day
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
/*WEEK_DATE_TO_MJDATE = LAMBDA(YearCE, ISOWeek, ISOWeekDay, [Time], [JulianCalendar],
    IFS(
        (YearCE = "") * (ISOWeek = "") * (ISOWeekDay = ""), "",
        NOT(ISNUMBER(YearCE)) + NOT(ISNUMBER(ISOWeek)) + NOT(ISNUMBER(ISOWeekDay)), {#VALUE!},
        TRUE, LET(
            _invalid, IFS(
                NOT(IS_INTEGER(YearCE)), TRUE,
                NOT(IS_INTEGER(ISOWeek)), TRUE,
                ISOWeek < 1, TRUE,
                ISOWeek > 53, TRUE,
                ISOWeek = 53, (WEEKS_IN_YEAR(YearCE, JulianCalendar) < 53),
                TRUE, FALSE
            ),
            IF(_invalid, {#NUM!},
                LET(
                    _shiftByWeeks, (ISOWeek - 1) * 7,
                    _shiftDayOfWeek, MOD(INT(ISOWeekDay) - 1, 7),
                    _firstDayYear, MODIFIED_JULIAN_DAY_NUMBER(YearCE, 1, 1, JulianCalendar),
                    _firstWeekDay, DAY_OF_WEEK(_firstDayYear),
                    _yearCorrection, MOD(4 - _firstWeekDay, 7) - 3,
                    _firstDayYear + _yearCorrection + _shiftByWeeks + _shiftDayOfWeek + N(Time) 
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
MJDATE_TO_WEEK_DATE

Converts a Modified Julian Date (MJDATE) to the year, ISO defined week number, ISO weekday, time, and weeks
in the year in the specified calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer         | YearCE
 2 | integer [1..53] | ISO week number
 3 | integer [1..7]  | ISO day of week Monday..Sunday
 4 | decimal [0..1)  | Time of day
 5 | integer [52,53] | ISO weeks in year

Parameters
----------------------------------------------------------------------------------------------------------------
MJDate           | decimal | Modified Julian Date
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
/*MJDATE_TO_WEEK_DATE = LAMBDA(MJDate, [JulianCalendar],
    IFS(
        MJDate = "", {"", "", "", "", ""},
        NOT(ISNUMBER(MJDate)), {#VALUE!, "", "", "", ""},
        TRUE, LET(
            _cDate, MJDATE_TO_CALENDAR_DATE(MJDate, JulianCalendar),
            _yearCE, INDEX(_cDate, 1, 1),
            _dayOfWeek, DAY_OF_WEEK(MJDate),
            _MJDNYear, MODIFIED_JULIAN_DAY_NUMBER(_yearCE, 1, 1, JulianCalendar) - 1,
            _dayOfYear, INT(MJDate - _MJDNYear),
            _nominalWeek, INT((_dayOfYear - _dayOfWeek + 10) / 7),
            IFS(
                // last week of previous year
                _nominalWeek = 0, LET(
                    _weeksInYear, WEEKS_IN_YEAR(_yearCE - 1, JulianCalendar), 
                    HSTACK(
                        _yearCE - 1,
                        _weeksInYear,
                        _dayOfWeek,
                        INDEX(_cDate, 1, 4),
                        _weeksInYear
                    )
                ),
                
                // auxiliary week
                _nominalWeek = 53, IF(WEEKS_IN_YEAR(_yearCE, JulianCalendar) = 53,
                    HSTACK(
                        _yearCE,
                        53,
                        _dayOfWeek,
                        INDEX(_cDate, 1, 4),
                        53
                    ),
                    // if this year does not have 53 weeks, then is the first week of following year
                    LET(
                        _weeksInYear, WEEKS_IN_YEAR(_yearCE + 1, JulianCalendar),
                        HSTACK(
                            _yearCE + 1,
                            1,
                            _dayOfWeek,
                            INDEX(_cDate, 1, 4),
                            _weeksInYear
                        )
                    )
                ),
                
                // any other week in the year
                TRUE, LET(
                    _weeksInYear, WEEKS_IN_YEAR(_yearCE, JulianCalendar),
                    HSTACK(
                        _yearCE,
                        _nominalWeek,
                        _dayOfWeek,
                        INDEX(_cDate, 1, 4),
                        _weeksInYear
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
WEEK_NUMBER

Returns the ISO defined week number for a given Modified Julian Date in the specified calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [1..53] | ISO week number

Parameters
----------------------------------------------------------------------------------------------------------------
MJDate           | decimal | Modified Julian Date
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
/*WEEK_NUMBER = LAMBDA(MJDate, [JulianCalendar],
    IFS(
        MJDate = "", "",
        NOT(ISNUMBER(MJDate)), {#VALUE!},
        TRUE, LET(
            _weekDate, MJDATE_TO_WEEK_DATE(MJDate, JulianCalendar),
            CHOOSECOLS(_weekDate, 2)
        )
    )
);











/*##############################################################################################################
# QUARTERS                                                                                                     #
##############################################################################################################*/


/*--------------------------------------------------------------------------------------------------------------
DAYS_IN_QUARTER

Returns the count of days in a quarter of a given year of the specified calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [89..92]

Parameters
----------------------------------------------------------------------------------------------------------------
Quarter          | integer [1..4]  | Quarter of the year 1..4, transitive, exceeding range will carry to year.
[FiscalYearCE]   | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
                 |                 | When month offset is non-zero the fiscal year spans calendar years and
                 |                 | is defined as the year where June falls.
[MonthOffset]    | integer [-6..3] | Quarter month offset from Januaray
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.

Examples
----------------------------------------------------------------------------------------------------------------
DAYS_IN_QUARTER(3, 2020, -6)
Returns: 91
i.e. 3rd quarter starting from July 2019, namely Jan, Feb, Mar 2020 with 31, 29, 31 days respectively
--------------------------------------------------------------------------------------------------------------*/
/*DAYS_IN_QUARTER = LAMBDA(Quarter, [FiscalYearCE], [MonthOffset], [JulianCalendar],
    IFS(
        Quarter = "", "",
        NOT(ISNUMBER(Quarter)), {#VALUE!},
        NOT(IS_INTEGER(Quarter)), {#NUM!},
        TRUE, LET(
            _monthOffset, ROUND(N(MonthOffset), 0),
            IF((_monthOffset < -6) + (_monthOffset > 3), {#NUM!},
                LET(
                    _quarter, MOD(INT(Quarter) - 1, 4), // 0..3
                    _daysInQuarterCyclical, {90,89,92,91,92,92,92,92,91,92,92,90},
                    _quarterWithFeb, INT(MOD(1 - _monthOffset, 12) / 3),  // 0..3
                    _quarterPrecession, MOD(_monthOffset + (_quarter * 3), 12) + 1,
                    _nominalDaysInQuarter, INDEX(_daysInQuarterCyclical, 1, _quarterPrecession),
                    _leapDay, IF(ISNUMBER(FiscalYearCE) * (_quarterWithFeb = _quarter),
                        LET(
                            _yearOfFeb, INT(FiscalYearCE) + N(_quarter = 3),
                            N(IS_LEAP_YEAR(_yearOfFeb, JulianCalendar))
                        ),
                        0
                    ),
                    _nominalDaysInQuarter + _leapDay
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
QUARTER_DATE_TO_MJDATE

Converts a date expressed as fiscal year, quarter, day of quarter and time in the specified calendar to a
Modified Julian Date (MJDATE).

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Modified Julian Date

Parameters
----------------------------------------------------------------------------------------------------------------
FiscalYearCE     | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
                 |                 | When month offset is non-zero the fiscal year spans calendar years and
                 |                 | is defined as the year where June falls.
Quarter          | integer [1..4]  | Quarter of the year 1..4, transitive, exceeding range will carry to year.
DayOfQuarter     | integer [1..92] | Ordinal day of the quarter, exceeding range will carry
[Time]           | decimal [0..1)  | Time of day
[MonthOffset]    | integer [-6..3] | Quarter month offset from January
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
/*QUARTER_DATE_TO_MJDATE = LAMBDA(FiscalYearCE, Quarter, DayOfQuarter, [Time], [MonthOffset], [JulianCalendar],
    IFS(
        (FiscalYearCE = "") * (Quarter = "") * (DayOfQuarter = ""), "",
        NOT(ISNUMBER(FiscalYearCE)), {#VALUE!},
        NOT(ISNUMBER(Quarter)), {#VALUE!},
        NOT(ISNUMBER(DayOfQuarter)), {#VALUE!},
        NOT(IS_INTEGER(Quarter)), {#NUM!},
        TRUE, LET(
            _monthOffset, ROUND(N(MonthOffset), 0),
            IF((_monthOffset < -6) + (_monthOffset > 3), {#NUM!},
                LET(
                    _fiscalYearCE, INT(FiscalYearCE),
                    _quarter, INT(Quarter),
                    _shiftMonth, (_quarter - 1) * 3 + _monthOffset,
                    _yearCE, _fiscalYearCE + INT(_shiftMonth / 12),
                    _month, MOD(_shiftMonth, 12) + 1,
                    _MJDNQuarter, MODIFIED_JULIAN_DAY_NUMBER(_yearCE, _month, 1, JulianCalendar) - 1,
                    _MJDNQuarter + INT(DayOfQuarter) + N(Time)
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
MJDATE_TO_QUARTER_DATE

Converts Modified Julian Date (MJDATE) to a date expressed as fiscal year, quarter, day of quarter and time
in the specified calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer          | FiscalYearCE
   |                  | When month offset is non-zero the fiscal year spans calendar years and
   |                  | is defined as the year where June falls.
 2 | integer [1..4]   | Quarter
 3 | integer [1..92]  | Day of quarter
 4 | decimal [0..1)   | Time of day
 5 | integer [89..92] | Days in quarter

Parameters
----------------------------------------------------------------------------------------------------------------
MJDate           | decimal         | Modified Julian Date
[MonthOffset]    | integer [-6..3] | Quarter month offset from January
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
/*MJDATE_TO_QUARTER_DATE = LAMBDA(MJDate, [MonthOffset], [JulianCalendar],
    IFS(
        MJDate = "", {"", "", "", "", ""},
        NOT(ISNUMBER(MJDate)), {#VALUE!, "", "", "", ""},
        TRUE, LET(
            _monthOffset, ROUND(N(MonthOffset), 0),
            IFS(
                _monthOffset < -6, {#NUM!, "", "", "", ""},
                _monthOffset > 3, {#NUM!, "", "", "", ""},
                TRUE, LET(
                    _cDate, MJDATE_TO_CALENDAR_DATE(MJDate, JulianCalendar),
                    _shiftMonth, INDEX(_cDate, 1, 2) - 1 - _monthOffset,
                    _fiscalYear, INDEX(_cDate, 1, 1) + INT(_shiftMonth / 12),
                    _zeroBasedFiscalMonth, MOD(_shiftMonth, 12),
                    _quarter, INT(_zeroBasedFiscalMonth / 3) + 1,
                    _MJDNQuarter, QUARTER_DATE_TO_MJDATE(_fiscalYear, _quarter, 1, 0, _monthOffset, JulianCalendar) - 1,
                    _dayOfQuarter, INT(MJDate - _MJDNQuarter),
                    _daysInQuarter, DAYS_IN_QUARTER(_quarter, _fiscalYear, _monthOffset, JulianCalendar),
                    HSTACK(
                        _fiscalYear,
                        _quarter,
                        _dayOfQuarter,
                        INDEX(_cDate, 1, 4),
                        _daysInQuarter
                    )
                )
            )
        )
    )
);













/*##############################################################################################################
# DELTAS                                                                                                       #
##############################################################################################################*/


/*--------------------------------------------------------------------------------------------------------------
DELTA_HOURS

Returns the timespan difference between Modified Julian Dates in hours.
Can also accept standard Julian Dates, provided types are not mixed.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Difference in hours

Parameters
----------------------------------------------------------------------------------------------------------------
MJDateStart | decimal | Starting Modified Julian Date 
MJDateEnd   | decimal | Ending Modified Julian Date
--------------------------------------------------------------------------------------------------------------*/
DELTA_HOURS = LAMBDA(MJDateStart, MJDateEnd,
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), "",
        NOT(ISNUMBER(MJDateStart)), {#VALUE!},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
        TRUE, (MJDateEnd - MJDateStart) * 24
    )
);


/*--------------------------------------------------------------------------------------------------------------
DELTA_MINUTES

Returns the timespan difference between Modified Julian Dates in minutes.
Can also accept standard Julian Dates, provided types are not mixed.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Difference in minutes

Parameters
----------------------------------------------------------------------------------------------------------------
MJDateStart | decimal | Starting Modified Julian Date 
MJDateEnd   | decimal | Ending Modified Julian Date
--------------------------------------------------------------------------------------------------------------*/
DELTA_MINUTES = LAMBDA(MJDateStart, MJDateEnd,
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), "",
        NOT(ISNUMBER(MJDateStart)), {#VALUE!},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
        TRUE, (MJDateEnd - MJDateStart) * 1440
    )
);


/*--------------------------------------------------------------------------------------------------------------
DELTA_SECONDS

Returns the timespan difference between Modified Julian Dates in seconds.
Can also accept standard Julian Dates, provided types are not mixed.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Difference in seconds

Parameters
----------------------------------------------------------------------------------------------------------------
MJDateStart | decimal | Starting Modified Julian Date 
MJDateEnd   | decimal | Ending Modified Julian Date
--------------------------------------------------------------------------------------------------------------*/
DELTA_SECONDS = LAMBDA(MJDateStart, MJDateEnd,
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), "",
        NOT(ISNUMBER(MJDateStart)), {#VALUE!},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
        TRUE, (MJDateEnd - MJDateStart) * 86400
    )
);


/*--------------------------------------------------------------------------------------------------------------
DELTA_DHMS

Returns the sexagesimal difference between Modified Julian Dates with the given lowest order component rounded
to the specified precision.
Can also accept standard Julian Dates, provided types are not mixed.

Output - LowOrder = 4 (default)
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Days
 3 | integer [0..23]  | Hours
 4 | integer [0..59]  | Minutes
 5 | decimal [0..60)  | Seconds

Output - LowOrder = 3
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Days
 3 | integer [0..23]  | Hours
 4 | decimal [0..60)  | Minutes

Output - LowOrder = 2
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Days
 3 | decimal [0..24)  | Hours

Output - LowOrder = 1
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | decimal [0..]    | Days

Parameters
----------------------------------------------------------------------------------------------------------------
MJDateStart   | decimal | Starting Modified Julian Date 
MJDateEnd     | decimal | Ending Modified Julian Date
[HighOrder]   | integer | Highest-order component. Defaults to Day.
              | [1..4]  |  1 - Day
              |         |  2 - Hour
              |         |  3 - Minute
              |         |  4 - Second
[LowOrder]    | integer | Lowest-order component. Defaults to Second.
              | [1..4]  |  1 - Day
              |         |  2 - Hour
              |         |  3 - Minute
              |         |  4 - Second
[Precision]   | integer | Select precision level
              | [0..9]  | Null - Floating
[Truncate]    | switch  | Round to precision by truncating components. Default is rounding to nearest.
--------------------------------------------------------------------------------------------------------------*/
/*DELTA_DHMS = LAMBDA(MJDateStart, MJDateEnd, [HighOrder], [LowOrder], [Precision], [Truncate],
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), {"","","",""},
        NOT(ISNUMBER(MJDateStart)), {#VALUE!, "", "", ""},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!, "", "", ""},
        TRUE, RESOLVE_TIMESPAN(MJDateEnd - MJDateStart, HighOrder, LowOrder, Precision, Truncate)
    )
);


/*--------------------------------------------------------------------------------------------------------------
DELTA_TIMESPAN

Returns the timespan difference between Modified Julian Dates.
Can also accept standard Julian Dates, provided types are not mixed.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Timespan difference, day = 1

Parameters
----------------------------------------------------------------------------------------------------------------
MJDateStart | decimal | Starting Modified Julian Date 
MJDateEnd   | decimal | Ending Modified Julian Date
--------------------------------------------------------------------------------------------------------------*/
/*DELTA_TIMESPAN = LAMBDA(MJDateStart, MJDateEnd,
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), "",
        NOT(ISNUMBER(MJDateStart)), {#VALUE!},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
        TRUE, (MJDateEnd - MJDateStart)
    )
);


/*--------------------------------------------------------------------------------------------------------------
DELTA_WEEKS

Returns the timespan difference between Modified Julian Dates in weeks.
Can also accept standard Julian Dates, provided types are not mixed.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Difference in weeks

Parameters
----------------------------------------------------------------------------------------------------------------
MJDateStart | decimal | Starting Modified Julian Date 
MJDateEnd   | decimal | Ending Modified Julian Date
--------------------------------------------------------------------------------------------------------------*/
/*DELTA_WEEKS = LAMBDA(MJDateStart, MJDateEnd,
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), "",
        NOT(ISNUMBER(MJDateStart)), {#VALUE!},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
        TRUE, (MJDateEnd - MJDateStart) / 7
    )
);


/*--------------------------------------------------------------------------------------------------------------
DELTA_MONTHS

Returns the timespan difference between Modified Julian Dates in months.
Where the difference includes partial months, the fraction is calculated on the basis of days in the month
of the calendar. If the Modified Julian Dates are expressed in UTC rather than local time then a small margin
of error will be introduced due to the bounds of calendar days.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Difference in months

Parameters
----------------------------------------------------------------------------------------------------------------
MJDateStart      | decimal | Starting Modified Julian Date 
MJDateEnd        | decimal | Ending Modified Julian Date
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
/*DELTA_MONTHS = LAMBDA(MJDateStart, MJDateEnd, [JulianCalendar],
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), "",
        NOT(ISNUMBER(MJDateStart)), {#VALUE!},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
        TRUE, IF(MJDateStart = MJDateEnd, 0,
            LET(
                _sign, IF(MJDateEnd >= MJDateStart, 1, -1),
                _date_A, MJDATE_TO_CALENDAR_DATE(
                    IF(_sign = 1, MJDateStart, MJDateEnd),
                    JulianCalendar
                ),
                _date_B, MJDATE_TO_CALENDAR_DATE(
                    IF(_sign = 1, MJDateEnd, MJDateStart),
                    JulianCalendar
                ),
                _deltaYear, INDEX(_date_B, 1, 1) - INDEX(_date_A, 1, 1),
                _deltaMonth, INDEX(_date_B, 1, 2) - INDEX(_date_A, 1, 2),
                _diffMonths, (_deltaYear * 12) + _deltaMonth,
                _daysMonth_A, DAYS_IN_MONTH(INDEX(_date_A, 1, 2), INDEX(_date_A, 1, 1), JulianCalendar),
                _daysMonth_B, DAYS_IN_MONTH(INDEX(_date_B, 1, 2), INDEX(_date_B, 1, 1), JulianCalendar),
                _partialMonth_A, (INDEX(_date_A, 1, 3) - 1 + INDEX(_date_A, 1, 4)) / _daysMonth_A,
                _partialMonth_B, (INDEX(_date_B, 1, 3) - 1 + INDEX(_date_B, 1, 4)) / _daysMonth_B,
                _sign * (_diffMonths - _partialMonth_A + _partialMonth_B)
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
DELTA_QUARTERS

Returns the timespan difference between Modified Julian Dates in quarters.
Where the difference includes partial quarters, the fraction is calculated on the basis of days in the
quarter of the calendar. If the Modified Julian Dates are expressed in UTC rather than local time then a
small margin of error will be introduced due to the bounds of calendar days.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Difference in quarters

Parameters
----------------------------------------------------------------------------------------------------------------
MJDateStart      | decimal         | Starting Modified Julian Date 
MJDateEnd        | decimal         | Ending Modified Julian Date
[MonthOffset]    | integer [-6..3] | Quarter month offset from January.
[JulianCalendar] | switch          | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
/*DELTA_QUARTERS = LAMBDA(MJDateStart, MJDateEnd, [MonthOffset], [JulianCalendar],
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), "",
        NOT(ISNUMBER(MJDateStart)), {#VALUE!},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
        TRUE, LET(
            _monthOffset, ROUND(N(MonthOffset), 0),
            IFS(
                _monthOffset < -6, {#NUM!},
                _monthOffset > 3, {#NUM!},
                MJDateStart = MJDateEnd, 0,
                TRUE, LET(
                    _sign, IF(MJDateEnd >= MJDateStart, 1, -1),
                    _quarterDate_A, MJDATE_TO_QUARTER_DATE(
                        IF(_sign = 1, MJDateStart, MJDateEnd),
                        _monthOffset, JulianCalendar
                    ),
                    _quarterDate_B, MJDATE_TO_QUARTER_DATE(
                        IF(_sign = 1, MJDateEnd, MJDateStart),
                        _monthOffset, JulianCalendar
                    ),
                    _deltaYear, INDEX(_quarterDate_B, 1, 1) - INDEX(_quarterDate_A, 1, 1),
                    _deltaQuarter, INDEX(_quarterDate_B, 1, 2) - INDEX(_quarterDate_A, 1, 2),
                    _diffQuarters, (_deltaYear * 4) + _deltaQuarter,
                    _partialQuarter_A, (INDEX(_quarterDate_A, 1, 3) - 1 + INDEX(_quarterDate_A, 1, 4)) / INDEX(_quarterDate_A, 1, 5),
                    _partialQuarter_B, (INDEX(_quarterDate_B, 1, 3) - 1 + INDEX(_quarterDate_B, 1, 4)) / INDEX(_quarterDate_B, 1, 5),
                    _sign * (_diffQuarters - _partialQuarter_A + _partialQuarter_B)
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
DELTA_YEARS

Returns the timespan difference between Modified Julian Dates in years.
Where the difference includes partial years, the fraction is calculated on the basis of days in the
year of the calendar. If the Modified Julian Dates are expressed in UTC rather than local time then a
small margin of error will be introduced due to the bounds of calendar days.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Difference in years

Parameters
----------------------------------------------------------------------------------------------------------------
MJDateStart      | decimal | Starting Modified Julian Date 
MJDateEnd        | decimal | Ending Modified Julian Date
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
/*DELTA_YEARS = LAMBDA(MJDateStart, MJDateEnd, [JulianCalendar],
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), "",
        NOT(ISNUMBER(MJDateStart)), {#VALUE!},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
        MJDateStart = MJDateEnd, 0,
        TRUE, LET(
            _sign, IF(MJDateEnd >= MJDateStart, 1, -1),
            _ordinalDate_A, MJDATE_TO_ORDINAL_DATE(
                IF(_sign = 1, MJDateStart, MJDateEnd),
                JulianCalendar
            ),
            _ordinalDate_B, MJDATE_TO_ORDINAL_DATE(
                IF(_sign = 1, MJDateEnd, MJDateStart),
                JulianCalendar
            ),
            _deltaYear, INDEX(_ordinalDate_B, 1, 1) - INDEX(_ordinalDate_A, 1, 1),
            _partialYear_A, (INDEX(_ordinalDate_A, 1, 2) - 1 + INDEX(_ordinalDate_A, 1, 3)) / INDEX(_ordinalDate_A, 1, 4),
            _partialYear_B, (INDEX(_ordinalDate_B, 1, 2) - 1 + INDEX(_ordinalDate_B, 1, 3)) / INDEX(_ordinalDate_B, 1, 4),
            _sign * (_deltaYear - _partialYear_A + _partialYear_B)
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
DELTA_WEEK_DAYS

Returns the timespan difference between Modified Julian Dates in weeks and days.
Can also accept standard Julian Dates, provided types are not mixed.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Delta weeks 
 3 | integer [0..6]   | Delta days
 4 | decimal [0..1)   | Delta time

Parameters
----------------------------------------------------------------------------------------------------------------
MJDateStart | decimal | Starting Modified Julian Date 
MJDateEnd   | decimal | Ending Modified Julian Date
--------------------------------------------------------------------------------------------------------------*/
/*DELTA_WEEK_DAYS = LAMBDA(MJDateStart, MJDateEnd,
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), {"", "", "", ""},
        NOT(ISNUMBER(MJDateStart)), {#VALUE!, "", "", ""},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!, "", "", ""},
        TRUE, LET(
            _diffDays, (MJDateEnd - MJDateStart),
            IF(_diffDays = 0, {0, 0, 0, 0},
                LET(
                    _sign, IF(_diffDays >= 0, 1, -1),
                    _absDiffDays, _sign * _diffDays,
                    _deltaWeek, INT(_absDiffDays / 7),
                    _remDays, _absDiffDays - _deltaWeek * 7,
                    _deltaDay, INT(_remDays),
                    _deltaTime, _remDays - _deltaDay,
                    HSTACK(
                        _sign,
                        _deltaWeek,
                        _deltaDay,
                        _deltaTime
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
DELTA_YEAR_WEEK_DAYS

Returns the timespan difference between Modified Julian Dates in years, weeks, and days.
Note the number of weeks per year can vary between 52 and 53. If an absolute number of weeks is being sought
then use either DELTA_WEEK_DAYS or DELTA_WEEKS functions. If the Modified Julian Dates are expressed in UTC
rather than local time then a small margin of error will be introduced due to the bounds of calendar days.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Delta years
 3 | integer [0..52]  | Delta weeks 
 4 | decimal [0..6]   | Delta days
 5 | decimal [0..1)   | Delta time

Parameters
----------------------------------------------------------------------------------------------------------------
MJDateStart      | decimal | Starting Modified Julian Date 
MJDateEnd        | decimal | Ending Modified Julian Date
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
/*DELTA_YEAR_WEEK_DAYS = LAMBDA(MJDateStart, MJDateEnd, [JulianCalendar],
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), {"", "", "", "", ""},
        NOT(ISNUMBER(MJDateStart)), {#VALUE!, "", "", "", ""},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!, "", "", "", ""},
        MJDateStart = MJDateEnd, {0, 0, 0, 0, 0},
        TRUE, LET(
            _sign, IF(MJDateEnd >= MJDateStart, 1, -1),
            _weekDate_A, MJDATE_TO_WEEK_DATE(
                IF(_sign = 1, MJDateStart, MJDateEnd),
                JulianCalendar
            ),
            _weekDate_B, MJDATE_TO_WEEK_DATE(
                IF(_sign = 1, MJDateEnd, MJDateStart),
                JulianCalendar
            ),
            _deltaYear, INDEX(_weekDate_B, 1, 1) - INDEX(_weekDate_A, 1, 1),
            _deltaWeek, INDEX(_weekDate_B, 1, 2) - INDEX(_weekDate_A, 1, 2),
            _diffDays, INDEX(_weekDate_B, 1, 3) - INDEX(_weekDate_A, 1, 3)
                + INDEX(_weekDate_B, 1, 4) - INDEX(_weekDate_A, 1, 4),
            _carryWeek, INT(_diffDays / 7),
            _remDays, _diffDays - _carryWeek * 7,
            _deltaWeek2, _deltaWeek + _carryWeek,
            _deltaDay, INT(_remDays),
            _deltaTime, _remDays - _deltaDay,
            IF(_deltaWeek2 >= 0,
                HSTACK(
                    _sign,
                    _deltaYear,
                    _deltaWeek2,
                    _deltaDay,
                    _deltaTime
                ),
                HSTACK(
                    _sign,
                    _deltaYear - 1,
                    _deltaWeek2 + INDEX(_weekDate_A, 1, 5),
                    _deltaDay,
                    _deltaTime
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
DELTA_MONTH_DAYS

Returns the timespan difference between Modified Julian Dates in months and days.
If the Modified Julian Dates are expressed in UTC rather than local time then a small margin of error will
be introduced due to the bounds of calendar days.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Delta months
 3 | integer [0..30]  | Delta days
 4 | decimal [0..1)   | Delta time

Parameters
----------------------------------------------------------------------------------------------------------------
MJDateStart      | decimal | Starting Modified Julian Date 
MJDateEnd        | decimal | Ending Modified Julian Date
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
/*DELTA_MONTH_DAYS = LAMBDA(MJDateStart, MJDateEnd, [JulianCalendar],
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), {"", "", "", ""},
        NOT(ISNUMBER(MJDateStart)), {#VALUE!, "", "", ""},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!, "", "", ""},
        MJDateStart = MJDateEnd, {0, 0, 0, 0},
        TRUE, LET(
            _sign, IF(MJDateEnd >= MJDateStart, 1, -1),
            _date_A, MJDATE_TO_CALENDAR_DATE(
                IF(_sign = 1, MJDateStart, MJDateEnd),
                JulianCalendar
            ),
            _date_B, MJDATE_TO_CALENDAR_DATE(
                IF(_sign = 1, MJDateEnd, MJDateStart),
                JulianCalendar
            ),
            _deltaYear, INDEX(_date_B, 1, 1) - INDEX(_date_A, 1, 1),
            _deltaMonth, INDEX(_date_B, 1, 2) - INDEX(_date_A, 1, 2),
            _diffMonths, (_deltaYear * 12) + _deltaMonth,
            _diffDays, INDEX(_date_B, 1, 3) - INDEX(_date_A, 1, 3)
                + INDEX(_date_B, 1, 4) - INDEX(_date_A, 1, 4),
            IF(_diffDays >= 0,
                LET(
                    _deltaDay, INT(_diffDays),
                    _deltaTime, _diffDays - _deltaDay,
                    HSTACK(
                        _sign,
                        _diffMonths,
                        _deltaDay,
                        _deltaTime
                    )
                ),
                LET(
                    _daysMonth_A, DAYS_IN_MONTH(INDEX(_date_A, 1, 2), INDEX(_date_A, 1, 1), JulianCalendar),
                    _diffDays2, _diffDays + _daysMonth_A,  
                    _deltaDay, INT(_diffDays2),
                    _deltaTime, _diffDays2 - _deltaDay,
                    HSTACK(
                        _sign,
                        _diffMonths - 1,
                        _deltaDay,
                        _deltaTime
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
DELTA_QUARTER_DAYS

Returns the timespan difference between Modified Julian Dates in quarters and days.
If the Modified Julian Dates are expressed in UTC rather than local time then a small margin of error will
be introduced due to the bounds of calendar days.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Delta quarters
 3 | decimal [0..92)  | Delta days

Parameters
----------------------------------------------------------------------------------------------------------------
MJDateStart      | decimal         | Starting Modified Julian Date 
MJDateEnd        | decimal         | Ending Modified Julian Date
[MonthOffset]    | integer [-6..3] | Quarter month offset from January.
[JulianCalendar] | switch          | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
/*DELTA_QUARTER_DAYS = LAMBDA(MJDateStart, MJDateEnd, [MonthOffset], [JulianCalendar],
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), {"", "", "", ""},
        NOT(ISNUMBER(MJDateStart)), {#VALUE!, "", "", ""},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!, "", "", ""},
        TRUE, LET(
            _monthOffset, ROUND(N(MonthOffset), 0),
            IFS(
                _monthOffset < -6, {#NUM!, "", "", ""},
                _monthOffset > 3, {#NUM!, "", "", ""},
                MJDateStart = MJDateEnd, {0, 0, 0, 0},
                TRUE, LET(
                    _sign, IF(MJDateEnd >= MJDateStart, 1, -1),
                    _quarterDate_A, MJDATE_TO_QUARTER_DATE(
                        IF(_sign = 1, MJDateStart, MJDateEnd),
                        _monthOffset, JulianCalendar
                    ),
                    _quarterDate_B, MJDATE_TO_QUARTER_DATE(
                        IF(_sign = 1, MJDateEnd, MJDateStart),
                        _monthOffset, JulianCalendar
                    ),
                    _deltaYear, INDEX(_quarterDate_B, 1, 1) - INDEX(_quarterDate_A, 1, 1),
                    _deltaQuarter, INDEX(_quarterDate_B, 1, 2) - INDEX(_quarterDate_A, 1, 2),
                    _diffQuarters, (_deltaYear * 4) + _deltaQuarter,
                    _diffDays, INDEX(_quarterDate_B, 1, 3) - INDEX(_quarterDate_A, 1, 3)
                        + INDEX(_quarterDate_B, 1, 4) - INDEX(_quarterDate_A, 1, 4),
                    IF(_diffDays >= 0,
                        LET(
                            _deltaDay, INT(_diffDays),
                            _deltaTime, _diffDays - _deltaDay,
                            HSTACK(
                                _sign,
                                _diffQuarters,
                                _deltaDay,
                                _deltaTime
                            )
                        ),
                        LET(
                            _diffDays2, _diffDays + INDEX(_quarterDate_A, 1, 5),
                            _deltaDay, INT(_diffDays2),
                            _deltaTime, _diffDays2 - _deltaDay,
                            HSTACK(
                                _sign,
                                _diffQuarters - 1,
                                _deltaDay,
                                _deltaTime
                            )
                        )
                    )
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
DELTA_INTERVAL

Returns the timespan difference between Modified Julian Dates in the specified units.

Output where Units = H, N, S, D, W, M, Q, Y
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Delta units decimal

Output where Units = HMS
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Delta hours
 3 | integer [0..59]  | Delta minutes
 4 | decimal [0..60)  | Delta seconds

Output where Units = DHMS
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Delta days
 3 | integer [0..23]  | Delta hours
 4 | integer [0..59]  | Delta minutes
 5 | decimal [0..60)  | Delta seconds

Output where Units = WD, MD, QD
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1]     | Sign
 2 | integer [0..]        | Delta weeks/months/quarters
 3 | integer [0..6/30/91] | Delta days
 4 | decimal [0..1)       | Delta time

Output where Units = YWD, YMD, YQD
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1]     | Sign
 2 | integer [0..]        | Delta years
 3 | integer [0..52/12/4] | Delta weeks/months/quarters
 4 | integer [0..6/30/91] | Delta days
 5 | decimal [0..1)       | Delta time

Output where Units = YMDHMS
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Delta years
 3 | integer [0..12]  | Delta months
 4 | integer [0..30]  | Delta days
 5 | integer [0..23]  | Delta hours
 6 | integer [0..59]  | Delta minutes
 7 | decimal [0..60)  | Delta seconds

Parameters
----------------------------------------------------------------------------------------------------------------
Units            | text            |      H - hours decimal
                 |                 |      N - minutes decimal
                 |                 |      S - seconds decimal
                 |                 |      T - timespan decimal
                 |                 |      W - weeks decimal
                 |                 |      M - months decimal
                 |                 |      Q - quarters decimal
                 |                 |      Y - years decimal
                 |                 |    HMS - hours, minutes, seconds
                 |                 |   DHMS - days, hours, minutes, seconds
                 |                 |     WD - weeks and days
                 |                 |     MD - months and days
                 |                 |     QD - quarters and days
                 |                 |    YWD - years, weeks, days
                 |                 |    YMD - years, months, days
                 |                 |    YQD - years, quarters, days
                 |                 | YMDHMS - years, months, days, hours, minutes, seconds
MJDateStart      | decimal         | Starting Modified Julian Date 
MJDateEnd        | decimal         | Ending Modified Julian Date
[MonthOffset]    | integer [-6..3] | Quarter month offset from January.
[JulianCalendar] | switch          | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
/*DELTA_INTERVAL = LAMBDA(Units, MJDateStart, MJDateEnd, [MonthOffset], [JulianCalendar],
    IFS(
        Units = "", {#VALUE!},
        Units = "H", DELTA_HOURS(MJDateStart, MJDateEnd),
        Units = "N", DELTA_MINUTES(MJDateStart, MJDateEnd),
        Units = "S", DELTA_SECONDS(MJDateStart, MJDateEnd),
        Units = "DHMS", DELTA_DHMS(MJDateStart, MJDateEnd, 4),
        Units = "T", DELTA_TIMESPAN(MJDateStart, MJDateEnd),
        Units = "W", DELTA_WEEKS(MJDateStart, MJDateEnd),
        Units = "M", DELTA_MONTHS(MJDateStart, MJDateEnd, JulianCalendar),
        Units = "Q", DELTA_QUARTERS(MJDateStart, MJDateEnd, MonthOffset, JulianCalendar),
        Units = "Y", DELTA_YEARS(MJDateStart, MJDateEnd, JulianCalendar),
        Units = "WD", DELTA_WEEK_DAYS(MJDateStart, MJDateEnd),
        Units = "YWD", DELTA_YEAR_WEEK_DAYS(MJDateStart, MJDateEnd, JulianCalendar),
        Units = "MD", DELTA_MONTH_DAYS(MJDateStart, MJDateEnd, JulianCalendar),
        Units = "QD", DELTA_QUARTER_DAYS(MJDateStart, MJDateEnd, MonthOffset, JulianCalendar),
        Units = "HMS", LET(
                _dhms, DELTA_DHMS(MJDateStart, MJDateEnd, 4),
                _hours, INDEX(_dhms, 1, 3) + (24 * INDEX(_dhms, 1, 2)),
                HSTACK(
                    INDEX(_dhms, 1, 1),
                    _hours,
                    INDEX(_dhms, 1, 4),
                    INDEX(_dhms, 1, 5)
                )
            ),
        Units = "YMD", LET(
                _monthDays, DELTA_MONTH_DAYS(MJDateStart, MJDateEnd, JulianCalendar),
                _years, INT(INDEX(_monthDays, 1, 2) / 12),
                _months, INDEX(_monthDays, 1, 2) - _years * 12,
                HSTACK(
                    INDEX(_monthDays, 1, 1),
                    _years,
                    _months,
                    INDEX(_monthDays, 1, 3),
                    INDEX(_monthDays, 1, 4)
                )
            ),
        Units = "YQD", LET(
                _quarterDays, DELTA_QUARTER_DAYS(MJDateStart, MJDateEnd, MonthOffset, JulianCalendar),
                _years, INT(INDEX(_quarterDays, 1, 2) / 4),
                _quarters, INDEX(_quarterDays, 1, 2) - _years * 4,
                HSTACK(
                    INDEX(_quarterDays, 1, 1),
                    _years,
                    _quarters,
                    INDEX(_quarterDays, 1, 3),
                    INDEX(_quarterDays, 1, 4)
                )
            ),
        Units = "YMDHMS", LET(
                _monthDays, DELTA_MONTH_DAYS(MJDateStart, MJDateEnd, JulianCalendar),
                _years, INT(INDEX(_monthDays, 1, 2) / 12),
                _months, INDEX(_monthDays, 1, 2) - _years * 12,
                _hms, RESOLVE_TIMESPAN(INDEX(_monthDays, 1, 4), 1, 4, 0, 1),
                _carryDay, INDEX(_hms, 1, 2),
                HSTACK(
                    INDEX(_monthDays, 1, 1),
                    _years,
                    _months,
                    INDEX(_monthDays, 1, 3) + _carryDay,
                    CHOOSECOLS(_hms, {3,4,5})
                )
            ),
        TRUE, {#VALUE!}
    )
);













/*##############################################################################################################
# EXTENTS                                                                                                      #
##############################################################################################################*/


/*--------------------------------------------------------------------------------------------------------------
EXTENT_OF_DAYS

Returns the inclusive extent of days spanned by two Modified Julian Dates expressed in local time.
If the Modified Julian Dates are expressed in UTC rather than local time then inconsistent results may be
produced due to the bounds of calendar days.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Extent of days

Parameters
----------------------------------------------------------------------------------------------------------------
LocalMJDateStart | decimal | Starting Modified Julian Date in local time 
LocalMJDateEnd   | decimal | Ending Modified Julian Date in local time

Examples
----------------------------------------------------------------------------------------------------------------
EXTENT_DAYS(MODIFIED_JULIAN_DATE(2023,1,1,TIME(23,59,55)), MODIFIED_JULIAN_DATE(2023,1,2,TIME(0,0,5)))
= 2  i.e. 2 days because the 10 second timespan crosses the day boundary
--------------------------------------------------------------------------------------------------------------*/
/*EXTENT_OF_DAYS = LAMBDA(LocalMJDateStart, LocalMJDateEnd,
    IFS(
        IS_EMPTY(LocalMJDateStart) * IS_EMPTY(LocalMJDateEnd), "",
        NOT(ISNUMBER(LocalMJDateStart)), {#VALUE!},
        NOT(ISNUMBER(LocalMJDateEnd)), {#VALUE!},
        TRUE, LET(
            _sign, IF(LocalMJDateEnd >= LocalMJDateStart, 1, -1),
            _deltaDay, INT(LocalMJDateEnd) - INT(LocalMJDateStart),
            _sign * (ABS(_deltaDay) + 1)
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
EXTENT_OF_WEEKS

Returns the inclusive extent of weeks spanned by two Modified Julian Dates expressed in local time.
If the Modified Julian Dates are expressed in UTC rather than local time then inconsistent results may be
produced due to the bounds of calendar days.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Extent of weeks

Parameters
----------------------------------------------------------------------------------------------------------------
LocalMJDateStart | decimal | Starting Modified Julian Date in local time 
LocalMJDateEnd   | decimal | Ending Modified Julian Date in local time

Examples
----------------------------------------------------------------------------------------------------------------
EXTENT_WEEKS(MODIFIED_JULIAN_DATE(2023,6,4,TIME(23,59,55)), MODIFIED_JULIAN_DATE(2023,6,5,TIME(0,0,5)))
= 2  i.e. 2 weeks because the 10 second timespan crosses the week boundary
--------------------------------------------------------------------------------------------------------------*/
/*EXTENT_OF_WEEKS = LAMBDA(LocalMJDateStart, LocalMJDateEnd,
    IFS(
        IS_EMPTY(LocalMJDateStart) * IS_EMPTY(LocalMJDateEnd), "",
        NOT(ISNUMBER(LocalMJDateStart)), {#VALUE!},
        NOT(ISNUMBER(LocalMJDateEnd)), {#VALUE!},
        TRUE, LET(
            _sign, IF(LocalMJDateEnd >= LocalMJDateStart, 1, -1),
            _startMonday, INT(LocalMJDateStart) + 1 - DAY_OF_WEEK(LocalMJDateStart),
            _endMonday, INT(LocalMJDateEnd) + 1 - DAY_OF_WEEK(LocalMJDateEnd),
            _sign * (INT(ABS(_endMonday - _startMonday) / 7) + 1)
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
EXTENT_OF_MONTHS

Returns the inclusive extent of months spanned by two Modified Julian Dates expressed in local time.
If the Modified Julian Dates are expressed in UTC rather than local time then inconsistent results may be
produced due to the bounds of calendar days.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Extent of months

Parameters
----------------------------------------------------------------------------------------------------------------
LocalMJDateStart | decimal | Starting Modified Julian Date in local time 
LocalMJDateEnd   | decimal | Ending Modified Julian Date in local time
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
/*EXTENT_OF_MONTHS = LAMBDA(LocalMJDateStart, LocalMJDateEnd, [JulianCalendar],
    IFS(
        IS_EMPTY(LocalMJDateStart) * IS_EMPTY(LocalMJDateEnd), "",
        NOT(ISNUMBER(LocalMJDateStart)), {#VALUE!},
        NOT(ISNUMBER(LocalMJDateEnd)), {#VALUE!},
        TRUE, LET(
            _sign, IF(LocalMJDateEnd >= LocalMJDateStart, 1, -1),
            _date_A, MJDATE_TO_CALENDAR_DATE(
                IF(_sign = 1, LocalMJDateStart, LocalMJDateEnd),
                JulianCalendar
            ),
            _date_B, MJDATE_TO_CALENDAR_DATE(
                IF(_sign = 1, LocalMJDateEnd, LocalMJDateStart),
                JulianCalendar
            ),
            _deltaYear, INDEX(_date_B, 1, 1) - INDEX(_date_A, 1, 1),
            _deltaMonth, INDEX(_date_B, 1, 2) - INDEX(_date_A, 1, 2),
            _diffMonths, (_deltaYear * 12) + _deltaMonth,
            _sign * (_diffMonths + 1)
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
EXTENT_OF_QUARTERS

Returns the inclusive extent of quarters spanned by two Modified Julian Dates expressed in local time.
If the Modified Julian Dates are expressed in UTC rather than local time then inconsistent results may be
produced due to the bounds of calendar days.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Extent of quarters

Parameters
----------------------------------------------------------------------------------------------------------------
LocalMJDateStart | decimal         | Starting Modified Julian Date in local time 
LocalMJDateEnd   | decimal         | Ending Modified Julian Date in local time
[MonthOffset]    | integer [-6..3] | Quarter month offset from January.
[JulianCalendar] | switch          | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
/*EXTENT_OF_QUARTERS = LAMBDA(LocalMJDateStart, LocalMJDateEnd, [MonthOffset], [JulianCalendar],
    IFS(
        IS_EMPTY(LocalMJDateStart) * IS_EMPTY(LocalMJDateEnd), "",
        NOT(ISNUMBER(LocalMJDateStart)), {#VALUE!},
        NOT(ISNUMBER(LocalMJDateEnd)), {#VALUE!},
        TRUE, LET(
            _monthOffset, ROUND(N(MonthOffset), 0),
            IFS(
                _monthOffset < -6, {#NUM!},
                _monthOffset > 3, {#NUM!},
                TRUE, LET(
                    _sign, IF(LocalMJDateEnd >= LocalMJDateStart, 1, -1),
                    _quarterDate_A, MJDATE_TO_QUARTER_DATE(
                        IF(_sign = 1, LocalMJDateStart, LocalMJDateEnd),
                        _monthOffset, JulianCalendar
                    ),
                    _quarterDate_B, MJDATE_TO_QUARTER_DATE(
                        IF(_sign = 1, LocalMJDateEnd, LocalMJDateStart),
                        _monthOffset, JulianCalendar
                    ),
                    _deltaYear, INDEX(_quarterDate_B, 1, 1) - INDEX(_quarterDate_A, 1, 1),
                    _deltaQuarter, INDEX(_quarterDate_B, 1, 2) - INDEX(_quarterDate_A, 1, 2),
                    _diffQuarters, (_deltaYear * 4) + _deltaQuarter,
                    _sign * (_diffQuarters + 1)
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
EXTENT_OF_YEARS

Returns the inclusive extent of years spanned by two Modified Julian Dates expressed in local time.
If the Modified Julian Dates are expressed in UTC rather than local time then inconsistent results may be
produced due to the bounds of calendar days.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer | Extent of quarters

Parameters
----------------------------------------------------------------------------------------------------------------
LocalMJDateStart | decimal | Starting Modified Julian Date in local time 
LocalMJDateEnd   | decimal | Ending Modified Julian Date in local time
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
/*EXTENT_OF_YEARS = LAMBDA(LocalMJDateStart, LocalMJDateEnd, [JulianCalendar],
    IFS(
        IS_EMPTY(LocalMJDateStart) * IS_EMPTY(LocalMJDateEnd), "",
        NOT(ISNUMBER(LocalMJDateStart)), {#VALUE!},
        NOT(ISNUMBER(LocalMJDateEnd)), {#VALUE!},
        TRUE, LET(
            _sign, IF(LocalMJDateEnd >= LocalMJDateStart, 1, -1),
            _date_A, MJDATE_TO_CALENDAR_DATE(
                IF(_sign = 1, LocalMJDateStart, LocalMJDateEnd),
                JulianCalendar
            ),
            _date_B, MJDATE_TO_CALENDAR_DATE(
                IF(_sign = 1, LocalMJDateEnd, LocalMJDateStart),
                JulianCalendar
            ),
            _deltaYear, INDEX(_date_B, 1, 1) - INDEX(_date_A, 1, 1),
            _sign * (_deltaYear + 1)
        )
    )
);















/*##############################################################################################################
# CONVERSIONS                                                                                                  #
##############################################################################################################*/


/*--------------------------------------------------------------------------------------------------------------
TIMESPAN_TO_EXCELTIME

Converts a TimeSpan to an Excel Date/Time.

Output
----------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1]     | Sign
 2 | decimal [0..2958466) | Excel Date/Time.

Parameters
----------------------------------------------------------------------------------------------------------------
TimeSpan | decimal |
--------------------------------------------------------------------------------------------------------------*/
/*TIMESPAN_TO_EXCELTIME = LAMBDA(TimeSpan,
    IFS(
        IS_EMPTY(TimeSpan), {"", ""},
        NOT(ISNUMBER(TimeSpan)), {#VALUE!, ""},
        TRUE, LET(
            _absTimeSpan, ABS(TimeSpan),
            _sign, SIGN(TimeSpan),
            IF(_absTimeSpan >= 2958466,
                HSTACK(_sign, {#NUM!}),
                HSTACK(_sign, _absTimeSpan)
            )
        )
    )
);

/*--------------------------------------------------------------------------------------------------------------
EXCELTIME_TO_TIMESPAN

Converts an Excel Date/Time to a TimeSpan.

Output
----------------------------------------------------------------------------------------------------------------
 1 | TimeSpan | decimal |

Parameters
----------------------------------------------------------------------------------------------------------------
Sign      | integer [-1,0,1]     |
ExcelTime | decimal [0..2958466) | Excel Date/Time.
--------------------------------------------------------------------------------------------------------------*/
/*EXCELTIME_TO_TIMESPAN = LAMBDA(Sign, ExcelTime,
    IFS(
        IS_EMPTY(ExcelTime), "",
        NOT(ISNUMBER(ExcelTime)), {#VALUE!},
        TRUE, LET(
            _sign, IFS(
                NOT(ISNUMBER(Sign)), 1,
                Sign < 0, -1, 
                TRUE, 1
            ),
            _sign * ExcelTime
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
MJDATE_TO_EXCELDATE

Converts a Modified Julian Date to an Excel Date/Time.
Note Excel Date/Time uses the Gregorian calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal         | Excel Date/Time.
   | [1..2958466)    | 1900-01-01..9999-12-31

Parameters
----------------------------------------------------------------------------------------------------------------
MJDate  | decimal          | Modified Julian Date
        | [15019..2973484) |
--------------------------------------------------------------------------------------------------------------*/
/*MJDATE_TO_EXCELDATE = LAMBDA(MJDate,
    IFS(
        IS_EMPTY(MJDate), "",
        NOT(ISNUMBER(MJDate)), {#VALUE!},
        MJDate < 15019, {#NUM!},
        MJDate >= 2973484, {#NUM!}, 
        TRUE, MJDate - 15018
    )
);


/*--------------------------------------------------------------------------------------------------------------
EXCELDATE_TO_MJDATE

Converts an Excel Date/Time to a Modified Julian Date.
Note Excel Date/Time uses the Gregorian calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal          | Modified Julian Date.
   | [15019..2973484) |

Parameters
----------------------------------------------------------------------------------------------------------------
ExcelDate | decimal      | Excel Date/Time
          | [1..2958466) | 1900-01-01..9999-12-31
--------------------------------------------------------------------------------------------------------------*/
/*EXCELDATE_TO_MJDATE = LAMBDA(ExcelDate,
    IFS(
        IS_EMPTY(ExcelDate), "", 
        NOT(ISNUMBER(ExcelDate)), {#VALUE!},
        TRUE, ExcelDate + 15018
    )
);


/*--------------------------------------------------------------------------------------------------------------
USDATE_TO_EXCELDATE

Converts a US format date to an Excel Date/Time.
Note Excel Date/Time uses the Gregorian calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal | Excel Date/Time.

Parameters
----------------------------------------------------------------------------------------------------------------
USDate | text | Date in US format ie. MM/dd/yyyy hh:mm:ss
--------------------------------------------------------------------------------------------------------------*/
/*USDATE_TO_EXCELDATE = LAMBDA(USDate,
    IF(IS_EMPTY(USDate), "",
        LET(
            _USDate, PARSE_US_DATE(USDate),
            _time, N(INDEX(_USDate, 1, 4)),
            _year, INDEX(_USDate, 1, 1),
            _excelDate, IF(IS_EMPTY(_year), 0,
                DATE(_year, INDEX(_USDate, 1, 2), INDEX(_USDate, 1, 3))
            ),
            _excelDate + _time
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
EXCELDATE_TO_USDATE

Converts an Excel Date/Time to a US format date.
Note Excel Date/Time uses the Gregorian calendar.

Output
----------------------------------------------------------------------------------------------------------------
 1 | text | US format date and time

Parameters
----------------------------------------------------------------------------------------------------------------
ExcelDate | decimal | Excel Date/Time.
[Options] | text    | String with elements: [<][LowOrder][DateSeparator][TimeSeparator]
          |         |      LowOrder : low order component to display
          |         |          Null : Defaults to minutes if time present, otherwise day
          |         |             D : Day
          |         |             H : Hour
          |         |             M : Minute
          |         |             S : Second
          |         |             T : Millisecond (ticks)
          |         |             < : Round by truncating components. Default is rounding to nearest.
          |         | DateSeparator : Character to separate date components. [,./-_]
          |         | TimeSeparator : Character to separate time components. [,.:-_]
--------------------------------------------------------------------------------------------------------------*/
/*EXCELDATE_TO_USDATE = LAMBDA(ExcelDate, [Options],
    IFS(
        IS_EMPTY(ExcelDate), "",
        NOT(ISNUMBER(ExcelDate)), {#VALUE!},
        ExcelDate <= 1, FORMAT_US_DATE("", "", "", ExcelDate, Options, 0),
        TRUE, LET(
            _yearCE, YEAR(ExcelDate),
            _month, MONTH(ExcelDate),
            _day, DAY(ExcelDate),
            _time, ExcelDate - INT(ExcelDate),
            FORMAT_US_DATE(_yearCE, _month, _day, _time, Options, 0)
        )
    )
);



/*--------------------------------------------------------------------------------------------------------------
ISO_DATETIME_TO_EXCELDATE

Converts an ISO formatted date and time to an Excel Date/Time and time zone offset.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal         | Excel Date/Time.
 2 | decimal         | Time zone offset from UTC as decimal fraction of a day.
   | [-0.625..0.625] | -15:00..+15:00

Parameters
----------------------------------------------------------------------------------------------------------------
ISODateTime        | text   | Date, time and time zone offset in ISO format
[AllowMixedStyles] | switch | Relax validation for no mixing of basic and extended formats. eg. yyyyMMddThh:mm
--------------------------------------------------------------------------------------------------------------*/
/*ISO_DATETIME_TO_EXCELDATE = LAMBDA(ISODateTime, [AllowMixedStyles],
    IF(IS_EMPTY(ISODateTime), {"", ""},
        LET(
            _isoDateTime, PARSE_ISO_DATETIME(ISODateTime, AllowMixedStyles),
            IFS(
                ISERROR(INDEX(_isoDateTime, 1, 1)), HSTACK({#VALUE!}, INDEX(_isoDateTime, 1, 5)),
                ISERROR(INDEX(_isoDateTime, 1, 4)), HSTACK({#VALUE!}, INDEX(_isoDateTime, 1, 5)),
                IS_EMPTY(INDEX(_isoDateTime, 1, 1)), HSTACK(INDEX(_isoDateTime, 1, 4), INDEX(_isoDateTime, 1, 5)),
                TRUE, LET(
                    _date, DATE(
                        INDEX(_isoDateTime, 1, 1),
                        INDEX(_isoDateTime, 1, 2),
                        INDEX(_isoDateTime, 1, 3)
                    ),
                    HSTACK(_date + N(INDEX(_isoDateTime, 1, 4)), INDEX(_isoDateTime, 1, 5))
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
EXCELDATE_TO_ISO_DATETIME

Converts an Excel Date/Time and time zone offset to an ISO formatted date and time.

Output
----------------------------------------------------------------------------------------------------------------
 1 | text  | ISO formated date and time

Parameters
----------------------------------------------------------------------------------------------------------------
ExcelDate    | decimal     | Excel Date/Time.
[TZOMinutes] | decimal     | Time zone offset from UTC in minutes
             | [-900..900] | Assumed to be UTC if omitted. [-15:00..+15:00]
[Options]    | text        | String with elements: [B][<][LowOrder][Precision][Z]
             |             |        B : Display in basic format eg T0000
             |             |        < : Round by truncating components. Default is rounding to nearest.
             |             | LowOrder : low order component to display
             |             |     Null : Defaults to seconds if time present, otherwise day
             |             |        D : Day
             |             |        H : Hour
             |             |        M : Minute
             |             |        S : Second
             |             | Precision: [0-9] Only has an effect when low order component is seconds.
             |             |        Z : Display 'Z' for Zulu time zone +00:00
--------------------------------------------------------------------------------------------------------------*/
/*EXCELDATE_TO_ISO_DATETIME = LAMBDA(ExcelDate, [TZOMinutes], [Options],
    IFS(
        IS_EMPTY(ExcelDate), "",
        NOT(ISNUMBER(ExcelDate)), {#VALUE!},
        ExcelDate <= 1, FORMAT_ISO_DATETIME("", "", "", ExcelDate, TZOMinutes, Options),
        TRUE, LET(
            _yearCE, YEAR(ExcelDate),
            _month, MONTH(ExcelDate),
            _day, DAY(ExcelDate),
            _time, ExcelDate - INT(ExcelDate),
            FORMAT_ISO_DATETIME(_yearCE, _month, _day, _time, TZOMinutes, Options)
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
ISO_DATETIME_TO_MJDATE

Converts an ISO formatted date and time to a Modified Julian Date and time zone offset.

Output
----------------------------------------------------------------------------------------------------------------
 1 | decimal         | Local Modifed Julian Date
 2 | decimal         | Time zone offset from UTC as decimal fraction of a day.
   | [-0.625..0.625] | -15:00..+15:00

Parameters
----------------------------------------------------------------------------------------------------------------
ISODateTime        | text   | Date, time and time zone offset in ISO format
[AllowMixedStyles] | switch | Relax validation for no mixing of basic and extended formats. eg. yyyyMMddThh:mm
[JulianCalendar]   | switch | Calculate for the Julian proleptic calendar. Default is Gregorian
                   |        | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
/*ISO_DATETIME_TO_MJDATE = LAMBDA(ISODateTime, [AllowMixedStyles], [JulianCalendar],
    IF(IS_EMPTY(ISODateTime), {"", ""},
        LET(
            _isoDateTime, PARSE_ISO_DATETIME(ISODateTime, AllowMixedStyles),
            IFS(
                ISERROR(INDEX(_isoDateTime, 1, 1)), HSTACK({#VALUE!}, INDEX(_isoDateTime, 1, 5)),
                NOT(IS_NUMERIC_NULL(INDEX(_isoDateTime, 1, 4))), HSTACK({#VALUE!}, INDEX(_isoDateTime, 1, 5)),
                IS_EMPTY(INDEX(_isoDateTime, 1, 1)), HSTACK({#VALUE!}, INDEX(_isoDateTime, 1, 5)),
                TRUE, LET(
                    _MJDate, MODIFIED_JULIAN_DATE(
                        INDEX(_isoDateTime, 1, 1),
                        INDEX(_isoDateTime, 1, 2),
                        INDEX(_isoDateTime, 1, 3),
                        INDEX(_isoDateTime, 1, 4),
                        JulianCalendar
                    ),
                    HSTACK(_MJDate, INDEX(_isoDateTime, 1, 5))
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------------
MJDATE_TO_ISO_DATETIME

Converts a Modified Julian Date and time zone offset to an ISO formatted date and time.

Output
----------------------------------------------------------------------------------------------------------------
 1 | text  | ISO formated date and time

Parameters
----------------------------------------------------------------------------------------------------------------
MJDate           | decimal     | Modified Julian Date
[TZOMinutes]     | decimal     | Time zone offset from UTC in minutes
                 | [-900..900] | Assumed to be UTC if omitted. [-15:00..+15:00]
[Options]        | text        | String with elements: [B][<][LowOrder][Precision][Z]
                 |             |        B : Display in basic format eg T0000
                 |             |        < : Round by truncating components. Default is rounding to nearest.
                 |             | LowOrder : low order component to display
                 |             |     Null : Defaults to seconds if time present, otherwise day
                 |             |        D : Day
                 |             |        H : Hour
                 |             |        M : Minute
                 |             |        S : Second
                 |             | Precision: [0-9] Only has an effect when low order component is seconds.
                 |             |        Z : Display 'Z' for Zulu time zone +00:00
[JulianCalendar] | switch      | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |             | proleptic calendar.
--------------------------------------------------------------------------------------------------------------*/
/*MJDATE_TO_ISO_DATETIME = LAMBDA(MJDate, [TZOMinutes], [Options], [JulianCalendar],
    IFS(
        IS_EMPTY(MJDate), "",
        NOT(ISNUMBER(MJDate)), {#VALUE!},
        TRUE, LET(
            _cDate, MJDATE_TO_CALENDAR_DATE(MJDate, JulianCalendar),
            FORMAT_ISO_DATETIME(
                INDEX(_cDate, 1, 1),
                INDEX(_cDate, 1, 2),
                INDEX(_cDate, 1, 3),
                INDEX(_cDate, 1, 4),
                TZOMinutes,
                Options,
                JulianCalendar
            )
        )
    )
);


/*##############################################################################################################
# END CALENDAR                                                                                                 #
##############################################################################################################*/
