/*###########################################################################################################
# CALENDAR v3.0                                                                                             #
#                                                                                                           #
# Module for working with dates in the Gregorian and Julian calendars outside the range of the Excel        #
# Date/Time type.                                                                                           #
#                                                                                                           #
# Module Dependencies: None                                                                                 #
#                                                                                                           #
# GENERAL                                                                                                   #
# --------------------------------------------------------------------------------------------------------- #
# NULLIFY                 Ensures an empty cell reference is not resolved to zero.                          #
# IS_EMPTY                Tests if the parameter has an empty value. Errors return FALSE.                   #
# IS_NUMERIC_NULL         Tests if the parameter has a numeric value or is empty. Errors return FALSE.      #
# IS_INTEGER              Tests if a number is an integer or very close to an integer. Use in place of      #
#                         MOD(N, 0) > 0 where N can be within a large range of magnitudes.                  #
# DECIMALS                Returns the number of decimal places for a rational number.                       #
# VALIDATE_CHARSET        Validates that the given text only contains characters in the specified character #
#                         set. Matching is case sensitive.                                                  #
# REPLACE_CHARS           Replaces each instance of a set of characters within text with another character. #
#                         Matching is case sensitive. Note can be used to remove characters by supplying an #
#                         empty CharReplaceWith.                                                            #
# FIND_NTH_CHAR           Locates the position of the Nth count of any one of a set of characters within    #
#                         the given text. The search is case sensitive.                                     #
# SEARCH_NTH_CHAR         Locates the position of the Nth count of any one of a set of characters within    #
#                         the given text. The search is case insensitive                                    #
# SPLIT_AROUND_CHARS      Splits text at any character not in the given set. First element returned is the  #
#                         sequence of unmatched characters, followed by each substring. Matching is case    #
#                         sensitive.                                                                        #
#                                                                                                           #
# TIMESPAN                                                                                                  #
# --------------------------------------------------------------------------------------------------------- #
# IS_VALID_TIMESPAN       Tests if sexagesimal representation of a timespan is valid. A component can       #
#                         exceed its modulus if no higher order element is provided.                        #
# VALIDATE_TIMESPAN       Validate each element of a sexagesimal representation of a timespan. A component  #
#                         can exceed its modulus if no higher order omponent is provided.                   #
# TIMESPAN_LOW_ORDER      Returns a number representing the lowest order component of the sexagesimal       #
#                         representation of a timespan value.                                               #
# TIMESPAN_HIGH_ORDER     Returns a number representing the highest order component of the sexagesimal      #
#                         representation of a timespan value.                                               #
# TIMESPAN                Returns a decimal timespan as a fraction of a day from a sexagesimal              #
#                         representation of time. Note components exceeding their modulus will carry.       #
# ROUND_TIMESPAN          Returns a decimal timespan value rounded to the specified precision level.        #
# RESOLVE_TIMESPAN        Returns the sexagesimal representation of a timespan value expressed from the     #
#                         specified high order component and the given lowest order component rounded to    #
#                         the specified precision.                                                          #
# PARSE_TIMESPAN          Parses a text timespan expression into sexagesimal components.                    #
# FORMAT_TIMESPAN         Returns a timespan as text in the specified format from a given decimal timespan. #
#                                                                                                           #
# CALENDAR DATES                                                                                            #
# --------------------------------------------------------------------------------------------------------- #
# YEAR_COMMON_ERA         Returns year value relative to the Common Era.                                    #
# PARSE_MONTH             Returns a number representing the month of year from a given month name.          #
# MONTH_NAME              Returns name of month.                                                            #
# IS_LEAP_YEAR            Tests if a year includes a leap day in the given calendar.                        #
# IS_VALID_DATE           Tests if a date is valid for the given calendar.                                  #
# DAYS_IN_YEAR            Returns number of days in the given year of the specified calendar.               #
# DAYS_IN_MONTH           Returns number of days in the given month and year of the specified calendar.     #
# PARSE_ISO_CALENDAR_DATE Parses an ISO formatted calendar date into respective parts of year, month and    #
#                         day.                                                                              #
# FORMAT_ISO_YEAR         Returns a year as text in ISO format.                                             #
# FORMAT_ISO_CALENDAR_DATE  Returns a calendar date as text in ISO format.                                  #
# JULIAN_DAY_NUMBER       Returns the Julian Day Number (JDN) of the provided date in the specified         #
#                         calendar. Note the Julian Day Number is an integer type and is an ordinal day     #
#                         number referenced from January 1, 4713 BC in the proleptic Julian calendar. It    #
#                         does not include any value for time of day.                                       #
# MODIFIED_JULIAN_DAY_NUMBER   Returns the Modified Julian Day Number (MJDN) of the provided date in the    #
#                         specified calendar. Note the Modified Julian Day Number is an integer type and    #
#                         is an ordinal day number referenced from November 17, 1858 in the proleptic       #
#                         Gregorian calendar. It does not include any value for time of day.                #
# JDN_TO_MODIFIED         Converts a Julian Day Number (JDN) to a Modified Julian Day Number (MJDN).        #
# MODIFIED_TO_JDN         Converts a Modified Julian Day Number (MJDN) to a Julian Day Number (JDN).        #
# JDN_TO_CALENDAR_DATE    Converts a Julian Day Number (JDN) to a date in the specified calendar.           #
# MJDN_TO_CALENDAR_DATE   Converts a Modified Julian Day Number (MJDN) to a date in the specified calendar. #
# GREGORIAN_TO_JULIAN     Translates a date in the Gregorian proleptic calendar to the Julian proleptic     #
#                         calendar.                                                                         #
# JULIAN_TO_GREGORIAN     Translates a date in the Julian proleptic calendar to the Gregorian proleptic     #
#                         calendar.                                                                         #
# SECULAR_DIFFERENCE      Returns the number of days the Gregorian proleptic calendar is ahead of the       #
#                         Julian proleptic calendar for a given date.                                       #
#                                                                                                           #
# TIME ZONES                                                                                                #
# --------------------------------------------------------------------------------------------------------- #
# IS_VALID_TZO            Tests if a time zone offset in minutes is within the range -900..+900             #
# TIMESPAN_TO_TZO         Converts a deimal timespan into time zone offset minutes.                         #
# TZO_TO_TIMESPAN         Converts time zone offset minutes into a decimal timespan.                        #
# PARSE_ISO_TZO           Parses an ISO formatted time zone offset into a decimal timespan.                 #
# FORMAT_ISO_TZO          Returns a time zone offset as text in ISO format.                                 #

#                                                                                                           #
# DATE AND TIME                                                                                             #
# --------------------------------------------------------------------------------------------------------- #
# IS_VALID_TIME_OF_DAY    Tests if sexagesimal representation of time is valid for a 24 hour day.           #
# JULIAN_DATE             Returns the Julian Date of the provided date and time of day in the specified     #
#                         calendar. Note that the decimal time component of Julian Date is based from       #
#                         midday.                                                                           #
# MODIFIED_JULIAN_DATE    Returns the Modified Julian Date of the provided date and time of day in the      #
#                         specified calendar. Note that the time component of Modified Julian Date is       #
#                         based from midnight.                                                              #
# JDATE_TO_MODIFIED       Converts a Julian Date (JDATE) to a Modified Julian Date (MJDATE). Note that the  #
#                         decimal time component of MJDATE is based from midnight.                          #
# MODIFIED_TO_JDATE       Converts a Modified Julian Date (MJDATE) to a Julian Date (JDATE). Note that the  #
#                         decimal time component of JDATE is based from midday.                             #
# JDATE_TO_CALENDAR_DATE  Converts a Julian Date (JDATE) to a date and time in the specified calendar.      #
# MJDATE_TO_CALENDAR_DATE Converts a Modified Julian Date (MJDATE) to a date and time in the specified      #
#                         calendar.                                                                         #
# RESOLVE_MJDATE          Returns the date and sexagesimal representation of the time value with the given  #
#                         lowest order component rounded to the specified precision.                        #
# MJDATE_ADDITION         Returns the addition of a timespan complication to a given Modified Julian Date.  #
#                         Note if date components of years, quarters or months are added for a MJDate       #
#                         expressed in UTC rather than local time, then results may be inconsistent due to  #
#                         the bounds of calendar days.                                                      #
# PARSE_ISO_TIME          Parses an ISO formatted time of day into decimal time of day.                     #
# FORMAT_ISO_TIME         Returns a time of day as text in ISO format.                                      #
# PARSE_ISO_DATETIME      Parses an ISO formatted date and time into respective date parts, time, and time  #
#                         zone offset from UTC. Providing a time zone offset on its own is invalid for      #
#                         this function.                                                                    #
# FORMAT_ISO_DATETIME     Returns a date, time and time zone offset as text in ISO format.                  #
# PARSE_LITERARY_YEAR     Returns a number representing the year relative to the common era from a given    #
#                         literary year.                                                                    #
# FORMAT_LITERARY_YEAR    Returns a year formatted in literary style.                                       #
# PARSE_LITERARY_DATE     Parses a literary date into respective parts of year, month, day and time of day. #
# FORMAT_LITERARY_DATE    Returns a date formatted in literary style.                                       #
# PARSE_US_DATE           Parses a US formatted date into respective parts of year, month, day and time of  #
#                         day.                                                                              #
# FORMAT_US_DATE          Returns a date formatted in the US style.                                         #
# PARSE_MIL_DTG           Parses a date-time group in the format used by US Military message traffic, into  #
#                         respective parts of year, month, day, time of day and time zone offset in         #
#                         minutes from UTC.                                                                 #
# FORMAT_MIL_DTG          Returns a date-time group formatted in US Military message traffic style.         #
# SHIFT_TIMEZONE          Translates a Modified Julian Date from one time zone to another. If a time zone   #
#                         is omitted it is assumed to be UTC.                                               #
#                                                                                                           #
# ORDINAL DATES                                                                                             #
# --------------------------------------------------------------------------------------------------------- #
# IS_VALID_ORDINAL_DATE   Tests if an ordinal date is valid for the given calendar.                         #
# PARSE_ISO_ORDINAL_DATE  Parses an ISO formatted ordinal date into respective parts of year, and ordinal   #
#                         day.                                                                              #
# FORMAT_ISO_ORDINAL_DATE Returns an ordinal date as text in ISO format.                                    #
# ORDINAL_DATE_TO_MJDATE  Converts an ordinal date and time in the specified calendar to a Modified Julian  #
#                         Date.                                                                             #
# MJDATE_TO_ORDINAL_DATE  Converts a Modified Julian Date (MJDATE) to an ordinal date and time in the       #
#                         specified calendar.                                                               #
#                                                                                                           #
# WEEKS                                                                                                     #
# --------------------------------------------------------------------------------------------------------- #
# CONVERT_WEEKDAY_NUMBER  Returns an integer for the day of the week from the traditonal numbering scheme   #
#                         to the ISO definition, or vice versa.                                             #
# PARSE_WEEKDAY           Returns a number representing the day of the week from a given text weekday name. #
# WEEKDAY_NAME           Returns name of an ISO day of week number as text.                                 #
# DAY_OF_WEEK             Returns an integer for the day of the week for a given Modified Julian Date.      #
# WEEKDAY_OF_MONTH        Returns a Modified Julian Date for a given day of week, relative week for the     #
#                         month, year and time of day of the specified calendar.                            #
# IS_VALID_WEEK_DATE      Tests if a week date is valid for the given calendar.                             #
# WEEKS_IN_YEAR           Returns the count of ISO defined weeks in a given year of the specified calendar. #
# PARSE_ISO_WEEK_DATE     Parses an ISO formatted week date into respective parts of year, week and         #
#                         weekday.                                                                          #
# FORMAT_ISO_WEEK_DATE    Returns a week date as text in ISO format.                                        #
# WEEK_DATE_TO_MJDATE     Converts a week date of year, ISO defined week number, ISO weekday, and time in   #
#                         the specified calendar to a Modified Julian Date (MJDATE).                        #
# MJDATE_TO_WEEK_DATE     Converts a Modified Julian Date (MJDATE) to the year, ISO defined week number,    #
#                         ISO weekday, time, and weeks in the year in the specified calendar.               #
# WEEK_NUMBER             Returns the ISO defined week number for a given Modified Julian Date in the       #
#                         specified calendar.                                                               #
#                                                                                                           #
# QUARTERS                                                                                                  #
# --------------------------------------------------------------------------------------------------------- #
# DAYS_IN_QUARTER         Returns the count of days in a quarter of a given year of the specified calendar. #
# QUARTER_DATE_TO_MJDATE  Converts a date expressed as fiscal year, quarter, day of quarter and time in     #
#                         the specified calendar to a Modified Julian Date (MJDATE).                        #
# MJDATE_TO_QUARTER_DATE  Converts a Modified Julian Date (MJDATE) to a date expressed as fiscal year,      #
#                         quarter, day of quarter and time in the specified calendar.                       #
#                                                                                                           #
# DELTAS                                                                                                    #
# --------------------------------------------------------------------------------------------------------- #
# DELTA_INTERVAL          Returns the timespan difference between Modified Julian Dates in the specified    #
#                         units.                                                                            #
# DELTA_HOURS             Returns the timespan difference between Modified Julian Dates in hours.           #
# DELTA_MINUTES           Returns the timespan difference between Modified Julian Dates in minutes.         #
# DELTA_SECONDS           Returns the timespan difference between Modified Julian Dates in seconds.         #
# DELTA_DHMS              Returns the sexagesimal difference between Modified Julian Dates with the given   #
#                         lowest order component rounded to the specified precision.                        #
# DELTA_TIMESPAN          Returns the timespan difference between Modified Julian Dates.                    #
# DELTA_WEEKS             Returns the timespan difference between Modified Julian Dates in weeks.           #
# DELTA_MONTHS            Returns the timespan difference between Modified Julian Dates in months. Where    #
#                         the difference includes partial months, the fraction is calculated on the basis   #
#                         of days in the month of the calendar. If the Modified Julian Dates are expressed  #
#                         in UTC rather than local time then a small margin of error will be introduced due #
#                         to the bounds of calendar days.                                                   #
# DELTA_QUARTERS          Returns the timespan difference between Modified Julian Dates in quarters. Where  #
#                         the difference includes partial quarters, the fraction is calculated on the basis #
#                         of days in the quarter of the calendar. If the Modified Julian Dates are          #
#                         expressed in UTC rather than local time then a small margin of error will be      #
#                         introduced due to the bounds of calendar days.                                    #
# DELTA_YEARS             Returns the timespan difference between Modified Julian Dates in years. Where the #
#                         difference includes partial years, the fraction is calculated on the basis of     #
#                         days in the year of the calendar. If the Modified Julian Dates are expressed in   #
#                         UTC rather than local time then a small margin of error will be introduced due to #
#                         the bounds of calendar days.                                                      #
# DELTA_WEEK_DAYS         Returns the timespan difference between Modified Julian Dates in weeks and days.  #
# DELTA_YEAR_WEEK_DAYS    Returns the timespan difference between Modified Julian Dates in years, weeks,    #
#                         and days. Note the number of weeks per year can vary between 52 and 53. If an     #
#                         absolute number of weeks is being sought then use either DELTA_WEEK_DAYS or       #
#                         DELTA_WEEKS functions. If the Modified Julian Dates are expressed in UTC rather   #
#                         than local time then a small margin of error will be introduced due to the bounds #
#                         of calendar days.                                                                 #
# DELTA_MONTH_DAYS        Returns the timespan difference between Modified Julian Dates in months and days. #
#                         If the Modified Julian Dates are expressed in UTC rather than local time then a   #
#                         small margin of error will be introduced due to the bounds of calendar days.      #
# DELTA_QUARTER_DAYS      Returns the timespan difference between Modified Julian Dates in quarters and     #
#                         days. If the Modified Julian Dates are expressed in UTC rather than local time    #
#                         then a small margin of error will be introduced due to the bounds of calendar     #
#                         days.                                                                             #
#                                                                                                           #
# EXTENTS                                                                                                   #
# --------------------------------------------------------------------------------------------------------- #
# EXTENT_OF_DAYS          Returns the inclusive extent of days spanned by two Modified Julian Dates         #
#                         expressed in local time. If the Modified Julian Dates are expressed in UTC rather #
#                         than local time then inconsistent results may be produced due to the bounds of    #
#                         calendar days.                                                                    #
# EXTENT_OF_WEEKS         Returns the inclusive extent of weeks spanned by two Modified Julian Dates        #
#                         expressed in local time. If the Modified Julian Dates are expressed in UTC rather #
#                         than local time then inconsistent results may be produced due to the bounds of    #
#                         calendar days.                                                                    #
# EXTENT_OF_MONTHS        Returns the inclusive extent of months spanned by two Modified Julian Dates       #
#                         expressed in local time. If the Modified Julian Dates are expressed in UTC rather #
#                         than local time then inconsistent results may be produced due to the bounds of    #
#                         calendar days.                                                                    #
# EXTENT_OF_QUARTERS      Returns the inclusive extent of quarters spanned by two Modified Julian Dates     #
#                         expressed in local time. If the Modified Julian Dates are expressed in UTC rather #
#                         than local time then inconsistent results may be produced due to the bounds of    #
#                         calendar days.                                                                    #
# EXTENT_OF_YEARS         Returns the inclusive extent of years spanned by two Modified Julian Dates        #
#                         expressed in local time. If the Modified Julian Dates are expressed in UTC rather #
#                         than local time then inconsistent results may be produced due to the bounds of    #
#                         calendar days.                                                                    #
#                                                                                                           #
# CONVERSIONS                                                                                               #
# --------------------------------------------------------------------------------------------------------- #
# TIMESPAN_TO_EXCELTIME   Converts a TimeSpan to an Excel Date/Time.                                        #
# EXCELTIME_TO_TIMESPAN   Converts an Excel Date/Time to a TimeSpan.                                        #
# MJDATE_TO_EXCELDATE     Converts a Modified Julian Date to an Excel Date/Time.                            #
# EXCELDATE_TO_MJDATE     Converts an Excel Date/Time to a Modified Julian Date.                            #
# USDATE_TO_EXCELDATE     Converts a US format date to an Excel Date/Time.                                  #
# EXCELDATE_TO_USDATE     Converts an Excel Date/Time to a US format date.                                  #
# ISO_DATETIME_TO_EXCELDATE  Converts an ISO formatted date and time to an Excel Date/Time and time zone    #
#                         offset.                                                                           #
# EXCELDATE_TO_ISO_DATETIME  Converts an Excel Date/Time and time zone offset to an ISO formatted date and  #
#                         time.                                                                             #
# ISO_DATETIME_TO_MJDATE  Converts an ISO formatted date and time to a Modified Julian Date and time zone   #
#                         offset.                                                                           #
# MJDATE_TO_ISO_DATETIME  Converts a Modified Julian Date and time zone offset to an ISO formatted date and #
#                         time.                                                                             #
#                                                                                                           #
###########################################################################################################*/


/*###########################################################################################################
# GENERAL                                                                                                   #
###########################################################################################################*/


/*-----------------------------------------------------------------------------------------------------------
NULLIFY

Ensures an empty cell reference is not resolved to zero.

Output
-------------------------------------------------------------------------------------------------------------
 1 | variant | 

Parameters
-------------------------------------------------------------------------------------------------------------
Value | variant |

Examples
-------------------------------------------------------------------------------------------------------------
NULLIFY(A1), where A1 is empty
Returns ""
----------------------------------------------------------------------------------------------------------*/
NULLIFY = LAMBDA(Value,
    IF(ISBLANK(Value), "", Value)
);

/*----------------------------------------------------------------------------------------------------------
IS_EMPTY

Tests if the parameter has an empty value. Errors return FALSE.

Output
-------------------------------------------------------------------------------------------------------------
 1 | boolean | 

Parameters
-------------------------------------------------------------------------------------------------------------
Value | variant |

Examples
-------------------------------------------------------------------------------------------------------------
IS_EMPTY("")
Returns TRUE

IS_EMPTY(1)
Returns FALSE

IS_EMPTY(#N/A)
Returns FALSE
----------------------------------------------------------------------------------------------------------*/
IS_EMPTY = LAMBDA(Value,
    IF(ISERROR(Value), FALSE,
        Value = ""
    )
);


/*----------------------------------------------------------------------------------------------------------
IS_NUMERIC_NULL

Tests if the parameter has a numeric value or is empty. Errors return FALSE.

Output
-------------------------------------------------------------------------------------------------------------
 1 | boolean | 

Parameters
-------------------------------------------------------------------------------------------------------------
Value | variant |

Examples
-------------------------------------------------------------------------------------------------------------
IS_NUMERIC_NULL(1)
Returns TRUE

IS_NUMERIC_NULL("")
Returns TRUE

IS_NUMERIC_NULL("X")
Returns FALSE

IS_NUMERIC_NULL(#VALUE!)
Returns FALSE
----------------------------------------------------------------------------------------------------------*/
IS_NUMERIC_NULL = LAMBDA(Value,
    IFS(
        ISERROR(Value), FALSE,
        Value = "", TRUE,
        ISNUMBER(Value), TRUE,
        TRUE, FALSE
    )    
);


/*----------------------------------------------------------------------------------------------------------
IS_INTEGER

Tests if a number is an integer or very close to an integer. Use in place of MOD(N, 0) > 0 where N
can be within a large range of magnitudes.

Output
-------------------------------------------------------------------------------------------------------------
 1 | boolean | 

Parameters
-------------------------------------------------------------------------------------------------------------
N | decimal |

Examples
-------------------------------------------------------------------------------------------------------------
IS_INTEGER(1)
Returns TRUE

IS_INTEGER(0.5)
Returns FALSE

IS_INTEGER("3")
Returns #VALUE!
----------------------------------------------------------------------------------------------------------*/
IS_INTEGER = LAMBDA(N,
    IF(NOT(ISNUMBER(N)), {#VALUE!},
        LET(
            _integer, INT(N),
            ROUNDDOWN(N - _integer, 15) = 0
        )
    )
);



/*----------------------------------------------------------------------------------------------------------
DECIMALS

Returns the number of decimal places for a rational number.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer [0..] | max value 15 for values > 1

Parameters
-------------------------------------------------------------------------------------------------------------
N | decimal | 
----------------------------------------------------------------------------------------------------------*/
DECIMALS = LAMBDA(N,
    IFS(
        N = "", "",
        NOT(ISNumber(N)), {#VALUE!},
        N = 0, 0,
        TRUE, LET(
            // IEEE 754 floating point arithmetic introduces errors in the mathematical algorithm:
            // num -> frac = MOD(num, 1); smallest n where frac * 10^n = INT(frac * 10^n)
            // MOD involves subraction, which for a numbers >> 1 with a small decimal part produces
            // an error margin that results in a much larger n 
            // eg num = 10^12 + 0.1 ; MOD(num, 1) - 0.1 = -0.000244...
            // n should = 1, however the algorithm results in a run-away n
            // Using Excel string formatting instead
            _num1, ABS(N),
            _frac1, _num1 - INT(_num1),
            _shift, IFERROR(CEILING(-LOG10(_frac1), 1) - 1, 0),
            _num2, _num1 * POWER(10, _shift),
            _sNum2, TEXT(_num2,"0.000000000000000"),
            _sFrac, RIGHT(_sNum2, 15),
            IF(_sFrac = "000000000000000", 0,
                LET(
                    _last, REDUCE("", SEQUENCE(15,,15, -1),
                        LAMBDA(_acc, _curr,
                            IF(_acc <> "", _acc,
                                IF(MID(_sFrac, _curr, 1) = "0", "", _curr)
                            )
                        )
                    ),
                    _last + _shift
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
VALIDATE_CHARSET

Validates that the given text only contains characters in the specified character set.
Matching is case sensitive.

Output
-------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
-------------------------------------------------------------------------------------------------------------
CharSet | text | Valid characters
Text    | text | Text to validate
----------------------------------------------------------------------------------------------------------*/
VALIDATE_CHARSET = LAMBDA(CharSet, Text, [IgnoreCase],
    IF((CharSet = "") + (Text = ""), FALSE,
        LET(
            _ignoreCase, N(IgnoreCase) <> 0,
            _text, IF(_ignoreCase, UPPER(Text), Text),
            _chars, IF(_ignoreCase, UPPER(CharSet), CharSet),
            _escapeText, SUBSTITUTE(SUBSTITUTE(_text, "&", "&amp;"), "<", "&lt;"),
            _xml, "<xml><s>" & _escapeText & "</s></xml>",
            _xpath, "//s[translate(.,'" & _chars & "','')='']",
            NOT(ISERROR(FILTERXML(_xml, _xpath)))
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
REPLACE_CHARS

Replaces each instance of a set of characters within text with another character.
Matching is case sensitive. Note can be used to remove characters by supplying an empty CharReplaceWith.

Output
-------------------------------------------------------------------------------------------------------------
 1 | text |

Parameters
-------------------------------------------------------------------------------------------------------------
Text            | text | Text within which to replace characters
CharSet         | text | Set of characters to be replaced
CharReplaceWith | text | Target character with which to replace each character in CharSet

Examples
-------------------------------------------------------------------------------------------------------------
REPLACE_CHARS("abc:def/g/h", ":/", "")
Returns: "abcdefgh"

REPLACE_CHARS("abc:def/g/h", ":/", "_")
Returns: "abc_def_g_h"
----------------------------------------------------------------------------------------------------------*/
REPLACE_CHARS = LAMBDA(Text, CharSet, CharReplaceWith,
    IFS(
        Text = "", "",
        CharSet = "", Text,
        TRUE, LET(
            _charNew, LEFT(CharReplaceWith),
            REDUCE(text, SEQUENCE(LEN(CharSet)),
                LAMBDA(acc, curr,
                    SUBSTITUTE(acc, MID(CharSet, curr, 1), _charNew)
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
FIND_NTH_CHAR

Locates the position of the Nth count of any one of a set of characters within the given text.
The search is case sensitive.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer | Character position in text. Negative if a negative StartPos was used.
 2 | char    | Character found. Returned if ReturnChar is set

Parameters
-------------------------------------------------------------------------------------------------------------
Chars        | text             | Characters to search for
Text         | text             | Text to search within
N            | integer          | Nth count of any of the characters
             |                  | Negative values will perform a reverse search from the end of the text.
[ReturnChar] | switch           | Also return the character found
[LowerPos]   | integer          | Position to start the search from.
             | [1..LEN(Text)]   | Negative values are relative to the end of the text.
             | [-LEN(Text)..-1] | Defaults to beginning of the text.
[UpperPos]   | integer          | Position limit of the search.
             | [1..LEN(Text)]   | Negative values are relative to the end of the text.
             | [-LEN(Text)..-1] | Defaults to end of the text.

Examples
-------------------------------------------------------------------------------------------------------------
FIND_NTH_CHAR("AB", "1234_A_B_A_0", 1)
Returns: 6 i.e. 1st A or B at position 6

FIND_NTH_CHAR("AB", "1234_A_B_A_0", 2)
Returns: 8 i.e. 2nd A or B at position 8

FIND_NTH_CHAR("AB", "1234_A_B_A_0", 2, 1, 7)
Returns: {10, "A"} i.e. 2nd A or B at position 10, searching from position 7. A was found

FIND_NTH_CHAR("AB", "1234_A_B_A_0", -2, 1, -4)
Returns: {6, "A"} i.e. 2nd A or B at position 6, using reverse search from 4 characters from end. A was found
----------------------------------------------------------------------------------------------------------*/
FIND_NTH_CHAR = LAMBDA(Chars, Text, N, [ReturnChar], [LowerPos], [UpperPos],
    LET(
        _n, INT(N(N)),
        _signN, SIGN(_n),
        _outChar, N(ReturnChar) <> 0,
        _len, LEN(Text),
        _startPos, IFS(
            NOT(ISNUMBER(LowerPos)), 1,
            LowerPos > 0, LowerPos,
            LowerPos < 0, _len + LowerPos + 1,
            LowerPos = 0, 1
        ),
        _endPos, IFS(
            NOT(ISNUMBER(UpperPos)), _len,
            UpperPos > 0, UpperPos,
            UpperPos < 0, _len + UpperPos + 1,
            UpperPos = 0, 0
        ),
        
        IF((_startPos > _len) + (_startPos > _endPos) + (Chars = "") + (_n = 0),
            IF(_outChar, {0, ""}, 0),
            LET(
                _text, MID(Text, _startPos, _endPos - _startPos + 1),
                _searchLen, LEN(_text),
                _chars, MID(Chars, SEQUENCE(1, LEN(Chars)), 1),
                _findCount, LET(
                    _removed, REDUCE(_text, _chars,
                        LAMBDA(_acc, _curr, SUBSTITUTE(_acc, _curr, ""))
                    ),
                    _searchLen - LEN(_removed)
                ),
                IF(_findCount < ABS(_n), IF(_outChar, {0, ""}, 0),
                    LET(
                        // nth can count from end backwards
                        _nth, IF(_n > 0, _n, _findCount + _n + 1),
                        _nthPos, REDUCE(0, SEQUENCE(1, _nth),
                            LAMBDA(_acc, _curr,
                                IF(_acc < 0, -1,
                                    LET(
                                        _nextPosChars, IFERROR(
                                            FIND(_chars, _text, _acc + 1),
                                            0
                                        ),
                                        _nextPos, MIN(
                                            FILTER(_nextPosChars, _nextPosChars > 0, 0)
                                        ),
                                        IF(_nextPos = 0, -1, _nextPos)
                                    )
                                )
                            )
                        ),
                        _outPos, _nthPos + _startPos - 1,
                        
                        IF(_outChar,
                            IF(_outPos = 0, {0, ""},
                                HSTACK(
                                    _outPos,
                                    MID(_text, _nthPos, 1)
                                )
                            ),
                            _outPos
                        )
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
SEARCH_NTH_CHAR

Locates the position of the Nth count of any one of a set of characters within the given text.
The search is case insensitive. 

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer | Character position in text. Negative if a negative StartPos was used.
 2 | char    | Character found. Returned if ReturnChar is set

Parameters
-------------------------------------------------------------------------------------------------------------
Chars        | text             | Characters to search for
Text         | text             | Text to search within
N            | integer          | Nth count of any of the characters
             |                  | Negative values will perform a reverse search from the end of the text.
[ReturnChar] | switch           | Also return the character found
[LowerPos]   | integer          | Position to start the search from.
             | [1..LEN(Text)]   | Negative values are relative to the end of the text.
             | [-LEN(Text)..-1] | Defaults to beginning of the text.
[UpperPos]   | integer          | Position limit of the search.
             | [1..LEN(Text)]   | Negative values are relative to the end of the text.
             | [-LEN(Text)..-1] | Defaults to end of the text.

Examples
-------------------------------------------------------------------------------------------------------------
SEARCH_NTH_CHAR("ab", "1234_A_B_A_0", 1)
Returns: 6 i.e. 1st A or B at position 6

SEARCH_NTH_CHAR("ab", "1234_A_B_A_0", 2)
Returns: 8 i.e. 2nd A or B at position 8

SEARCH_NTH_CHAR("ab", "1234_A_B_A_0", 2, 1, 7)
Returns: {10, "A"} i.e. 2nd A or B at position 10, searching from position 7. A was found

SEARCH_NTH_CHAR("ab", "1234_A_B_A_0", -2, 1, -4)
Returns: {6, "A"} i.e. 2nd A or B at position 6, using reverse search from 4 characters from end. A was found
----------------------------------------------------------------------------------------------------------*/
SEARCH_NTH_CHAR = LAMBDA(Chars, Text, N, [ReturnChar], [LowerPos], [UpperPos],
    LET(
        _n, INT(N(N)),
        _signN, SIGN(_n),
        _outChar, N(ReturnChar) <> 0,
        _len, LEN(Text),
        _startPos, IFS(
            NOT(ISNUMBER(LowerPos)), 1,
            LowerPos > 0, LowerPos,
            LowerPos < 0, _len + LowerPos + 1,
            LowerPos = 0, 1
        ),
        _endPos, IFS(
            NOT(ISNUMBER(UpperPos)), _len,
            UpperPos > 0, UpperPos,
            UpperPos < 0, _len + UpperPos + 1,
            UpperPos = 0, 0
        ),
        
        IF((_startPos > _len) + (_startPos > _endPos) + (Chars = "") + (_n = 0),
            IF(_outChar, {0, ""}, 0),
            LET(
                _text, MID(Text, _startPos, _endPos - _startPos + 1),
                _searchLen, LEN(_text),
                _searchText, UPPER(_text),
                _chars, UPPER(MID(Chars, SEQUENCE(1, LEN(Chars)), 1)),
                _findCount, LET(
                    _removed, REDUCE(_searchText, _chars,
                        LAMBDA(_acc, _curr, SUBSTITUTE(_acc, _curr, ""))
                    ),
                    _searchLen - LEN(_removed)
                ),
                IF(_findCount < ABS(_n), IF(_outChar, {0, ""}, 0),
                    LET(
                        // nth can count from end backwards
                        _nth, IF(_n > 0, _n, _findCount + _n + 1),
                        _nthPos, REDUCE(0, SEQUENCE(1, _nth),
                            LAMBDA(_acc, _curr,
                                IF(_acc < 0, -1,
                                    LET(
                                        _nextPosChars, IFERROR(
                                            FIND(_chars, _searchText, _acc + 1),
                                            0
                                        ),
                                        _nextPos, MIN(
                                            FILTER(_nextPosChars, _nextPosChars > 0, 0)
                                        ),
                                        IF(_nextPos = 0, -1, _nextPos)
                                    )
                                )
                            )
                        ),
                        _outPos, _nthPos + _startPos - 1,
                        
                        IF(_outChar,
                            IF(_outPos = 0, {0, ""},
                                HSTACK(
                                    _outPos,
                                    MID(_text, _nthPos, 1)
                                )
                            ),
                            _outPos
                        )
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
SPLIT_AROUND_CHARS

Splits text at any character not in the given set. First element returned is the sequence of unmatched
characters, followed by each substring. Matching is case sensitive.

Output
-------------------------------------------------------------------------------------------------------------
 1 | text | Array of substrings

Parameters
-------------------------------------------------------------------------------------------------------------
Chars   | text    | Characters not split at
Text    | text    | Text to split
[Limit] | integer | Limit at which to stop splitting

Examples
-------------------------------------------------------------------------------------------------------------
SPLIT_AROUND_CHARS("123456", "A12b34B56")
Returns: { "AbB"; ""; "12"; "34"; "56"}
----------------------------------------------------------------------------------------------------------*/
SPLIT_AROUND_CHARS = LAMBDA(Chars, Text, [Limit],
    IF((Chars = "") + (Text = ""), VSTACK("", NULLIFY(Text)),
        LET(
            _chars, MID(Chars, SEQUENCE(1, LEN(Chars)), 1),
            _limit, MAX(INT(N(Limit)), 0),
            _len, LEN(Text),
            _pos, VSTACK(
                REDUCE({0}, SEQUENCE(_len),
                    LAMBDA(_acc, _curr,
                        LET(
                            _isMatch, MAX(N(CODE(MID(Text, _curr, 1)) = CODE(_chars))),
                            IF(_isMatch, _acc,
                                VSTACK(_acc, _curr)
                            )
                        )
                    )
                )
            ),
            
            _count, IF(_limit, MIN(_limit, ROWS(_pos) - 1), ROWS(_pos) - 1),
            
            _limitPos, VSTACK(
                IFERROR(TAKE(_pos, _count + 1), 0),
                _len + 1
            ),
            _sift, CONCAT(IFERROR(MID(Text, DROP(_limitPos, 1), 1), "")),
            _idx, SEQUENCE(_count + 1),
            VSTACK(
               _sift,
               IFERROR(MID(Text, INDEX(_limitPos, _idx) + 1, INDEX(_limitPos, _idx + 1) - INDEX(_limitPos, _idx) - 1), Text)
            )
        )
    )
);

















/*###########################################################################################################
# TIMESPAN                                                                                                  #
###########################################################################################################*/


/*----------------------------------------------------------------------------------------------------------
IS_VALID_TIMESPAN

Tests if sexagesimal representation of a timespan is valid.
A component can exceed its modulus if no higher order component is provided.

Output
-------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
-------------------------------------------------------------------------------------------------------------
Sign      | integer [-1,0,1] |
Days      | decimal [0..]    | Fractional allowed if hours, minutes and seconds empty.
[Hours]   | decimal [0..24)  | Fractional allowed if minutes and seconds empty.
[Minutes] | decimal [0..60)  | Fractional allowed if seconds empty.
[Seconds] | decimal [0..60)  | Fractional allowed
----------------------------------------------------------------------------------------------------------*/
IS_VALID_TIMESPAN = LAMBDA(Sign, Days, [Hours], [Minutes], [Seconds],
    IFS(
        ISERROR(Sign), FALSE,
        NOT(ISNUMBER(Sign)), FALSE,
        Sign < -1, FALSE,
        Sign > 1, FALSE,
        NOT(IS_INTEGER(Sign)), FALSE,
        TRUE, LET(
            _high, IFS(
                ISNUMBER(Days), 1,
                ISNUMBER(Hours), 2,
                ISNUMBER(Minutes), 3,
                ISNUMBER(Seconds), 4,
                TRUE, 0
            ),
            IF(_high = 0, FALSE,
                LET(
                    _low, IFS(
                        ISNUMBER(Seconds), 4,
                        ISNUMBER(Minutes), 3,
                        ISNUMBER(Hours), 2,
                        ISNUMBER(Days), 1
                    ),
                    
                    fnInvalidElement, LAMBDA(_element, _max, _level, _zeroSign,
                        IFS(
                            ISERROR(_element), TRUE,
                            (_element = "") * (_high < _level) * (_low > _level), TRUE,
                            _element = "", FALSE,
                            NOT(ISNUMBER(_element)), TRUE,
                            (_low > _level) * NOT(IS_INTEGER(_element)), TRUE,
                            _element < 0, TRUE,
                            _zeroSign * (_element > 0), TRUE,
                            IF(_max = "", 0, (_high < _level) * (_element >= _max)), TRUE,
                            TRUE, FALSE
                        )
                    ),
                    
                    _zeroSign, Sign = 0,
                    IFS(
                        fnInvalidElement(Days, "", 1, _zeroSign), FALSE,
                        fnInvalidElement(Hours, 24, 2, _zeroSign), FALSE,
                        fnInvalidElement(Minutes, 60, 3, _zeroSign), FALSE,
                        fnInvalidElement(Seconds, 60, 4, _zeroSign), FALSE,
                        TRUE, TRUE
                    )
                )
            )
        )
    )    
);


/*----------------------------------------------------------------------------------------------------------
VALIDATE_TIMESPAN

Validate each element of a sexagesimal representation of a timespan.
A component can exceed its modulus if no higher order component is provided.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | decimal [0..]    | Days
 3 | decimal [0..24)  | Hours
 4 | decimal [0..60)  | Minutes
 5 | decimal [0..60)  | Seconds

Parameters
-------------------------------------------------------------------------------------------------------------
Sign      | integer [-1,0,1] |
Days      | decimal [0..]    | Fractional allowed if hours, minutes and seconds empty.
[Hours]   | decimal [0..24)  | Fractional allowed if minutes and seconds empty.
[Minutes] | decimal [0..60)  | Fractional allowed if seconds empty.
[Seconds] | decimal [0..60)  | Fractional allowed
----------------------------------------------------------------------------------------------------------*/
VALIDATE_TIMESPAN = LAMBDA(Sign, Days, [Hours], [Minutes], [Seconds],
    LET(
        _high, IFS(
            ISNUMBER(Days), 1,
            ISNUMBER(Hours), 2,
            ISNUMBER(Minutes), 3,
            ISNUMBER(Seconds), 4,
            TRUE, 0
        ),

        _low, IFS(
            ISNUMBER(Seconds), 4,
            ISNUMBER(Minutes), 3,
            ISNUMBER(Hours), 2,
            ISNUMBER(Days), 1,
            TRUE, 0
        ),
        
        fnCheckElement, LAMBDA(_element, _max, _level, _zeroSign,
            IFS(
                ISERROR(_element), _element,
                (_element = "") * (_high < _level) * (_low > _level), {#VALUE!},
                _element = "", "",
                NOT(ISNUMBER(_element)), {#VALUE!},
                (_low > _level) * NOT(IS_INTEGER(_element)), {#NUM!},
                _element < 0, {#NUM!},
                _zeroSign * (_element > 0), {#NUM!},
                IF(_max = "", 0, (_high < _level) * (_element >= _max)), {#NUM!},
                TRUE, _element
            )
        ),
        
        _sign, IFS(
            NOT(ISNUMBER(Sign)), {#VALUE!},
            Sign < -1, {#NUM!},
            Sign > 1, {#NUM!},
            NOT(IS_INTEGER(Sign)), {#NUM!},
            TRUE, Sign
        ),
        _zeroSign, IF(ISNUMBER(_sign), _sign = 0, FALSE),
        
        _days, fnCheckElement(Days, "", 1, _zeroSign),
        _hours, fnCheckElement(Hours, 24, 2, _zeroSign),
        _minutes, fnCheckElement(Minutes, 60, 3, _zeroSign),
        _seconds, fnCheckElement(Seconds, 60, 4, _zeroSign),
        IF(
            ISNUMBER(_sign) * IS_EMPTY(_days) * IS_EMPTY(_hours) * IS_EMPTY(_minutes) * IS_EMPTY(_seconds),
            HSTACK(_sign, {#VALUE!, #VALUE!, #VALUE!, #VALUE!}),
            HSTACK(_sign, _days, _hours, _minutes, _seconds)
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
TIMESPAN_LOW_ORDER

Returns a number representing the lowest order element of the sexagesimal representation of a timespan value.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer | Order, #N/A for zero
   |         |  1 - Day
   |         |  2 - Hour
   |         |  3 - Minute
   |         |  4 - Second

Parameters
-------------------------------------------------------------------------------------------------------------
Days      | decimal         | Decimal timespan when omitting hours, minutes and seconds
[Hours]   | integer [0..23] |
[Minutes] | integer [0..59] |
[Seconds] | decimal [0..60) |
----------------------------------------------------------------------------------------------------------*/
TIMESPAN_LOW_ORDER = LAMBDA(Days, [Hours], [Minutes], [Seconds],
    IFS(
        (Days = "") * (Hours = "") * (Minutes = "") * (Seconds = ""), "",
        ISNUMBER(Days) * IS_EMPTY(Hours) * IS_EMPTY(Minutes) * IS_EMPTY(Seconds), IFS(
            Days = 0, {#N/A},
            NOT(IS_INTEGER(Days * 1440)), 4,
            NOT(IS_INTEGER(Days * 24)), 3,
            NOT(IS_INTEGER(Days)), 2,
            ISNUMBER(Days), 1,
            TRUE, {#N/A}
        ),
        ISNUMBER(Hours) + ISNUMBER(Minutes) + ISNUMBER(Seconds), IFS(
            ABS(N(Seconds)) > 0, 4,
            ABS(N(Minutes)) > 0, 3,
            ABS(N(Hours)) > 0, 2,
            ABS(N(Days)) > 0, 1,
            TRUE, {#N/A}
        ),
        TRUE, {#VALUE!}
    )
);


/*----------------------------------------------------------------------------------------------------------
TIMESPAN_HIGH_ORDER

Returns a number representing the highest order component of the sexagesimal representation of a timespan value.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer | Order, #N/A for zero
   |         |  1 - Day
   |         |  2 - Hour
   |         |  3 - Minute
   |         |  4 - Second

Parameters
-------------------------------------------------------------------------------------------------------------
Days      | decimal         | Decimal timespan when omitting hours, minutes and seconds
[Hours]   | integer [0..23] |
[Minutes] | integer [0..59] |
[Seconds] | decimal [0..60) |
----------------------------------------------------------------------------------------------------------*/
TIMESPAN_HIGH_ORDER = LAMBDA(Days, [Hours], [Minutes], [Seconds],
    IFS(
        (Days = "") * (Hours = "") * (Minutes = "") * (Seconds = ""), "",
        ISNUMBER(Days) * IS_EMPTY(Hours) * IS_EMPTY(Minutes) * IS_EMPTY(Seconds), LET(
            _absTimeSpan, ABS(Days),
            IFS(
                _absTimeSpan = 0, {#N/A},
                _absTimeSpan >= 1, 1,
                _absTimeSpan * 24 >= 1, 2,
                _absTimeSpan * 1440 >= 1, 3,
                TRUE, 4
            )
        ),
        ISNUMBER(Days) + ISNUMBER(Hours) + ISNUMBER(Minutes) + ISNUMBER(Seconds), IFS(
            ABS(N(Days)) > 0, 1,
            ABS(N(Hours)) > 0, 2,
            ABS(N(Minutes)) > 0, 3,
            ABS(N(Seconds)) > 0, 4,
            TRUE, {#N/A}
        ),
        TRUE, {#VALUE!}
    )
);


/*----------------------------------------------------------------------------------------------------------
TIMESPAN

Returns a decimal timespan as a fraction of a day from a sexagesimal representation of time.
Note components exceeding their modulus will carry.

Output
-------------------------------------------------------------------------------------------------------------
 1 | decimal | Timespan as fraction of a day. Implicitly converts to Excel Date/Time type for non-negative
   |         | values.

Parameters
-------------------------------------------------------------------------------------------------------------
Sign      | integer [-1,0,1] |
Days      | decimal [0..]    |
[Hours]   | decimal [0..23]  |
[Minutes] | decimal [0..59]  |
[Seconds] | decimal [0..60)  |
----------------------------------------------------------------------------------------------------------*/
TIMESPAN = LAMBDA(Sign, Days, [Hours], [Minutes], [Seconds],
    IFS(
        IS_EMPTY(Days) * IS_EMPTY(Hours) * IS_EMPTY(Minutes) * IS_EMPTY(Seconds), "",
        ISERROR(Sign), Sign,
        ISERROR(Days), Days,
        ISERROR(Hours), Hours,
        ISERROR(Minutes), Minutes,
        ISERROR(Seconds), Seconds,
        NOT(IS_NUMERIC_NULL(Sign)), {#VALUE!},
        NOT(IS_NUMERIC_NULL(Days)), {#VALUE!},
        NOT(IS_NUMERIC_NULL(Hours)), {#VALUE!},
        NOT(IS_NUMERIC_NULL(Minutes)), {#VALUE!},
        NOT(IS_NUMERIC_NULL(Seconds)), {#VALUE!},
        TRUE, LET(
            _sign, IFS(
                Sign = 0, 0,
                Sign < 0, -1,
                TRUE, 1
            ),
            _sign * (N(Days) + (N(Hours) / 24) + (N(Minutes) / 1440) + (N(Seconds) / 86400))
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
ROUND_TIMESPAN

Returns a decimal timespan value rounded to the specified precision level.

Output
-------------------------------------------------------------------------------------------------------------
 1 | decimal | TimeSpan

Parameters
-------------------------------------------------------------------------------------------------------------
TimeSpan         | decimal | Decimal timespan where a day = 1
[PrecisionLevel] | integer | Select precision level
                 | [-3..9] | Null - Floating
                 |         |   -3 - Day
                 |         |   -2 - Hour
                 |         |   -1 - Minute
                 |         |    0 - Second
                 |         |    1 - Decisecond
                 |         |    2 - Centisecond
                 |         |    3 - Millisecond
                 |         |    ...
                 |         |    9 - Nanosecond
[Truncate]       | switch  | Round to precision by truncating components. Default is rounding to nearest.
----------------------------------------------------------------------------------------------------------*/
ROUND_TIMESPAN = LAMBDA(TimeSpan, [PrecisionLevel], [Truncate],
    IFS(
        TimeSpan = "", "",
        NOT(ISNUMBER(TimeSpan)), {#VALUE!},
        TimeSpan = 0, 0,
        TRUE, LET(
            _truncate, N(Truncate) <> 0,
            _precision, IFS(
                NOT(ISNUMBER(PrecisionLevel)), "",
                PrecisionLevel < -3, -3,
                PrecisionLevel > 9, 9,
                TRUE, INT(PrecisionLevel)
            ),
            IFS(
                _precision = "", TimeSpan,
                _truncate, IFS(
                    _precision = -3, ROUNDDOWN(TimeSpan, 0),
                    _precision = -2, ROUNDDOWN(TimeSpan * 24, 0) / 24,
                    _precision = -1, ROUNDDOWN(TimeSpan * 1440, 0) / 1440,
                    TRUE, ROUNDDOWN(TimeSpan * 86400, _precision) / 86400
                ),
                TRUE, IFS(
                    _precision = -3, ROUND(TimeSpan, 0),
                    _precision = -2, ROUND(TimeSpan * 24, 0) / 24,
                    _precision = -1, ROUND(TimeSpan * 1440, 0) / 1440,
                    TRUE, ROUND(TimeSpan * 86400, _precision) / 86400
                )
            )
        )
    )
);



/*----------------------------------------------------------------------------------------------------------
RESOLVE_TIMESPAN

Returns the sexagesimal representation of a timespan value expressed from the specified high order component
and the given lowest order component rounded to the specified precision.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Days
 3 | integer [0..23]  | Hours
 4 | integer [0..59]  | Minutes
 5 | decimal [0..60)  | Seconds

Parameters
-------------------------------------------------------------------------------------------------------------
TimeSpan      | decimal | Decimal timespan where a day = 1
[HighOrder]   | integer | Highest-order component. Defaults to Day.
              | [1..4]  |  1 - Day
              |         |  2 - Hour
              |         |  3 - Minute
              |         |  4 - Second
[LowOrder]    | integer | Lowest-order component. Defaults to Second.
              | [1..4]  |  1 - Day
              |         |  2 - Hour
              |         |  3 - Minute
              |         |  4 - Second
[Precision]   | integer | Select precision level
              | [0..9]  | Null - Floating
[Truncate]    | switch  | Round to precision by truncating components. Default is rounding to nearest.
----------------------------------------------------------------------------------------------------------*/
RESOLVE_TIMESPAN = LAMBDA(TimeSpan, [HighOrder], [LowOrder], [Precision], [Truncate],
    LET(
        _lowOrder, IFS(
            NOT(ISNUMBER(LowOrder)), 4,
            LowOrder < 1, 4,
            LowOrder > 4, 4,
            TRUE, INT(LowOrder)
        ),
        
        _highOrder, LET(
            _high, IFS(
                NOT(ISNUMBER(HighOrder)), 1,
                HighOrder < 1, 1,
                HighOrder > 4, 4,
                TRUE, INT(HighOrder)
            ),
            IF(_high > _lowOrder, _lowOrder, _high)
        ),
        
        IFS(
            TimeSpan = "", {"", "", "", "", ""},
            NOT(ISNUMBER(TimeSpan)), {#VALUE!, "", "", "", ""},
            TimeSpan = 0, CHOOSECOLS({0, 0, 0, 0, 0, "", "", ""}, SEQUENCE(1, 5, 5 - _lowOrder)), 
            TRUE, LET(
                _truncate, N(Truncate) <> 0,
                _absTimeSpan, ABS(TimeSpan),
                _sign, SIGN(TimeSpan),
                _precision, IFS(
                    Precision = "", "",
                    Precision < 0, 0,
                    Precision > 9, 9,
                    TRUE, INT(Precision)
                ),
                IFS(
                    _highOrder = 1, IFS(
                        _lowOrder = 4, LET(
                            _seconds, _absTimeSpan * 86400,
                            _minutes, INT(_seconds / 60),
                            _decSecond, _seconds - (_minutes * 60),
                            _hours, INT(_minutes / 60),
                            _rMinute, _minutes - (_hours * 60),
                            _rDay, INT(_hours / 24),
                            _rHour, _hours - (_rDay * 24),
                            // Round second last because arithmetic rounding of the timespan decimal value
                            // can bring in floating point errors.
                            // Sign checked for rounding down to zero.
                            // Second checked for rounding up to minute.
                            _rSecond, IFS(
                                _precision = "", _decSecond,
                                _truncate, ROUNDDOWN(_decSecond, _precision),
                                TRUE, ROUND(_decSecond, _precision)
                            ),
                            _rSign, IFS(
                                _rSecond > 0, _sign,
                                _rMinute > 0, _sign,
                                _rHour > 0, _sign,
                                _rDay > 0, _sign,
                                TRUE, 0
                            ),
                            IFS(
                                _rSecond < 60, HSTACK(_rSign, _rDay, _rHour, _rMinute, _rSecond),
                                _rMinute <= 58, HSTACK(_rSign, _rDay, _rHour, _rMinute + 1, 0),
                                _rHour <= 22, HSTACK(_rSign, _rDay, _rHour + 1, 0, 0),
                                TRUE, HSTACK(_rSign, _rDay + 1, 0, 0, 0)
                            )
                        ),
                    
                        _lowOrder = 3, LET(
                            _minutes, _absTimeSpan * 1440,
                            _hours, INT(_minutes / 60),
                            _decMinute, _minutes - (_hours * 60),
                            _rDay, INT(_hours / 24),
                            _rHour, _hours - (_rDay * 24),
                            // Round minute last because arithmetic rounding of the timespan decimal value
                            // can bring in floating point errors.
                            // Sign checked for rounding down to zero.
                            // Minute checked for rounding up to hour.
                            _rMinute, IFS(
                                _precision = "", _decMinute,
                                _truncate, ROUNDDOWN(_decMinute, _precision),
                                TRUE, ROUND(_decMinute, _precision)
                            ),
                            _rSign, IFS(
                                _rMinute > 0, _sign,
                                _rHour > 0, _sign,
                                _rDay > 0, _sign,
                                TRUE, 0
                            ),
                            IFS(
                                _rMinute < 60, HSTACK(_rSign, _rDay, _rHour, _rMinute, ""),
                                _rHour <= 22, HSTACK(_rSign, _rDay, _rHour + 1, 0, ""),
                                TRUE, HSTACK(_rSign, _rDay + 1, 0, 0, "")
                            )
                        ),
                        _lowOrder = 2, LET(
                            _hours, _absTimeSpan * 24,
                            _rDay, INT(_hours / 24),
                            _decHour, _hours - (_rDay * 24),
                            // Round hour last because arithmetic rounding of the timespan decimal value
                            // can bring in floating point errors.
                            // Sign checked for rounding down to zero.
                            // Hour checked for rounding up to day.
                            _rHour, IFS(
                                _precision = "", _decHour,
                                _truncate, ROUNDDOWN(_decHour, _precision),
                                TRUE, ROUND(_decHour, _precision)
                            ),
                            _rSign, IFS(
                                _rHour > 0, _sign,
                                _rDay > 0, _sign,
                                TRUE, 0
                            ),
                            IFS(
                                _rHour < 24, HSTACK(_rSign, _rDay, _rHour, "", ""),
                                TRUE, HSTACK(_rSign, _rDay + 1, 0, "", "")
                            )
                        ),
                        _lowOrder = 1, LET(
                            _decDay, _absTimeSpan,
                            _rDay, IFS(
                                _precision = "", _decDay,
                                _truncate, ROUNDDOWN(_decDay, _precision),
                                TRUE, ROUND(_decDay, _precision)
                            ),
                            _rSign, IFS(
                                _rDay > 0, _sign,
                                TRUE, 0
                            ),
                            HSTACK(_rSign, _rDay, "", "", "")
                        )
                    ),

                    _highOrder = 2, IFS(
                        _lowOrder = 4, LET(
                            _seconds, _absTimeSpan * 86400,
                            _minutes, INT(_seconds / 60),
                            _decSecond, _seconds - (_minutes * 60),
                            _rHour, INT(_minutes / 60),
                            _rMinute, _minutes - (_rHour * 60),
                            // Round second last because arithmetic rounding of the timespan decimal value
                            // can bring in floating point errors.
                            // Sign checked for rounding down to zero.
                            // Second checked for rounding up to minute.
                            _rSecond, IFS(
                                _precision = "", _decSecond,
                                _truncate, ROUNDDOWN(_decSecond, _precision),
                                TRUE, ROUND(_decSecond, _precision)
                            ),
                            _rSign, IFS(
                                _rSecond > 0, _sign,
                                _rMinute > 0, _sign,
                                _rHour > 0, _sign,
                                TRUE, 0
                            ),
                            IFS(
                                _rSecond < 60, HSTACK(_rSign, "", _rHour, _rMinute, _rSecond),
                                _rMinute <= 58, HSTACK(_rSign, "", _rHour, _rMinute + 1, 0),
                                TRUE, HSTACK(_rSign, "", _rHour + 1, 0, 0)
                            )
                        ),
                    
                        _lowOrder = 3, LET(
                            _minutes, _absTimeSpan * 1440,
                            _rHour, INT(_minutes / 60),
                            _decMinute, _minutes - (_rHour * 60),
                            // Round minute last because arithmetic rounding of the timespan decimal value
                            // can bring in floating point errors.
                            // Sign checked for rounding down to zero.
                            // Minute checked for rounding up to hour.
                            _rMinute, IFS(
                                _precision = "", _decMinute,
                                _truncate, ROUNDDOWN(_decMinute, _precision),
                                TRUE, ROUND(_decMinute, _precision)
                            ),
                            _rSign, IFS(
                                _rMinute > 0, _sign,
                                _rHour > 0, _sign,
                                TRUE, 0
                            ),
                            IF(_rMinute < 60,
                                HSTACK(_rSign, "", _rHour, _rMinute, ""),
                                HSTACK(_rSign, "", _rHour + 1, 0, "")
                            )
                        ),
                        _lowOrder = 2, LET(
                            _decHour, _absTimeSpan * 24,
                            // Round hour last because arithmetic rounding of the timespan decimal value
                            // can bring in floating point errors.
                            // Sign checked for rounding down to zero.
                            // Hour checked for rounding up to day.
                            _rHour, IFS(
                                _precision = "", _decHour,
                                _truncate, ROUNDDOWN(_decHour, _precision),
                                TRUE, ROUND(_decHour, _precision)
                            ),
                            _rSign, IF(_rHour > 0,
                                _sign,
                                0
                            ),
                            HSTACK(_rSign, "", _rHour, "", "")
                        )
                    ),

                    _highOrder = 3, IFS(
                        _lowOrder = 4, LET(
                            _seconds, _absTimeSpan * 86400,
                            _rMinute, INT(_seconds / 60),
                            _decSecond, _seconds - (_rMinute * 60),
                            // Round second last because arithmetic rounding of the timespan decimal value
                            // can bring in floating point errors.
                            // Sign checked for rounding down to zero.
                            // Second checked for rounding up to minute.
                            _rSecond, IFS(
                                _precision = "", _decSecond,
                                _truncate, ROUNDDOWN(_decSecond, _precision),
                                TRUE, ROUND(_decSecond, _precision)
                            ),
                            _rSign, IFS(
                                _rSecond > 0, _sign,
                                _rMinute > 0, _sign,
                                TRUE, 0
                            ),
                            IF(_rSecond < 60,
                                HSTACK(_rSign, "", "", _rMinute, _rSecond),
                                HSTACK(_rSign, "", "", _rMinute + 1, 0)
                            )
                        ),
                    
                        _lowOrder = 3, LET(
                            _minutes, _absTimeSpan * 1440,
                            _rHour, INT(_minutes / 60),
                            _decMinute, _minutes - (_rHour * 60),
                            // Round minute last because arithmetic rounding of the timespan decimal value
                            // can bring in floating point errors.
                            // Sign checked for rounding down to zero.
                            // Minute checked for rounding up to hour.
                            _rMinute, IFS(
                                _precision = "", _decMinute,
                                _truncate, ROUNDDOWN(_decMinute, _precision),
                                TRUE, ROUND(_decMinute, _precision)
                            ),
                            _rSign, IFS(
                                _rMinute > 0, _sign,
                                _rHour > 0, _sign,
                                TRUE, 0
                            ),
                            IF(_rMinute < 60,
                                HSTACK(_rSign, "", _rHour, _rMinute, ""),
                                HSTACK(_rSign, "", _rHour + 1, 0, "")
                            )
                        )
                    ),

                    _highOrder = 4, IFS(
                        _lowOrder = 4, LET(
                            _decSecond, _absTimeSpan * 86400,
                            // Round second last because arithmetic rounding of the timespan decimal value
                            // can bring in floating point errors.
                            // Sign checked for rounding down to zero.
                            // Second checked for rounding up to minute.
                            _rSecond, IFS(
                                _precision = "", _decSecond,
                                _truncate, ROUNDDOWN(_decSecond, _precision),
                                TRUE, ROUND(_decSecond, _precision)
                            ),
                            _rSign, IF(_rSecond > 0,
                                _sign,
                                0
                            ),
                            HSTACK(_rSign, "", "", "", _rSecond)
                        )
                    )
                )                    
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
PARSE_TIMESPAN

Parses a text timespan expression into sexagesimal components.

Output
-------------------------------------------------------------------------------------------------------------
 1 | decimal [0..1] | Time of day as decimal fraction of a day.

Output when AsComplication switch set
-------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Days
 3 | integer [0..23]  | Hours
 4 | integer [0..59]  | Minutes
 5 | decimal [0..60)  | Seconds

Parameters
-------------------------------------------------------------------------------------------------------------
TimeSpanText     | text   | Formatted TimeSpan
[AsComplication] | switch | Output component parts

Examples
-------------------------------------------------------------------------------------------------------------
PARSE_TIMESPAN("12:00")
Returns: 0.5

PARSE_TIMESPAN("24:00:01")
Returns: #NUM!  i.e. range is 0 to 24 hours 
----------------------------------------------------------------------------------------------------------*/
PARSE_TIMESPAN = LAMBDA(TimeSpanText, [AsComplication],
    LET(
        _asValue, N(AsComplication) = 0,
        IFS(
            TimeSpanText = "", IF(_asValue, "", {"", "", "", "", ""}),
            _asValue * ISNUMBER(TimeSpanText), TimeSpanText, 
            TRUE, LET(
                fnParseModernFmt, LAMBDA(_text,
                    LET(
                        _split, SPLIT_AROUND_CHARS("0123456789", _text),
                        _pattern, INDEX(_split, 1),
                        IFS(
                            // d.hh:mm:ss.000
                            _pattern = ".::.", LET(
                                _decimals, MIN(LEN(INDEX(_split, 6)), 9),
                                HSTACK(
                                    VALUE(INDEX(_split, 2)),
                                    VALUE(INDEX(_split, 3)),
                                    VALUE(INDEX(_split, 4)),
                                    VALUE(INDEX(_split, 5)) + (VALUE(LEFT(INDEX(_split, 6), _decimals)) / (10 ^ _decimals))
                                )
                            ),
                            // d.hh:mm:ss
                            _pattern = ".::", HSTACK(
                                VALUE(INDEX(_split, 2)),
                                VALUE(INDEX(_split, 3)),
                                VALUE(INDEX(_split, 4)),
                                VALUE(INDEX(_split, 5))
                            ),
                            // d.hh:mm
                            _pattern = ".:", HSTACK(
                                VALUE(INDEX(_split, 2)),
                                VALUE(INDEX(_split, 3)),
                                VALUE(INDEX(_split, 4)),
                                ""
                            ),
                            // h:mm:ss.000
                            _pattern = "::.", LET(
                                _decimals, MIN(LEN(INDEX(_split, 5)), 9),
                                HSTACK(
                                    "",
                                    VALUE(INDEX(_split, 2)),
                                    VALUE(INDEX(_split, 3)),
                                    VALUE(INDEX(_split, 4)) + (VALUE(LEFT(INDEX(_split, 5), _decimals)) / (10 ^ _decimals))
                                )
                            ),
                            // h:mm:ss
                            _pattern = "::", HSTACK(
                                "",
                                VALUE(INDEX(_split, 2)),
                                VALUE(INDEX(_split, 3)),
                                VALUE(INDEX(_split, 4))
                            ),
                            // m:ss.000
                            _pattern = ":.", LET(
                                _decimals, MIN(LEN(INDEX(_split, 4)), 9),
                                HSTACK(
                                    "",
                                    "",
                                    VALUE(INDEX(_split, 2)),
                                    VALUE(INDEX(_split, 3)) + (VALUE(LEFT(INDEX(_split, 4), _decimals)) / (10 ^ _decimals))
                                )
                            ),
                            // h:mm
                            _pattern = ":", HSTACK(
                                "",
                                VALUE(INDEX(_split, 2)),
                                VALUE(INDEX(_split, 3)),
                                ""
                            ),
                            // d.000
                            _pattern = ".", LET(
                                _decimals, MIN(LEN(INDEX(_split, 3)), 9),
                                HSTACK(
                                    VALUE(INDEX(_split, 2)) + (VALUE(LEFT(INDEX(_split, 3), _decimals)) / (10 ^ _decimals)),
                                    "",
                                    "",
                                    ""
                                )
                            ),
                            TRUE, {#VALUE!}
                        )
                    )
                ),

                fnParseTraditionalFmt, LAMBDA(_text,
                    LET(
                        _text1, SUBSTITUTE(_text, " ", ""),
                        _split, SPLIT_AROUND_CHARS("0123456789", _text1),
                        _pattern, INDEX(_split, 1),
                        IFS(
                            // 0d00h00'00.000"
                            _pattern = "dh'.""", LET(
                                _decimals, MIN(LEN(INDEX(_split, 6)), 9),
                                HSTACK(
                                    VALUE(INDEX(_split, 2)),
                                    VALUE(INDEX(_split, 3)),
                                    VALUE(INDEX(_split, 4)),
                                    VALUE(INDEX(_split, 5)) + (VALUE(LEFT(INDEX(_split, 6), _decimals)) / (10 ^ _decimals))
                                )
                            ),
                            // 0d00h00'00"
                            _pattern = "dh'""", HSTACK(
                                VALUE(INDEX(_split, 2)),
                                VALUE(INDEX(_split, 3)),
                                VALUE(INDEX(_split, 4)),
                                VALUE(INDEX(_split, 5))
                            ),
                            // 0d00h00.000'
                            _pattern = "dh.'", LET(
                                _decimals, MIN(LEN(INDEX(_split, 5)), 9),
                                HSTACK(
                                    VALUE(INDEX(_split, 2)),
                                    VALUE(INDEX(_split, 3)),
                                    VALUE(INDEX(_split, 4)) + (VALUE(LEFT(INDEX(_split, 5), _decimals)) / (10 ^ _decimals)),
                                    ""
                                )
                            ),
                            // 0d00h00'
                            _pattern = "dh'", HSTACK(
                                VALUE(INDEX(_split, 2)),
                                VALUE(INDEX(_split, 3)),
                                VALUE(INDEX(_split, 4)),
                                ""
                            ),
                            // 0d00.000h
                            _pattern = "d.h", LET(
                                _decimals, MIN(LEN(INDEX(_split, 4)), 9),
                                HSTACK(
                                    VALUE(INDEX(_split, 2)),
                                    VALUE(INDEX(_split, 3)) + (VALUE(LEFT(INDEX(_split, 4), _decimals)) / (10 ^ _decimals)),
                                    "",
                                    ""
                                )
                            ),
                            // 0d00h
                            _pattern = "dh", HSTACK(
                                VALUE(INDEX(_split, 2)),
                                VALUE(INDEX(_split, 3)),
                                "",
                                ""
                            ),
                            // 0.000d
                            _pattern = ".d", LET(
                                _decimals, MIN(LEN(INDEX(_split, 3)), 9),
                                HSTACK(
                                    VALUE(INDEX(_split, 2)) + (VALUE(LEFT(INDEX(_split, 3), _decimals)) / (10 ^ _decimals)),
                                    "",
                                    "",
                                    ""
                                )
                            ),
                            // 0d
                            _pattern = "d", HSTACK(
                                VALUE(INDEX(_split, 2)),
                                "",
                                "",
                                ""
                            ),
                            // 0h00'00.000"
                            _pattern = "h'.""", LET(
                                _decimals, MIN(LEN(INDEX(_split, 5)), 9),
                                HSTACK(
                                    "",
                                    VALUE(INDEX(_split, 2)),
                                    VALUE(INDEX(_split, 3)),
                                    VALUE(INDEX(_split, 4)) + (VALUE(LEFT(INDEX(_split, 5), _decimals)) / (10 ^ _decimals))
                                )
                            ),
                            // 0h00'00"
                            _pattern = "h'""", HSTACK(
                                "",
                                VALUE(INDEX(_split, 2)),
                                VALUE(INDEX(_split, 3)),
                                VALUE(INDEX(_split, 4))
                            ),
                            // 0h00.000'
                            _pattern = "h.'", LET(
                                _decimals, MIN(LEN(INDEX(_split, 4)), 9),
                                HSTACK(
                                    "",
                                    VALUE(INDEX(_split, 2)),
                                    VALUE(INDEX(_split, 3)) + (VALUE(LEFT(INDEX(_split, 4), _decimals)) / (10 ^ _decimals)),
                                    ""
                                )
                            ),
                            // 0h00'
                            _pattern = "h'", HSTACK(
                                "",
                                VALUE(INDEX(_split, 2)),
                                VALUE(INDEX(_split, 3)),
                                ""
                            ),
                            // 0.000h
                            _pattern = ".h", LET(
                                _decimals, MIN(LEN(INDEX(_split, 3)), 9),
                                HSTACK(
                                    "",
                                    VALUE(INDEX(_split, 2)) + (VALUE(LEFT(INDEX(_split, 3), _decimals)) / (10 ^ _decimals)),
                                    "",
                                    ""
                                )
                            ),
                            // 0h
                            _pattern = "h", HSTACK(
                                "",
                                VALUE(INDEX(_split, 2)),
                                "",
                                ""
                            ),
                            // 0'00.000"
                            _pattern = "'.""", LET(
                                _decimals, MIN(LEN(INDEX(_split, 4)), 9),
                                HSTACK(
                                    "",
                                    "", 
                                    VALUE(INDEX(_split, 2)),
                                    VALUE(INDEX(_split, 3)) + (VALUE(LEFT(INDEX(_split, 4), _decimals)) / (10 ^ _decimals))
                                )
                            ),
                            // 0'00"
                            _pattern = "'""", HSTACK(
                                "",
                                "", 
                                VALUE(INDEX(_split, 2)),
                                VALUE(INDEX(_split, 3))
                            ),
                            // 0.000'
                            _pattern = ".'", LET(
                                _decimals, MIN(LEN(INDEX(_split, 3)), 9),
                                HSTACK(
                                    "",
                                    "",
                                    VALUE(INDEX(_split, 2)) + (VALUE(LEFT(INDEX(_split, 3), _decimals)) / (10 ^ _decimals)),
                                    ""
                                )
                            ),
                            // 0'
                            _pattern = "'", HSTACK(
                                "",
                                "",
                                VALUE(INDEX(_split, 2)),
                                ""
                            ),
                            // 0.000"
                            _pattern = ".""", LET(
                                _decimals, MIN(LEN(INDEX(_split, 3)), 9),
                                HSTACK(
                                    "",
                                    "",
                                    "",
                                    VALUE(INDEX(_split, 2)) + (VALUE(LEFT(INDEX(_split, 3), _decimals)) / (10 ^ _decimals))
                                )
                            ),
                            // 0"
                            _pattern = """", HSTACK(
                                "",
                                "",
                                "",
                                VALUE(INDEX(_split, 2))
                            ),
                            // 0.000
                            _pattern = ".", LET(
                                _decimals, MIN(LEN(INDEX(_split, 3)), 9),
                                HSTACK(
                                    VALUE(INDEX(_split, 2)) + (VALUE(LEFT(INDEX(_split, 3), _decimals)) / (10 ^ _decimals)),
                                    "",
                                    "",
                                    ""
                                )
                            ),
                            // 0
                            _pattern = "", HSTACK(
                                VALUE(INDEX(_split, 2)),
                                "",
                                "",
                                ""
                            ),
                            TRUE, {#VALUE!}
                        )
                    )
                ),

                _complication, IF(ISNUMBER(TimeSpanText), RESOLVE_TIMESPAN(TimeSpanText),
                    LET(
                        _isModernFmt, IFERROR(FIND(":", TimeSpanText), 0) > 0,
                        _timeSpanText, IF(_isModernFmt, TimeSpanText, SUBSTITUTE(TimeSpanText, " ", "")),
                        _firstChar, LEFT(_timeSpanText, 1),
                        _hasSign, IFS(
                            _firstChar = "+", TRUE,
                            _firstChar = "-", TRUE,
                            _firstChar = UNICHAR(8722), TRUE,
                            TRUE, FALSE
                        ),
                        _nominalSign, IFS(
                            _firstChar = "-", -1,
                            _firstChar = UNICHAR(8722), -1,
                            TRUE, 1
                        ),
                        _uTimeSpan, IF(_hasSign, MID(_timeSpanText, 2, LEN(_timeSpanText) - 1), _timeSpanText),
                        
                        _tryParse, IF(_isModernFmt,
                            fnParseModernFmt(_uTimeSpan),
                            fnParseTraditionalFmt(_uTimeSpan)
                        ),
                        IF(ISERROR(INDEX(_tryParse, 1, 1)), {#VALUE!, "", "", "", ""},
                            LET(
                                _sign, IFS(
                                    INDEX(_tryParse, 1, 1) > 0, _nominalSign,
                                    INDEX(_tryParse, 1, 2) > 0, _nominalSign,
                                    INDEX(_tryParse, 1, 3) > 0, _nominalSign,
                                    INDEX(_tryParse, 1, 4) > 0, _nominalSign,
                                    TRUE, 0
                                ),
                                VALIDATE_TIMESPAN(
                                    _sign,
                                    INDEX(_tryParse, 1, 1),
                                    INDEX(_tryParse, 1, 2),
                                    INDEX(_tryParse, 1, 3),
                                    INDEX(_tryParse, 1, 4)
                                )
                            )
                        )
                    )
                ),

                IF(_asValue,
                    TIMESPAN(
                        INDEX(_complication, 1, 1),
                        INDEX(_complication, 1, 2),
                        INDEX(_complication, 1, 3),
                        INDEX(_complication, 1, 4),
                        INDEX(_complication, 1, 5)
                    ),
                    _complication
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
FORMAT_TIMESPAN

Returns a timespan as text in the specified format from a given decimal timespan.

Output
-------------------------------------------------------------------------------------------------------------
 1 | text    | Formatted timespan d.HH:mm:ss.000

Parameters
-------------------------------------------------------------------------------------------------------------
TimeSpan       | decimal | Decimal timespan where a day = 1
[Options]      | text    | String with elements: [+][T][P][_][<][~][HighOrder][LowOrder][Precision]
               |         |         + : Display positive sign for non-negative values
               |         |         T : Traditional Style. Modern style when not present
               |         |         P : Pad leading values with zero.
               |         |         _ : Insert spacing. Applicable to traditional style only.
               |         |         < : Round by truncating components. Default is rounding to nearest.
               |         |         ~ : Floating display of components. For modern style only has an effect when
               |         |           : low order item is seconds, by allowing floating display of decimal seconds.
               |         |           : For traditional style, floats from high order to low order.
               |         | HighOrder : high order component
               |         | LowOrder  : low order component
               |         | HighOrder and LowOrder elements take the following:
               |         |         D : Day
               |         |         H : Hour
               |         |         M : Minute
               |         |         S : Second
               |         | Precision : [0-9] For modern style only has an effect when low order component is seconds.
               |         |           : For traditional style, decimals can be expressed on any low order component 
Examples
-------------------------------------------------------------------------------------------------------------
FORMAT_TIMESPAN(1.7865, "")
Returns: 1.18:52:34

FORMAT_TIMESPAN(1.7865, "HS3")
Returns: 42:52:33.600

FORMAT_TIMESPAN(1.7865, "T+_HS")
Returns: + 42h 52' 34"
----------------------------------------------------------------------------------------------------------*/
FORMAT_TIMESPAN = LAMBDA(TimeSpan, [Options],
    IFS(
        IS_EMPTY(TimeSpan), "",
        NOT(ISNUMBER(TimeSpan)), {#VALUE!},
        TRUE, LET(
            _modernStyle, IFERROR(SEARCH("T", Options), 0) = 0,
            _signPositive, IFERROR(FIND("+", Options), 0) > 0,
            _fixed, IFERROR(FIND("~", Options), 0) = 0,
            _padding, IFERROR(SEARCH("P", Options), 0) > 0,
            _spacing, IFERROR(FIND("_", Options), 0) > 0,
            _truncate, IFERROR(FIND("<", Options), 0) > 0,
                    
            _tryHighOrderChar, SEARCH_NTH_CHAR("DHMS", Options, 1, 1),
            _passedHighOrder, IFS(
                INDEX(_tryHighOrderChar, 1, 1) = 0, "",
                INDEX(_tryHighOrderChar, 1, 2) = "D", 1,
                INDEX(_tryHighOrderChar, 1, 2) = "H", 2,
                INDEX(_tryHighOrderChar, 1, 2) = "M", 3,
                INDEX(_tryHighOrderChar, 1, 2) = "S", 4
            ),

            _tryLowOrderChar, SEARCH_NTH_CHAR("DHMS", Options, 1, 1, INDEX(_tryHighOrderChar, 1, 1) + 1),
            _passedLowOrder, IFS(
                INDEX(_tryLowOrderChar, 1, 1) = 0, "",
                INDEX(_tryLowOrderChar, 1, 2) = "D", 1,
                INDEX(_tryLowOrderChar, 1, 2) = "H", 2,
                INDEX(_tryLowOrderChar, 1, 2) = "M", 3,
                INDEX(_tryLowOrderChar, 1, 2) = "S", 4
            ),
                                
            // switch if needed
            _lowOrder, IFS(
                ISNUMBER(_passedLowOrder) * ISNUMBER(_passedHighOrder),
                    MAX(_passedHighOrder, _passedLowOrder),
                ISNUMBER(_passedLowOrder) * NOT(ISNUMBER(_passedHighOrder)),
                    IF(_passedLowOrder <= 2, "", _passedLowOrder),
                NOT(ISNUMBER(_passedLowOrder)) * ISNUMBER(_passedHighOrder),
                    IF(_passedHighOrder >= 3, _passedHighOrder, ""),
                TRUE, ""
            ),
                    
            _highOrder, IFS(
                ISNUMBER(_passedLowOrder) * ISNUMBER(_passedHighOrder),
                    MIN(_passedHighOrder, _passedLowOrder),
                ISNUMBER(_passedLowOrder) * NOT(ISNUMBER(_passedHighOrder)),
                    IF(_passedLowOrder <= 2, _passedLowOrder, ""),
                NOT(ISNUMBER(_passedLowOrder)) * ISNUMBER(_passedHighOrder),
                    IF(_passedHighOrder >= 3, "", _passedHighOrder),
                TRUE, ""
            ),
                
            // precision (max 9 decimals for nanoseconds)
            _tryPrecision, SEARCH_NTH_CHAR("0123456789", Options, 1, 1),
            _precision, IF(INDEX(_tryPrecision, 1, 1) = 0, "", VALUE(INDEX(_tryPrecision, 1, 2))),
            
            _provider, IF(_modernStyle,
                _FORMAT_PROVIDER_TIMESPAN_MODERN(TimeSpan, _signPositive, _fixed, _padding, _precision, _truncate, _highOrder, _lowOrder),
                _FORMAT_PROVIDER_TIMESPAN_TRADITIONAL(TimeSpan, _signPositive, _fixed, _padding, _spacing, _precision, _truncate, _highOrder, _lowOrder)
            ),

            _count, INDEX(_provider, 1, 2) - INDEX(_provider, 1, 1) + 1,
            IF(_count < 1, "",
                LET(
                    _designator, IF(INDEX(_provider, 2, 1) = "", "",
                        INDEX(_provider, 2, 1) & IF(INDEX(_provider, 1, 6), " ", "")
                    ),
                    _parts, MAP(SEQUENCE(1, _count),
                        LAMBDA(_n,
                            LET(
                                _fmt, IFS(
                                    _n = _count, INDEX(_provider, 1, 5),
                                    _n = 1, INDEX(_provider, 1, 3),
                                    TRUE, INDEX(_provider, 1, 4)
                                ),
                                _col, INDEX(_provider, 1, 1) + _n,
                                _part, TEXT(INDEX(_provider, 3, _col), _fmt),
                                _delim, INDEX(_provider, 2, _col),
                                _spc, IF(INDEX(_provider, 1, 6) * (_n < _count), " ", ""),
                                _part & _delim & _spc
                            )
                        )
                    ),
                    CONCAT(_designator, _parts)
                )
            )
        )
    )
);

_FORMAT_PROVIDER_TIMESPAN_MODERN = LAMBDA(TimeSpan, SignPositive, Fixed, Padding, Precision, Truncate, HighOrder, LowOrder,
    LET(
        _setHighOrder, ISNUMBER(HighOrder),
        _setLowOrder, ISNUMBER(LowOrder),
        _setPrecision, ISNUMBER(Precision),

        _resolveHighOrder, IFS(
            // modern style high order can only be days or hours
            _setHighOrder * (HighOrder > 2), 2,
            _setHighOrder, HighOrder,
            // default to days
            TRUE, 1
        ),

        _resolveLowOrder, IFS(
            // modern style low order can only be minutes or seconds
            _setLowOrder * (LowOrder < 3), 3,
            _setLowOrder, LowOrder,
            // default to seconds
            TRUE, 4
        ),
        
        _resolvePrecision, IFS(
            // modern style only seconds can have decimals
            _resolveLowOrder < 4, 0,
            _setPrecision, Precision,
            // default to 0 for fixed
            Fixed, 0,
            // default to 9 for floating
            TRUE, 9
        ),
        
        _resolveTimeSpan, RESOLVE_TIMESPAN(TimeSpan, _resolveHighOrder, _resolveLowOrder, _resolvePrecision, Truncate),
        
        _showHighOrder, IF(Fixed, _resolveHighOrder,
            LET(
                // floating
                _hasHighOrder, IFERROR(
                    TIMESPAN_HIGH_ORDER(
                        INDEX(_resolveTimeSpan, 1, 2),
                        INDEX(_resolveTimeSpan, 1, 3),
                        INDEX(_resolveTimeSpan, 1, 4),
                        INDEX(_resolveTimeSpan, 1, 5)
                    ), 2
                ),
                // effectively high order can be days or hours
                MIN(2, MAX(_resolveHighOrder, _hasHighOrder))
            )
        ),
        
        _showLowOrder, IF(Fixed, _resolveLowOrder,
            LET(
                // floating
                _hasLowOrder, IFERROR(
                    TIMESPAN_LOW_ORDER(
                        INDEX(_resolveTimeSpan, 1, 2),
                        INDEX(_resolveTimeSpan, 1, 3),
                        INDEX(_resolveTimeSpan, 1, 4),
                        INDEX(_resolveTimeSpan, 1, 5)
                    ), 3
                ),
                // effectively low order can be minutes or seconds
                MAX(3, MIN(_resolveLowOrder, _hasLowOrder))
            )
        ),
        
        _showPrecision, IFS(
            // if fixed then use resolved precision
            Fixed, _resolvePrecision,
            // floating without seconds
            _showLowOrder < 4, 0,
            // if floating then use lowest
            TRUE, MIN(_resolvePrecision, DECIMALS(INDEX(_resolveTimeSpan, 1, 5)))
        ),
        
        _leadFmt, IF(Padding, "00", "0"),
        _midFmt, "00",
        _lastFmt, IF(_showPrecision = 0, _midFmt,
            _midFmt & LEFT(".000000000", _showPrecision + 1)
        ),
        
        _designator, IFS(
            INDEX(_resolveTimeSpan, 1, 1) < 0, UNICHAR(8722),
            SignPositive, "+",
            TRUE, ""
        ),

        _delims, IF(_showLowOrder = 4,
            {".", ":", ":", ""},
            {".", ":", "", ""}
        ),
        
        VSTACK(
            HSTACK(_showHighOrder, _showLowOrder, _leadFmt, _midFmt, _lastFmt, FALSE),
            HSTACK(_designator, _delims),
            _resolveTimeSpan
        )
    )
);

_FORMAT_PROVIDER_TIMESPAN_TRADITIONAL = LAMBDA(TimeSpan, SignPositive, Fixed, Padding, Spacing, Precision, Truncate, HighOrder, LowOrder,
    LET(
        _setHighOrder, ISNUMBER(HighOrder),
        _setLowOrder, ISNUMBER(LowOrder),
        _setPrecision, ISNUMBER(Precision),

        // default high order to days
        _resolveHighOrder, IF(_setHighOrder, HighOrder, 1),
        
        // default low order to seconds 
        _resolveLowOrder, IF(_setLowOrder, LowOrder, 4),
        
        // default precision to 9
        _resolvePrecision, IFS(
            _setPrecision, Precision,
            // default to 0 for fixed
            Fixed, 0,
            // default to 9 for floating
            TRUE, 9
        ),

        _resolveTimeSpan, RESOLVE_TIMESPAN(TimeSpan, _resolveHighOrder, _resolveLowOrder, _resolvePrecision, Truncate),

        _showLowOrder, IF(Fixed, _resolveLowOrder,
            LET(
                // floating
                _hasLowOrder, IFERROR(
                    TIMESPAN_LOW_ORDER(
                        INDEX(_resolveTimeSpan, 1, 2),
                        INDEX(_resolveTimeSpan, 1, 3),
                        INDEX(_resolveTimeSpan, 1, 4),
                        INDEX(_resolveTimeSpan, 1, 5)
                    ), 4
                ),
                MIN(_resolveLowOrder, _hasLowOrder)
            )
        ),

        _showHighOrder, IF(Fixed, _resolveHighOrder,
            LET(
                // floating
                _hasHighOrder, IFERROR(
                    TIMESPAN_HIGH_ORDER(
                        INDEX(_resolveTimeSpan, 1, 2),
                        INDEX(_resolveTimeSpan, 1, 3),
                        INDEX(_resolveTimeSpan, 1, 4),
                        INDEX(_resolveTimeSpan, 1, 5)
                    ), _showLowOrder
                ),
                MAX(_resolveHighOrder, _hasHighOrder)
            )
        ),
        
        _showPrecision, IF(Fixed,
            // if fixed then use resolved precision
            _resolvePrecision,
            // if floating then use lowest
            MIN(_resolvePrecision, DECIMALS(INDEX(_resolveTimeSpan, 1, _showLowOrder + 1)))
        ),

        _leadFmt, IF(Padding, "00", "0"),
        _midFmt, _leadFmt,
        _lastFmt, IF(_showPrecision = 0, _midFmt,
            _midFmt & LEFT(".000000000", _showPrecision + 1)
        ),
        
        _designator, IFS(
            INDEX(_resolveTimeSpan, 1, 1) < 0, UNICHAR(8722),
            SignPositive, "+",
            TRUE, ""
        ),

        _delims, {"d", "h", "'", """"},
        
        VSTACK(
            HSTACK(_showHighOrder, _showLowOrder, _leadFmt, _midFmt, _lastFmt, Spacing),
            HSTACK(_designator, _delims),
            _resolveTimeSpan
        )
    )
);

















/*###########################################################################################################
# CALENDAR DATES                                                                                            #
###########################################################################################################*/


/*----------------------------------------------------------------------------------------------------------
YEAR_COMMON_ERA

Returns year value relative to the Common Era.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer | 1 CE = 1, 1 BCE = 0, 2 BCE = -1

Parameters
-------------------------------------------------------------------------------------------------------------
Year  | integer [1..] | Positive non-zero integer.
BCE   | switch        | Before Common Era.
----------------------------------------------------------------------------------------------------------*/
YEAR_COMMON_ERA = LAMBDA(Year, BCE,
    IFS(
        Year = "", "",
        NOT(ISNUMBER(Year)), {#VALUE!},
        TRUE, LET(
            _year, INT(Year),
            IF(_year < 1, {#NUM!},
                IF(N(BCE), 1 - _year, _year)
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
PARSE_MONTH

Returns a number representing the month of year from a given text month name.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer [1..12] | Month

Parameters
-------------------------------------------------------------------------------------------------------------
MonthText | text | Month name

Examples
-------------------------------------------------------------------------------------------------------------
PARSE_MONTH("Feb")
Returns: 2

PARSE_MONTH("January")
Returns: 1

PARSE_MONTH("J")
Returns: #VALUE!

PARSE_MONTH("Marzo")
Returns: 3 (if local language is set to Italian)
----------------------------------------------------------------------------------------------------------*/
PARSE_MONTH = LAMBDA(MonthText,
    IF(MonthText = "", "",
        MONTH(DATEVALUE(MonthText & " 2000"))
    )
);


/*----------------------------------------------------------------------------------------------------------
MONTH_NAME

Returns a month as text.

Output
-------------------------------------------------------------------------------------------------------------
 1 | text | Month name

Parameters
-------------------------------------------------------------------------------------------------------------
Month                  | integer [1..12] | Month
[Short]                | switch          | Return short format Jan..Dec
[InternationalEnglish] | switch          | International English instead of local language set in Excel
----------------------------------------------------------------------------------------------------------*/
MONTH_NAME = LAMBDA(Month, [Short], [InternationalEnglish],
    IFS(
        Month = "", "",
        NOT(ISNUMBER(Month)), #VALUE!,
        TRUE, LET(
            _useShort, N(Short) <> 0,
            _useLocalLang, N(InternationalEnglish) = 0,
            _month, INT(Month),
            IF(_useLocalLang,
                LET(
                    _dayOfMonth, DATE(2000, _month, 1),
                    _fmt, IF(_useShort, "MMM", "MMMM"),
                    TEXT(_dayOfMonth, _fmt)
                ),
                IF(
                    _useShort,
                    INDEX(
                        {
                            "Jan";
                            "Feb";
                            "Mar";
                            "Apr";
                            "May";
                            "Jun";
                            "Jul";
                            "Aug";
                            "Sep";
                            "Oct";
                            "Nov";
                            "Dec"
                        },
                        _month
                    ),
                    INDEX(
                        {
                            "January";
                            "February";
                            "March";
                            "April";
                            "May";
                            "June";
                            "July";
                            "August";
                            "September";
                            "October";
                            "November";
                            "December"
                        },
                        _month
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
IS_LEAP_YEAR

Tests if a year includes a leap day in the given calendar.

Output
-------------------------------------------------------------------------------------------------------------
 1 | boolean | null if empty

Parameters
-------------------------------------------------------------------------------------------------------------
YearCE           | decimal | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
IS_LEAP_YEAR = LAMBDA(YearCE, [JulianCalendar],
    IFS(
        YearCE = "", "",
        NOT(ISNUMBER(YearCE)), {#VALUE!},
        TRUE, LET(
            _yearCE, INT(YearCE),
            IF(
                N(JulianCalendar) = 0,
                IFS(MOD(_yearCE, 400) = 0, TRUE,
                    MOD(_yearCE, 100) = 0, FALSE,
                    TRUE, MOD(_yearCE, 4) = 0
                ),
                MOD(_yearCE, 4) = 0
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
IS_VALID_DATE

Tests if a date is valid for the given calendar.

Output
-------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
-------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] | Month of year
[Day]            | decimal [1..32) | Day of month
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
IS_VALID_DATE = LAMBDA(YearCE, Month, [Day], [JulianCalendar],
    IFS(
        NOT(ISNUMBER(YearCE)) + NOT(ISNUMBER(Month)), FALSE, // cannot ommit year or month
        NOT(IS_INTEGER(YearCE) * IS_INTEGER(Month)), FALSE, // year and month cannot be fractional
        (Month < 1) + (Month > 12), FALSE, 
        Day = "", TRUE,
        TRUE, LET(
            _day, INT(Day),
            IF(_day < 1, FALSE,
                LET(
                    _daysInMonth, DAYS_IN_MONTH(Month, YearCE, JulianCalendar),
                    IF(ISERROR(_daysInMonth), FALSE,
                        _day <= _daysInMonth
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
DAYS_IN_YEAR

Returns number of days in the given year of the specified calendar.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer [365,366]

Parameters
-------------------------------------------------------------------------------------------------------------
YearCE           | integer | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian proleptic
                 |         | calendar.
----------------------------------------------------------------------------------------------------------*/
DAYS_IN_YEAR = LAMBDA(YearCE, [JulianCalendar],
    IFS(
        YearCE = "", "",
        NOT(ISNUMBER(YearCE)), {#VALUE!},
        IS_LEAP_YEAR(YearCE, JulianCalendar), 366,
        TRUE, 365
    )
);


/*----------------------------------------------------------------------------------------------------------
DAYS_IN_MONTH

Returns number of days in the given month and year of the specified calendar.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer [1..31]

Parameters
-------------------------------------------------------------------------------------------------------------
Month            | integer [1..12] | Month of year
[YearCE]         | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
DAYS_IN_MONTH = LAMBDA(Month, [YearCE], [JulianCalendar],
    IFS(
        Month = "", "",
        NOT(ISNUMBER(Month)), {#VALUE!},
        TRUE, LET(
            _month, INT(Month),
            IFS(
                _month < 1, {#NUM!},
                _month > 12, {#NUM!},

                // February
                _month = 2,
                    LET(
                        _leapDay, IF(ISNUMBER(YearCE),
                            N(IS_LEAP_YEAR(YearCE, JulianCalendar)),
                            0
                        ),
                        28 + _leapDay
                    ),

                // Jan, Mar, Apr, May, Jun, Jul
                _month <= 7, 30 + MOD(_month, 2),
                
                // Aug, Sep, Oct, Nov, Dec
                TRUE, 31 - MOD(_month, 2)
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
PARSE_ISO_CALENDAR_DATE

Parses an ISO formatted calendar date into respective parts of year, month and day.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer | YearCE
 2 | integer | Month
 3 | integer | Day

Parameters
-------------------------------------------------------------------------------------------------------------
ISOCalendarDate  | text   | Date in ISO format ie. yyyy-MM-dd
[JulianCalendar] | switch | Validate in the Julian proleptic calendar. Default is Gregorian
                 |        | proleptic calendar.

Examples
-------------------------------------------------------------------------------------------------------------
PARSE_ISO_CALENDAR_DATE("2023-05-23")
Returns: {2023, 5, 23}

PARSE_ISO_CALENDAR_DATE("1900-02-29", 1)
Returns: {2023, 2, 29} i.e. Feb 29, 1900 is valid in the Julian calendar
----------------------------------------------------------------------------------------------------------*/
PARSE_ISO_CALENDAR_DATE = LAMBDA(ISOCalendarDate, [JulianCalendar],
    IFS(
        ISOCalendarDate = "", {"", "", ""},
        NOT(VALIDATE_CHARSET("+-0123456789" & UNICHAR(8722), ISOCalendarDate)), {#VALUE!, "", ""},
        TRUE, LET(
            _firstChar, LEFT(ISOCalendarDate, 1),
            _isSigned, IFS(
                _firstChar = "+", TRUE,
                _firstChar = "-", TRUE,
                _firstChar = UNICHAR(8722), TRUE,
                TRUE, FALSE
            ),
            _sign, IFS(
                NOT(_isSigned), 1,
                _firstChar = "-", -1,
                _firstChar = UNICHAR(8722), -1,
                TRUE, 1
            ),
            _unSigned, IF(_isSigned,
                RIGHT(ISOCalendarDate, LEN(ISOCalendarDate) - 1),
                ISOCalendarDate
            ),
            _len, LEN(_unSigned),
            _pattern, REPLACE_CHARS(_unSigned, "0123456789", "_"),
            _tryParse, IFS(
                _len >= 10, IFS(
                    _pattern = RIGHT("_______________-__-__", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 6)),
                        VALUE(MID(_unSigned, _len - 4, 2)),
                        VALUE(RIGHT(_unSigned, 2))
                    ),
                    _pattern = RIGHT("_______________-__", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 3)),
                        VALUE(RIGHT(_unSigned, 2)),
                        ""
                    ),
                    _pattern = RIGHT("___________________", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 4)),
                        VALUE(MID(_unSigned, _len - 3, 2)),
                        VALUE(RIGHT(_unSigned, 2))
                    ),
                    TRUE, ""
                ),
                _len >= 8, IFS(
                    _pattern = RIGHT("______-__", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 3)),
                        VALUE(RIGHT(_unSigned, 2)),
                        ""
                    ),
                    _pattern = RIGHT("_________", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 4)),
                        VALUE(MID(_unSigned, _len - 3, 2)),
                        VALUE(RIGHT(_unSigned, 2))
                    ),
                    TRUE, ""
                ),
                _len = 7, IF(
                    _pattern = "____-__",
                    HSTACK(
                        VALUE(LEFT(_unSigned, 4)),
                        VALUE(RIGHT(_unSigned, 2)),
                        ""
                    ),
                    ""
                ),
                (_len >= 4) * (_len <= 5),  IF(
                    _pattern = RIGHT("_____", _len),
                    HSTACK(
                        VALUE(_unSigned),
                        "",
                        ""
                    ),
                    ""
                ),
                TRUE, ""
            ),

            IF(INDEX(_tryParse, 1, 1) = "", {#VALUE!, "", ""},
                LET(
                    _year, _sign * INDEX(_tryParse, 1, 1),
                    _month, INDEX(_tryParse, 1, 2),
                    IFS(
                        _month = "", HSTACK(_year, "", ""),
                        (_month < 1) + (_month > 12), HSTACK(_year, {#NUM!}, ""),
                        TRUE, LET(
                            _day, INDEX(_tryParse, 1, 3),
                            IF(_day = "",
                                HSTACK(_year, _month, ""),    
                                IF(IS_VALID_DATE(_year, _month, _day, JulianCalendar),
                                    HSTACK(_year, _month, _day),
                                    HSTACK(_year, _month, {#NUM!})
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
FORMAT_ISO_YEAR

Returns a year as text in ISO format.

Output
-------------------------------------------------------------------------------------------------------------
 1 | text | ISO formatted year

Parameters
-------------------------------------------------------------------------------------------------------------
YearCE | integer | Note that 1 BC = 0 CE, 2 BC = -1 CE
----------------------------------------------------------------------------------------------------------*/
FORMAT_ISO_YEAR = LAMBDA(YearCE,
    IFS(
        YearCE = "", "",
        NOT(ISNUMBER(YearCE)), {#VALUE!},
        NOT(IS_INTEGER(YearCE)), {#NUM!},
        TRUE, LET(
            _yearFmt, IF((YearCE >= 1000) * (YearCE <= 9999),
                "0000;" & UNICHAR(8722) & "0000",
                "+0000;" & UNICHAR(8722) & "0000"
            ),
            TEXT(YearCE, _yearFmt)
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
FORMAT_ISO_CALENDAR_DATE

Returns a calendar date as text in ISO format.

Output
-------------------------------------------------------------------------------------------------------------
 1 | text | ISO formatted date

Parameters
-------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] |
Day              | integer [1..31] |
[Basic]          | switch          | Display in basic format eg yyyyMMdd
                 |                 | Invalid when Day not provided and YearCE outside of range
                 |                 | -9999..9999 due to collision with yyyyddd ISO format.
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar. 
----------------------------------------------------------------------------------------------------------*/
FORMAT_ISO_CALENDAR_DATE = LAMBDA(YearCE, Month, Day, [Basic], [JulianCalendar],
    IFS(
        (YearCE = "") * (Month = "") * (Day = ""), "",
        NOT(ISNUMBER(YearCE)), {#VALUE!},
        NOT(IS_NUMERIC_NULL(Month)), {#VALUE!},
        NOT(IS_NUMERIC_NULL(Day)), {#VALUE!},
        NOT(ISNUMBER(Month)) * ISNUMBER(Day), {#VALUE!},
        NOT(ISNUMBER(Month)), FORMAT_ISO_Year(YearCE),
        NOT(IS_VALID_DATE(YearCE, Month, Day, JulianCalendar)), {#NUM!},
        TRUE, LET(
            _basic, N(Basic) <> 0,
            _delim, IF(_basic, "", "-"),
            IFS(
                _basic * (ABS(YearCE) > 9999), {#VALUE!},
                ISNUMBER(Day), CONCAT(
                    FORMAT_ISO_Year(YearCE),
                    _delim, TEXT(Month, "00"),
                    _delim, TEXT(Day, "00")
                ),
                TRUE, CONCAT(
                    FORMAT_ISO_Year(YearCE),
                    _delim, TEXT(Month, "00")
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
JULIAN_DAY_NUMBER

Returns the Julian Day Number (JDN) of the provided date in the specified calendar.
Note the Julian Day Number is an integer type and is an ordinal day number referenced from January 1,
4713 BC in the proleptic Julian calendar. It does not include any value for time of day.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer | Julian Day Number

Parameters
-------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] | Month of year
Day              | integer [1..31] | Day of month
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
JULIAN_DAY_NUMBER = LAMBDA(YearCE, Month, Day, [JulianCalendar],
    IFS(
        (YearCE = "") * (Month = "") * (Day = ""), "",
        NOT(IS_VALID_DATE(YearCE, Month, Day, JulianCalendar)), {#NUM!},
        TRUE, LET(
            _day, INT(Day),
            _gregorian, N(JulianCalendar) = 0,
            _YEAR4801BCE, -4800,
            _G4801BCE_JD, -32045,
            _J4801BCE_JD, -32083,
            _DaysIn5MonthsFromMarch, 153,
            _MarchShiftYear, INT((14 - Month) / 12),
            _years, YearCE - _YEAR4801BCE - _MarchShiftYear,
            _MarchShiftMonth, Month + (12 * _MarchShiftYear) - 3,
            _days, 365 * _years + INT(_years / 4) + INT((_DaysIn5MonthsFromMarch * _MarchShiftMonth + 2) / 5) + _day,
            _days + IF(_gregorian,
                _G4801BCE_JD - INT(_years / 100) + INT(_years / 400),
                _J4801BCE_JD
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
MODIFIED_JULIAN_DAY_NUMBER

Returns the Modified Julian Day Number (MJDN) of the provided date in the specified calendar.
Note the Modified Julian Day Number is an integer type and is an ordinal day number referenced from November 17,
1858 in the proleptic Gregorian calendar. It does not include any value for time of day.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer | Modified Julian Day Number

Parameters
-------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] | Month of year
Day              | integer [1..31] | Day of month
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
MODIFIED_JULIAN_DAY_NUMBER = LAMBDA(YearCE, Month, Day, [JulianCalendar],
    LET(
        _JDN, JULIAN_DAY_NUMBER(YearCE, Month, Day, JulianCalendar),
        IF(NOT(ISNUMBER(_JDN)), _JDN,
            JDN_TO_MODIFIED(_JDN)
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
JDN_TO_MODIFIED

Converts a Julian Day Number (JDN) to a Modified Julian Day Number (MJDN).

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer | Modified Julian Day Number

Parameters
-------------------------------------------------------------------------------------------------------------
JDN | integer | Julian Day Number
----------------------------------------------------------------------------------------------------------*/
JDN_TO_MODIFIED = LAMBDA(JDN,
    IF(JDN = "", "",
        INT(JDN) - 2400001
    )
);


/*----------------------------------------------------------------------------------------------------------
MODIFIED_TO_JDN

Converts a Modified Julian Day Number (MJDN) to a Julian Day Number (JDN).

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer | Julian Day Number

Parameters
-------------------------------------------------------------------------------------------------------------
MJDN | integer | Modified Julian Day Number
----------------------------------------------------------------------------------------------------------*/
MODIFIED_TO_JDN = LAMBDA(MJDN,
    IF(MJDN = "", "",
        INT(MJDN) + 2400001
    )
);


/*----------------------------------------------------------------------------------------------------------
JDN_TO_CALENDAR_DATE

Converts a Julian Day Number to a date in the specified calendar.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day of month

Parameters
-------------------------------------------------------------------------------------------------------------
JDN              | integer | Julian Day Number
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
JDN_TO_CALENDAR_DATE = LAMBDA(JDN, [JulianCalendar],
    IFS(
        JDN = "", {"", "", ""},
        NOT(ISNUMBER(JDN)), {#VALUE!, "", ""},
        TRUE, LET(
            _JDN, INT(JDN),
            _gregorian, N(JulianCalendar) = 0,
            _YEAR4801BCE, -4800,
            _DaysIn4Year, 1461,
            _DaysInYear, 365,
            _MonthCorrectionDays, 308,
            _DaysIn4Months, 122,
            _DaysIn5MonthsFromMarch, 153,
            IF(_gregorian,
                LET(
                    _G4801BCE_JD0, -32045,
                    _GregDaysIn400Year, 146097,
                    _GregDaysIn100Year, 36524,
                    _days0, _jdn - _G4801BCE_JD0 - 1,
                    _quadCent, INT(_days0 / _GregDaysIn400Year),
                    _days1, _days0 - _quadCent * _GregDaysIn400Year,
                    _remCent, INT((INT(_days1 / _GregDaysIn100Year) + 1) * 0.75),
                    _days2, _days1 - _remCent * _GregDaysIn100Year,
                    _quadYr, INT(_days2 / _DaysIn4Year),
                    _days3, _days2 - _quadYr * _DaysIn4Year,
                    _remYr, INT((INT(_days3 / _DaysInYear) + 1) * 0.75),
                    _days4, _days3 - _remYr * _DaysInYear,
                    _y, _quadCent * 400 + _remCent * 100 + _quadYr * 4 + _remYr,
                    _m, INT((_days4 * 5 + _MonthCorrectionDays) / _DaysIn5MonthsFromMarch) - 2,
                    _day, _days4 - INT((_m + 4) * _DaysIn5MonthsFromMarch / 5) +
                        _DaysIn4Months + 1,
                    _year, _YEAR4801BCE + _y + INT((_m + 2) / 12),
                    _month, MOD(_m + 2, 12) + 1,
                    HSTACK(_year, _month, _day)
                ),
                LET(
                    _J4801BCE_JD0, -32083,
                    _days0, _jdn - _J4801BCE_JD0 - 1,
                    _quadYr, INT(_days0 / _DaysIn4Year),
                    _days1, _days0 - _quadYr * _DaysIn4Year,
                    _remYr, INT((INT(_days1 / _DaysInYear) + 1) * 0.75),
                    _days2, _days1 - _remYr * _DaysInYear,
                    _y, _quadYr * 4 + _remYr,
                    _m, INT((_days2 * 5 + _MonthCorrectionDays) / _DaysIn5MonthsFromMarch) - 2,
                    _day, _days2 - INT((_m + 4) * _DaysIn5MonthsFromMarch / 5) +
                        _DaysIn4Months + 1,
                    _year, _YEAR4801BCE + _y + INT((_m + 2) / 12),
                    _month, MOD(_m + 2, 12) + 1,
                    HSTACK(_year, _month, _day)
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
MJDN_TO_CALENDAR_DATE

Converts a Modified Julian Day Number (MJDN) to a date in the specified calendar.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day of month

Parameters
-------------------------------------------------------------------------------------------------------------
MJDN             | integer | Modified Julian Day Number
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
MJDN_TO_CALENDAR_DATE = LAMBDA(MJDN, [JulianCalendar],
    LET(
        _JDN, MODIFIED_TO_JDN(MJDN),
        IF(NOT(ISNUMBER(_JDN)), _JDN,
            JDN_TO_CALENDAR_DATE(_JDN, JulianCalendar)
        )
    )
);

/*----------------------------------------------------------------------------------------------------------
GREGORIAN_TO_JULIAN

Translates a date in the Gregorian proleptic calendar to the Julian proleptic calendar.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day

Parameters
-------------------------------------------------------------------------------------------------------------
YearCE | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month  | integer [1..12] | 
Day    | integer [1..31] |
----------------------------------------------------------------------------------------------------------*/
GREGORIAN_TO_JULIAN = LAMBDA(YearCE, Month, Day,
    LET(
        _JDN, JULIAN_DAY_NUMBER(YearCE, Month, Day, 0),
        IFS(ISERROR(_JDN), {#VALUE!, "", ""},
            _JDN = "", {"", "", ""},
            TRUE, JDN_TO_CALENDAR_DATE(_JDN, 1)
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
JULIAN_TO_GREGORIAN

Translates a date in the Julian proleptic calendar to the Gregorian proleptic calendar.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day

Parameters
-------------------------------------------------------------------------------------------------------------
YearCE | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month  | integer [1..12] | 
Day    | integer [1..31] | 
----------------------------------------------------------------------------------------------------------*/
JULIAN_TO_GREGORIAN = LAMBDA(YearCE, Month, Day,
    LET(
        _JDN, JULIAN_DAY_NUMBER(YearCE, Month, Day, 1),
        IFS(ISERROR(_JDN), {#VALUE!, "", ""},
            _JDN = "", {"", "", ""},
            TRUE, JDN_TO_CALENDAR_DATE(_JDN, 0)
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
SECULAR_DIFFERENCE

Returns the number of days the Gregorian proleptic calendar is ahead of the Julian proleptic calendar for
a given date.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer | Days difference. Negative values are when the Julian proleptic calender is ahead.

Parameters
-------------------------------------------------------------------------------------------------------------
YearCE               | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month                | integer [1..12] | 
Day                  | integer [1..31] | 
[FromJulianCalendar] | switch          | Provided date is in Julian calendar.
                     |                 | Default is the Gregorian calendar.
----------------------------------------------------------------------------------------------------------*/
SECULAR_DIFFERENCE = LAMBDA(YearCE, Month, Day, [FromJulianCalendar],
    IF(N(FromJulianCalendar) = 0,
        // From Gregorian calendar
        LET(
            _JDN_G, JULIAN_DAY_NUMBER(YearCE, Month, Day, 0),
            IF(ISERROR(_JDN_G), {#VALUE!},
                IF(_JDN_G = "", "",
                    LET(
                        _JDN_J, IF((Month = 2) * (Day = 29),
                            IF(IS_LEAP_YEAR(YearCE, 1),
                                JULIAN_DAY_NUMBER(YearCE, 2, 29, 1),
                                JULIAN_DAY_NUMBER(YearCE, 2, 28, 1)
                            ),
                            JULIAN_DAY_NUMBER(YearCE, Month, Day, 1)
                        ),
                        _JDN_J - _JDN_G
                    )
                )
            )
        ),
        
        // From Julian calendar
        LET(
            _date_G, JULIAN_TO_GREGORIAN(YearCE, Month, Day),
            IF(ISERROR(INDEX(_date_G, 1, 1)), {#VALUE!},
                IF(INDEX(_date_G, 1, 1) = "", "",
                    SECULAR_DIFFERENCE(
                        INDEX(_date_G, 1, 1),
                        INDEX(_date_G, 1, 2),
                        INDEX(_date_G, 1, 3),
                        0
                    )
                )
            )
        )
    )
);











/*###########################################################################################################
# TIME ZONES                                                                                                #
###########################################################################################################*/


/*----------------------------------------------------------------------------------------------------------
IS_VALID_TZO

Tests if a time zone offset in minutes is within the range -15:00..+15:00

Output
-------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
-------------------------------------------------------------------------------------------------------------
TZOMinutes | decimal [-900..900] | Fractional allowed if minute and second empty.
----------------------------------------------------------------------------------------------------------*/
IS_VALID_TZO = LAMBDA(TZOMinutes,
    IFS(
        IS_EMPTY(TZOMinutes), FALSE,
        NOT(ISNUMBER(TZOMinutes)), FALSE,
        ABS(TZOMinutes) > 900, FALSE,
        TRUE, TRUE
    )
);


/*----------------------------------------------------------------------------------------------------------
TIMESPAN_TO_TZO

Converts a deimal timespan into time zone offset minutes.

Output
-------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
-------------------------------------------------------------------------------------------------------------
TZOTimeSpan | decimal [-0.625..0.625] |
----------------------------------------------------------------------------------------------------------*/
TIMESPAN_TO_TZO = LAMBDA(TZOTimeSpan,
    IF(IS_EMPTY(TZOTimeSpan), "",
        LET(
            _tzo, TZOTimeSpan * 1440,
            IF(IS_VALID_TZO(_tzo), _tzo, {#NUM!})
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
TZO_TO_TIMESPAN

Converts time zone offset minutes into a decimal timespan.

Output
-------------------------------------------------------------------------------------------------------------
 1 | boolean | Time Zone Offset expressed as a TimeSpan 

Parameters
-------------------------------------------------------------------------------------------------------------
TZOTimeSpan | decimal [-0.625..0.625] |
----------------------------------------------------------------------------------------------------------*/
TZO_TO_TIMESPAN = LAMBDA(TZOMinutes,
    IFS(
        IS_EMPTY(TZOMinutes), "",
        NOT(IS_VALID_TZO(TZOMinutes)), {#NUM!},
        TRUE, TZOMinutes / 1440
    )
);


/*----------------------------------------------------------------------------------------------------------
PARSE_ISO_TZO

Parses an ISO formatted time zone offset into time zone offset minutes.

Output
-------------------------------------------------------------------------------------------------------------
 1 | decimal [-900..900] | Time zone offset in minutes

Parameters
-------------------------------------------------------------------------------------------------------------
ISOTimeZoneOffset | text | Time zone offset in ISO format ie. hh:mm

Examples
-------------------------------------------------------------------------------------------------------------
PARSE_ISO_TZO("Z")
Returns: 0 i.e. UTC time zone (Zulu)

PARSE_ISO_TIME("06:00")
Returns: -360

PARSE_ISO_TIME("+16:00")
Returns: #NUM! i.e. range is 15:00 to +15:00
----------------------------------------------------------------------------------------------------------*/
PARSE_ISO_TZO = LAMBDA(ISOTimeZoneOffset,
    IFS(
        IS_EMPTY(ISOTimeZoneOffset), "",
        (LEN(ISOTimeZoneOffset) = 1) * (CODE(ISOTimeZoneOffset) = 90), 0,
        TRUE, LET(
            _sChar, LEFT(ISOTimeZoneOffset, 1),
            _sign, IFS(
                _sChar = "+", 1,
                _sChar = "-", -1,
                UNICODE(_sChar) = 8722, -1,
                TRUE, 0
            ),
            IF(_sign = 0, {#VALUE!},
                LET(
                    _tz, MID(ISOTimeZoneOffset, 2, LEN(ISOTimeZoneOffset) - 1),
                    _pattern, REPLACE_CHARS(_tz, "0123456789", "_"),
                    _tryParse, IFS(
                        _pattern = "__:__:__",
                            HSTACK(
                                VALUE(LEFT(_tz, 2)),
                                VALUE(MID(_tz, 4, 2)),
                                VALUE(RIGHT(_tz, 2))
                            ),
                        _pattern = "__:__",
                            HSTACK(
                                VALUE(LEFT(_tz, 2)),
                                VALUE(RIGHT(_tz, 2)),
                                0
                            ),
                        _pattern = "______",
                            HSTACK(
                                VALUE(LEFT(_tz, 2)),
                                VALUE(MID(_tz, 3, 2)),
                                VALUE(RIGHT(_tz, 2))
                            ),
                        _pattern = "____",
                            HSTACK(
                                VALUE(LEFT(_tz, 2)),
                                VALUE(RIGHT(_tz, 2)),
                                0
                            ),
                        _pattern = "__",
                            HSTACK(VALUE(_tz), 0, 0),
                        TRUE, {#VALUE!}
                    ),
                    
                    IFS(
                        ISERROR(INDEX(_tryParse, 1, 1)), {#VALUE!},
                        NOT(IS_VALID_TIME_OF_DAY(
                            INDEX(_tryParse, 1, 1),
                            INDEX(_tryParse, 1, 2),
                            INDEX(_tryParse, 1, 3)
                        )), {#NUM!},
                        TRUE, TIMESPAN_TO_TZO(
                            _sign * TIMESPAN(
                                1, 0,
                                INDEX(_tryParse, 1, 1),
                                INDEX(_tryParse, 1, 2),
                                INDEX(_tryParse, 1, 3)
                            )
                        )
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
FORMAT_ISO_TZO

Returns a time zone offset as text in ISO format.

Output
-------------------------------------------------------------------------------------------------------------
 1 | text | ISO formatted time zone offset

Parameters
-------------------------------------------------------------------------------------------------------------
TZOMinutes | decimal     | Time zone offset from UTC in minutes.
           | [-900..900] | Assumed to be UTC if ommitted. [-15:00..+15:00]
[Options]  | text        | String with elements: [B][Z]
           |             |  B : Display in basic format eg +0000
           |             |  Z : Display 'Z' for Zulu time zone +00:00
----------------------------------------------------------------------------------------------------------*/
FORMAT_ISO_TZO = LAMBDA(TZOMinutes, [Options],
    IFS(
        IS_EMPTY(TZOMinutes), "",
        NOT(ISNUMBER(TZOMinutes)), {#VALUE!},
        NOT(IS_VALID_TZO(TZOMinutes)), {#NUM!},
        TRUE, LET(
            _basic, IFERROR(SEARCH("B", Options), 0) > 0,
            _zulu, IFERROR(SEARCH("Z", Options), 0) > 0,
            _tzo, ABS(TZOMinutes),
            IF((_tzo = 0) * _zulu, "Z",
                LET(
                    _sign, IF(TZOMinutes >= 0, "+", UNICHAR(8722)), 
                    _delim, IF(_basic, "", ":"),
                    _rTZO, RESOLVE_TIMESPAN(TZO_TO_TIMESPAN(_tzo), 2, 4, 0),
                    IF(INDEX(_rTZO, 5) > 0, 
                        CONCAT(
                            _sign,
                            TEXT(INDEX(_rTZO, 1, 3), "00"),
                            _delim, TEXT(INDEX(_rTZO, 1, 4), "00"),
                            _delim, TEXT(INDEX(_rTZO, 1, 5), "00")
                        ),
                        CONCAT(
                            _sign,
                            TEXT(INDEX(_rTZO, 1, 3), "00"),
                            _delim, TEXT(INDEX(_rTZO, 1, 4), "00")
                        )
                    )
                )
            )
        )
    )
);








/*###########################################################################################################
# DATE AND TIME                                                                                             #
###########################################################################################################*/


/*----------------------------------------------------------------------------------------------------------
IS_VALID_TIME_OF_DAY

Tests if sexagesimal representation of time is valid for a 24 hour day.

Output
-------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
-------------------------------------------------------------------------------------------------------------
Hour           | decimal [0..24) | Fractional allowed if minute and second empty.
Minute         | decimal [0..60) | Fractional allowed if second empty.
Second         | decimal [0..60) | Fractional allowed
[Accept24Hour] | switch          | Accept time of 24:00:00 to represent midnight next day.
----------------------------------------------------------------------------------------------------------*/
IS_VALID_TIME_OF_DAY = LAMBDA(Hour, Minute, Second, [Accept24Hour],
    LET(
        _accept24hour, N(Accept24Hour) <> 0,
        IFS(
            ISNUMBER(Hour) * ISNUMBER(Minute) * ISNUMBER(Second),
                IFS(
                    (_accept24hour * (Hour = 24) * (Minute = 0) * (Second = 0)) > 0, TRUE,
                    NOT(IS_INTEGER(Hour) * IS_INTEGER(Minute)), FALSE,
                    (Hour < 0) + (Hour > 23), FALSE,
                    (Minute < 0) + (Minute > 59), FALSE,
                    (Second < 0) + (Second >= 60), FALSE,
                    TRUE, TRUE
                ),
            ISNUMBER(Hour) * ISNUMBER(Minute) * (Second = ""),
                IFS(
                    (_accept24hour * (Hour = 24) * (Minute = 0)) > 0, TRUE,
                    NOT(IS_INTEGER(Hour)), FALSE,
                    (Hour < 0) + (Hour > 23), FALSE,
                    (Minute < 0) + (Minute >= 60), FALSE,
                    TRUE, TRUE
                ),
            ISNUMBER(Hour) * (Minute = "") * (Second = ""),
                IF((_accept24hour * (Hour = 24)) > 0, TRUE,
                    ((Hour >= 0) * (Hour < 24)) > 0
                ),
            (Hour = "") * ISNUMBER(Minute) * ISNUMBER(Second),
                IFS(
                    NOT(IS_INTEGER(Minute)), FALSE,
                    (Minute < 0) + (Minute > 59), FALSE,
                    (Second < 0) + (Second >= 60), FALSE,
                    TRUE, TRUE
                ),
            (Hour = "") * ISNUMBER(Minute) * (Second = ""),
                ((Minute >= 0) * (Minute < 60)) <> 0,
            (Hour = "") * (Minute = "") * ISNUMBER(Second),
                ((Second >= 0) * (Second < 60)) <> 0,
            TRUE, FALSE
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
JULIAN_DATE

Returns the Julian Date of the provided date and time of day in the specified calendar.
Note that the decimal time component of Julian Date is based from midday.

Output
-------------------------------------------------------------------------------------------------------------
 1 | decimal | Julian Date

Parameters
-------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] | Month of year
Day              | intger  [1..31] | Day of month
]Time]           | decimal [0..1)  | Time of day
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
JULIAN_DATE = LAMBDA(YearCE, Month, Day, [Time], [JulianCalendar],
    LET(
        _JDN, JULIAN_DAY_NUMBER(YearCE, Month, Day, JulianCalendar),
        IF(NOT(ISNUMBER(_JDN)), _JDN,
            LET(
                _timeAfterMidday, N(Time) - 0.5,
                _JDN + _timeAfterMidday
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
MODIFIED_JULIAN_DATE

Returns the Modified Julian Date of the provided date and time of day in the specified calendar.
Note that the time component of Modified Julian Date is based from midnight.

Output
-------------------------------------------------------------------------------------------------------------
 1 | decimal | Modified Julian Date

Parameters
-------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] | Month of year
Day              | intger  [1..31] | Day of month
[Time]           | decimal [0..1)  | Time of day
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
MODIFIED_JULIAN_DATE = LAMBDA(YearCE, Month, Day, [Time], [JulianCalendar],
    LET(
        _MJDN, MODIFIED_JULIAN_DAY_NUMBER(YearCE, Month, Day, JulianCalendar),
        IF(NOT(ISNUMBER(_MJDN)), _MJDN,
            _MJDN + N(Time)
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
JDATE_TO_MODIFIED

Converts a Julian Date (JDATE) to a Modified Julian Date (MJDATE).
Note that the decimal time component of MJDATE is based from midnight.

Output
-------------------------------------------------------------------------------------------------------------
 1 | decimal | Modified Julian Date

Parameters
-------------------------------------------------------------------------------------------------------------
JDate | decimal | Julian Date
----------------------------------------------------------------------------------------------------------*/
JDATE_TO_MODIFIED = LAMBDA(JDate,
    IF(JDate = "", "",
        JDate - 2400000.5
    )
);


/*----------------------------------------------------------------------------------------------------------
MODIFIED_TO_JDATE

Converts a Modified Julian Date (MJDATE) to a Julian Date (JDATE).
Note that the decimal time component of JDATE is based from midday.

Output
-------------------------------------------------------------------------------------------------------------
 1 | decimal | Julian Date

Parameters
-------------------------------------------------------------------------------------------------------------
MJDate | decimal | Modified Julian Date
----------------------------------------------------------------------------------------------------------*/
MODIFIED_TO_JDATE = LAMBDA(MJDate,
    IF(MJDate = "", "",
        MJDate + 2400000.5
    )
);


/*----------------------------------------------------------------------------------------------------------
JDATE_TO_CALENDAR_DATE

Converts a Julian Date (JDATE) to a date and time in the specified calendar.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day of month
 4 | decimal [0..1)  | Time of day

Parameters
-------------------------------------------------------------------------------------------------------------
JDate            | decimal | Julian Date
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
JDATE_TO_CALENDAR_DATE = LAMBDA(JDate, [JulianCalendar],
    IFS(
        JDate = "", {"", "", "", ""},
        NOT(ISNUMBER(JDate)), {#VALUE!, "", "", ""},
        TRUE, LET(
            _JDN, INT(JDate + 0.5),
            _timeOfDay, JDate - _JDN + 0.5,
            _cDate, JDN_TO_CALENDAR_DATE(_JDN, JulianCalendar),
            HSTACK(_cDate, _timeOfDay)
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
MJDATE_TO_CALENDAR_DATE

Converts a Modified Julian Date (MJDATE) to a date and time in the specified calendar.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day of month
 4 | decimal [0..1)  | Time of day

Parameters
-------------------------------------------------------------------------------------------------------------
MJDate           | decimal | Modified Julian Date
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
MJDATE_TO_CALENDAR_DATE = LAMBDA(MJDate, [JulianCalendar],
    IF(MJDate = "", {"", "", "", ""},
        IF(NOT(ISNUMBER(MJDate)), {#VALUE!, "", "", ""},
            LET(
                _JDate, MODIFIED_TO_JDATE(MJDate),
                JDATE_TO_CALENDAR_DATE(_JDate, JulianCalendar)
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
RESOLVE_MJDATE

Returns the date and sexagesimal representation of the time value with the given lowest order component
rounded to the specified precision.

Output - LowOrder = 6
-------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day of month
 4 | integer [0..23] | Hour
 5 | integer [0..59] | Minute
 6 | decimal [0..60) | Second

Output - LowOrder = 5
-------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day of month
 4 | integer [0..23] | Hour
 5 | decimal [0..60) | Minute

Output - LowOrder = 4
-------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day of month
 4 | decimal [0..24) | Hour

Output - LowOrder = 3
-------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month
 3 | decimal [1..32) | Day of month

Output - LowOrder = 2
-------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..12] | Month

Output - LowOrder = 1
-------------------------------------------------------------------------------------------------------------
 1 | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE

Parameters
-------------------------------------------------------------------------------------------------------------
MJDate           | decimal        | Modified Julian Date
[LowOrder]       | integer [1..6] | Low-order component
                 |                |  1 - YearCE
                 |                |  2 - Month
                 |                |  3 - Day
                 |                |  4 - Hour
                 |                |  5 - Minute
                 |                |  6 - Second
[Precision]      | integer [0..9] | Select precision level. Not applicable when LowOrder = 1,2
                 |                | Null - Floating
[Truncate]       | switch         | Round to precision by truncating components. Default is rounding to nearest.
[JulianCalendar] | switch         | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
RESOLVE_MJDATE = LAMBDA(MJDate, [LowOrder], [Precision], [Truncate], [JulianCalendar],
    LET(
        _lowOrder, IFS(
            NOT(ISNUMBER(LowOrder)), 6,
            LowOrder < 1, 6,
            LowOrder > 6, 6,
            TRUE, INT(LowOrder)
        ),
        _precision, IFS(
            NOT(ISNUMBER(Precision)), "",
            Precision < 0, 0,
            Precision > 9, 9,
            TRUE, INT(Precision)
        ),
        _truncate, N(Truncate) <> 0,
        IFS(
            MJDate = "", TAKE({"", "", "", "", "", ""}, 1, _lowOrder),
            NOT(ISNUMBER(MJDate)), TAKE({#VALUE!, "", "", "", "", ""}, 1, _lowOrder),
            _lowOrder = 1, LET(
                _cDate, MJDN_TO_CALENDAR_DATE(MJDate, JulianCalendar),
                IF(_truncate,
                    INDEX(_cDate, 1, 1),
                    INDEX(_cDate, 1, 1) + N(INDEX(_cDate, 1, 2) > 6)
                )
            ),
            _lowOrder = 2, LET(
                _cDate, MJDATE_TO_CALENDAR_DATE(MJDate, JulianCalendar),
                IF(_truncate,
                    TAKE(_cDate, 1, 2),
                    LET(
                        _daysInMonth, DAYS_IN_MONTH(INDEX(_cDate, 1, 2), INDEX(_cDate, 1, 1)),
                        _carryMonth, ROUND(((INDEX(_cDate, 1, 3) - 1 + INDEX(_cDate, 1, 4)) / _daysInMonth), 0),
                        IFS(
                            _carryMonth = 0, TAKE(_cDate, 1, 2),
                            INDEX(_cDate, 1, 2) = 12, HSTACK(INDEX(_cDate, 1, 1) + 1, 1),
                            TRUE, HSTACK(INDEX(_cDate, 1, 1), INDEX(_cDate, 1, 2) + 1)
                        )
                    )
                )
            ),
            _lowOrder = 3, LET(
                _MJDN, INT(MJDate),
                _time, MJDate - _MJDN,
                _rTime, IFS(
                    _precision = "", _time,
                    _truncate, ROUNDDOWN(_time, _precision),
                    TRUE, ROUND(_time, _precision)
                ),
                IF(_rTime = 1,
                    MJDN_TO_CALENDAR_DATE(_MJDN + 1, JulianCalendar),
                    LET(
                        _cDate, MJDN_TO_CALENDAR_DATE(_MJDN, JulianCalendar),
                        HSTACK(
                            INDEX(_cDate, 1, 1),
                            INDEX(_cDate, 1, 2),
                            INDEX(_cDate, 1, 3) + _rTime
                        )
                    )
                )
            ),
            TRUE, LET(
                _MJDN, INT(MJDate),
                _time, MJDate - _MJDN,
                _rTime, RESOLVE_TIMESPAN(_time, 1, _lowOrder - 2, _precision, _truncate),
                _carryDay, INDEX(_rTime, 2),
                _rDate, MJDN_TO_CALENDAR_DATE(_MJDN + _carryDay, JulianCalendar),
                HSTACK(_rDate, CHOOSECOLS(_rTime, SEQUENCE(1, _lowOrder - 3, 3)))
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
MJDATE_ADDITION

Returns the addition of a timespan complication to a given Modified Julian Date.
Note if date components of years, quarters or months are added for a MJDate expressed in UTC rather than
local time, then results may be inconsistent due to the bounds of calendar days.

Output
-------------------------------------------------------------------------------------------------------------
 1 | decimal | Modified Julian Date

Parameters
-------------------------------------------------------------------------------------------------------------
LocalMJDate      | decimal     | Modified Julian Date in local time zone
[AddTimeSpan]    | decimal     | Add timespan.
[AddWeeks]       | decimal     | Add weeks timespan. Fractional part carries to day.
[AddMonths]      | decimal     | Add months timespan. Fractional part carries to day.
[AddQuarters]    | decimal     | Add quarters timespan. Fractional part carries to month and day.
[AddYears]       | decimal     | Add years timespan. Fractional part carries to month and day.
[JulianCalendar] | switch      | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |             | proleptic calendar. Only needed if date parts of years, quarters or months
                 |             | are added.
----------------------------------------------------------------------------------------------------------*/
MJDATE_ADDITION = LAMBDA(LocalMJDate, [AddTimeSpan], [AddWeeks], [AddMonths], [AddQuarters], [AddYears], [JulianCalendar],
    IFS(
        LocalMJDate = "", "",
        NOT(ISNUMBER(LocalMJDate)), {#VALUE!},
        (N(AddTimeSpan) = 0) * (N(AddWeeks) = 0) * (N(AddMonths) = 0) * (N(AddQuarters) = 0) * (N(AddYears) = 0), LocalMJDate,
        TRUE, LET(
            _hasDatePartsAdded, ((N(AddMonths) <> 0) + (N(AddQuarters) <> 0) + (N(AddYears) <> 0)) <> 0,
            _baseMJDate, IF(NOT(_hasDatePartsAdded), LocalMJDate,
                LET(
                    _decMonths, (N(AddYears) * 12) + (N(AddQuarters) * 3) + N(AddMonths),
                    _addTotalMonths, INT(_decMonths),
                    _partialMonths, _decMonths - _addTotalMonths,
                    _startDate, MJDATE_TO_CALENDAR_DATE(LocalMJDate, JulianCalendar),
                    _shiftMonths, INDEX(_startDate, 1, 2) - 1 + _addTotalMonths,
                    _resultYear, INDEX(_startDate, 1, 1) + INT(_shiftMonths / 12),
                    _resultMonth, MOD(_shiftMonths, 12) + 1,
                    _MJDateMonth, MODIFIED_JULIAN_DATE(_resultYear, _resultMonth, 1, 0, JulianCalendar) - 1,
                    _avgDaysMonth, IF(N(JulianCalendar), 30.4375, 30.436875),
                    _MJDateMonth + INDEX(_startDate, 1, 3) + ROUND(_partialMonths * _avgDaysMonth, 0) + INDEX(_startDate, 1, 4)
                )
            ),
            _baseMJDate + N(AddTimeSpan) + ROUND(N(AddWeeks) * 7, 0)
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
PARSE_ISO_TIME

Parses an ISO formatted time of day into decimal time of day.

Output
-------------------------------------------------------------------------------------------------------------
 1 | decimal [0..1] | Time of day as decimal fraction of a day.

Output when AsComplication switch set
-------------------------------------------------------------------------------------------------------------
 1 | integer [0..24]  | Hours
 2 | integer [0..59]  | Minutes
 3 | decimal [0..60)  | Seconds

Parameters
-------------------------------------------------------------------------------------------------------------
ISOTime          | text   | Time in ISO format ie. Thh:mm:ss.000
[AsComplication] | switch | Output component parts

Examples
-------------------------------------------------------------------------------------------------------------
PARSE_ISO_TIME("12:00")
Returns: 0.5

PARSE_ISO_TIME("24:00:01")
Returns: #NUM!  i.e. range is 0 to 24 hours 
----------------------------------------------------------------------------------------------------------*/
PARSE_ISO_TIME = LAMBDA(ISOTime, [AsComplication],
    IF(ISOTime = "", "",
        LET(
            _asValue, N(AsComplication) = 0,
            IF(CODE(ISOTime) <> 84, IF(_asValue, {#VALUE!}, {#VALUE!, "", ""}),
                LET(
                    _len, LEN(ISOTime) - 1,
                    _timePart, RIGHT(ISOTime, _len),
                    _pattern, REPLACE_CHARS(_timePart, "0123456789", "_"),
                    _tryParse, IFS(
                        LEFT(_pattern, 10) = "__:__:__._", LET(
                            _decimals, _len - 9,
                            HSTACK(
                                VALUE(LEFT(_timePart, 2)),
                                VALUE(MID(_timePart, 4, 2)),
                                VALUE(MID(_timePart, 7, 2)) + (VALUE(RIGHT(_timePart, _decimals)) / (10 ^ _decimals))
                            )
                        ),
                        _pattern = "__:__:__",
                            HSTACK(
                                VALUE(LEFT(_timePart, 2)),
                                VALUE(MID(_timePart, 4, 2)),
                                VALUE(RIGHT(_timePart, 2))
                            ),
                        _pattern = "__:__",
                            HSTACK(
                                VALUE(LEFT(_timePart, 2)),
                                VALUE(RIGHT(_timePart, 2)),
                                0
                            ),
                        LEFT(_pattern, 8) = "______._", LET(
                            _decimals, _len - 7,
                            HSTACK(
                                VALUE(LEFT(_timePart, 2)),
                                VALUE(MID(_timePart, 3, 2)),
                                VALUE(MID(_timePart, 5, 2)) + (VALUE(RIGHT(_timePart, _decimals)) / (10 ^ _decimals))
                            )    
                        ),
                        _pattern = "______",
                            HSTACK(
                                VALUE(LEFT(_timePart, 2)),
                                VALUE(MID(_timePart, 3, 2)),
                                VALUE(RIGHT(_timePart, 2))
                            ),
                        _pattern = "____",
                            HSTACK(
                                VALUE(LEFT(_timePart, 2)),
                                VALUE(RIGHT(_timePart, 2)),
                                0
                            ),
                        _pattern = "__",
                            HSTACK(
                                VALUE(_timePart), 0, 0
                            ),
                        TRUE, {#VALUE!}
                    ),
                    IFS(
                        ISERROR(INDEX(_tryParse, 1, 1)), IF(_asValue, {#VALUE!}, {#VALUE!, "", ""}),
                        NOT(IS_VALID_TIME_OF_DAY(
                                INDEX(_tryParse, 1, 1),
                                INDEX(_tryParse, 1, 2),
                                INDEX(_tryParse, 1, 3), 1
                            )
                        ), IF(_asValue, {#NUM!}, {#NUM!, "", ""}),
                        _asValue, TIMESPAN(1, 0, 
                            INDEX(_tryParse, 1, 1),
                            INDEX(_tryParse, 1, 2),
                            INDEX(_tryParse, 1, 3)
                        ),
                        TRUE, HSTACK( 
                            INDEX(_tryParse, 1, 1),
                            INDEX(_tryParse, 1, 2),
                            INDEX(_tryParse, 1, 3)
                        )
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
FORMAT_ISO_TIME

Returns a time as text in ISO format.

Output
-------------------------------------------------------------------------------------------------------------
 1 | text | ISO formatted time

Parameters
-------------------------------------------------------------------------------------------------------------
Time             | decimal [0..1] | Time of day as decimal fraction of a day.
[Options]        | text           | String with elements: [B][<][LowOrder][Precision]
                 |                |        B : Display in basic format eg T000000
                 |                |        < : Round by truncating components. Default is rounding to nearest.
                 |                | LowOrder : low order component
                 |                |     Null : Defaults to seconds
                 |                |        H : Hour
                 |                |        M : Minute
                 |                |        S : Second
                 |                | Precision: [0-9] Only has an effect when low order component is seconds.
Examples
-------------------------------------------------------------------------------------------------------------
FORMAT_ISO_TIME(0.25)
Returns: T06:00:00

PARSE_ISO_TIME(0.6747, "M<")
Returns: T16:11
----------------------------------------------------------------------------------------------------------*/
FORMAT_ISO_TIME = LAMBDA(Time, [Options],
    IFS(
        Time = "", "",
        NOT(ISNUMBER(Time)), {#VALUE!},
        (Time < 0) + (Time > 1), {#NUM!},
        TRUE, LET(
            _basic, IFERROR(SEARCH("B", Options), 0) > 0,
            _truncate, IFERROR(FIND("<", Options), 0) > 0,
            _tryLowOrderChar, SEARCH_NTH_CHAR("HMS", Options, 1, 1),
            _lowOrder, IFS(
                INDEX(_tryLowOrderChar, 1, 1) = 0, 4,
                INDEX(_tryLowOrderChar, 1, 2) = "H", 2,
                INDEX(_tryLowOrderChar, 1, 2) = "M", 3,
                INDEX(_tryLowOrderChar, 1, 2) = "S", 4
            ),
            _precision, IF(_lowOrder < 4, 0,
                LET(
                    _tryPrecisionChar, SEARCH_NTH_CHAR("0123456789", Options, 1, 1),
                    IF(INDEX(_tryPrecisionChar, 1, 1) = 0, 0,
                        VALUE(INDEX(_tryPrecisionChar, 1, 2))
                    )
                )
            ),
            
            _rTime, RESOLVE_TIMESPAN(Time, 2, _lowOrder, _precision, _truncate),
            _delim, IF(_basic, "", ":"),
            IFS(
                _lowOrder = 4, LET(
                    _secFmt, IF(_precision = 0, "00", LEFT("00.000000000", _precision + 3)),
                    CONCAT(
                        "T", TEXT(INDEX(_rTime, 1, 3), "00"),
                        _delim, TEXT(INDEX(_rTime, 1, 4), "00"),
                        _delim, TEXT(INDEX(_rTime, 1, 5), _secFmt)
                    )
                ),
                _lowOrder = 3,
                    CONCAT(
                        "T", TEXT(INDEX(_rTime, 1, 3), "00"),
                        _delim, TEXT(INDEX(_rTime, 1, 4), "00")
                    ),
                _lowOrder = 2,
                    "T" & TEXT(INDEX(_rTime, 1, 3), "00")
            )
        )
    )
);




/*----------------------------------------------------------------------------------------------------------
PARSE_ISO_DATETIME

Parses an ISO formatted date and time into respective date parts, time, and time zone offset from UTC.
Providing a time zone offset on its own is invalid for this function.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer         | Year
 2 | integer         | Month
 3 | integer         | Day
 4 | decimal [0..1]  | Time
 5 | decimal         | Time zone offset from UTC
   | [-0.625..0.625] | 

Parameters
-------------------------------------------------------------------------------------------------------------
ISODateTime        | text   | Date time in ISO format ie. yyyy-MM-ddThh:mm:ss+hh:mm
[AllowMixedStyles] | switch | Relax validation for no mixing of basic and extended formats. eg. yyyyMMddThh:mm
[JulianCalendar]   | switch | Validate in the Julian proleptic calendar. Default is Gregorian
                   |        | proleptic calendar.

Examples
-------------------------------------------------------------------------------------------------------------
PARSE_ISO_DATETIME("2023-05-23")
Returns: {2023, 5, 23, "", ""}

PARSE_ISO_DATETIME("2023-05-23T06:00")
Returns: {2023, 5, 23, 0.25, ""}

PARSE_ISO_DATETIME("T12:00")
Returns: {"", "", "", 0.5, ""}

PARSE_ISO_DATETIME("T12:0006:00")
Returns: {"", "", "", 0.5, -360}

PARSE_ISO_DATETIME("2023-05-23T+09:00")
Returns: {2023, 5, 23, "", 540}
----------------------------------------------------------------------------------------------------------*/
PARSE_ISO_DATETIME = LAMBDA(ISODateTime, [AllowMixedStyles], [JulianCalendar],
    IFS(
        IS_EMPTY(ISODateTime), {"", "", "", "", ""},
        NOT(VALIDATE_CHARSET("+,-.0123456789:TWZ" & UNICHAR(8722), ISODateTime)), {#VALUE!, "", "", "", ""},
        TRUE, LET(
            _Tpos, IFERROR(FIND("T", ISODateTime), 0),
            _parts, IF(_Tpos = 0, 
                HSTACK(ISODateTime, "", ""),
                LET(
                    _len, LEN(ISODateTime),
                    _datePart, LEFT(ISODateTime, _Tpos - 1),
                    _TZpos, FIND_NTH_CHAR("Z+-" & UNICHAR(8722), ISODateTime, 1, 0, _Tpos + 1),
                    IFS(
                        _TZpos = 0,
                        HSTACK(
                            _datePart,
                            RIGHT(ISODateTime, _len - _Tpos + 1),
                            ""
                        ),
                        _TZpos = _Tpos + 1,
                        HSTACK(
                            _datePart,
                            "",
                            RIGHT(ISODateTime, _len - _TZpos + 1)
                        ),
                        TRUE,
                        HSTACK(
                            _datePart,
                            MID(ISODateTime, _Tpos, _TZPos - _Tpos),
                            RIGHT(ISODateTime, _len - _TZpos + 1)
                        )
                    )
                )
            ),
            _failStyleCheck, IF(N(AllowMixedStyles) <> 0, FALSE,
                LET(
                    _fmtDate, IFS(
                        INDEX(_parts, 1, 1) = "", 3,
                        IFERROR(FIND("-", INDEX(_parts, 1, 1), 5), 0) > 0, 2,
                        TRUE, 1
                    ),
                    _fmtTime, IFS(
                        INDEX(_parts, 1, 2) = "", 3,
                        LEN(INDEX(_parts, 1, 2)) = 3, 3,
                        IFERROR(FIND(":", INDEX(_parts, 1, 2), 4), 0) > 0, 2,
                        TRUE, 1
                    ),
                    _fmtTZO, IFS(
                        INDEX(_parts, 1, 3) = "", 3,
                        CODE(INDEX(_parts, 1, 3)) = 90, 3,
                        LEN(INDEX(_parts, 1, 3)) = 3, 3,
                        IFERROR(FIND(":", INDEX(_parts, 1, 3), 4), 0) > 0, 2,
                        TRUE, 1
                    ),
                    IFS(
                        BITAND(_fmtDate, _fmtTime) = 0, TRUE,
                        BITAND(_fmtDate, _fmtTZO) = 0, TRUE,
                        BITAND(_fmtTime, _fmtTZO) = 0, TRUE,
                        TRUE, FALSE
                    )
                )
            ),
            IF(_failStyleCheck, {#N/A, "", "", "", ""},
                LET(
                    _time, PARSE_ISO_TIME(INDEX(_parts, 1, 2)),
                    _tzo, PARSE_ISO_TZO(INDEX(_parts, 1, 3)),
                    IF(INDEX(_parts, 1, 1) = "",
                        IF(IS_EMPTY(_time),
                            HSTACK("", "", "", {#VALUE!}, _tzo),
                            HSTACK("", "", "", _time, _tzo)
                        ),
                        LET(
                            _date, PARSE_ISO_CALENDAR_DATE(INDEX(_parts, 1, 1), JulianCalendar),
                            HSTACK(_date, _time, _tzo)
                        )
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
FORMAT_ISO_DATETIME

Returns a date, time and time zone offset as text in ISO format.

Output
-------------------------------------------------------------------------------------------------------------
 1 | text | ISO formatted date, time and time zone offset

Parameters
-------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] |
Day              | integer [1..31] |
[Time]           | decimal [0..1]  | Time of day as decimal fraction of a day.
[TZOMinutes]     | decimal         | Time zone offset from UTC in minutes
                 | [-900..900]     | Assumed to be UTC if ommitted. [-15:00..+15:00]
[Options]        | text            | String with elements: [B][<][LowOrder][Precision][Z]
                 |                 |        B : Display in basic format eg T0000
                 |                 |        < : Round by truncating components. Default is rounding to nearest.
                 |                 | LowOrder : low order component to display
                 |                 |     Null : Defaults to seconds if time present, otherwise day
                 |                 |        D : Day
                 |                 |        H : Hour
                 |                 |        M : Minute
                 |                 |        S : Second
                 |                 | Precision: [0-9] Only has an effect when low order component is seconds.
                 |                 |        Z : Display 'Z' for Zulu time zone +00:00
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar. 
----------------------------------------------------------------------------------------------------------*/
FORMAT_ISO_DATETIME = LAMBDA(YearCE, Month, Day, [Time], [TZOMinutes], [Options], [JulianCalendar],
    IF(IS_EMPTY(YearCE) * IS_EMPTY(Month) * IS_EMPTY(Day) * IS_EMPTY(Time), "",
        LET(
            _hasDate, ISNUMBER(YearCE) * ISNUMBER(Month) * ISNUMBER(Day),
            _hasTime, NOT(IS_EMPTY(Time)),
            IF(_hasDate + _hasTime = 0, {#VALUE!},
                LET(
                    _basic, IFERROR(SEARCH("B", Options), 0) > 0,
                    _truncate, IFERROR(FIND("<", Options), 0) > 0,
                    _tryLowOrderChar, SEARCH_NTH_CHAR("DHMS", Options, 1, 1),
                    _lowOrder, IFS(
                        INDEX(_tryLowOrderChar, 1, 1) = 0, IF(_hasTime, 4, 1),
                        INDEX(_tryLowOrderChar, 1, 2) = "D", 1,
                        INDEX(_tryLowOrderChar, 1, 2) = "H", 2,
                        INDEX(_tryLowOrderChar, 1, 2) = "M", 3,
                        INDEX(_tryLowOrderChar, 1, 2) = "S", 4
                    ),
                    _roundLevel, IF(_lowOrder < 4, _lowOrder - 4,
                        LET(
                            _tryPrecisionChar, FIND_NTH_CHAR("0123456789", Options, 1, 1),
                            IF(INDEX(_tryPrecisionChar, 1, 1) = 0, 0,
                                VALUE(INDEX(_tryPrecisionChar, 1, 2))
                            )
                        )
                     ),

                    _roundTime, IF(ISNUMBER(Time),
                        ROUND_TIMESPAN(Time, _roundLevel, _truncate),
                        0
                    ),
                    
                    _timeOutOfRange, ISERROR(Time) + (_roundTime < 0) + (_roundTime > 1) > 0,
                    
                    _rDate, IFS(
                        NOT(_hasDate), "",
                        NOT(IS_VALID_DATE(YearCE, Month, Day, JulianCalendar)), "#DATE!",
                        NOT(_hasTime), HSTACK(YearCE, Month, Day),
                        _timeOutOfRange, HSTACK(YearCE, Month, Day),
                        (Time = 1) * (_lowOrder > 1), HSTACK(YearCE, Month, Day),
                        _roundTime < 1, HSTACK(YearCE, Month, Day),
                        TRUE, LET(
                            // (_roundTime = 1) * (_lowOrder = 1) ie round to day
                            _MJDN, MODIFIED_JULIAN_DAY_NUMBER(YearCE, Month, Day, JulianCalendar),
                            MJDN_TO_CALENDAR_DATE(_MJDN + 1, JulianCalendar)
                        )
                    ),

                    _rTime, IFS(
                        _timeOutOfRange, "T#TIME!",
                        NOT(_hasTime), "",
                        _roundTime < 1, _roundTime,
                        (Time = 1) * (_lowOrder > 1), Time,
                        TRUE, 0 // (_roundTime = 1) * (_lowOrder = 1) ie round to day
                    ),
                    
                    _sDate, IF(NOT(ISNUMBER(INDEX(_rDate, 1, 1))), _rDate,
                        FORMAT_ISO_CALENDAR_DATE(
                            INDEX(_rDate, 1, 1),
                            INDEX(_rDate, 1, 2),
                            INDEX(_rDate, 1, 3),
                            _basic,
                            JulianCalendar
                        )
                    ),
                    _sTime, IFS(
                        NOT(ISNUMBER(_rTime)), _rTime,
                        _lowOrder = 1, "",
                        TRUE, FORMAT_ISO_TIME(_rTime, Options)
                    ),
                    _sTZO, IFERROR(FORMAT_ISO_TZO(TZOMinutes, Options), "#TZO!"),
                    IF((_sTime = "") * (_sTZO <> ""),
                        CONCAT(_sDate, "T", _sTZO),
                        CONCAT(_sDate, _sTime, _sTZO)
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
PARSE_LITERARY_YEAR

Returns a number representing the year relative to the common era from a given literary year.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer | YearCE. Note that 1 BC = 0 CE, 2 BC = -1 CE

Parameters
-------------------------------------------------------------------------------------------------------------
LiteraryYear | text | Literary year
----------------------------------------------------------------------------------------------------------*/
PARSE_LITERARY_YEAR = LAMBDA(LiteraryYear,
    IFS(
        IS_EMPTY(LiteraryYear), "",
        NOT(VALIDATE_CHARSET(" -+0123456789BCE" & UNICHAR(8722), LiteraryYear)), {#VALUE!},
        TRUE, LET(
            fnYearValue, LAMBDA(_text,
                LET(
                    _char1, LEFT(_text, 1),
                    _sign, IFS(
                        _char1 = "+", 1,
                        _char1 = "-", -1,
                        UNICODE(_char1) = 8722, -1,
                        TRUE, ""
                    ),
                    IF(_sign = "",
                        INT(VALUE(_text)),
                        _sign * INT(VALUE(RIGHT(_text, LEN(_text) -1)))
                    )
                )
            ),

            _litYear, SUBSTITUTE(SUBSTITUTE(LiteraryYear, ",", ""), " ", ""),
            _yearCE, IFS(
                RIGHT(_litYear, 3) = "BCE",
                    LET(
                        _sYear, LEFT(_litYear, LEN(_litYear) - 3),
                        1 - fnYearValue(_sYear)
                    ),
                RIGHT(_litYear, 2) = "CE",
                    LET(
                        _sYear, LEFT(_litYear, LEN(_litYear) - 2),
                        fnYearValue(_sYear)
                    ),
                TRUE, fnYearValue(_litYear)
            ),
            
            IFERROR(_yearCE, {#VALUE!})
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
FORMAT_LITERARY_YEAR

Returns a year formatted in literary style.

Output
-------------------------------------------------------------------------------------------------------------
 1 | text | Literary year

Parameters
-------------------------------------------------------------------------------------------------------------
YearCE          | integer | Note that 1 BC = 0 CE, 2 BC = -1 CE
[AlwaysShowEra] | switch  | Always apply BCE/CE suffix. If not used, only years less than 1000 show an era.
----------------------------------------------------------------------------------------------------------*/
FORMAT_LITERARY_YEAR = LAMBDA(YearCE, [AlwaysShowEra],
    IF(IS_EMPTY(YearCE), "",
        LET(
            _yearCE, INT(YearCE),
            _isCE, _yearCE >= 1,
            _year, IF(_isCE, _yearCE, 1 - _yearCE),
            _suffix, IFS(NOT(_isCE), " BCE",
                _yearCE < 1000, " CE",
                N(AlwaysShowEra) <> 0, " CE",
                TRUE, ""
            ),
            _year & _suffix
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
PARSE_LITERARY_DATE

Parses a literary date into respective parts of year, month, day and time of day.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer         | Year
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day
 4 | decimal [0..1]  | Time

Parameters
-------------------------------------------------------------------------------------------------------------
LiteraryDate     | text   | Literary date and time
[JulianCalendar] | switch | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |        | proleptic calendar. 

Examples
-------------------------------------------------------------------------------------------------------------
PARSE_LITERARY_DATE("Feb 25, 2014, 6:00")
Returns: {2014, 2, 25, 0.25}

PARSE_LITERARY_DATE("Dec 31, 2023, 24:00")
Returns: {2023, 12, 31, 1}

PARSE_LITERARY_DATE("Feb 25")
Returns: {"" , 2, 25, ""}
----------------------------------------------------------------------------------------------------------*/
PARSE_LITERARY_DATE = LAMBDA(LiteraryDate, [JulianCalendar],
    IF(IS_EMPTY(LiteraryDate), {"", "", "", ""},
        LET(
            fnParseTime, LAMBDA(_timePart,
                LET(
                    _tryTime, DATEVALUE(_timePart) + TIMEVALUE(_timePart),
                    IFS(
                        ISERROR(_tryTime), "",
                        _tryTime > 1, {#NUM!},
                        TRUE, _tryTime
                    )
                )
            ),

            fnParseDay, LAMBDA(_dayPart, _year, _month,
                LET(
                    _day, INT(VALUE(_dayPart)),
                    IFS(
                        _day <= 0, {#NUM!},
                        _day <= DAYS_IN_MONTH(_month, _year, JulianCalendar), _day,
                        TRUE, {#NUM!}
                    )
                )
            ),

            _parts, TRIM(TEXTSPLIT(LiteraryDate, ",")),
            _cols, COLUMNS(_parts),
            IFS(_cols = 1,
                LET(
                    _part1, INDEX(_parts, 1, 1),
                    _spacePos, IFERROR(FIND(" ", _part1), 0),
                    IF(_spacePos = 0, {#VALUE!, "", "", ""},
                        LET(
                            _month, PARSE_MONTH(LEFT(_part1, _spacePos - 1)),
                            _daysInMonth, DAYS_IN_MONTH(_month, 2000),
                            _remain, MID(_part1, _spacePos + 1, LEN(_part1) - _spacePos),
                            _denotedYear, IFERROR(FIND("C", _remain), 0) > 0,
                            _val, IF(_denotedYear, PARSE_LITERARY_YEAR(_remain),
                                INT(VALUE(_remain))
                            ), 
                            _day, IFS(_denotedYear, "",
                                _val <= 0, "",
                                _val <= _daysInMonth, _val,
                                TRUE, ""
                            ),
                            _year, IFS(_denotedYear, _val,
                                _val <= 0, _val,
                                _val <= _daysInMonth, "",
                                TRUE, _val
                            ),
                            HSTACK(_year, _month, _day, "")
                        )
                    )
                ),
                _cols = 2,
                LET(
                    _p1, INDEX(_parts, 1, 1),
                    _spacePos, IFERROR(FIND(" ", _p1), 0),
                    IF(_spacePos = 0, {#VALUE!, "", "", ""},
                        LET(
                            _month, PARSE_MONTH(LEFT(_p1, _spacePos - 1)),
                            _p2, INDEX(_parts, 1, 2),
                            _time, fnParseTime(_p2),
                            _year, IF(NOT(ISNUMBER(_time)), PARSE_LITERARY_YEAR(_p2), ""),
                            _dayPart, MID(_p1, _spacePos + 1, LEN(_p1) - _spacePos),
                            _day, fnParseDay(_dayPart, _year, _month),
                            HSTACK(_year, _month, _day, _time)
                        )
                    )
                ),
                _cols = 3,
                LET(
                    _year, PARSE_LITERARY_YEAR(INDEX(_parts, 1, 2)),
                    _time, fnParseTime(INDEX(_parts, 1, 3)),
                    _p1, INDEX(_parts, 1, 1),
                    _spacePos, IFERROR(FIND(" ", _p1), 0),
                    IF(_spacePos = 0, {#VALUE!, "", "", ""},
                        LET(
                            _month, PARSE_MONTH(LEFT(_p1, _spacePos - 1)),
                            _dayPart, MID(_p1, _spacePos + 1, LEN(_p1) - _spacePos),
                            _day, fnParseDay(_dayPart, 2000, _month),
                            HSTACK(_year, _month, _day, _time)
                        )
                    )
                ),
                TRUE, {#VALUE!, "", "", ""}
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
FORMAT_LITERARY_DATE

Returns a date formatted in literary style.

Output
-------------------------------------------------------------------------------------------------------------
 1 | text | Literary date

Parameters
-------------------------------------------------------------------------------------------------------------
YearCE                 | integer         | Note that 1 BC = 0 CE, 2 BC = -1 CE
Month                  | integer [1..12] |
Day                    | integer [1..31] |
[Time]                 | decimal [0..1]  | Time of day as decimal fraction of a day.
[Options]              | text            | [S][I][E]
                       |                 |  S : Display short form months
                       |                 |  I : Use International English instead of local language set in Excel
                       |                 |  E : Always apply BCE/CE suffix. If not used, only years less than 1000
                       |                 |      show an era.
[JulianCalendar]       | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                       |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
FORMAT_LITERARY_DATE = LAMBDA(YearCE, Month, Day, [Time], [Options], [JulianCalendar],
    IFS(
        IS_EMPTY(YearCE) * IS_EMPTY(Month) * IS_EMPTY(Day), "",
        NOT(ISNUMBER(Month)) + (NOT(ISNUMBER(YearCE)) * NOT(ISNUMBER(Day))), {#VALUE!},
        TRUE, LET(
            _short, IFERROR(SEARCH("S", Options), 0) > 0,
            _intEnglish, IFERROR(SEARCH("I", Options), 0) > 0,
            _era, IFERROR(SEARCH("E", Options), 0) > 0,

            fnFormatDate, LAMBDA(_carryDay,
                LET(
                    _yearCE, IF(YearCE = "", 2000, YearCE),
                    _day, IF(Day = "", 1, INT(Day)),
                    IF(NOT(IS_VALID_DATE(_yearCE, Month, _day, JulianCalendar)), "#DATE!",
                        LET(
                            _rDate, IF(_carryDay,
                                LET(
                                    _MJDN, MODIFIED_JULIAN_DAY_NUMBER(_yearCE, Month, _day, JulianCalendar),
                                    MJDN_TO_CALENDAR_DATE(_MJDN + 1)
                                ),
                                HSTACK(_yearCE, Month, _day)
                            ),
                            _sMonth, MONTH_NAME(INDEX(_rDate, 1, 2), _short, _intEnglish),
                            _sDay, IF(ISNUMBER(Day), " " & INDEX(_rDate, 1, 3), ""),
                            _sYear, IF(ISNUMBER(YearCE), ", " & FORMAT_LITERARY_YEAR(INDEX(_rDate, 1, 1), _era), ""),
                            CONCAT(_sMonth, _sDay, _sYear)
                        )
                    )
                )    
            ),

            fnFormatTime, LAMBDA(
                IFS(
                    IS_EMPTY(Time), {"", 0},
                    NOT(ISNUMBER(Time)), {" #TIME!", 0},
                    (Time < 0) + (Time > 1), {" #TIME!", 0},
                    TRUE, LET(
                        _rTime, ROUND_TIMESPAN(Time, -1, 0),
                        _carryDay, N((_rTime = 1) * (Time < 1)),
                        _fmt, IF(Time = 1, "[H]:mm", "h:mm AM/PM"),
                        HSTACK(
                            ", " & TEXT(_rTime, _fmt),
                            _carryDay
                        )
                    )
                )
            ),
                
            _rTime, fnFormatTime(),
            _sDate, fnFormatDate(INDEX(_rTime, 1, 2)),
            CONCAT(_sDate, INDEX(_rTime, 1, 1))
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
PARSE_US_DATE

Parses a US formated date into respective parts of year, month, day and time of day.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer         | Year
 2 | integer [1..12] | Month
 3 | integer [1..31] | Day
 4 | decimal [0..1)  | Time

Parameters
-------------------------------------------------------------------------------------------------------------
USDate           | text   | Date in US format ie. MM/dd/yyyy hh:mm:ss
[JulianCalendar] | switch | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |        | proleptic calendar. 

Examples
-------------------------------------------------------------------------------------------------------------
PARSE_US_DATE("1/25/2014 6:00")
Returns: {2014, 1, 25, 0.25}

PARSE_US_DATE("12/31/2023 24:00")
Returns: {2023, 12, 31, 1}
----------------------------------------------------------------------------------------------------------*/
PARSE_US_DATE = LAMBDA(USDate, [JulianCalendar], 
    IFS(
        IS_EMPTY(USDate), {"", "", "", ""},
        NOT(VALIDATE_CHARSET(" ,-./0123456789:AMPTamp_" & UNICHAR(8722), USDate)), {#VALUE!},
        TRUE, LET(
            _tryDate, DATEVALUE(USDate),
            _tryTime, TIMEVALUE(USDate),
            _isTimeOnly, IFS(
                ISERROR(_tryTime), FALSE,
                ISERROR(_tryDate), FALSE,
                TRUE, ISNUMBER(_tryTime) * (_tryDate = 0)
            ),
            IF(_isTimeOnly, HSTACK("", "", "", _tryTime),
                LET( 
                    fnYearValue, LAMBDA(_text,
                        LET(
                            _char1, LEFT(_text, 1),
                            _sign, IFS(
                                _char1 = "+", 1,
                                _char1 = "-", -1,
                                UNICODE(_char1) = 8722, -1,
                                TRUE, ""
                            ),
                            IF(_sign = "",
                                INT(VALUE(_text)),
                                _sign * INT(VALUE(RIGHT(_text, LEN(_text) - 1)))
                            )
                        )
                    ),

                    _pos1, FIND_NTH_CHAR(",./-_", USDate, 1),
                    _pos2, FIND_NTH_CHAR(",./-_", USDate, 2),
                    _pos3, IF(_pos2 = 0, 0, FIND_NTH_CHAR(",./-_T ", USDate, 1, 0, _pos2 + 2)),
                    _pos4, IF(_pos3 = 0, 0, FIND_NTH_CHAR("0123456789", USDate, 1, 0, MAX(_pos2, _pos3) + 1)),
                    _month, IF(_pos1 = 0, {#VALUE!},
                        INT(VALUE(LEFT(USDate, _pos1 - 1)))
                    ),
                    _year, IF(ISERROR(_month), {#VALUE!},
                        fnYearValue(
                            IF(_pos3 = 0,
                                RIGHT(USDate, LEN(USDate) - _pos2),
                                MID(USDate, _pos2 + 1, _pos3 - _pos2 - 1)
                            )
                        )
                    ),
                    _time, IF(_pos4 = 0, "",
                        LET(
                            _timePart, RIGHT(USDate, LEN(USDate) - _pos4 + 1),
                            _timeVal, DATEVALUE(_timePart) + TIMEVALUE(_timePart),
                            IF(_timeVal >= 1, {#NUM!}, _timeVal)
                        )
                    ),
                    _day, IF(_pos2 = 0, {#VALUE!},
                        LET(
                            _d, INT(VALUE(MID(USDate, _pos1 + 1, _pos2 - _pos1 - 1))),
                            IF(NOT(IFERROR(IS_VALID_DATE(_year, _month, _d, JulianCalendar), FALSE)), {#NUM!},
                                _d
                            )
                        )
                    ),
                    HSTACK(_year, _month, _day, _time)
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
FORMAT_US_DATE

Returns a date formatted in the US style.

Output
-------------------------------------------------------------------------------------------------------------
 1 | text | US style date

Parameters
-------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] |
Day              | integer [1..31] |
[Time]           | decimal [0..1)  | Time of day as decimal fraction of a day.
[Options]        | text            | String with elements: [<][LowOrder][DateSeparator][TimeSeparator]
                 |                 |      LowOrder : low order component to display
                 |                 |          Null : Defaults to minutes if time present, otherwise day
                 |                 |             D : Day
                 |                 |             H : Hour
                 |                 |             M : Minute
                 |                 |             S : Second
                 |                 |             T : Millisecond (ticks)
                 |                 |             < : Round by truncating components. Default is rounding to nearest.
                 |                 | DateSeparator : Character to separate date components. [,./-_]
                 |                 | TimeSeparator : Character to separate time components. [,.:-_]
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar. 
----------------------------------------------------------------------------------------------------------*/
FORMAT_US_DATE = LAMBDA(YearCE, Month, Day, [Time], [Options], [JulianCalendar],
    IF(IS_EMPTY(YearCE) * IS_EMPTY(Month) * IS_EMPTY(Day) * IS_EMPTY(Time),  "",
       LET( 
            _hasTime, ISNUMBER(Time),
            _hasDate, ISNUMBER(YearCE) * ISNUMBER(Month) * ISNUMBER(Day),
            IF(NOT(_hasDate + _hasTime), {#VALUE!},
                LET(
                    fnFormatDate, LAMBDA(_separator, _carryDay,
                        IF(NOT(IS_VALID_DATE(YearCE, Month, Day, JulianCalendar)), "#DATE!",
                            LET(
                                _rDay, INT(Day),
                                _rDate, IF(_carryDay,
                                    LET(
                                        _MJDN, MODIFIED_JULIAN_DAY_NUMBER(YearCE, Month, _rday, JulianCalendar),
                                        MJDN_TO_CALENDAR_DATE(_MJDN + 1)
                                    ),
                                    HSTACK(YearCE, Month, _rDay)
                                ),
                                _sYear, TEXT(INDEX(_rDate, 1, 1), "0000;" & UNICHAR(8722) & "0000;0000"),
                                _sMonth, TEXT(INDEX(_rDate, 1, 2), "0"),
                                _sDay, TEXT(INDEX(_rDate, 1, 3), "0"),
                                CONCAT(_sMonth, _separator, _sDay, _separator, _sYear)
                            )
                        )
                    ),
                                        
                    fnFormatTime, LAMBDA(_lowOrder, _truncate, _separator,
                        IFS(
                            IS_EMPTY(Time), {"", 0},
                            NOT(ISNUMBER(Time)), {"#TIME!", 0},
                            (Time < 0) + (Time > 1), {" #TIME!", 0},
                            TRUE, LET(
                                _roundLevel, IF(_lowOrder = 5, 3, _lowOrder - 4),
                                _rTime, ROUND_TIMESPAN(Time, _roundLevel, _truncate),
                                _carryDay, N(_rTime = 1),
                                _fmt, IFS(
                                    _lowOrder = 1, "",
                                    _lowOrder = 2, "h AM/PM",
                                    _lowOrder = 3, "h\" & _separator & "mm AM/PM",
                                    _lowOrder = 4, "h\" & _separator & "mm\" & _separator & "ss AM/PM",
                                    _lowOrder = 5, "h\" & _separator & "mm\" & _separator & "ss.000 AM/PM"
                                ),
                                _sTime, TEXT(_rTime, _fmt),
                                HSTACK(_sTime, _carryDay)
                            )
                        )
                    ),

                    _truncate, IFERROR(FIND("<", Options), 0) > 0,
                    _lowOrder, IF(NOT(_hasTime), 1,
                        LET(
                            _tryLowOrderChar, SEARCH_NTH_CHAR("DHMST", Options, 1, 1),
                            IFS(
                                INDEX(_tryLowOrderChar, 1, 1) = 0, 3,
                                INDEX(_tryLowOrderChar, 1, 2) = "D", 1,
                                INDEX(_tryLowOrderChar, 1, 2) = "H", 2,
                                INDEX(_tryLowOrderChar, 1, 2) = "M", 3,
                                INDEX(_tryLowOrderChar, 1, 2) = "S", 4,
                                INDEX(_tryLowOrderChar, 1, 2) = "T", 5
                            )
                        )
                    ),
            
                    _tryDateSepChar, FIND_NTH_CHAR(",./-_", Options, 1, 1),
                    _dateSeparator, IF(INDEX(_tryDateSepChar, 1, 1) = 0, "/",
                        INDEX(_tryDateSepChar, 1, 2)
                    ),
                    _tryTimeSepChar, FIND_NTH_CHAR(",.:-_", Options, 1, 1, INDEX(_tryDateSepChar, 1, 1) + 1),
                    _timeSeparator, IF(INDEX(_tryTimeSepChar, 1, 1) = 0, ":",
                        INDEX(_tryTimeSepChar, 1, 2)
                    ),
                    
                    IFS(
                        _hasDate * _hasTime, LET(
                            _rTime, fnFormatTime(_lowOrder, _truncate, _timeSeparator),
                            _sDate, fnFormatDate(_dateSeparator, INDEX(_rTime, 1, 2)),
                            CONCAT(_sDate, " ", INDEX(_rTime, 1 ,1))
                        ),
                        _hasTime, LET(
                            // no date, time only
                            _rTime, fnFormatTime(_lowOrder, _truncate, _timeSeparator),
                            INDEX(_rTime, 1 ,1)
                        ),
                        TRUE, fnFormatDate(_dateSeparator, 0) // date only
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
PARSE_MIL_DTG

Parses a date-time group in the format used by US Military message traffic, into respective parts of year,
month, day, time of day and time zone offset in minutes.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer [1951..2050] | Year
 2 | integer [1..12]      | Month
 3 | integer [1..31]      | Day
 4 | decimal [0..1)       | Time
 5 | decimal [-900..900]  | Time zone offset minutes

Parameters
-------------------------------------------------------------------------------------------------------------
DTG | text | Date-time group in US Military format ie. ddHHmmssZmmmYY

Examples
-------------------------------------------------------------------------------------------------------------
PARSE_MIL_DTG("12 15 30 45 B MAY 23")
Returns: {2023, 5, 12, 0.77118055, 120}

PARSE_MIL_DTG("05064515KJUN00")
Returns: {2000, 6, 5, 0.281423611, 600}

PARSE_MIL_DTG("150600Z")
Returns: {"", "", 15, 0.25, 0}
----------------------------------------------------------------------------------------------------------*/
PARSE_MIL_DTG = LAMBDA(DTG,
    LET(
        _DTG, SUBSTITUTE(DTG, " ", ""),
        IFS(
            IS_EMPTY(_DTG), {"", "", "", "", ""},
            NOT(VALIDATE_CHARSET("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ", _DTG)), {#VALUE!, "", "", "", ""},
            TRUE, LET(
                fnYear, LAMBDA(_sYear,
                    LET(
                        _yy, VALUE(_sYear),
                        IF(_yy < 51, 2000 + _yy, 1900 + _yy)
                    )
                ),

                fnTime, LAMBDA(_hour, _minute, _second,
                    IF(NOT(IS_VALID_TIME_OF_DAY(_hour, _minute, _second, 0)), {#NUM!},
                        TIMESPAN(1, 0, _hour, _minute, _second)
                    )
                ),

                fnParseTZ, LAMBDA(_tzChar,
                    LET(
                        _code, CODE(_tzChar) - 64,
                        IFS(
                            _code = 26, 0, // Z = UTC
                            _code = 10, "", // J = Local Time
                            _code <= 0, {#VALUE!},
                            _code <= 9, _code * 60, // ABCDEFGHI -> +1..+9
                            _code <= 13, (_code - 1) * 60,  // KLM -> +10..+12
                            _code <= 25, (13 - _code) * 60, // NOPQRSTUVWXY -> -1..-12
                            TRUE, {#VALUE!}
                        )
                    )
                ),

                fnParseFull, LAMBDA(_DTG,
                    LET(
                        _day, VALUE(LEFT(_DTG, 2)),
                        _month, PARSE_MONTH(MID(_DTG, 10, 3)),
                        _year, fnYear(RIGHT(_DTG, 2)),
                        IF(NOT(IS_VALID_DATE(_year, _month, _day, 0)), {#VALUE!, "", "", "", ""},
                            LET(
                                _hour, VALUE(MID(_DTG, 3, 2)),
                                _minute, VALUE(MID(_DTG, 5, 2)),
                                _second, VALUE(MID(_DTG, 7, 2)),
                                _time, fnTime(_hour, _minute, _second),
                                _tz, fnParseTZ(MID(_DTG, 9, 1)),
                                HSTACK(
                                    _year,
                                    _month,
                                    _day,
                                    _time,
                                    _tz
                                )
                            )
                        )
                    )
                ),

                fnParseShort, LAMBDA(_DTG,
                    LET(
                        _day, VALUE(LEFT(_DTG, 2)),
                        _month, PARSE_MONTH(MID(_DTG, 8, 3)),
                        _year, fnYear(RIGHT(_DTG, 2)),
                        IF(NOT(IS_VALID_DATE(_year, _month, _day, 0)), {#VALUE!, "", "", "", ""},
                            LET(
                                _hour, VALUE(MID(_DTG, 3, 2)),
                                _minute, VALUE(MID(_DTG, 5, 2)),
                                _time, fnTime(_hour, _minute, 0),
                                _tz, fnParseTZ(MID(_DTG, 7, 1)),
                                HSTACK(
                                    _year,
                                    _month,
                                    _day,
                                    _time,
                                    _tz
                                )
                            )
                        )
                    )
                ),

                fnParsePlan, LAMBDA(_DTG,
                    LET(
                        _day, VALUE(LEFT(_DTG, 2)),
                        _hour, VALUE(MID(_DTG, 3, 2)),
                        _minute, VALUE(MID(_DTG, 5, 2)),
                        _time, fnTime(_hour, _minute, 0),
                        _tz, fnParseTZ(MID(_DTG, 7, 1)),
                        HSTACK(
                            "",
                            "",
                            _day,
                            _time,
                            _tz
                        )
                    )
                ),

                _len, LEN(_DTG),
                _fmt, IFS(_len = 14, "F", 
                    _len = 12, "S",
                    _len = 7, "P",
                    TRUE, #N/A
                ),
                IFS(
                    ISNA(_fmt), {#VALUE!, "", "", "", ""},
                    _fmt = "F", fnParseFull(_DTG),
                    _fmt = "S", fnParseShort(_DTG),
                    _fmt = "P", fnParsePlan(_DTG)
                )
            )
        )
    )
);

/*--------------------------------------------------------------------------------------------------------
FORMAT_MIL_DTG

Returns a date formatted in US Military message traffic style.

Output
----------------------------------------------------------------------------------------------------------
 1 | text | DTG formatted date

Parameters
----------------------------------------------------------------------------------------------------------
Year         | integer         |
             | [1951..2050]    |
Month        | integer [1..12] |
Day          | integer [1..31] |
Time         | decimal [0..1)  | Time of day as decimal fraction of a day.
[TZOMinutes] | decimal         | Time zone offset from UTC in minutes
             | [-900..900]     | Assumed to be UTC if ommitted. [-15:00..+15:00]
             |                 | Time will be converted if the offset does not align with military
             |                 | time zones.
[Options]    | text            | String with elements: [S][_][<]
             |                 |  S : Short format, ommits seconds
             |                 |  _ : Spacing between components
             |                 |  < : Round by truncating components. Default is rounding to nearest.

Examples
----------------------------------------------------------------------------------------------------------
FORMAT_MIL_DTG(2023, 2, 12, 0.75, 600, 1)
Returns: 121800KFEB23

FORMAT_MIL_DTG( , , 12, 0.25)
Returns: 120600J
--------------------------------------------------------------------------------------------------------*/
FORMAT_MIL_DTG = LAMBDA(Year, Month, Day, Time, [TZOMinutes], [Options],
    IFS(
        IS_EMPTY(Year) * IS_EMPTY(Month) * IS_EMPTY(Day) * IS_EMPTY(Time), "",
        NOT(IS_NUMERIC_NULL(Year)), {#VALUE!},
        NOT(IS_NUMERIC_NULL(Month)), {#VALUE!},
        NOT(IS_NUMERIC_NULL(Day)), {#VALUE!},
        NOT(IS_EMPTY(Month)) * NOT(IS_VALID_DATE(Year, Month, Day, 0)), "#DATE!",
        TRUE, LET(
            _tzo, N(TZOMinutes),
            _short, IFERROR(SEARCH("S", Options), 0) > 0,
            _spacing, IFERROR(FIND("_", Options), 0) > 0,
            _truncate, IFERROR(FIND("<", Options), 0) > 0,
            
            fnFmtTime, LAMBDA(_time,
                LET(
                    _timeFmt, IF(N(_short), "BM<", "BS<"),
                    _sTime, FORMAT_ISO_TIME(_time, _timeFmt),
                    RIGHT(_sTime, LEN(_sTime) - 1)
                )
            ),

            fnResolveMilitaryTZ, LAMBDA(
                IFS(
                    IS_EMPTY(TZOMinutes), HSTACK(N(Time), "J"),
                    _tzo > 720, LET(
                        _shiftTZO, (_tzo - 720) / 1440,
                        _time, N(Time) - _shiftTZO,  
                        HSTACK(_time, "M")
                    ),
                    _tzo < -720, LET(
                        _shiftTZO, (_tzo + 720) / 1440,
                        _time, N(Time) - _shiftTZO,  
                        HSTACK(_time, "Y")
                    ),
                    TRUE, LET(
                        _militaryTZO, SIGN(_tzo) * MROUND(ABS(_tzo), 60),
                        _shiftTZO, (_tzo - _militaryTZO) / 1440,
                        _time, N(Time) - _shiftTZO,
                        _idx, INT(_militaryTZO / 60) + 13,
                        _militaryTZ, CHOOSE(_idx, "Y", "X", "W", "V", "U", "T", "S", "R", "Q", "P", "O", "N", "Z", "A", "B", "C", "D", "E", "F", "G", "H", "I", "K", "L", "M"),
                        HSTACK(_time, _militaryTZ)
                    )
                )
            ),
    
            _day, INT(Day),
            _militaryTime, fnResolveMilitaryTZ(),
            _nominalYear, IF(IS_EMPTY(Year), 2000, Year),
            _nominalMonth, IF(IS_EMPTY(Year), 3, Month),
            _rDate, IF(INDEX(_militaryTime, 1, 1) < 1,
                HSTACK(_nominalYear, _nominalMonth, _day, INDEX(_militaryTime, 1, 1)),
                LET(
                    _MJDN, MODIFIED_JULIAN_DAY_NUMBER(_nominalYear, _nominalMonth, _day, 0),
                    _rTime, INDEX(_militaryTime, 1, 1) - 1,
                    HSTACK(
                        MJDN_TO_CALENDAR_DATE(_MJDN + 1, 0),
                        _rTime
                    )
                )
            ),
            _sDay, TEXT(INDEX(_rDate, 3), "00"),
            IF(IS_EMPTY(Year),
                CONCAT(_sDay, fnFmtTime(INDEX(_rDate, 4)), INDEX(_militaryTime, 1, 2)),
                IF((INDEX(_rDate, 1) < 1951) + (INDEX(_rDate, 1) > 2050), "#RANGE!",
                    LET(
                        _sTime, fnFmtTime(INDEX(_rDate, 4)),
                        _sMonth, UPPER(MONTH_NAME(INDEX(_rDate, 2), 1, 1)),
                        _sYY, RIGHT(TEXT(INDEX(_rDate, 1), "00"), 2),
                        CONCAT(_sDay, _sTime, INDEX(_militaryTime, 1, 2), _sMonth, _sYY)
                    )
                )
            )
        )
    )
);















/*###########################################################################################################
# ORDINAL DATES                                                                                             #
###########################################################################################################*/


/*----------------------------------------------------------------------------------------------------------
IS_VALID_ORDINAL_DATE

Tests if an ordinal date is valid for the given calendar.

Output
-------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
-------------------------------------------------------------------------------------------------------------
YearCE           | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
OrdinalDay       | decimal [1..367) | Day of year
[JulianCalendar] | switch           | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                  | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
IS_VALID_ORDINAL_DATE = LAMBDA(YearCE, OrdinalDay, [JulianCalendar],
    IFS(
        NOT(ISNUMBER(YearCE)) + NOT(ISNUMBER(OrdinalDay)), FALSE, // cannot ommit year or ordinal day
        NOT(IS_INTEGER(YearCE)), FALSE, // year cannot be fractional
        TRUE, LET(
            _ordinalDay, INT(OrdinalDay),
            IF(_ordinalDay < 1, FALSE,
                LET(
                    _daysInYear, DAYS_IN_YEAR(YearCE, JulianCalendar),
                    _ordinalDay <= _daysInYear
                )
            )
        )
    )
);

/*----------------------------------------------------------------------------------------------------------
PARSE_ISO_ORDINAL_DATE

Parses an ISO formatted ordinal date into respective parts of year, and ordinal day.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer          | YearCE
 2 | integer [1..366] | Ordinal day

Parameters
-------------------------------------------------------------------------------------------------------------
ISOOrdinalDate   | text   | Date in ISO format ie. yyyy-ddd
[JulianCalendar] | switch | Validate in the Julian proleptic calendar. Default is Gregorian
                 |        | proleptic calendar.

Examples
-------------------------------------------------------------------------------------------------------------
PARSE_ISO_ORDINAL_DATE("2023-223")
Returns: {2023, 223}

PARSE_ISO_ORDINAL_DATE("1900-366", 1)
Returns: {2023, 366} i.e. 1900 was a leap year in the Julian calendar
----------------------------------------------------------------------------------------------------------*/
PARSE_ISO_ORDINAL_DATE = LAMBDA(ISOOrdinalDate, [JulianCalendar],
    IFS(
        IS_EMPTY(ISOOrdinalDate), {"", ""},
        NOT(VALIDATE_CHARSET("+-0123456789" & UNICHAR(8722), ISOOrdinalDate)), {#VALUE!, ""},
        TRUE, LET(
            _firstChar, LEFT(ISOOrdinalDate, 1),
            _isSigned, IFS(
                _firstChar = "+", TRUE,
                _firstChar = "-", TRUE,
                _firstChar = UNICHAR(8722), TRUE,
                TRUE, FALSE
            ),
            _sign, IFS(
                NOT(_isSigned), 1,
                _firstChar = "-", -1,
                _firstChar = UNICHAR(8722), -1,
                TRUE, 1
            ),
            _unSigned, IF(_isSigned,
                RIGHT(ISOOrdinalDate, LEN(ISOOrdinalDate) - 1),
                ISOOrdinalDate
            ),
            _len, LEN(_unSigned),
            _pattern, REPLACE_CHARS(_unSigned, "0123456789", "_"),
            _tryParse, IFS(
                _len >= 8, IF(
                    _pattern = RIGHT("_______________-___", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 4)),
                        VALUE(RIGHT(_unSigned, 3))
                    ),
                    ""
                ),
                _len = 7, IF(
                    _pattern = "_______",
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 3)),
                        VALUE(RIGHT(_unSigned, 3))
                    ),
                    ""
                ),
                (_len >= 4) * (_len <= 5), IF(
                    _pattern = RIGHT("_____", _len),
                    HSTACK(
                        VALUE(_unSigned),
                        ""
                    ),
                    ""
                ),
                TRUE, #N/A
            ),

            IF(ISERROR(INDEX(_tryParse, 1, 1)), {#VALUE!, ""},
                LET(
                    _year, _sign * INDEX(_tryParse, 1, 1),
                    _ordinalDay, INDEX(_tryParse, 1, 2),
                    IFS(
                        _ordinalDay = "", HSTACK(_year, ""),
                        IS_VALID_ORDINAL_DATE(_year, _ordinalDay, JulianCalendar),
                            HSTACK(_year, _ordinalDay),
                        TRUE,
                            HSTACK(_year, {#NUM!})
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
FORMAT_ISO_ORDINAL_DATE

Returns an ordinal date as text in ISO format.

Output
-------------------------------------------------------------------------------------------------------------
 1 | text | ISO formatted ordinal date

Parameters
-------------------------------------------------------------------------------------------------------------
YearCE           | integer          | Note that 1 BC = 0 CE, 2 BC = -1 CE
OrdinalDay       | integer [1..366] |
[Basic]          | switch           | Display in basic format eg yyyyddd.
                 |                  | Invalid when OrdinalDay provided and YearCE outside of range -9999..9999
                 |                  | due to collision with yyyyMMdd ISO format.
[JulianCalendar] | switch           | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                  | proleptic calendar. 
----------------------------------------------------------------------------------------------------------*/
FORMAT_ISO_ORDINAL_DATE = LAMBDA(YearCE, OrdinalDay, [Basic], [JulianCalendar],
    IFS(
        IS_EMPTY(YearCE) * IS_EMPTY(OrdinalDay), "",
        NOT(ISNUMBER(YearCE)), {#VALUE!},
        NOT(IS_NUMERIC_NULL(OrdinalDay)), {#VALUE!},
        IS_EMPTY(OrdinalDay), FORMAT_ISO_Year(YearCE),
        TRUE, LET(
            _basic, N(Basic) <> 0,
            IF(_basic * (ABS(YearCE) > 9999), {#VALUE!},
                LET(
                    _delim, IF(_basic, "", "-"),
                    IF(NOT(IS_VALID_ORDINAL_DATE(YearCE, OrdinalDay, JulianCalendar)), {#NUM!},
                        CONCAT(
                            FORMAT_ISO_Year(YearCE),
                            _delim, TEXT(OrdinalDay, "000")
                        )
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
ORDINAL_DATE_TO_MJDATE

Converts an ordinal date and time in the specified calendar to a Modified Julian Date (MJDATE).

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer | Modified Julian Date

Parameters
-------------------------------------------------------------------------------------------------------------
YearCE           | integer          | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
OrdinalDay       | integer [1..366] | Day of year, carries if range exceeded
[Time]           | decimal [0..1)   | Time of day
[JulianCalendar] | switch           | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                  | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
ORDINAL_DATE_TO_MJDATE = LAMBDA(YearCE, OrdinalDay, [Time], [JulianCalendar],
    IFS(
        (YearCE = "") * (OrdinalDay = "") * (Time = ""), "",
        NOT(ISNUMBER(YearCE)) + NOT(ISNUMBER(OrdinalDay)), {#VALUE!},
        TRUE, LET(
            _ordinalDay, INT(OrdinalDay),
            _MJDNYear, MODIFIED_JULIAN_DAY_NUMBER(YearCE, 1, 1, JulianCalendar) - 1,
            _MJDNYear + _ordinalDay + N(Time)
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
MJDATE_TO_ORDINAL_DATE

Converts a Modified Julian Date (MJDATE) to an ordinal date and time in the specified calendar.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer           | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
 2 | integer [1..366]  | Ordinal day
 3 | decimal [0..1)    | Time of day
 4 | integer [365,366] | Days in year

Parameters
-------------------------------------------------------------------------------------------------------------
MJDate           | decimal | Modified Julian Date
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
MJDATE_TO_ORDINAL_DATE = LAMBDA(MJDate, [JulianCalendar],
    IFS(
        MJDate = "", {"", "", "", ""},
        NOT(ISNUMBER(MJDate)), {#VALUE!, "", "", ""},
        TRUE, LET(
            _cDate, MJDATE_TO_CALENDAR_DATE(MJDate, JulianCalendar),
            _yearCE, INDEX(_cDate, 1, 1),
            _MJDNYear, MODIFIED_JULIAN_DAY_NUMBER(_yearCE, 1, 1, JulianCalendar) - 1,
            _ordinalDay, INT(MJDate - _MJDNYear),
            _daysInYear, DAYS_IN_YEAR(_yearCE, JulianCalendar),
            HSTACK(
                _yearCE,
                _ordinalDay,
                INDEX(_cDate, 1, 4),
                _daysInYear
            )
        )
    )
);












/*###########################################################################################################
# WEEKS                                                                                                     #
###########################################################################################################*/


/*----------------------------------------------------------------------------------------------------------
CONVERT_WEEKDAY_NUMBER

Returns an integer for the day of the week from the traditonal numbering scheme to the ISO definition, or
vice versa.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer | Weekday number
   | [1..7]  |    | ISO       | Traditioal
   |         | ---------------------------
   |         |  1 | Monday    | Sunday 
   |         |  2 | Tuesday   | Monday 
   |         |  3 | Wednesday | Tuesday
   |         |  4 | Thursday  | Wednesday
   |         |  5 | Friday    | Thursday
   |         |  6 | Saturday  | Friday
   |         |  7 | Sunday    | Saturday

Parameters
-------------------------------------------------------------------------------------------------------------
DayOfWeek          | integer [1..7] | Day of week number
[ISOtoTraditional] | switch         | Return day of week using traditional numbering scheme, assuming 
                   |                | DayOfWeek was provided according to ISO definition.
                   |                | Default is to return in ISO definition, assuming DayOfWeek was
                   |                | provided according to the traditional numbering scheme.
----------------------------------------------------------------------------------------------------------*/
CONVERT_WEEKDAY_NUMBER = LAMBDA(DayOfWeek, [ISOtoTraditional],
    IFS(
        DayOfWeek = "", "",
        NOT(ISNUMBER(DayOfWeek)), {#VALUE!},
        TRUE, LET(
            _givenDoW, INT(N(DayOfWeek)),
            _fromISO, N(ISOtoTraditional) <> 0, 
            _shiftDoW, _givenDow + IF(_fromISO, 0, -2),
            MOD(_shiftDow, 7) + 1
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
PARSE_WEEKDAY

Returns a number representing the day of the week from a given text weekday name.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer | Weekday number
   | [1..7]  |    | ISO       | Traditioal
   |         | ---------------------------
   |         |  1 | Monday    | Sunday 
   |         |  2 | Tuesday   | Monday 
   |         |  3 | Wednesday | Tuesday
   |         |  4 | Thursday  | Wednesday
   |         |  5 | Friday    | Thursday
   |         |  6 | Saturday  | Friday
   |         |  7 | Sunday    | Saturday

Parameters
-------------------------------------------------------------------------------------------------------------
DayOfWeekText | text   | Day of week name
[Traditional] | switch | Return day of week using traditional numbering scheme.

Examples
-------------------------------------------------------------------------------------------------------------
PARSE_WEEKDAY("Saturday")
Returns: 6

PARSE_WEEKDAY("Mon", 1)
Returns: 2

PARSE_WEEKDAY("Thurs")
Returns: #VALUE!

PARSE_WEEKDAY("Ven")
Returns: 5 (Friday, if local language is set to Italian)
----------------------------------------------------------------------------------------------------------*/
PARSE_WEEKDAY = LAMBDA(DayOfWeekText, [Traditional],
    IF(DayOfWeekText = "", "",
        LET(
            fnMatchIntEng, LAMBDA(DoW,
                LET(
                    _dow, IF(LEN(DayOfWeekText) = 3,
                        XMATCH(
                            DayOfWeekText,
                            {
                                "Mon";
                                "Tue";
                                "Wed";
                                "Thu";
                                "Fri";
                                "Sat";
                                "Sun"
                            }
                        ),
                        XMATCH(
                            DayOfWeekText,
                            {
                                "Monday";
                                "Tuesday";
                                "Wednesday";
                                "Thursday";
                                "Friday";
                                "Saturday";
                                "Sunday"
                            }
                        )
                    ),
                    IFNA(_dow, 0)
                )
            ),
            fnMatchLocalLang, LAMBDA(DoW,
                LET(
                    _days, SEQUENCE(7, 1, 36528),
                    _dow, IF(LEN(DayOfWeekText) = 3,
                        XMATCH(DayOfWeekText, TEXT(_days, "ddd")),
                        XMATCH(DayOfWeekText, TEXT(_days, "dddd"))
                    ),
                    IFNA(_dow, 0)
                )
            ),
            _ISOWeekday, LET(
                _idx, fnMatchIntEng(DayOfWeekText),
                IF(_idx > 0, _idx, fnMatchLocalLang(DayOfWeekText))
            ),
            IFS(_ISOWeekday = 0, {#VALUE!},
                N(Traditional) = 0, _ISOWeekday,
                TRUE, MOD(_ISOWeekday, 7) + 1
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
WEEKDAY_NAME

Returns name of an ISO day of week number as text.

Output
-------------------------------------------------------------------------------------------------------------
 1 | text | Weekday

Parameters
-------------------------------------------------------------------------------------------------------------
ISOWeekDay             | integer [1..7] | ISO day of week number
[Short]                | switch         | Return short format Mon..Sun
[InternationalEnglish] | switch         | International English instead of local language set in Excel
----------------------------------------------------------------------------------------------------------*/
WEEKDAY_NAME = LAMBDA(ISOWeekDay, [Short], [InternationalEnglish],
    IFS(
        ISOWeekDay = "", "",
        NOT(ISNUMBER(ISOWeekDay)), {#VALUE!},
        TRUE, LET(
            _useShort, N(Short) <> 0,
            _useLocalLang, N(InternationalEnglish) = 0,
            _isoDoW, MOD(INT(ISOWeekDay) - 1, 7) + 1, 
            IF(_useLocalLang,
                LET(
                    _y2krefDay, 36527 + _isoDoW,
                    _fmt, IF(_useShort, "ddd", "dddd"),
                    TEXT(_y2krefDay, _fmt)
                ),
                IF(
                    _useShort,
                    CHOOSE(_isoDoW,
                        "Mon",
                        "Tue",
                        "Wed",
                        "Thu",
                        "Fri",
                        "Sat",
                        "Sun"
                    ),
                    CHOOSE(_isoDoW,
                        "Monday",
                        "Tuesday",
                        "Wednesday",
                        "Thursday",
                        "Friday",
                        "Saturday",
                        "Sunday"
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
DAY_OF_WEEK

Returns an integer for the day of the week for a given Modified Julian Date.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer [1..7] | ISO day of week number
   |                | Monday..Sunday

Parameters
-------------------------------------------------------------------------------------------------------------
MJDate | decimal | Modified Julian Date
----------------------------------------------------------------------------------------------------------*/
DAY_OF_WEEK = LAMBDA(MJDate,
    IFS(
        MJDate = "", "",
        NOT(ISNUMBER(MJDate)), {#VALUE!},
        TRUE, LET(
            _MJDN, INT(MJDate),
            MOD(_MJDN + 2, 7) + 1
        )
    )
);




/*----------------------------------------------------------------------------------------------------------
WEEKDAY_OF_MONTH

Returns a Modified Julian Date for a given day of week, relative week for the month, year and time of day
of the specified calendar.

Output
-------------------------------------------------------------------------------------------------------------
 1 | decimal | Modified Julian Date

Parameters
-------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
Month            | integer [1..12] | Month of the year
WeekOfMonth      | integer [-4..5] | Week in the month.
                 |                 | Note if the reference exceeds the bounds of the month, another month
                 |                 | will be returned.
                 |                 |  0 - last week of previous month
                 |                 |  1 - first week
                 |                 |  2 - second week
                 |                 |  3 - third week
                 |                 |  4 - fourth week
                 |                 |  5 - fifth week
                 |                 | -1 - last week
                 |                 | -2 - second to last week
                 |                 | -3 - third to last week
                 |                 | -4 - fourth to last week
ISOWeekDay       | integer [1..7]  | ISO day of week number Monday..Sunday
[Time]           | decimal [0..1)  | Time of day
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
    
Examples
-------------------------------------------------------------------------------------------------------------
WEEKDAY_OF_MONTH(2023, 6, 0, 7)
Returns: MJDate 60120.0 (25/06/2023) ie. the last Sunday of June 2023

WEEKDAY_OF_MONTH(2023, 1, 2, 2, 0.5)
Returns: MJDate 59954.5 (10/01/2023 12pm) ie. midday of the second Tuesday of January 2023
----------------------------------------------------------------------------------------------------------*/
WEEKDAY_OF_MONTH = LAMBDA(YearCE, Month, WeekOfMonth, ISOWeekDay, [Time], [JulianCalendar],
    IFS(
        (YearCE = "") * (Month = "") * (WeekOfMonth = "") * (ISOWeekDay = ""), "",
        NOT(ISNUMBER(YearCE)) + NOT(ISNUMBER(Month)) + NOT(ISNUMBER(WeekOfMonth)) + NOT(ISNUMBER(ISOWeekDay)), {#VALUE!},
        NOT(IS_INTEGER(YearCE) * IS_INTEGER(Month) * IS_INTEGER(WeekOfMonth) * IS_INTEGER(ISOWeekDay)), {#NUM!},
        (WeekOfMonth < -4) + (WeekOfMonth > 5), {#NUM!},
        TRUE, LET(
            _month, Month + N(WeekOfMonth < 0),
            _weekOffset, WeekOfMonth - N(WeekOfMonth >= 0),
            _isoDoW, MOD(ISOWeekDay - 1, 7) + 1,
            _firstOfMonth, MODIFIED_JULIAN_DATE(YearCE, _month, 1, 0, JulianCalendar),
            _firstDoW, DAY_OF_WEEK(_firstOfMonth),
            _firstOfMonth + (_weekOffset * 7) + MOD(_isoDow - _firstDoW, 7) + N(Time)
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
IS_VALID_WEEK_DATE

Tests if a week date is valid for the given calendar.

Output
-------------------------------------------------------------------------------------------------------------
 1 | boolean |

Parameters
-------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
ISOWeek          | integer [1..53] | ISO defined week number of the year
[ISOWeekDay]     | integer [1..7]  | ISO defined day of week Monday..Sunday
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
IS_VALID_WEEK_DATE = LAMBDA(YearCE, ISOWeek, [ISOWeekDay], [JulianCalendar],
    IFS(
        NOT(ISNUMBER(YearCE)) + NOT(ISNUMBER(ISOWeek)), FALSE, // cannot ommit year or week
        NOT(IS_INTEGER(YearCE) * IS_INTEGER(ISOWeek)), FALSE, // year and week cannot be fractional
        TRUE, LET(
            _validWeek, IFS(
                ISOWeek < 1, FALSE,
                ISOWeek <= 52, TRUE,
                ISOWeek = 53, (WEEKS_IN_YEAR(YearCE, JulianCalendar) = 53),
                TRUE, FALSE
            ),
            IF(NOT(_validWeek), FALSE,
                IF(NOT(ISNUMBER(ISOWeekDay)), TRUE,
                    LET(
                        _weekDay, INT(ISOWeekDay),
                        (_weekDay >= 1) * (_weekDay <= 7) <> 0
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
WEEKS_IN_YEAR

Returns the count of ISO defined weeks in a given year of the specified calendar.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer [52,53]

Parameters
-------------------------------------------------------------------------------------------------------------
YearCE           | integer | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
WEEKS_IN_YEAR = LAMBDA(YearCE, [JulianCalendar],
    IFS(
        YearCE = "", "",
        NOT(ISNUMBER(YearCE)), {#VALUE!},
        TRUE, LET(
            _gregorian, N(JulianCalendar) = 0,
            fnLastWeekDayOfYear, LAMBDA(_yearCE,
                LET(
                    _dayPrecession, IF(_gregorian,
                        _yearCE + INT(_yearCE / 4) - INT(_yearCE / 100) + INT(_yearCE / 400) + 6,
                        _yearCE + INT(_yearCE / 4) + 4
                    ),
                    MOD(_dayPrecession, 7) + 1
                )
            ),

            _yearCE, INT(YearCE),
            _dowLastDay, fnLastWeekDayOfYear(_yearCE),
            IF(
                _dowLastDay = 4,
                // if last day of year is a Thursday, then has an extra week
                53,
                LET(
                    _dowLastDayPrev, fnLastWeekDayOfYear(_yearCE - 1) ,
                    IF(
                        _dowLastDayPrev = 3,
                        // if last day of previous year is a Wednesday, then has an extra week
                        53,
                        // otherwise
                        52
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
PARSE_ISO_WEEK_DATE

Parses an ISO formatted week date into respective parts of year, week and weekday.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer | YearCE
 2 | integer | ISO week
 3 | integer | ISO week day

Parameters
-------------------------------------------------------------------------------------------------------------
ISOWeekDate      | text   | Week date in ISO format ie. yyyy-Www-d
[JulianCalendar] | switch | Validate in the Julian proleptic calendar. Default is Gregorian
                 |        | proleptic calendar.

Examples
-------------------------------------------------------------------------------------------------------------
PARSE_ISO_WEEK_DATE("2023-W05-1")
Returns: {2023, 5, 1}
----------------------------------------------------------------------------------------------------------*/
PARSE_ISO_WEEK_DATE = LAMBDA(ISOWeekDate, [JulianCalendar],
    IFS(
        IS_EMPTY(ISOWeekDate), {"", "", ""},
        NOT(VALIDATE_CHARSET("+-0123456789W" & UNICHAR(8722), ISOWeekDate)), {#VALUE!, "", ""},
        TRUE, LET(
            _firstChar, LEFT(ISOWeekDate, 1),
            _isSigned, IFS(
                _firstChar = "+", TRUE,
                _firstChar = "-", TRUE,
                _firstChar = UNICHAR(8722), TRUE,
                TRUE, FALSE
            ),
            _sign, IFS(
                NOT(_isSigned), 1,
                _firstChar = "-", -1,
                _firstChar = UNICHAR(8722), -1,
                TRUE, 1
            ),
            _unSigned, IF(_isSigned,
                RIGHT(ISOWeekDate, LEN(ISOWeekDate) - 1),
                ISOWeekDate
            ),
            _len, LEN(_unSigned),
            _pattern, REPLACE_CHARS(_unSigned, "0123456789", "_"),
            _tryParse, IFS(
                _len >= 10, IFS(
                    _pattern = RIGHT("_______________-W__-_", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 6)),
                        VALUE(MID(_unSigned, _len - 3, 2)),
                        VALUE(RIGHT(_unSigned, 1))
                    ),
                    _pattern = RIGHT("_______________-W__", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 4)),
                        VALUE(RIGHT(_unSigned, 2)),
                        ""
                    ),
                    _pattern = RIGHT("_______________W___", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 4)),
                        VALUE(MID(_unSigned, _len - 2, 2)),
                        VALUE(RIGHT(_unSigned, 1))
                    ),
                    _pattern = RIGHT("_______________W__", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 3)),
                        VALUE(RIGHT(_unSigned, 2)),
                        ""
                    ),
                    TRUE, ""
                ),
                _len >= 8, IFS(
                    _pattern = RIGHT("_____-W__", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 4)),
                        VALUE(RIGHT(_unSigned, 2)),
                        ""
                    ),
                    _pattern = RIGHT("_____W___", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 4)),
                        VALUE(MID(_unSigned, _len - 2, 2)),
                        VALUE(RIGHT(_unSigned, 1))
                    ),
                    _pattern = RIGHT("______W__", _len),
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 3)),
                        VALUE(RIGHT(_unSigned, 2)),
                        ""
                    ),
                    TRUE, ""
                ),
                _len = 7, IF(
                    _pattern = "____W__",
                    HSTACK(
                        VALUE(LEFT(_unSigned, _len - 3)),
                        VALUE(RIGHT(_unSigned, 2)),
                        ""
                    ),
                    ""
                ),
                (_len >= 4) * (_len <= 5), IF(
                    _pattern = RIGHT("_____", _len),
                    HSTACK(
                        VALUE(_unSigned),
                        "",
                        ""
                    ),
                    ""
                ),
                TRUE, #N/A
            ),

            IF(ISERROR(INDEX(_tryParse, 1, 1)), {#VALUE!, "", ""},
                LET(
                    _year, _sign * INDEX(_tryParse, 1, 1),
                    _week, INDEX(_tryParse, 1, 2),
                    IF(_week = "", HSTACK(_year, "", ""),
                        LET(
                            _invalidWeek, IFS(
                                _week < 1, TRUE,
                                _week <= 52, FALSE,
                                _week > 53, TRUE,
                                TRUE, WEEKS_IN_YEAR(_year, JulianCalendar) < 53
                            ),
                            IF(_invalidWeek, HSTACK(_year, {#NUM!}, ""),
                                LET(
                                    _day, INDEX(_tryParse, 1, 3),
                                    IF(_day = "", HSTACK(_year, _week, ""),
                                        IF((_day >= 1) * (_day <= 7),
                                            HSTACK(_year, _week, _day),
                                            HSTACK(_year, _week, {#NUM!})
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
FORMAT_ISO_WEEK_DATE

Returns a week date as text in ISO format.

Output
-------------------------------------------------------------------------------------------------------------
 1 | text | ISO formatted week date

Parameters
-------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Note that 1 BC = 0 CE, 2 BC = -1 CE
ISOWeek          | integer [1..53] | Note most years have 52 ISO weeks
[ISOWeekDay]     | integer [1..7]  | ISO day of week Monday..Sunday
[Basic]          | switch          | Display in basic format eg yyyyWwwd
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar. 
----------------------------------------------------------------------------------------------------------*/
FORMAT_ISO_WEEK_DATE = LAMBDA(YearCE, ISOWeek, [ISOWeekDay], [Basic], [JulianCalendar],
    IFS(
        IS_EMPTY(YearCE) * IS_EMPTY(ISOWeek) * IS_EMPTY(ISOWeekDay), "",
        NOT(ISNUMBER(YearCE)), {#VALUE!},
        NOT(IS_NUMERIC_NULL(ISOWeek)) + NOT(IS_NUMERIC_NULL(ISOWeekDay)), {#VALUE!},
        NOT(ISNUMBER(ISOWeek)) * ISNUMBER(ISOWeekDay), {#VALUE!},
        TRUE, LET(
            _delim, IF(N(Basic) = 0, "-", ""),
            IFS(
                IS_EMPTY(ISOWeek), FORMAT_ISO_Year(YearCE),
                NOT(IS_VALID_WEEK_DATE(YearCE, ISOWeek, ISOWeekDay, JulianCalendar)), {#NUM!},
                IS_EMPTY(ISOWeekDay), CONCAT(
                    FORMAT_ISO_Year(YearCE),
                    _delim, "W", TEXT(ISOWeek, "00")
                ),
                TRUE, CONCAT(
                    FORMAT_ISO_Year(YearCE),
                    _delim, "W", TEXT(ISOWeek, "00"),
                    _delim, TEXT(ISOWeekDay, "0")
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
WEEK_DATE_TO_MJDATE

Converts a week date of year, ISO defined week number, ISO weekday, and time in the specified calendar to a
Modified Julian Date (MJDATE).

Output
-------------------------------------------------------------------------------------------------------------
 1 | decimal | Modified Julian Date

Parameters
-------------------------------------------------------------------------------------------------------------
YearCE           | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
ISOWeek          | integer [1..53] | ISO defined week number of the year
ISOWeekDay       | integer [1..7]  | ISO defined day of week Monday..Sunday
[Time]           | decimal [0..1)  | Time of day
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
WEEK_DATE_TO_MJDATE = LAMBDA(YearCE, ISOWeek, ISOWeekDay, [Time], [JulianCalendar],
    IFS(
        (YearCE = "") * (ISOWeek = "") * (ISOWeekDay = ""), "",
        NOT(ISNUMBER(YearCE)) + NOT(ISNUMBER(ISOWeek)) + NOT(ISNUMBER(ISOWeekDay)), {#VALUE!},
        TRUE, LET(
            _invalid, IFS(
                NOT(IS_INTEGER(YearCE)), TRUE,
                NOT(IS_INTEGER(ISOWeek)), TRUE,
                ISOWeek < 1, TRUE,
                ISOWeek > 53, TRUE,
                ISOWeek = 53, (WEEKS_IN_YEAR(YearCE, JulianCalendar) < 53),
                TRUE, FALSE
            ),
            IF(_invalid, {#NUM!},
                LET(
                    _shiftByWeeks, (ISOWeek - 1) * 7,
                    _shiftDayOfWeek, MOD(INT(ISOWeekDay) - 1, 7),
                    _firstDayYear, MODIFIED_JULIAN_DAY_NUMBER(YearCE, 1, 1, JulianCalendar),
                    _firstWeekDay, DAY_OF_WEEK(_firstDayYear),
                    _yearCorrection, MOD(4 - _firstWeekDay, 7) - 3,
                    _firstDayYear + _yearCorrection + _shiftByWeeks + _shiftDayOfWeek + N(Time) 
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
MJDATE_TO_WEEK_DATE

Converts a Modified Julian Date (MJDATE) to the year, ISO defined week number, ISO weekday, time, and weeks
in the year in the specified calendar.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer         | YearCE
 2 | integer [1..53] | ISO week number
 3 | integer [1..7]  | ISO day of week Monday..Sunday
 4 | decimal [0..1)  | Time of day
 5 | integer [52,53] | ISO weeks in year

Parameters
-------------------------------------------------------------------------------------------------------------
MJDate           | decimal | Modified Julian Date
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
MJDATE_TO_WEEK_DATE = LAMBDA(MJDate, [JulianCalendar],
    IFS(
        MJDate = "", {"", "", "", "", ""},
        NOT(ISNUMBER(MJDate)), {#VALUE!, "", "", "", ""},
        TRUE, LET(
            _cDate, MJDATE_TO_CALENDAR_DATE(MJDate, JulianCalendar),
            _yearCE, INDEX(_cDate, 1, 1),
            _dayOfWeek, DAY_OF_WEEK(MJDate),
            _MJDNYear, MODIFIED_JULIAN_DAY_NUMBER(_yearCE, 1, 1, JulianCalendar) - 1,
            _dayOfYear, INT(MJDate - _MJDNYear),
            _nominalWeek, INT((_dayOfYear - _dayOfWeek + 10) / 7),
            IFS(
                // last week of previous year
                _nominalWeek = 0, LET(
                    _weeksInYear, WEEKS_IN_YEAR(_yearCE - 1, JulianCalendar), 
                    HSTACK(
                        _yearCE - 1,
                        _weeksInYear,
                        _dayOfWeek,
                        INDEX(_cDate, 1, 4),
                        _weeksInYear
                    )
                ),
                
                // auxiliary week
                _nominalWeek = 53, IF(WEEKS_IN_YEAR(_yearCE, JulianCalendar) = 53,
                    HSTACK(
                        _yearCE,
                        53,
                        _dayOfWeek,
                        INDEX(_cDate, 1, 4),
                        53
                    ),
                    // if this year does not have 53 weeks, then is the first week of following year
                    LET(
                        _weeksInYear, WEEKS_IN_YEAR(_yearCE + 1, JulianCalendar),
                        HSTACK(
                            _yearCE + 1,
                            1,
                            _dayOfWeek,
                            INDEX(_cDate, 1, 4),
                            _weeksInYear
                        )
                    )
                ),
                
                // any other week in the year
                TRUE, LET(
                    _weeksInYear, WEEKS_IN_YEAR(_yearCE, JulianCalendar),
                    HSTACK(
                        _yearCE,
                        _nominalWeek,
                        _dayOfWeek,
                        INDEX(_cDate, 1, 4),
                        _weeksInYear
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
WEEK_NUMBER

Returns the ISO defined week number for a given Modified Julian Date in the specified calendar.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer [1..53] | ISO week number

Parameters
-------------------------------------------------------------------------------------------------------------
MJDate           | decimal | Modified Julian Date
[JulianCalendar] | switch  | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
WEEK_NUMBER = LAMBDA(MJDate, [JulianCalendar],
    IFS(
        MJDate = "", "",
        NOT(ISNUMBER(MJDate)), {#VALUE!},
        TRUE, LET(
            _weekDate, MJDATE_TO_WEEK_DATE(MJDate, JulianCalendar),
            CHOOSECOLS(_weekDate, 2)
        )
    )
);











/*###########################################################################################################
# QUARTERS                                                                                                  #
###########################################################################################################*/


/*----------------------------------------------------------------------------------------------------------
DAYS_IN_QUARTER

Returns the count of days in a quarter of a given year of the specified calendar.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer [89..92]

Parameters
-------------------------------------------------------------------------------------------------------------
Quarter          | integer [1..4]  | Quarter of the year 1..4, transitive, exceeding range will carry to year.
[FiscalYearCE]   | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
                 |                 | When month offset is non-zero the fiscal year spans calendar years and
                 |                 | is defined as the year where June falls.
[MonthOffset]    | integer [-6..3] | Quarter month offset from Januaray
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.

Examples
-------------------------------------------------------------------------------------------------------------
DAYS_IN_QUARTER(3, 2020, -6)
Returns: 91
i.e. 3rd quarter starting from July 2019, namely Jan, Feb, Mar 2020 with 31, 29, 31 days respectively
----------------------------------------------------------------------------------------------------------*/
DAYS_IN_QUARTER = LAMBDA(Quarter, [FiscalYearCE], [MonthOffset], [JulianCalendar],
    IFS(
        Quarter = "", "",
        NOT(ISNUMBER(Quarter)), {#VALUE!},
        NOT(IS_INTEGER(Quarter)), {#NUM!},
        TRUE, LET(
            _monthOffset, ROUND(N(MonthOffset), 0),
            IF((_monthOffset < -6) + (_monthOffset > 3), {#NUM!},
                LET(
                    _quarter, MOD(INT(Quarter) - 1, 4), // 0..3
                    _daysInQuarterCyclical, {90,89,92,91,92,92,92,92,91,92,92,90},
                    _quarterWithFeb, INT(MOD(1 - _monthOffset, 12) / 3),  // 0..3
                    _quarterPrecession, MOD(_monthOffset + (_quarter * 3), 12) + 1,
                    _nominalDaysInQuarter, INDEX(_daysInQuarterCyclical, 1, _quarterPrecession),
                    _leapDay, IF(ISNUMBER(FiscalYearCE) * (_quarterWithFeb = _quarter),
                        LET(
                            _yearOfFeb, INT(FiscalYearCE) + N(_quarter = 3),
                            N(IS_LEAP_YEAR(_yearOfFeb, JulianCalendar))
                        ),
                        0
                    ),
                    _nominalDaysInQuarter + _leapDay
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
QUARTER_DATE_TO_MJDATE

Converts a date expressed as fiscal year, quarter, day of quarter and time in the specified calendar to a
Modified Julian Date (MJDATE).

Output
-------------------------------------------------------------------------------------------------------------
 1 | decimal | Modified Julian Date

Parameters
-------------------------------------------------------------------------------------------------------------
FiscalYearCE     | integer         | Year in Common Era. Note that 1 BC = 0 CE, 2 BC = -1 CE
                 |                 | When month offset is non-zero the fiscal year spans calendar years and
                 |                 | is defined as the year where June falls.
Quarter          | integer [1..4]  | Quarter of the year 1..4, transitive, exceeding range will carry to year.
DayOfQuarter     | integer [1..92] | Ordinal day of the quarter, exceeding range will carry
[Time]           | decimal [0..1)  | Time of day
[MonthOffset]    | integer [-6..3] | Quarter month offset from January
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
QUARTER_DATE_TO_MJDATE = LAMBDA(FiscalYearCE, Quarter, DayOfQuarter, [Time], [MonthOffset], [JulianCalendar],
    IFS(
        (FiscalYearCE = "") * (Quarter = "") * (DayOfQuarter = ""), "",
        NOT(ISNUMBER(FiscalYearCE)), {#VALUE!},
        NOT(ISNUMBER(Quarter)), {#VALUE!},
        NOT(ISNUMBER(DayOfQuarter)), {#VALUE!},
        NOT(IS_INTEGER(Quarter)), {#NUM!},
        TRUE, LET(
            _monthOffset, ROUND(N(MonthOffset), 0),
            IF((_monthOffset < -6) + (_monthOffset > 3), {#NUM!},
                LET(
                    _fiscalYearCE, INT(FiscalYearCE),
                    _quarter, INT(Quarter),
                    _shiftMonth, (_quarter - 1) * 3 + _monthOffset,
                    _yearCE, _fiscalYearCE + INT(_shiftMonth / 12),
                    _month, MOD(_shiftMonth, 12) + 1,
                    _MJDNQuarter, MODIFIED_JULIAN_DAY_NUMBER(_yearCE, _month, 1, JulianCalendar) - 1,
                    _MJDNQuarter + INT(DayOfQuarter) + N(Time)
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
MJDATE_TO_QUARTER_DATE

Converts Modified Julian Date (MJDATE) to a date expressed as fiscal year, quarter, day of quarter and time
in the specified calendar.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer          | FiscalYearCE
   |                  | When month offset is non-zero the fiscal year spans calendar years and
   |                  | is defined as the year where June falls.
 2 | integer [1..4]   | Quarter
 3 | integer [1..92]  | Day of quarter
 4 | decimal [0..1)   | Time of day
 5 | integer [89..92] | Days in quarter

Parameters
-------------------------------------------------------------------------------------------------------------
MJDate           | decimal         | Modified Julian Date
[MonthOffset]    | integer [-6..3] | Quarter month offset from January
[JulianCalendar] | switch          | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
MJDATE_TO_QUARTER_DATE = LAMBDA(MJDate, [MonthOffset], [JulianCalendar],
    IFS(
        MJDate = "", {"", "", "", "", ""},
        NOT(ISNUMBER(MJDate)), {#VALUE!, "", "", "", ""},
        TRUE, LET(
            _monthOffset, ROUND(N(MonthOffset), 0),
            IFS(
                _monthOffset < -6, {#NUM!, "", "", "", ""},
                _monthOffset > 3, {#NUM!, "", "", "", ""},
                TRUE, LET(
                    _cDate, MJDATE_TO_CALENDAR_DATE(MJDate, JulianCalendar),
                    _shiftMonth, INDEX(_cDate, 1, 2) - 1 - _monthOffset,
                    _fiscalYear, INDEX(_cDate, 1, 1) + INT(_shiftMonth / 12),
                    _zeroBasedFiscalMonth, MOD(_shiftMonth, 12),
                    _quarter, INT(_zeroBasedFiscalMonth / 3) + 1,
                    _MJDNQuarter, QUARTER_DATE_TO_MJDATE(_fiscalYear, _quarter, 1, 0, _monthOffset, JulianCalendar) - 1,
                    _dayOfQuarter, INT(MJDate - _MJDNQuarter),
                    _daysInQuarter, DAYS_IN_QUARTER(_quarter, _fiscalYear, _monthOffset, JulianCalendar),
                    HSTACK(
                        _fiscalYear,
                        _quarter,
                        _dayOfQuarter,
                        INDEX(_cDate, 1, 4),
                        _daysInQuarter
                    )
                )
            )
        )
    )
);













/*###########################################################################################################
# DELTAS                                                                                                    #
###########################################################################################################*/


/*----------------------------------------------------------------------------------------------------------
DELTA_HOURS

Returns the timespan difference between Modified Julian Dates in hours.
Can also accept standard Julian Dates, provided types are not mixed.

Output
-------------------------------------------------------------------------------------------------------------
 1 | decimal | Difference in hours

Parameters
-------------------------------------------------------------------------------------------------------------
MJDateStart | decimal | Starting Modified Julian Date 
MJDateEnd   | decimal | Ending Modified Julian Date
----------------------------------------------------------------------------------------------------------*/
DELTA_HOURS = LAMBDA(MJDateStart, MJDateEnd,
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), "",
        NOT(ISNUMBER(MJDateStart)), {#VALUE!},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
        TRUE, (MJDateEnd - MJDateStart) * 24
    )
);


/*----------------------------------------------------------------------------------------------------------
DELTA_MINUTES

Returns the timespan difference between Modified Julian Dates in minutes.
Can also accept standard Julian Dates, provided types are not mixed.

Output
-------------------------------------------------------------------------------------------------------------
 1 | decimal | Difference in minutes

Parameters
-------------------------------------------------------------------------------------------------------------
MJDateStart | decimal | Starting Modified Julian Date 
MJDateEnd   | decimal | Ending Modified Julian Date
----------------------------------------------------------------------------------------------------------*/
DELTA_MINUTES = LAMBDA(MJDateStart, MJDateEnd,
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), "",
        NOT(ISNUMBER(MJDateStart)), {#VALUE!},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
        TRUE, (MJDateEnd - MJDateStart) * 1440
    )
);


/*----------------------------------------------------------------------------------------------------------
DELTA_SECONDS

Returns the timespan difference between Modified Julian Dates in seconds.
Can also accept standard Julian Dates, provided types are not mixed.

Output
-------------------------------------------------------------------------------------------------------------
 1 | decimal | Difference in seconds

Parameters
-------------------------------------------------------------------------------------------------------------
MJDateStart | decimal | Starting Modified Julian Date 
MJDateEnd   | decimal | Ending Modified Julian Date
----------------------------------------------------------------------------------------------------------*/
DELTA_SECONDS = LAMBDA(MJDateStart, MJDateEnd,
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), "",
        NOT(ISNUMBER(MJDateStart)), {#VALUE!},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
        TRUE, (MJDateEnd - MJDateStart) * 86400
    )
);


/*----------------------------------------------------------------------------------------------------------
DELTA_DHMS

Returns the sexagesimal difference between Modified Julian Dates with the given lowest order component rounded
to the specified precision.
Can also accept standard Julian Dates, provided types are not mixed.

Output - LowOrder = 4 (default)
-------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Days
 3 | integer [0..23]  | Hours
 4 | integer [0..59]  | Minutes
 5 | decimal [0..60)  | Seconds

Output - LowOrder = 3
-------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Days
 3 | integer [0..23]  | Hours
 4 | decimal [0..60)  | Minutes

Output - LowOrder = 2
-------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Days
 3 | decimal [0..24)  | Hours

Output - LowOrder = 1
-------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | decimal [0..]    | Days

Parameters
-------------------------------------------------------------------------------------------------------------
MJDateStart   | decimal | Starting Modified Julian Date 
MJDateEnd     | decimal | Ending Modified Julian Date
[HighOrder]   | integer | Highest-order component. Defaults to Day.
              | [1..4]  |  1 - Day
              |         |  2 - Hour
              |         |  3 - Minute
              |         |  4 - Second
[LowOrder]    | integer | Lowest-order component. Defaults to Second.
              | [1..4]  |  1 - Day
              |         |  2 - Hour
              |         |  3 - Minute
              |         |  4 - Second
[Precision]   | integer | Select precision level
              | [0..9]  | Null - Floating
[Truncate]    | switch  | Round to precision by truncating components. Default is rounding to nearest.
----------------------------------------------------------------------------------------------------------*/
DELTA_DHMS = LAMBDA(MJDateStart, MJDateEnd, [HighOrder], [LowOrder], [Precision], [Truncate],
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), {"","","",""},
        NOT(ISNUMBER(MJDateStart)), {#VALUE!, "", "", ""},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!, "", "", ""},
        TRUE, RESOLVE_TIMESPAN(MJDateEnd - MJDateStart, HighOrder, LowOrder, Precision, Truncate)
    )
);


/*----------------------------------------------------------------------------------------------------------
DELTA_TIMESPAN

Returns the timespan difference between Modified Julian Dates.
Can also accept standard Julian Dates, provided types are not mixed.

Output
-------------------------------------------------------------------------------------------------------------
 1 | decimal | Timespan difference, day = 1

Parameters
-------------------------------------------------------------------------------------------------------------
MJDateStart | decimal | Starting Modified Julian Date 
MJDateEnd   | decimal | Ending Modified Julian Date
----------------------------------------------------------------------------------------------------------*/
DELTA_TIMESPAN = LAMBDA(MJDateStart, MJDateEnd,
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), "",
        NOT(ISNUMBER(MJDateStart)), {#VALUE!},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
        TRUE, (MJDateEnd - MJDateStart)
    )
);


/*----------------------------------------------------------------------------------------------------------
DELTA_WEEKS

Returns the timespan difference between Modified Julian Dates in weeks.
Can also accept standard Julian Dates, provided types are not mixed.

Output
-------------------------------------------------------------------------------------------------------------
 1 | decimal | Difference in weeks

Parameters
-------------------------------------------------------------------------------------------------------------
MJDateStart | decimal | Starting Modified Julian Date 
MJDateEnd   | decimal | Ending Modified Julian Date
----------------------------------------------------------------------------------------------------------*/
DELTA_WEEKS = LAMBDA(MJDateStart, MJDateEnd,
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), "",
        NOT(ISNUMBER(MJDateStart)), {#VALUE!},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
        TRUE, (MJDateEnd - MJDateStart) / 7
    )
);


/*----------------------------------------------------------------------------------------------------------
DELTA_MONTHS

Returns the timespan difference between Modified Julian Dates in months.
Where the difference includes partial months, the fraction is calculated on the basis of days in the month
of the calendar. If the Modified Julian Dates are expressed in UTC rather than local time then a small margin
of error will be introduced due to the bounds of calendar days.

Output
-------------------------------------------------------------------------------------------------------------
 1 | decimal | Difference in months

Parameters
-------------------------------------------------------------------------------------------------------------
MJDateStart      | decimal | Starting Modified Julian Date 
MJDateEnd        | decimal | Ending Modified Julian Date
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
DELTA_MONTHS = LAMBDA(MJDateStart, MJDateEnd, [JulianCalendar],
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), "",
        NOT(ISNUMBER(MJDateStart)), {#VALUE!},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
        TRUE, IF(MJDateStart = MJDateEnd, 0,
            LET(
                _sign, IF(MJDateEnd >= MJDateStart, 1, -1),
                _date_A, MJDATE_TO_CALENDAR_DATE(
                    IF(_sign = 1, MJDateStart, MJDateEnd),
                    JulianCalendar
                ),
                _date_B, MJDATE_TO_CALENDAR_DATE(
                    IF(_sign = 1, MJDateEnd, MJDateStart),
                    JulianCalendar
                ),
                _deltaYear, INDEX(_date_B, 1, 1) - INDEX(_date_A, 1, 1),
                _deltaMonth, INDEX(_date_B, 1, 2) - INDEX(_date_A, 1, 2),
                _diffMonths, (_deltaYear * 12) + _deltaMonth,
                _daysMonth_A, DAYS_IN_MONTH(INDEX(_date_A, 1, 2), INDEX(_date_A, 1, 1), JulianCalendar),
                _daysMonth_B, DAYS_IN_MONTH(INDEX(_date_B, 1, 2), INDEX(_date_B, 1, 1), JulianCalendar),
                _partialMonth_A, (INDEX(_date_A, 1, 3) - 1 + INDEX(_date_A, 1, 4)) / _daysMonth_A,
                _partialMonth_B, (INDEX(_date_B, 1, 3) - 1 + INDEX(_date_B, 1, 4)) / _daysMonth_B,
                _sign * (_diffMonths - _partialMonth_A + _partialMonth_B)
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
DELTA_QUARTERS

Returns the timespan difference between Modified Julian Dates in quarters.
Where the difference includes partial quarters, the fraction is calculated on the basis of days in the
quarter of the calendar. If the Modified Julian Dates are expressed in UTC rather than local time then a
small margin of error will be introduced due to the bounds of calendar days.

Output
-------------------------------------------------------------------------------------------------------------
 1 | decimal | Difference in quarters

Parameters
-------------------------------------------------------------------------------------------------------------
MJDateStart      | decimal         | Starting Modified Julian Date 
MJDateEnd        | decimal         | Ending Modified Julian Date
[MonthOffset]    | integer [-6..3] | Quarter month offset from January.
[JulianCalendar] | switch          | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
DELTA_QUARTERS = LAMBDA(MJDateStart, MJDateEnd, [MonthOffset], [JulianCalendar],
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), "",
        NOT(ISNUMBER(MJDateStart)), {#VALUE!},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
        TRUE, LET(
            _monthOffset, ROUND(N(MonthOffset), 0),
            IFS(
                _monthOffset < -6, {#NUM!},
                _monthOffset > 3, {#NUM!},
                MJDateStart = MJDateEnd, 0,
                TRUE, LET(
                    _sign, IF(MJDateEnd >= MJDateStart, 1, -1),
                    _quarterDate_A, MJDATE_TO_QUARTER_DATE(
                        IF(_sign = 1, MJDateStart, MJDateEnd),
                        _monthOffset, JulianCalendar
                    ),
                    _quarterDate_B, MJDATE_TO_QUARTER_DATE(
                        IF(_sign = 1, MJDateEnd, MJDateStart),
                        _monthOffset, JulianCalendar
                    ),
                    _deltaYear, INDEX(_quarterDate_B, 1, 1) - INDEX(_quarterDate_A, 1, 1),
                    _deltaQuarter, INDEX(_quarterDate_B, 1, 2) - INDEX(_quarterDate_A, 1, 2),
                    _diffQuarters, (_deltaYear * 4) + _deltaQuarter,
                    _partialQuarter_A, (INDEX(_quarterDate_A, 1, 3) - 1 + INDEX(_quarterDate_A, 1, 4)) / INDEX(_quarterDate_A, 1, 5),
                    _partialQuarter_B, (INDEX(_quarterDate_B, 1, 3) - 1 + INDEX(_quarterDate_B, 1, 4)) / INDEX(_quarterDate_B, 1, 5),
                    _sign * (_diffQuarters - _partialQuarter_A + _partialQuarter_B)
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
DELTA_YEARS

Returns the timespan difference between Modified Julian Dates in years.
Where the difference includes partial years, the fraction is calculated on the basis of days in the
year of the calendar. If the Modified Julian Dates are expressed in UTC rather than local time then a
small margin of error will be introduced due to the bounds of calendar days.

Output
-------------------------------------------------------------------------------------------------------------
 1 | decimal | Difference in years

Parameters
-------------------------------------------------------------------------------------------------------------
MJDateStart      | decimal | Starting Modified Julian Date 
MJDateEnd        | decimal | Ending Modified Julian Date
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
DELTA_YEARS = LAMBDA(MJDateStart, MJDateEnd, [JulianCalendar],
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), "",
        NOT(ISNUMBER(MJDateStart)), {#VALUE!},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!},
        MJDateStart = MJDateEnd, 0,
        TRUE, LET(
            _sign, IF(MJDateEnd >= MJDateStart, 1, -1),
            _ordinalDate_A, MJDATE_TO_ORDINAL_DATE(
                IF(_sign = 1, MJDateStart, MJDateEnd),
                JulianCalendar
            ),
            _ordinalDate_B, MJDATE_TO_ORDINAL_DATE(
                IF(_sign = 1, MJDateEnd, MJDateStart),
                JulianCalendar
            ),
            _deltaYear, INDEX(_ordinalDate_B, 1, 1) - INDEX(_ordinalDate_A, 1, 1),
            _partialYear_A, (INDEX(_ordinalDate_A, 1, 2) - 1 + INDEX(_ordinalDate_A, 1, 3)) / INDEX(_ordinalDate_A, 1, 4),
            _partialYear_B, (INDEX(_ordinalDate_B, 1, 2) - 1 + INDEX(_ordinalDate_B, 1, 3)) / INDEX(_ordinalDate_B, 1, 4),
            _sign * (_deltaYear - _partialYear_A + _partialYear_B)
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
DELTA_WEEK_DAYS

Returns the timespan difference between Modified Julian Dates in weeks and days.
Can also accept standard Julian Dates, provided types are not mixed.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Delta weeks 
 3 | integer [0..6]   | Delta days
 4 | decimal [0..1)   | Delta time

Parameters
-------------------------------------------------------------------------------------------------------------
MJDateStart | decimal | Starting Modified Julian Date 
MJDateEnd   | decimal | Ending Modified Julian Date
----------------------------------------------------------------------------------------------------------*/
DELTA_WEEK_DAYS = LAMBDA(MJDateStart, MJDateEnd,
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), {"", "", "", ""},
        NOT(ISNUMBER(MJDateStart)), {#VALUE!, "", "", ""},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!, "", "", ""},
        TRUE, LET(
            _diffDays, (MJDateEnd - MJDateStart),
            IF(_diffDays = 0, {0, 0, 0, 0},
                LET(
                    _sign, IF(_diffDays >= 0, 1, -1),
                    _absDiffDays, _sign * _diffDays,
                    _deltaWeek, INT(_absDiffDays / 7),
                    _remDays, _absDiffDays - _deltaWeek * 7,
                    _deltaDay, INT(_remDays),
                    _deltaTime, _remDays - _deltaDay,
                    HSTACK(
                        _sign,
                        _deltaWeek,
                        _deltaDay,
                        _deltaTime
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
DELTA_YEAR_WEEK_DAYS

Returns the timespan difference between Modified Julian Dates in years, weeks, and days.
Note the number of weeks per year can vary between 52 and 53. If an absolute number of weeks is being sought
then use either DELTA_WEEK_DAYS or DELTA_WEEKS functions. If the Modified Julian Dates are expressed in UTC
rather than local time then a small margin of error will be introduced due to the bounds of calendar days.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Delta years
 3 | integer [0..52]  | Delta weeks 
 4 | decimal [0..6]   | Delta days
 5 | decimal [0..1)   | Delta time

Parameters
-------------------------------------------------------------------------------------------------------------
MJDateStart      | decimal | Starting Modified Julian Date 
MJDateEnd        | decimal | Ending Modified Julian Date
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
DELTA_YEAR_WEEK_DAYS = LAMBDA(MJDateStart, MJDateEnd, [JulianCalendar],
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), {"", "", "", "", ""},
        NOT(ISNUMBER(MJDateStart)), {#VALUE!, "", "", "", ""},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!, "", "", "", ""},
        MJDateStart = MJDateEnd, {0, 0, 0, 0, 0},
        TRUE, LET(
            _sign, IF(MJDateEnd >= MJDateStart, 1, -1),
            _weekDate_A, MJDATE_TO_WEEK_DATE(
                IF(_sign = 1, MJDateStart, MJDateEnd),
                JulianCalendar
            ),
            _weekDate_B, MJDATE_TO_WEEK_DATE(
                IF(_sign = 1, MJDateEnd, MJDateStart),
                JulianCalendar
            ),
            _deltaYear, INDEX(_weekDate_B, 1, 1) - INDEX(_weekDate_A, 1, 1),
            _deltaWeek, INDEX(_weekDate_B, 1, 2) - INDEX(_weekDate_A, 1, 2),
            _diffDays, INDEX(_weekDate_B, 1, 3) - INDEX(_weekDate_A, 1, 3)
                + INDEX(_weekDate_B, 1, 4) - INDEX(_weekDate_A, 1, 4),
            _carryWeek, INT(_diffDays / 7),
            _remDays, _diffDays - _carryWeek * 7,
            _deltaWeek2, _deltaWeek + _carryWeek,
            _deltaDay, INT(_remDays),
            _deltaTime, _remDays - _deltaDay,
            IF(_deltaWeek2 >= 0,
                HSTACK(
                    _sign,
                    _deltaYear,
                    _deltaWeek2,
                    _deltaDay,
                    _deltaTime
                ),
                HSTACK(
                    _sign,
                    _deltaYear - 1,
                    _deltaWeek2 + INDEX(_weekDate_A, 1, 5),
                    _deltaDay,
                    _deltaTime
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
DELTA_MONTH_DAYS

Returns the timespan difference between Modified Julian Dates in months and days.
If the Modified Julian Dates are expressed in UTC rather than local time then a small margin of error will
be introduced due to the bounds of calendar days.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Delta months
 3 | integer [0..30]  | Delta days
 4 | decimal [0..1)   | Delta time

Parameters
-------------------------------------------------------------------------------------------------------------
MJDateStart      | decimal | Starting Modified Julian Date 
MJDateEnd        | decimal | Ending Modified Julian Date
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
DELTA_MONTH_DAYS = LAMBDA(MJDateStart, MJDateEnd, [JulianCalendar],
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), {"", "", "", ""},
        NOT(ISNUMBER(MJDateStart)), {#VALUE!, "", "", ""},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!, "", "", ""},
        MJDateStart = MJDateEnd, {0, 0, 0, 0},
        TRUE, LET(
            _sign, IF(MJDateEnd >= MJDateStart, 1, -1),
            _date_A, MJDATE_TO_CALENDAR_DATE(
                IF(_sign = 1, MJDateStart, MJDateEnd),
                JulianCalendar
            ),
            _date_B, MJDATE_TO_CALENDAR_DATE(
                IF(_sign = 1, MJDateEnd, MJDateStart),
                JulianCalendar
            ),
            _deltaYear, INDEX(_date_B, 1, 1) - INDEX(_date_A, 1, 1),
            _deltaMonth, INDEX(_date_B, 1, 2) - INDEX(_date_A, 1, 2),
            _diffMonths, (_deltaYear * 12) + _deltaMonth,
            _diffDays, INDEX(_date_B, 1, 3) - INDEX(_date_A, 1, 3)
                + INDEX(_date_B, 1, 4) - INDEX(_date_A, 1, 4),
            IF(_diffDays >= 0,
                LET(
                    _deltaDay, INT(_diffDays),
                    _deltaTime, _diffDays - _deltaDay,
                    HSTACK(
                        _sign,
                        _diffMonths,
                        _deltaDay,
                        _deltaTime
                    )
                ),
                LET(
                    _daysMonth_A, DAYS_IN_MONTH(INDEX(_date_A, 1, 2), INDEX(_date_A, 1, 1), JulianCalendar),
                    _diffDays2, _diffDays + _daysMonth_A,  
                    _deltaDay, INT(_diffDays2),
                    _deltaTime, _diffDays2 - _deltaDay,
                    HSTACK(
                        _sign,
                        _diffMonths - 1,
                        _deltaDay,
                        _deltaTime
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
DELTA_QUARTER_DAYS

Returns the timespan difference between Modified Julian Dates in quarters and days.
If the Modified Julian Dates are expressed in UTC rather than local time then a small margin of error will
be introduced due to the bounds of calendar days.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Delta quarters
 3 | decimal [0..92)  | Delta days

Parameters
-------------------------------------------------------------------------------------------------------------
MJDateStart      | decimal         | Starting Modified Julian Date 
MJDateEnd        | decimal         | Ending Modified Julian Date
[MonthOffset]    | integer [-6..3] | Quarter month offset from January.
[JulianCalendar] | switch          | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
DELTA_QUARTER_DAYS = LAMBDA(MJDateStart, MJDateEnd, [MonthOffset], [JulianCalendar],
    IFS(
        (MJDateStart = "") * (MJDateEnd = ""), {"", "", "", ""},
        NOT(ISNUMBER(MJDateStart)), {#VALUE!, "", "", ""},
        NOT(ISNUMBER(MJDateEnd)), {#VALUE!, "", "", ""},
        TRUE, LET(
            _monthOffset, ROUND(N(MonthOffset), 0),
            IFS(
                _monthOffset < -6, {#NUM!, "", "", ""},
                _monthOffset > 3, {#NUM!, "", "", ""},
                MJDateStart = MJDateEnd, {0, 0, 0, 0},
                TRUE, LET(
                    _sign, IF(MJDateEnd >= MJDateStart, 1, -1),
                    _quarterDate_A, MJDATE_TO_QUARTER_DATE(
                        IF(_sign = 1, MJDateStart, MJDateEnd),
                        _monthOffset, JulianCalendar
                    ),
                    _quarterDate_B, MJDATE_TO_QUARTER_DATE(
                        IF(_sign = 1, MJDateEnd, MJDateStart),
                        _monthOffset, JulianCalendar
                    ),
                    _deltaYear, INDEX(_quarterDate_B, 1, 1) - INDEX(_quarterDate_A, 1, 1),
                    _deltaQuarter, INDEX(_quarterDate_B, 1, 2) - INDEX(_quarterDate_A, 1, 2),
                    _diffQuarters, (_deltaYear * 4) + _deltaQuarter,
                    _diffDays, INDEX(_quarterDate_B, 1, 3) - INDEX(_quarterDate_A, 1, 3)
                        + INDEX(_quarterDate_B, 1, 4) - INDEX(_quarterDate_A, 1, 4),
                    IF(_diffDays >= 0,
                        LET(
                            _deltaDay, INT(_diffDays),
                            _deltaTime, _diffDays - _deltaDay,
                            HSTACK(
                                _sign,
                                _diffQuarters,
                                _deltaDay,
                                _deltaTime
                            )
                        ),
                        LET(
                            _diffDays2, _diffDays + INDEX(_quarterDate_A, 1, 5),
                            _deltaDay, INT(_diffDays2),
                            _deltaTime, _diffDays2 - _deltaDay,
                            HSTACK(
                                _sign,
                                _diffQuarters - 1,
                                _deltaDay,
                                _deltaTime
                            )
                        )
                    )
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
DELTA_INTERVAL

Returns the timespan difference between Modified Julian Dates in the specified units.

Output where Units = H, N, S, D, W, M, Q, Y
-------------------------------------------------------------------------------------------------------------
 1 | decimal | Delta units decimal

Output where Units = HMS
-------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Delta hours
 3 | integer [0..59]  | Delta minutes
 4 | decimal [0..60)  | Delta seconds

Output where Units = DHMS
-------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Delta days
 3 | integer [0..23]  | Delta hours
 4 | integer [0..59]  | Delta minutes
 5 | decimal [0..60)  | Delta seconds

Output where Units = WD, MD, QD
-------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1]     | Sign
 2 | integer [0..]        | Delta weeks/months/quarters
 3 | integer [0..6/30/91] | Delta days
 4 | decimal [0..1)       | Delta time

Output where Units = YWD, YMD, YQD
-------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1]     | Sign
 2 | integer [0..]        | Delta years
 3 | integer [0..52/12/4] | Delta weeks/months/quarters
 4 | integer [0..6/30/91] | Delta days
 5 | decimal [0..1)       | Delta time

Output where Units = YMDHMS
-------------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1] | Sign
 2 | integer [0..]    | Delta years
 3 | integer [0..12]  | Delta months
 4 | integer [0..30]  | Delta days
 5 | integer [0..23]  | Delta hours
 6 | integer [0..59]  | Delta minutes
 7 | decimal [0..60)  | Delta seconds

Parameters
-------------------------------------------------------------------------------------------------------------
Units            | text            |      H - hours decimal
                 |                 |      N - minutes decimal
                 |                 |      S - seconds decimal
                 |                 |      T - timespan decimal
                 |                 |      W - weeks decimal
                 |                 |      M - months decimal
                 |                 |      Q - quarters decimal
                 |                 |      Y - years decimal
                 |                 |    HMS - hours, minutes, seconds
                 |                 |   DHMS - days, hours, minutes, seconds
                 |                 |     WD - weeks and days
                 |                 |     MD - months and days
                 |                 |     QD - quarters and days
                 |                 |    YWD - years, weeks, days
                 |                 |    YMD - years, months, days
                 |                 |    YQD - years, quarters, days
                 |                 | YMDHMS - years, months, days, hours, minutes, seconds
MJDateStart      | decimal         | Starting Modified Julian Date 
MJDateEnd        | decimal         | Ending Modified Julian Date
[MonthOffset]    | integer [-6..3] | Quarter month offset from January.
[JulianCalendar] | switch          | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
DELTA_INTERVAL = LAMBDA(Units, MJDateStart, MJDateEnd, [MonthOffset], [JulianCalendar],
    IFS(
        Units = "", {#VALUE!},
        Units = "H", DELTA_HOURS(MJDateStart, MJDateEnd),
        Units = "N", DELTA_MINUTES(MJDateStart, MJDateEnd),
        Units = "S", DELTA_SECONDS(MJDateStart, MJDateEnd),
        Units = "DHMS", DELTA_DHMS(MJDateStart, MJDateEnd, 4),
        Units = "T", DELTA_TIMESPAN(MJDateStart, MJDateEnd),
        Units = "W", DELTA_WEEKS(MJDateStart, MJDateEnd),
        Units = "M", DELTA_MONTHS(MJDateStart, MJDateEnd, JulianCalendar),
        Units = "Q", DELTA_QUARTERS(MJDateStart, MJDateEnd, MonthOffset, JulianCalendar),
        Units = "Y", DELTA_YEARS(MJDateStart, MJDateEnd, JulianCalendar),
        Units = "WD", DELTA_WEEK_DAYS(MJDateStart, MJDateEnd),
        Units = "YWD", DELTA_YEAR_WEEK_DAYS(MJDateStart, MJDateEnd, JulianCalendar),
        Units = "MD", DELTA_MONTH_DAYS(MJDateStart, MJDateEnd, JulianCalendar),
        Units = "QD", DELTA_QUARTER_DAYS(MJDateStart, MJDateEnd, MonthOffset, JulianCalendar),
        Units = "HMS", LET(
                _dhms, DELTA_DHMS(MJDateStart, MJDateEnd, 4),
                _hours, INDEX(_dhms, 1, 3) + (24 * INDEX(_dhms, 1, 2)),
                HSTACK(
                    INDEX(_dhms, 1, 1),
                    _hours,
                    INDEX(_dhms, 1, 4),
                    INDEX(_dhms, 1, 5)
                )
            ),
        Units = "YMD", LET(
                _monthDays, DELTA_MONTH_DAYS(MJDateStart, MJDateEnd, JulianCalendar),
                _years, INT(INDEX(_monthDays, 1, 2) / 12),
                _months, INDEX(_monthDays, 1, 2) - _years * 12,
                HSTACK(
                    INDEX(_monthDays, 1, 1),
                    _years,
                    _months,
                    INDEX(_monthDays, 1, 3),
                    INDEX(_monthDays, 1, 4)
                )
            ),
        Units = "YQD", LET(
                _quarterDays, DELTA_QUARTER_DAYS(MJDateStart, MJDateEnd, MonthOffset, JulianCalendar),
                _years, INT(INDEX(_quarterDays, 1, 2) / 4),
                _quarters, INDEX(_quarterDays, 1, 2) - _years * 4,
                HSTACK(
                    INDEX(_quarterDays, 1, 1),
                    _years,
                    _quarters,
                    INDEX(_quarterDays, 1, 3),
                    INDEX(_quarterDays, 1, 4)
                )
            ),
        Units = "YMDHMS", LET(
                _monthDays, DELTA_MONTH_DAYS(MJDateStart, MJDateEnd, JulianCalendar),
                _years, INT(INDEX(_monthDays, 1, 2) / 12),
                _months, INDEX(_monthDays, 1, 2) - _years * 12,
                _hms, RESOLVE_TIMESPAN(INDEX(_monthDays, 1, 4), 1, 4, 0, 1),
                _carryDay, INDEX(_hms, 1, 2),
                HSTACK(
                    INDEX(_monthDays, 1, 1),
                    _years,
                    _months,
                    INDEX(_monthDays, 1, 3) + _carryDay,
                    CHOOSECOLS(_hms, {3,4,5})
                )
            ),
        TRUE, {#VALUE!}
    )
);













/*###########################################################################################################
# EXTENTS                                                                                                   #
###########################################################################################################*/


/*----------------------------------------------------------------------------------------------------------
EXTENT_OF_DAYS

Returns the inclusive extent of days spanned by two Modified Julian Dates expressed in local time.
If the Modified Julian Dates are expressed in UTC rather than local time then inconsistent results may be
produced due to the bounds of calendar days.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer | Extent of days

Parameters
-------------------------------------------------------------------------------------------------------------
LocalMJDateStart | decimal | Starting Modified Julian Date in local time 
LocalMJDateEnd   | decimal | Ending Modified Julian Date in local time

Examples
-------------------------------------------------------------------------------------------------------------
EXTENT_DAYS(MODIFIED_JULIAN_DATE(2023,1,1,TIME(23,59,55)), MODIFIED_JULIAN_DATE(2023,1,2,TIME(0,0,5)))
= 2  i.e. 2 days because the 10 second timespan crosses the day boundary
----------------------------------------------------------------------------------------------------------*/
EXTENT_OF_DAYS = LAMBDA(LocalMJDateStart, LocalMJDateEnd,
    IFS(
        IS_EMPTY(LocalMJDateStart) * IS_EMPTY(LocalMJDateEnd), "",
        NOT(ISNUMBER(LocalMJDateStart)), {#VALUE!},
        NOT(ISNUMBER(LocalMJDateEnd)), {#VALUE!},
        TRUE, LET(
            _sign, IF(LocalMJDateEnd >= LocalMJDateStart, 1, -1),
            _deltaDay, INT(LocalMJDateEnd) - INT(LocalMJDateStart),
            _sign * (ABS(_deltaDay) + 1)
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
EXTENT_OF_WEEKS

Returns the inclusive extent of weeks spanned by two Modified Julian Dates expressed in local time.
If the Modified Julian Dates are expressed in UTC rather than local time then inconsistent results may be
produced due to the bounds of calendar days.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer | Extent of weeks

Parameters
-------------------------------------------------------------------------------------------------------------
LocalMJDateStart | decimal | Starting Modified Julian Date in local time 
LocalMJDateEnd   | decimal | Ending Modified Julian Date in local time

Examples
-------------------------------------------------------------------------------------------------------------
EXTENT_WEEKS(MODIFIED_JULIAN_DATE(2023,6,4,TIME(23,59,55)), MODIFIED_JULIAN_DATE(2023,6,5,TIME(0,0,5)))
= 2  i.e. 2 weeks because the 10 second timespan crosses the week boundary
----------------------------------------------------------------------------------------------------------*/
EXTENT_OF_WEEKS = LAMBDA(LocalMJDateStart, LocalMJDateEnd,
    IFS(
        IS_EMPTY(LocalMJDateStart) * IS_EMPTY(LocalMJDateEnd), "",
        NOT(ISNUMBER(LocalMJDateStart)), {#VALUE!},
        NOT(ISNUMBER(LocalMJDateEnd)), {#VALUE!},
        TRUE, LET(
            _sign, IF(LocalMJDateEnd >= LocalMJDateStart, 1, -1),
            _startMonday, INT(LocalMJDateStart) + 1 - DAY_OF_WEEK(LocalMJDateStart),
            _endMonday, INT(LocalMJDateEnd) + 1 - DAY_OF_WEEK(LocalMJDateEnd),
            _sign * (INT(ABS(_endMonday - _startMonday) / 7) + 1)
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
EXTENT_OF_MONTHS

Returns the inclusive extent of months spanned by two Modified Julian Dates expressed in local time.
If the Modified Julian Dates are expressed in UTC rather than local time then inconsistent results may be
produced due to the bounds of calendar days.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer | Extent of months

Parameters
-------------------------------------------------------------------------------------------------------------
LocalMJDateStart | decimal | Starting Modified Julian Date in local time 
LocalMJDateEnd   | decimal | Ending Modified Julian Date in local time
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
EXTENT_OF_MONTHS = LAMBDA(LocalMJDateStart, LocalMJDateEnd, [JulianCalendar],
    IFS(
        IS_EMPTY(LocalMJDateStart) * IS_EMPTY(LocalMJDateEnd), "",
        NOT(ISNUMBER(LocalMJDateStart)), {#VALUE!},
        NOT(ISNUMBER(LocalMJDateEnd)), {#VALUE!},
        TRUE, LET(
            _sign, IF(LocalMJDateEnd >= LocalMJDateStart, 1, -1),
            _date_A, MJDATE_TO_CALENDAR_DATE(
                IF(_sign = 1, LocalMJDateStart, LocalMJDateEnd),
                JulianCalendar
            ),
            _date_B, MJDATE_TO_CALENDAR_DATE(
                IF(_sign = 1, LocalMJDateEnd, LocalMJDateStart),
                JulianCalendar
            ),
            _deltaYear, INDEX(_date_B, 1, 1) - INDEX(_date_A, 1, 1),
            _deltaMonth, INDEX(_date_B, 1, 2) - INDEX(_date_A, 1, 2),
            _diffMonths, (_deltaYear * 12) + _deltaMonth,
            _sign * (_diffMonths + 1)
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
EXTENT_OF_QUARTERS

Returns the inclusive extent of quarters spanned by two Modified Julian Dates expressed in local time.
If the Modified Julian Dates are expressed in UTC rather than local time then inconsistent results may be
produced due to the bounds of calendar days.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer | Extent of quarters

Parameters
-------------------------------------------------------------------------------------------------------------
LocalMJDateStart | decimal         | Starting Modified Julian Date in local time 
LocalMJDateEnd   | decimal         | Ending Modified Julian Date in local time
[MonthOffset]    | integer [-6..3] | Quarter month offset from January.
[JulianCalendar] | switch          | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |                 | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
EXTENT_OF_QUARTERS = LAMBDA(LocalMJDateStart, LocalMJDateEnd, [MonthOffset], [JulianCalendar],
    IFS(
        IS_EMPTY(LocalMJDateStart) * IS_EMPTY(LocalMJDateEnd), "",
        NOT(ISNUMBER(LocalMJDateStart)), {#VALUE!},
        NOT(ISNUMBER(LocalMJDateEnd)), {#VALUE!},
        TRUE, LET(
            _monthOffset, ROUND(N(MonthOffset), 0),
            IFS(
                _monthOffset < -6, {#NUM!},
                _monthOffset > 3, {#NUM!},
                TRUE, LET(
                    _sign, IF(LocalMJDateEnd >= LocalMJDateStart, 1, -1),
                    _quarterDate_A, MJDATE_TO_QUARTER_DATE(
                        IF(_sign = 1, LocalMJDateStart, LocalMJDateEnd),
                        _monthOffset, JulianCalendar
                    ),
                    _quarterDate_B, MJDATE_TO_QUARTER_DATE(
                        IF(_sign = 1, LocalMJDateEnd, LocalMJDateStart),
                        _monthOffset, JulianCalendar
                    ),
                    _deltaYear, INDEX(_quarterDate_B, 1, 1) - INDEX(_quarterDate_A, 1, 1),
                    _deltaQuarter, INDEX(_quarterDate_B, 1, 2) - INDEX(_quarterDate_A, 1, 2),
                    _diffQuarters, (_deltaYear * 4) + _deltaQuarter,
                    _sign * (_diffQuarters + 1)
                )
            )
        )
    )
);


/*----------------------------------------------------------------------------------------------------------
EXTENT_OF_YEARS

Returns the inclusive extent of years spanned by two Modified Julian Dates expressed in local time.
If the Modified Julian Dates are expressed in UTC rather than local time then inconsistent results may be
produced due to the bounds of calendar days.

Output
-------------------------------------------------------------------------------------------------------------
 1 | integer | Extent of quarters

Parameters
-------------------------------------------------------------------------------------------------------------
LocalMJDateStart | decimal | Starting Modified Julian Date in local time 
LocalMJDateEnd   | decimal | Ending Modified Julian Date in local time
[JulianCalendar] | switch  | Calculate in the Julian proleptic calendar. Default is Gregorian
                 |         | proleptic calendar.
----------------------------------------------------------------------------------------------------------*/
EXTENT_OF_YEARS = LAMBDA(LocalMJDateStart, LocalMJDateEnd, [JulianCalendar],
    IFS(
        IS_EMPTY(LocalMJDateStart) * IS_EMPTY(LocalMJDateEnd), "",
        NOT(ISNUMBER(LocalMJDateStart)), {#VALUE!},
        NOT(ISNUMBER(LocalMJDateEnd)), {#VALUE!},
        TRUE, LET(
            _sign, IF(LocalMJDateEnd >= LocalMJDateStart, 1, -1),
            _date_A, MJDATE_TO_CALENDAR_DATE(
                IF(_sign = 1, LocalMJDateStart, LocalMJDateEnd),
                JulianCalendar
            ),
            _date_B, MJDATE_TO_CALENDAR_DATE(
                IF(_sign = 1, LocalMJDateEnd, LocalMJDateStart),
                JulianCalendar
            ),
            _deltaYear, INDEX(_date_B, 1, 1) - INDEX(_date_A, 1, 1),
            _sign * (_deltaYear + 1)
        )
    )
);















/*###########################################################################################################
# CONVERSIONS                                                                                               #
###########################################################################################################*/


/*--------------------------------------------------------------------------------------------------------
TIMESPAN_TO_EXCELTIME

Converts a TimeSpan to an Excel Date/Time.

Output
----------------------------------------------------------------------------------------------------------
 1 | integer [-1,0,1]     | Sign
 2 | decimal [0..2958466) | Excel Date/Time.

Parameters
----------------------------------------------------------------------------------------------------------
TimeSpan | decimal |
--------------------------------------------------------------------------------------------------------*/
TIMESPAN_TO_EXCELTIME = LAMBDA(TimeSpan,
    IFS(
        IS_EMPTY(TimeSpan), {"", ""},
        NOT(ISNUMBER(TimeSpan)), {#VALUE!, ""},
        TRUE, LET(
            _absTimeSpan, ABS(TimeSpan),
            _sign, SIGN(TimeSpan),
            IF(_absTimeSpan >= 2958466,
                HSTACK(_sign, {#NUM!}),
                HSTACK(_sign, _absTimeSpan)
            )
        )
    )
);

/*--------------------------------------------------------------------------------------------------------
EXCELTIME_TO_TIMESPAN

Converts an Excel Date/Time to a TimeSpan.

Output
----------------------------------------------------------------------------------------------------------
 1 | TimeSpan | decimal |

Parameters
----------------------------------------------------------------------------------------------------------
Sign      | integer [-1,0,1]     |
ExcelTime | decimal [0..2958466) | Excel Date/Time.
--------------------------------------------------------------------------------------------------------*/
EXCELTIME_TO_TIMESPAN = LAMBDA(Sign, ExcelTime,
    IFS(
        IS_EMPTY(ExcelTime), "",
        NOT(ISNUMBER(ExcelTime)), {#VALUE!},
        TRUE, LET(
            _sign, IFS(
                NOT(ISNUMBER(Sign)), 1,
                Sign < 0, -1, 
                TRUE, 1
            ),
            _sign * ExcelTime
        )
    )
);


/*--------------------------------------------------------------------------------------------------------
MJDATE_TO_EXCELDATE

Converts a Modified Julian Date to an Excel Date/Time.
Note Excel Date/Time uses the Gregorian calendar.

Output
----------------------------------------------------------------------------------------------------------
 1 | decimal         | Excel Date/Time.
   | [1..2958466)    | 1900-01-01..9999-12-31

Parameters
----------------------------------------------------------------------------------------------------------
MJDate  | decimal          | Modified Julian Date
        | [15019..2973484) |
--------------------------------------------------------------------------------------------------------*/
MJDATE_TO_EXCELDATE = LAMBDA(MJDate,
    IFS(
        IS_EMPTY(MJDate), "",
        NOT(ISNUMBER(MJDate)), {#VALUE!},
        MJDate < 15019, {#NUM!},
        MJDate >= 2973484, {#NUM!}, 
        TRUE, MJDate - 15018
    )
);


/*--------------------------------------------------------------------------------------------------------
EXCELDATE_TO_MJDATE

Converts an Excel Date/Time to a Modified Julian Date.
Note Excel Date/Time uses the Gregorian calendar.

Output
----------------------------------------------------------------------------------------------------------
 1 | decimal          | Modified Julian Date.
   | [15019..2973484) |

Parameters
----------------------------------------------------------------------------------------------------------
ExcelDate | decimal      | Excel Date/Time
          | [1..2958466) | 1900-01-01..9999-12-31
--------------------------------------------------------------------------------------------------------*/
EXCELDATE_TO_MJDATE = LAMBDA(ExcelDate,
    IFS(
        IS_EMPTY(ExcelDate), "", 
        NOT(ISNUMBER(ExcelDate)), {#VALUE!},
        TRUE, ExcelDate + 15018
    )
);


/*--------------------------------------------------------------------------------------------------------
USDATE_TO_EXCELDATE

Converts a US format date to an Excel Date/Time.
Note Excel Date/Time uses the Gregorian calendar.

Output
----------------------------------------------------------------------------------------------------------
 1 | decimal | Excel Date/Time.

Parameters
----------------------------------------------------------------------------------------------------------
USDate | text | Date in US format ie. MM/dd/yyyy hh:mm:ss
--------------------------------------------------------------------------------------------------------*/
USDATE_TO_EXCELDATE = LAMBDA(USDate,
    IF(IS_EMPTY(USDate), "",
        LET(
            _USDate, PARSE_US_DATE(USDate),
            _time, N(INDEX(_USDate, 1, 4)),
            _year, INDEX(_USDate, 1, 1),
            _excelDate, IF(IS_EMPTY(_year), 0,
                DATE(_year, INDEX(_USDate, 1, 2), INDEX(_USDate, 1, 3))
            ),
            _excelDate + _time
        )
    )
);


/*--------------------------------------------------------------------------------------------------------
EXCELDATE_TO_USDATE

Converts an Excel Date/Time to a US format date.
Note Excel Date/Time uses the Gregorian calendar.

Output
----------------------------------------------------------------------------------------------------------
 1 | text | US format date and time

Parameters
----------------------------------------------------------------------------------------------------------
ExcelDate | decimal | Excel Date/Time.
[Options] | text    | String with elements: [<][LowOrder][DateSeparator][TimeSeparator]
          |         |      LowOrder : low order component to display
          |         |          Null : Defaults to minutes if time present, otherwise day
          |         |             D : Day
          |         |             H : Hour
          |         |             M : Minute
          |         |             S : Second
          |         |             T : Millisecond (ticks)
          |         |             < : Round by truncating components. Default is rounding to nearest.
          |         | DateSeparator : Character to separate date components. [,./-_]
          |         | TimeSeparator : Character to separate time components. [,.:-_]
--------------------------------------------------------------------------------------------------------*/
EXCELDATE_TO_USDATE = LAMBDA(ExcelDate, [Options],
    IFS(
        IS_EMPTY(ExcelDate), "",
        NOT(ISNUMBER(ExcelDate)), {#VALUE!},
        ExcelDate <= 1, FORMAT_US_DATE("", "", "", ExcelDate, Options, 0),
        TRUE, LET(
            _yearCE, YEAR(ExcelDate),
            _month, MONTH(ExcelDate),
            _day, DAY(ExcelDate),
            _time, ExcelDate - INT(ExcelDate),
            FORMAT_US_DATE(_yearCE, _month, _day, _time, Options, 0)
        )
    )
);



/*--------------------------------------------------------------------------------------------------------
ISO_DATETIME_TO_EXCELDATE

Converts an ISO formatted date and time to an Excel Date/Time and time zone offset.

Output
----------------------------------------------------------------------------------------------------------
 1 | decimal         | Excel Date/Time.
 2 | decimal         | Time zone offset from UTC as decimal fraction of a day.
   | [-0.625..0.625] | -15:00..+15:00

Parameters
----------------------------------------------------------------------------------------------------------
ISODateTime        | text   | Date, time and time zone offset in ISO format
[AllowMixedStyles] | switch | Relax validation for no mixing of basic and extended formats. eg. yyyyMMddThh:mm
--------------------------------------------------------------------------------------------------------*/
ISO_DATETIME_TO_EXCELDATE = LAMBDA(ISODateTime, [AllowMixedStyles],
    IF(IS_EMPTY(ISODateTime), {"", ""},
        LET(
            _isoDateTime, PARSE_ISO_DATETIME(ISODateTime, AllowMixedStyles),
            IFS(
                ISERROR(INDEX(_isoDateTime, 1, 1)), HSTACK({#VALUE!}, INDEX(_isoDateTime, 1, 5)),
                ISERROR(INDEX(_isoDateTime, 1, 4)), HSTACK({#VALUE!}, INDEX(_isoDateTime, 1, 5)),
                IS_EMPTY(INDEX(_isoDateTime, 1, 1)), HSTACK(INDEX(_isoDateTime, 1, 4), INDEX(_isoDateTime, 1, 5)),
                TRUE, LET(
                    _date, DATE(
                        INDEX(_isoDateTime, 1, 1),
                        INDEX(_isoDateTime, 1, 2),
                        INDEX(_isoDateTime, 1, 3)
                    ),
                    HSTACK(_date + N(INDEX(_isoDateTime, 1, 4)), INDEX(_isoDateTime, 1, 5))
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------
EXCELDATE_TO_ISO_DATETIME

Converts an Excel Date/Time and time zone offset to an ISO formatted date and time.

Output
----------------------------------------------------------------------------------------------------------
 1 | text  | ISO formated date and time

Parameters
----------------------------------------------------------------------------------------------------------
ExcelDate    | decimal     | Excel Date/Time.
[TZOMinutes] | decimal     | Time zone offset from UTC in minutes
             | [-900..900] | Assumed to be UTC if ommitted. [-15:00..+15:00]
[Options]    | text        | String with elements: [B][<][LowOrder][Precision][Z]
             |             |        B : Display in basic format eg T0000
             |             |        < : Round by truncating components. Default is rounding to nearest.
             |             | LowOrder : low order component to display
             |             |     Null : Defaults to seconds if time present, otherwise day
             |             |        D : Day
             |             |        H : Hour
             |             |        M : Minute
             |             |        S : Second
             |             | Precision: [0-9] Only has an effect when low order component is seconds.
             |             |        Z : Display 'Z' for Zulu time zone +00:00
--------------------------------------------------------------------------------------------------------*/
EXCELDATE_TO_ISO_DATETIME = LAMBDA(ExcelDate, [TZOMinutes], [Options],
    IFS(
        IS_EMPTY(ExcelDate), "",
        NOT(ISNUMBER(ExcelDate)), {#VALUE!},
        ExcelDate <= 1, FORMAT_ISO_DATETIME("", "", "", ExcelDate, TZOMinutes, Options),
        TRUE, LET(
            _yearCE, YEAR(ExcelDate),
            _month, MONTH(ExcelDate),
            _day, DAY(ExcelDate),
            _time, ExcelDate - INT(ExcelDate),
            FORMAT_ISO_DATETIME(_yearCE, _month, _day, _time, TZOMinutes, Options)
        )
    )
);


/*--------------------------------------------------------------------------------------------------------
ISO_DATETIME_TO_MJDATE

Converts an ISO formatted date and time to a Modified Julian Date and time zone offset.

Output
----------------------------------------------------------------------------------------------------------
 1 | decimal         | Local Modifed Julian Date
 2 | decimal         | Time zone offset from UTC as decimal fraction of a day.
   | [-0.625..0.625] | -15:00..+15:00

Parameters
----------------------------------------------------------------------------------------------------------
ISODateTime        | text   | Date, time and time zone offset in ISO format
[AllowMixedStyles] | switch | Relax validation for no mixing of basic and extended formats. eg. yyyyMMddThh:mm
[JulianCalendar]   | switch | Calculate for the Julian proleptic calendar. Default is Gregorian
                   |        | proleptic calendar.
--------------------------------------------------------------------------------------------------------*/
ISO_DATETIME_TO_MJDATE = LAMBDA(ISODateTime, [AllowMixedStyles], [JulianCalendar],
    IF(IS_EMPTY(ISODateTime), {"", ""},
        LET(
            _isoDateTime, PARSE_ISO_DATETIME(ISODateTime, AllowMixedStyles),
            IFS(
                ISERROR(INDEX(_isoDateTime, 1, 1)), HSTACK({#VALUE!}, INDEX(_isoDateTime, 1, 5)),
                NOT(IS_NUMERIC_NULL(INDEX(_isoDateTime, 1, 4))), HSTACK({#VALUE!}, INDEX(_isoDateTime, 1, 5)),
                IS_EMPTY(INDEX(_isoDateTime, 1, 1)), HSTACK({#VALUE!}, INDEX(_isoDateTime, 1, 5)),
                TRUE, LET(
                    _MJDate, MODIFIED_JULIAN_DATE(
                        INDEX(_isoDateTime, 1, 1),
                        INDEX(_isoDateTime, 1, 2),
                        INDEX(_isoDateTime, 1, 3),
                        INDEX(_isoDateTime, 1, 4),
                        JulianCalendar
                    ),
                    HSTACK(_MJDate, INDEX(_isoDateTime, 1, 5))
                )
            )
        )
    )
);


/*--------------------------------------------------------------------------------------------------------
MJDATE_TO_ISO_DATETIME

Converts a Modified Julian Date and time zone offset to an ISO formatted date and time.

Output
----------------------------------------------------------------------------------------------------------
 1 | text  | ISO formated date and time

Parameters
----------------------------------------------------------------------------------------------------------
MJDate           | decimal     | Modified Julian Date
[TZOMinutes]     | decimal     | Time zone offset from UTC in minutes
                 | [-900..900] | Assumed to be UTC if ommitted. [-15:00..+15:00]
[Options]        | text        | String with elements: [B][<][LowOrder][Precision][Z]
                 |             |        B : Display in basic format eg T0000
                 |             |        < : Round by truncating components. Default is rounding to nearest.
                 |             | LowOrder : low order component to display
                 |             |     Null : Defaults to seconds if time present, otherwise day
                 |             |        D : Day
                 |             |        H : Hour
                 |             |        M : Minute
                 |             |        S : Second
                 |             | Precision: [0-9] Only has an effect when low order component is seconds.
                 |             |        Z : Display 'Z' for Zulu time zone +00:00
[JulianCalendar] | switch      | Calculate for the Julian proleptic calendar. Default is Gregorian
                 |             | proleptic calendar.
--------------------------------------------------------------------------------------------------------*/
MJDATE_TO_ISO_DATETIME = LAMBDA(MJDate, [TZOMinutes], [Options], [JulianCalendar],
    IFS(
        IS_EMPTY(MJDate), "",
        NOT(ISNUMBER(MJDate)), {#VALUE!},
        TRUE, LET(
            _cDate, MJDATE_TO_CALENDAR_DATE(MJDate, JulianCalendar),
            FORMAT_ISO_DATETIME(
                INDEX(_cDate, 1, 1),
                INDEX(_cDate, 1, 2),
                INDEX(_cDate, 1, 3),
                INDEX(_cDate, 1, 4),
                TZOMinutes,
                Options,
                JulianCalendar
            )
        )
    )
);

/*--------------------------------------------------------------------------------------------------------
SHIFT_TIMEZONE

Translates a Modified Julian Date from one time zone to another. If a time zone is omitted it is assumed
to be UTC.

Output
----------------------------------------------------------------------------------------------------------
 1 | text  | ISO formated date and time

Parameters
----------------------------------------------------------------------------------------------------------
MJDate                | decimal     | Modified Julian Date
[ReferenceTZOMinutes] | decimal     | Time zone offset referenced by the MJDate
                      | [-900..900] | Assumed to be UTC if ommitted. [-15:00..+15:00]
[TranslateTZOMinutes] | decimal     | Time zone offset to translate the MJDate to.
                      | [-900..900] | Assumed to be UTC if ommitted. [-15:00..+15:00]
--------------------------------------------------------------------------------------------------------*/
SHIFT_TIMEZONE = LAMBDA(MJDate, [ReferenceTZOMinutes], [TranslateTZOMinutes],
    IFS(
        IS_EMPTY(MJDate), "",
        NOT(ISNUMBER(MJDate)), {#VALUE!},
        TRUE, LET(
            _referenceTZ, N(ReferenceTZOMinutes),
            _translateTZ, N(TranslateTZOMinutes),
            _difference, (_translateTZ - _referenceTZ) / 1440,
            HSTACK(MJDate + _difference, _translateTZ)
        )
    )
);


/*###########################################################################################################
# END CALENDAR                                                                                              #
###########################################################################################################*/
